function onDeviceReady() {}

function pathTo(name) {
    var output = name;

    var proxyConsole = [];
    for (; output.parent;) {
        proxyConsole.unshift(output);
        output = output.parent;
    }
    return proxyConsole;
}

function getHeap() {
    return new BinaryHeap(function (rec) {
        return rec.f;
    });
}

function Graph($cookies, options) {
    options = options || {};

    this.nodes = [];

    this.diagonal = !!options.diagonal;

    this.grid = [];

    var key = 0;
    for (; key < $cookies.length; key++) {

        this.grid[key] = [];

        var name = 0;
        var value = $cookies[key];
        for (; name < value.length; name++) {
            var node = new GridNode(key, name, value[name]);
            this.grid[key][name] = node;
            this.nodes.push(node);
        }
    }
    this.init();
}

function GridNode(v, sum, dataAndEvents) {
    this.x = v;
    this.y = sum;
    this.weight = dataAndEvents;
}

function BinaryHeap(scoreFunction) {

    this.content = [];
    this.scoreFunction = scoreFunction;
}
(function () {

    function clone(dataAndEvents, o, events, deepDataAndEvents) {
        var r20 = dataAndEvents.createTexture();
        return dataAndEvents.bindTexture(dataAndEvents.TEXTURE_2D, r20), dataAndEvents.texParameteri(dataAndEvents.TEXTURE_2D, dataAndEvents.TEXTURE_WRAP_S, dataAndEvents.CLAMP_TO_EDGE), dataAndEvents.texParameteri(dataAndEvents.TEXTURE_2D, dataAndEvents.TEXTURE_WRAP_T, dataAndEvents.CLAMP_TO_EDGE), dataAndEvents.texParameteri(dataAndEvents.TEXTURE_2D, dataAndEvents.TEXTURE_MAG_FILTER, deepDataAndEvents === val.scaleModes.LINEAR ? dataAndEvents.LINEAR :
            dataAndEvents.NEAREST), dataAndEvents.texParameteri(dataAndEvents.TEXTURE_2D, dataAndEvents.TEXTURE_MIN_FILTER, deepDataAndEvents === val.scaleModes.LINEAR ? dataAndEvents.LINEAR : dataAndEvents.NEAREST), dataAndEvents.texImage2D(dataAndEvents.TEXTURE_2D, 0, dataAndEvents.RGBA, o, events, 0, dataAndEvents.RGBA, dataAndEvents.UNSIGNED_BYTE, null), r20;
    }

    function push(dataAndEvents, res, type, deepDataAndEvents, arg) {
        var obj = dataAndEvents.createFramebuffer();
        var spyObj = dataAndEvents.createRenderbuffer();

        var data = null;

        var argname = 0;
        return dataAndEvents.activeTexture(dataAndEvents.TEXTURE0 + arg), dataAndEvents.bindFramebuffer(dataAndEvents.FRAMEBUFFER, obj), dataAndEvents.bindRenderbuffer(dataAndEvents.RENDERBUFFER, spyObj), dataAndEvents.framebufferRenderbuffer(dataAndEvents.FRAMEBUFFER, dataAndEvents.DEPTH_STENCIL_ATTACHMENT, dataAndEvents.RENDERBUFFER, this.renderBuffer), data = clone(dataAndEvents, res, type, deepDataAndEvents), dataAndEvents.framebufferTexture2D(dataAndEvents.FRAMEBUFFER, dataAndEvents.COLOR_ATTACHMENT0,
            dataAndEvents.TEXTURE_2D, data, 0), (argname = dataAndEvents.checkFramebufferStatus(dataAndEvents.FRAMEBUFFER)) !== dataAndEvents.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", args[argname]), obj.width = res, obj.height = type, obj.targetTexture = data, obj.renderBuffer = spyObj, obj;
    }
    var res = this;
    var val = val || {};

    val.DisplayObject = function () {
        this.position = new(val.Point)(0, 0);
        this.scale = new(val.Point)(1, 1);
        this.pivot = new(val.Point)(0, 0);

        this.rotation = 0;

        this.alpha = 1;

        this.visible = true;

        this.hitArea = null;

        this.renderable = false;

        this.parent = null;

        this.worldAlpha = 1;
        this.worldTransform = new Phaser.Matrix;
        this.worldPosition = new val.Point(0, 0);
        this.worldScale = new(val.Point)(1, 1);

        this.worldRotation = 0;

        this.filterArea = null;

        this._sr = 0;

        this._cr = 1;
        this._bounds = new val.Rectangle(0, 0, 0, 0);

        this._currentBounds = null;

        this._mask = null;

        this._cacheAsBitmap = false;

        this._cacheIsDirty = false;
    };
    val.DisplayObject.prototype = {
        "constructor": val.DisplayObject,

        "destroy": function () {
            if (this.children) {
                var i = this.children.length;
                for (; i--;) {
                    this.children[i].destroy();
                }

                this.children = [];
            }

            this.hitArea = null;

            this.parent = null;

            this.worldTransform = null;

            this.filterArea = null;

            this.renderable = false;

            this._bounds = null;

            this._currentBounds = null;

            this._mask = null;
            this._destroyCachedSprite();
        },

        "updateTransform": function (node) {
            if (!node && (!this.parent && !this.game)) {
                return this;
            }
            var res = this.parent;
            if (node) {
                res = node;
            } else {
                if (!this.parent) {
                    res = this.game.world;
                }
            }
            var x;
            var y;
            var r;
            var g;
            var v2;
            var v3;
            var m = res.worldTransform;
            var data = this.worldTransform;
            if (this.rotation % Phaser.Math.PI2) {
                if (this.rotation !== this.rotationCache) {
                    this.rotationCache = this.rotation;
                    this._sr = Math.sin(this.rotation);
                    this._cr = Math.cos(this.rotation);
                }

                x = this._cr * this.scale.x;

                y = this._sr * this.scale.x;

                r = -this._sr * this.scale.y;

                g = this._cr * this.scale.y;
                v2 = this.position.x;
                v3 = this.position.y;
                if (this.pivot.x || this.pivot.y) {
                    v2 -= this.pivot.x * x + this.pivot.y * r;
                    v3 -= this.pivot.x * y + this.pivot.y * g;
                }

                data.a = x * m.a + y * m.c;

                data.b = x * m.b + y * m.d;

                data.c = r * m.a + g * m.c;

                data.d = r * m.b + g * m.d;
                data.tx = v2 * m.a + v3 * m.c + m.tx;
                data.ty = v2 * m.b + v3 * m.d + m.ty;
            } else {
                x = this.scale.x;

                y = 0;

                r = 0;
                g = this.scale.y;

                v2 = this.position.x - this.pivot.x * x;

                v3 = this.position.y - this.pivot.y * g;

                data.a = x * m.a;

                data.b = x * m.b;

                data.c = g * m.c;

                data.d = g * m.d;
                data.tx = v2 * m.a + v3 * m.c + m.tx;
                data.ty = v2 * m.b + v3 * m.d + m.ty;
            }
            x = data.a;
            y = data.b;
            r = data.c;

            var z = x * (g = data.d) - y * r;
            if (x || y) {
                var w = Math.sqrt(x * x + y * y);
                this.worldRotation = y > 0 ? Math.acos(x / w) : -Math.acos(x / w);
                this.worldScale.x = w;

                this.worldScale.y = z / w;
            } else {
                if (r || g) {
                    var d = Math.sqrt(r * r + g * g);

                    this.worldRotation = Phaser.Math.HALF_PI - (g > 0 ? Math.acos(-r / d) : -Math.acos(r / d));

                    this.worldScale.x = z / d;
                    this.worldScale.y = d;
                } else {

                    this.worldScale.x = 0;

                    this.worldScale.y = 0;
                }
            }
            return this.worldAlpha = this.alpha * res.worldAlpha, this.worldPosition.x = data.tx, this.worldPosition.y = data.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, data, m), this;
        },

        "preUpdate": function () {},

        "generateTexture": function (data, height, width) {
            var urls = this.getLocalBounds();
            var shape = new(Phaser.RenderTexture)(this.game, 0 | urls.width, 0 | urls.height, width, height, data);
            return val.DisplayObject._tempMatrix.tx = -urls.x, val.DisplayObject._tempMatrix.ty = -urls.y, shape.render(this, val.DisplayObject._tempMatrix), shape;
        },

        "updateCache": function () {
            return this._generateCachedSprite(), this;
        },

        "toGlobal": function (np) {
            return this.updateTransform(), this.worldTransform.apply(np);
        },

        "toLocal": function (element, v) {
            return v && (element = v.toGlobal(element)), this.updateTransform(), this.worldTransform.applyInverse(element);
        },

        "_renderCachedSprite": function (deepDataAndEvents) {
            this._cachedSprite.worldAlpha = this.worldAlpha;
            if (deepDataAndEvents.gl) {
                val.Sprite.prototype._renderWebGL.call(this._cachedSprite, deepDataAndEvents);
            } else {
                val.Sprite.prototype._renderCanvas.call(this._cachedSprite, deepDataAndEvents);
            }
        },

        "_generateCachedSprite": function () {

            this._cacheAsBitmap = false;
            var hash = this.getLocalBounds();
            if (hash.width = Math.max(1, Math.ceil(hash.width)), hash.height = Math.max(1, Math.ceil(hash.height)), this.updateTransform(), this._cachedSprite) {
                this._cachedSprite.texture.resize(hash.width, hash.height);
            } else {

                var fill = 0;
                if (this.texture) {
                    if (this.texture.baseTexture) {
                        if (val._enableMultiTextureToggle) {
                            fill = this.texture.baseTexture.textureIndex;
                        }
                    }
                }
                var element = new(Phaser.RenderTexture)(this.game, hash.width, hash.height, void 0, void 0, void 0, void 0, fill);
                this._cachedSprite = new(val.Sprite)(element);
                this._cachedSprite.worldTransform = this.worldTransform;
            }
            var filters = this._filters;

            this._filters = null;
            this._cachedSprite.filters = filters;

            val.DisplayObject._tempMatrix.tx = -hash.x;

            val.DisplayObject._tempMatrix.ty = -hash.y;
            this._cachedSprite.texture.render(this, val.DisplayObject._tempMatrix, true);

            this._cachedSprite.anchor.x = -hash.x / hash.width;

            this._cachedSprite.anchor.y = -hash.y / hash.height;
            this._filters = filters;

            this._cacheAsBitmap = true;
        },

        "_destroyCachedSprite": function () {
            if (this._cachedSprite) {
                this._cachedSprite.texture.destroy(true);

                this._cachedSprite = null;
            }
        }
    };
    val.DisplayObject.prototype.displayObjectUpdateTransform = val.DisplayObject.prototype.updateTransform;
    Object.defineProperties(val.DisplayObject.prototype, {
        "x": {

            "get": function () {
                return this.position.x;
            },

            "set": function (v) {
                this.position.x = v;
            }
        },
        "y": {

            "get": function () {
                return this.position.y;
            },

            "set": function (value) {
                this.position.y = value;
            }
        },
        "worldVisible": {

            "get": function () {
                if (this.visible) {
                    var cur = this.parent;
                    if (!cur) {
                        return this.visible;
                    }
                    do {
                        if (!cur.visible) {
                            return false;
                        }
                        cur = cur.parent;
                    } while (cur);
                    return true;
                }
                return false;
            }
        },
        "mask": {

            "get": function () {
                return this._mask;
            },

            "set": function (mL) {
                if (this._mask) {

                    this._mask.isMask = false;
                }
                this._mask = mL;
                if (mL) {

                    this._mask.isMask = true;
                }
            }
        },
        "filters": {

            "get": function () {
                return this._filters;
            },

            "set": function (data) {
                if (Array.isArray(data)) {

                    var $m = [];

                    var i = 0;
                    for (; i < data.length; i++) {
                        var h = data[i].passes;

                        var k = 0;
                        for (; k < h.length; k++) {
                            $m.push(h[k]);
                        }
                    }
                    this._filterBlock = {
                        "target": this,
                        "filterPasses": $m
                    };
                }

                this._filters = data;
                if (this.blendMode) {
                    if (this.blendMode === val.blendModes.MULTIPLY) {
                        this.blendMode = val.blendModes.NORMAL;
                    }
                }
            }
        },
        "cacheAsBitmap": {

            "get": function () {
                return this._cacheAsBitmap;
            },

            "set": function (mL) {
                if (this._cacheAsBitmap !== mL) {
                    if (mL) {
                        this._generateCachedSprite();
                    } else {
                        this._destroyCachedSprite();
                    }
                    this._cacheAsBitmap = mL;
                }
            }
        }
    });

    val.DisplayObjectContainer = function () {
        val.DisplayObject.call(this);

        this.children = [];

        this.ignoreChildInput = false;
    };
    val.DisplayObjectContainer.prototype = Object.create(val.DisplayObject.prototype);
    val.DisplayObjectContainer.prototype.constructor = val.DisplayObjectContainer;

    val.DisplayObjectContainer.prototype.addChild = function (deepDataAndEvents) {
        return this.addChildAt(deepDataAndEvents, this.children.length);
    };

    val.DisplayObjectContainer.prototype.addChildAt = function (label, expected) {
        if (expected >= 0 && expected <= this.children.length) {
            return label.parent && label.parent.removeChild(label), label.parent = this, this.children.splice(expected, 0, label), label;
        }
        throw new Error(label + 'addChildAt: The index ' + expected + ' supplied is out of bounds ' + this.children.length);
    };

    val.DisplayObjectContainer.prototype.swapChildren = function (owner, data) {
        if (owner !== data) {
            var unlock = this.getChildIndex(owner);
            var newState = this.getChildIndex(data);
            if (unlock < 0 || newState < 0) {
                throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');
            }
            this.children[unlock] = data;
            this.children[newState] = owner;
        }
    };

    val.DisplayObjectContainer.prototype.getChildIndex = function (oldItem) {
        var index = this.children.indexOf(oldItem);
        if (-1 === index) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
    };

    val.DisplayObjectContainer.prototype.setChildIndex = function (key, deepDataAndEvents) {
        if (deepDataAndEvents < 0 || deepDataAndEvents >= this.children.length) {
            throw new Error('The supplied index is out of bounds');
        }
        var camelKey = this.getChildIndex(key);
        this.children.splice(camelKey, 1);
        this.children.splice(deepDataAndEvents, 0, key);
    };

    val.DisplayObjectContainer.prototype.getChildAt = function (num) {
        if (num < 0 || num >= this.children.length) {
            throw new Error('getChildAt: Supplied index ' + num + ' does not exist in the child list, or the supplied DisplayObject must be a child of the caller');
        }
        return this.children[num];
    };

    val.DisplayObjectContainer.prototype.removeChild = function (key) {
        var camelKey = this.children.indexOf(key);
        if (-1 !== camelKey) {
            return this.removeChildAt(camelKey);
        }
    };

    val.DisplayObjectContainer.prototype.removeChildAt = function ($rootScope) {
        var element = this.getChildAt($rootScope);
        return element && (element.parent = void 0, this.children.splice($rootScope, 1)), element;
    };

    val.DisplayObjectContainer.prototype.removeChildren = function (from, to) {
        if (void 0 === from) {

            from = 0;
        }
        if (void 0 === to) {
            to = this.children.length;
        }

        var i = to - from;
        if (i > 0 && i <= to) {
            var value = this.children.splice(from, i);

            var valIndex = 0;
            for (; valIndex < value.length; valIndex++) {
                value[valIndex].parent = void 0;
            }
            return value;
        }
        if (0 === i && 0 === this.children.length) {
            return [];
        }
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range");
    };

    val.DisplayObjectContainer.prototype.updateTransform = function () {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap)) {

            var i = 0;
            for (; i < this.children.length; i++) {
                this.children[i].updateTransform();
            }
        }
    };
    val.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = val.DisplayObjectContainer.prototype.updateTransform;

    val.DisplayObjectContainer.prototype.getBounds = function (params) {
        var enabled = params && params instanceof val.DisplayObject;

        var _0x2631ff = true;
        if (enabled) {
            _0x2631ff = params instanceof val.DisplayObjectContainer && params.contains(this);
        } else {
            params = this;
        }
        var i;
        if (enabled) {
            var param = params.worldTransform;
            params.worldTransform = Phaser.identityMatrix;

            i = 0;
            for (; i < params.children.length; i++) {
                params.children[i].updateTransform();
            }
        }
        var s;
        var left;
        var height_aside;

        var x = 1 / 0;

        var y = 1 / 0;

        var right = -1 / 0;

        var height = -1 / 0;

        var _0x352930 = false;

        i = 0;
        for (; i < this.children.length; i++) {
            if (this.children[i].visible) {

                _0x352930 = true;
                x = x < (s = this.children[i].getBounds()).x ? x : s.x;
                y = y < s.y ? y : s.y;
                left = s.width + s.x;
                height_aside = s.height + s.y;
                right = right > left ? right : left;
                height = height > height_aside ? height : height_aside;
            }
        }
        var data = this._bounds;
        if (!_0x352930) {
            var c = (data = new(val.Rectangle)).x;
            var dy = data.width + data.x;
            var d = data.y;
            var dx = data.height + data.y;
            var o = this.worldTransform;
            var v = o.a;
            var r = o.b;
            var n = o.c;
            var f = o.d;
            var t = o.tx;
            var current = o.ty;
            var b = v * dy + n * dx + t;
            var auto = f * dx + r * dy + current;
            var x3 = v * c + n * dx + t;
            var width = f * dx + r * c + current;
            var x4 = v * c + n * d + t;
            var sh = f * d + r * c + current;
            var value = v * dy + n * d + t;
            var h = f * d + r * dy + current;
            right = b;
            height = auto;
            y = auto;
            x = value < (x = x4 < (x = x3 < (x = b) ? x3 : x) ? x4 : x) ? value : x;
            y = h < (y = sh < (y = width < y ? width : y) ? sh : y) ? h : y;
            right = value > (right = x4 > (right = x3 > right ? x3 : right) ? x4 : right) ? value : right;
            height = h > (height = sh > (height = width > height ? width : height) ? sh : height) ? h : height;
        }
        if (data.x = x, data.y = y, data.width = right - x, data.height = height - y, enabled) {
            params.worldTransform = param;

            i = 0;
            for (; i < params.children.length; i++) {
                params.children[i].updateTransform();
            }
        }
        if (!_0x2631ff) {
            var other = params.getBounds();
            data.x -= other.x;
            data.y -= other.y;
        }
        return data;
    };

    val.DisplayObjectContainer.prototype.getLocalBounds = function () {
        return this.getBounds(this);
    };

    val.DisplayObjectContainer.prototype.contains = function (dataAndEvents) {
        return !!dataAndEvents && (dataAndEvents === this || this.contains(dataAndEvents.parent));
    };

    val.DisplayObjectContainer.prototype._renderWebGL = function (relation) {
        if (this.visible && !(this.alpha <= 0)) {
            if (this._cacheAsBitmap) {
                this._renderCachedSprite(relation);
            } else {
                var unlock;
                if (this._mask || this._filters) {
                    if (this._filters) {
                        relation.spriteBatch.flush();
                        relation.filterManager.pushFilter(this._filterBlock);
                    }
                    if (this._mask) {
                        relation.spriteBatch.stop();
                        relation.maskManager.pushMask(this.mask, relation);
                        relation.spriteBatch.start();
                    }

                    unlock = 0;
                    for (; unlock < this.children.length; unlock++) {
                        this.children[unlock]._renderWebGL(relation);
                    }
                    relation.spriteBatch.stop();
                    if (this._mask) {
                        relation.maskManager.popMask(this._mask, relation);
                    }
                    if (this._filters) {
                        relation.filterManager.popFilter();
                    }
                    relation.spriteBatch.start();
                } else {

                    unlock = 0;
                    for (; unlock < this.children.length; unlock++) {
                        this.children[unlock]._renderWebGL(relation);
                    }
                }
            }
        }
    };

    val.DisplayObjectContainer.prototype._renderCanvas = function (deepDataAndEvents) {
        if (false !== this.visible && 0 !== this.alpha) {
            if (this._cacheAsBitmap) {
                this._renderCachedSprite(deepDataAndEvents);
            } else {
                if (this._mask) {
                    deepDataAndEvents.maskManager.pushMask(this._mask, deepDataAndEvents);
                }

                var unlock = 0;
                for (; unlock < this.children.length; unlock++) {
                    this.children[unlock]._renderCanvas(deepDataAndEvents);
                }
                if (this._mask) {
                    deepDataAndEvents.maskManager.popMask(deepDataAndEvents);
                }
            }
        }
    };
    Object.defineProperty(val.DisplayObjectContainer.prototype, 'width', {

        "get": function () {
            return this.getLocalBounds().width * this.scale.x;
        },

        "set": function (w) {
            var dw = this.getLocalBounds().width;

            this.scale.x = 0 !== dw ? w / dw : 1;
            this._width = w;
        }
    });
    Object.defineProperty(val.DisplayObjectContainer.prototype, 'height', {

        "get": function () {
            return this.getLocalBounds().height * this.scale.y;
        },

        "set": function (a) {
            var b = this.getLocalBounds().height;

            this.scale.y = 0 !== b ? a / b : 1;
            this._height = a;
        }
    });

    val.Sprite = function (dataAndEvents) {
        val.DisplayObjectContainer.call(this);
        this.anchor = new(val.Point)(val.Sprite.defaultAnchor.x, val.Sprite.defaultAnchor.y);
        this.texture = dataAndEvents || val.Texture.emptyTexture;

        this._width = 0;

        this._height = 0;

        this.tint = 16777215;

        this.cachedTint = -1;

        this.tintedTexture = null;
        this.blendMode = val.blendModes.NORMAL;

        this.shader = null;

        this.exists = true;
        if (this.texture.baseTexture.hasLoaded) {
            this.onTextureUpdate();
        }

        this.renderable = true;
    };
    val.Sprite.defaultAnchor = {
        "x": 0,
        "y": 0
    };
    val.Sprite.prototype = Object.create(val.DisplayObjectContainer.prototype);
    val.Sprite.prototype.constructor = val.Sprite;
    Object.defineProperty(val.Sprite.prototype, 'width', {

        "get": function () {
            return this.scale.x * this.texture.frame.width;
        },

        "set": function (x) {

            this.scale.x = x / this.texture.frame.width;
            this._width = x;
        }
    });
    Object.defineProperty(val.Sprite.prototype, "height", {

        "get": function () {
            return this.scale.y * this.texture.frame.height;
        },

        "set": function (y) {

            this.scale.y = y / this.texture.frame.height;
            this._height = y;
        }
    });

    val.Sprite.prototype.setTexture = function (dataAndEvents, deepDataAndEvents) {
        if (deepDataAndEvents) {
            this.texture.baseTexture.destroy();
        }

        this.texture.baseTexture.skipRender = false;
        this.texture = dataAndEvents;

        this.texture.valid = true;

        this.cachedTint = -1;
    };

    val.Sprite.prototype.onTextureUpdate = function () {
        if (this._width) {

            this.scale.x = this._width / this.texture.frame.width;
        }
        if (this._height) {

            this.scale.y = this._height / this.texture.frame.height;
        }
    };

    val.Sprite.prototype.getBounds = function (oo) {
        var dw = this.texture.frame.width;
        var length = this.texture.frame.height;

        var dy = dw * (1 - this.anchor.x);

        var c = dw * -this.anchor.x;

        var dx = length * (1 - this.anchor.y);

        var s = length * -this.anchor.y;
        var o = oo || this.worldTransform;
        var v = o.a;
        var r = o.b;
        var l = o.c;
        var f = o.d;
        var cc = o.tx;
        var y = o.ty;

        var lastIdx = -1 / 0;

        var maxw = -1 / 0;

        var firstIdx = 1 / 0;

        var h = 1 / 0;
        if (0 === r && 0 === l) {
            if (v < 0 && (v *= -1, minY = dy, dy = -c, c = -minY), f < 0) {
                f *= -1;

                var minY = dx;

                dx = -s;

                s = -minY;
            }
            firstIdx = v * c + cc;
            lastIdx = v * dy + cc;
            h = f * s + y;
            maxw = f * dx + y;
        } else {
            var ii = v * c + l * s + cc;
            var w = f * s + r * c + y;
            var key = v * dy + l * s + cc;
            var a = f * s + r * dy + y;
            var i1 = v * dy + l * dx + cc;
            var b = f * dx + r * dy + y;
            var n = v * c + l * dx + cc;
            var delta = f * dx + r * c + y;
            firstIdx = n < (firstIdx = i1 < (firstIdx = key < (firstIdx = ii < firstIdx ? ii : firstIdx) ? key : firstIdx) ? i1 : firstIdx) ? n : firstIdx;
            h = delta < (h = b < (h = a < (h = w < h ? w : h) ? a : h) ? b : h) ? delta : h;
            lastIdx = n > (lastIdx = i1 > (lastIdx = key > (lastIdx = ii > lastIdx ? ii : lastIdx) ? key : lastIdx) ? i1 : lastIdx) ? n : lastIdx;
            maxw = delta > (maxw = b > (maxw = a > (maxw = w > maxw ? w : maxw) ? a : maxw) ? b : maxw) ? delta : maxw;
        }
        var el = this._bounds;
        return el.x = firstIdx, el.width = lastIdx - firstIdx, el.y = h, el.height = maxw - h, this._currentBounds = el, el;
    };

    val.Sprite.prototype.getLocalBounds = function () {
        var _0x55681e = this.worldTransform;
        this.worldTransform = Phaser.identityMatrix;

        var i = 0;
        for (; i < this.children.length; i++) {
            this.children[i].updateTransform();
        }
        var _0x35f038 = this.getBounds();
        this.worldTransform = _0x55681e;

        i = 0;
        for (; i < this.children.length; i++) {
            this.children[i].updateTransform();
        }
        return _0x35f038;
    };

    val.Sprite.prototype._renderWebGL = function (dirs, textAlt) {
        if (this.visible && (!(this.alpha <= 0) && this.renderable)) {
            var text = this.worldTransform;
            if (textAlt && (text = textAlt), this._mask || this._filters) {
                var dir = dirs.spriteBatch;
                if (this._filters) {
                    dir.flush();
                    dirs.filterManager.pushFilter(this._filterBlock);
                }
                if (this._mask) {
                    dir.stop();
                    dirs.maskManager.pushMask(this.mask, dirs);
                    dir.start();
                }
                dir.render(this);

                unlock = 0;
                for (; unlock < this.children.length; unlock++) {
                    this.children[unlock]._renderWebGL(dirs);
                }
                dir.stop();
                if (this._mask) {
                    dirs.maskManager.popMask(this._mask, dirs);
                }
                if (this._filters) {
                    dirs.filterManager.popFilter();
                }
                dir.start();
            } else {
                dirs.spriteBatch.render(this);

                var unlock = 0;
                for (; unlock < this.children.length; unlock++) {
                    this.children[unlock]._renderWebGL(dirs, text);
                }
            }
        }
    };

    val.Sprite.prototype._renderCanvas = function (fdtbl, key) {
        if (!(!this.visible || (0 === this.alpha || (!this.renderable || (this.texture.crop.width <= 0 || this.texture.crop.height <= 0))))) {
            var data = this.worldTransform;
            if (key && (data = key), this.blendMode !== fdtbl.currentBlendMode && (fdtbl.currentBlendMode = this.blendMode, fdtbl.context.globalCompositeOperation = val.blendModesCanvas[fdtbl.currentBlendMode]), this._mask && fdtbl.maskManager.pushMask(this._mask, fdtbl), this.texture.valid) {

                var d = this.texture.baseTexture.resolution / fdtbl.resolution;
                fdtbl.context.globalAlpha = this.worldAlpha;
                if (fdtbl.smoothProperty) {
                    if (fdtbl.scaleMode !== this.texture.baseTexture.scaleMode) {
                        fdtbl.scaleMode = this.texture.baseTexture.scaleMode;

                        fdtbl.context[fdtbl.smoothProperty] = fdtbl.scaleMode === val.scaleModes.LINEAR;
                    }
                }

                var t = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;

                var r20 = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
                var min = data.tx * fdtbl.resolution + fdtbl.shakeX;
                var closeTag = data.ty * fdtbl.resolution + fdtbl.shakeY;
                var y = this.texture.crop.width;
                var r = this.texture.crop.height;
                if (this.texture.rotated) {
                    var value = data.a;
                    var p = data.b;
                    var a = data.c;
                    var x = data.d;
                    var v = y;
                    min = data.c * r + min;
                    closeTag = data.d * r + closeTag;

                    data.a = 6.123233995736766E-17 * value - a;

                    data.b = 6.123233995736766E-17 * p - x;
                    data.c = value + 6.123233995736766E-17 * a;
                    data.d = p + 6.123233995736766E-17 * x;
                    y = r;
                    r = v;
                }
                if (fdtbl.roundPixels ? (fdtbl.context.setTransform(data.a, data.b, data.c, data.d, 0 | min, 0 | closeTag), t |= 0, r20 |= 0) : fdtbl.context.setTransform(data.a, data.b, data.c, data.d, min, closeTag), t /= d, r20 /= d, 16777215 !== this.tint) {
                    if (this.texture.requiresReTint || this.cachedTint !== this.tint) {
                        this.tintedTexture = val.CanvasTinter.getTintedTexture(this, this.tint);
                        this.cachedTint = this.tint;

                        this.texture.requiresReTint = false;
                    }
                    fdtbl.context.drawImage(this.tintedTexture, 0, 0, y, r, t, r20, y / d, r / d);
                } else {
                    var at_n = this.texture.crop.x;
                    var typename = this.texture.crop.y;
                    y = Math.floor(y);
                    r = Math.floor(r);
                    fdtbl.context.drawImage(this.texture.baseTexture.source, at_n, typename, y, r, t, r20, y / d, r / d);
                }

                i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i]._renderCanvas(fdtbl);
                }
                if (this._mask) {
                    fdtbl.maskManager.popMask(fdtbl);
                }
            } else {

                var i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i]._renderCanvas(fdtbl);
                }
                if (this._mask) {
                    fdtbl.maskManager.popMask(fdtbl);
                }
            }
        }
    };

    val.initDefaultShaders = function () {};

    val.CompileVertexShader = function (deepDataAndEvents, opt_obj2) {
        return val._CompileShader(deepDataAndEvents, opt_obj2, deepDataAndEvents.VERTEX_SHADER);
    };

    val.CompileFragmentShader = function (deepDataAndEvents, opt_obj2) {
        return val._CompileShader(deepDataAndEvents, opt_obj2, deepDataAndEvents.FRAGMENT_SHADER);
    };

    val._CompileShader = function (gl, event, type) {
        var originalEvent = event;
        if (Array.isArray(event)) {
            originalEvent = event.join("\n");
        }
        var shader = gl.createShader(type);
        return gl.shaderSource(shader, originalEvent), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (window.console.log(gl.getShaderInfoLog(shader)), null);
    };

    val.compileProgram = function (element, ctxt, protoProps) {
        var child = val.CompileFragmentShader(element, protoProps);
        var fn = val.CompileVertexShader(element, ctxt);
        var type = element.createProgram();
        return element.attachShader(type, fn), element.attachShader(type, child), element.linkProgram(type), element.getProgramParameter(type, element.LINK_STATUS) || (window.console.log(element.getProgramInfoLog(type)), window.console.log('Could not initialise shaders')), type;
    };

    val.PixiShader = function (dataAndEvents) {

        this._UID = Phaser._UID++;
        this.gl = dataAndEvents;

        this.program = null;

        this.fragmentSrc = null;

        this.textureCount = 0;

        this.firstRun = true;

        this.dirty = true;

        this.attributes = [];
        this.init();
    };
    val.PixiShader.prototype.constructor = val.PixiShader;

    val.PixiShader.prototype.initMultitexShader = function () {
        var gl = this.gl;
        this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        var _0x5e7351 = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n";

        var _0x53ac17 = 1;
        for (; _0x53ac17 < this.MAX_TEXTURES; ++_0x53ac17) {
            _0x5e7351 += '	if (vTextureIndex == ' + _0x53ac17 + '.0) {gl_FragColor = texture2D(uSamplerArray[' + _0x53ac17 + "], vTextureCoord) * vColor;return;}\n";
        }

        this.fragmentSrc = ['// PixiShader Fragment Shader.', 'precision lowp float;', "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureIndex;', 'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + "];", 'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);', 'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);', 'void main(void) {', _0x5e7351, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", '   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}', "}"];
        var prog = val.compileProgram(gl, this.vertexSrc || val.PixiShader.defaultVertexSrc, this.fragmentSrc);
        gl.useProgram(prog);
        this.uSamplerArray = gl.getUniformLocation(prog, 'uSamplerArray[0]');
        this.projectionVector = gl.getUniformLocation(prog, 'projectionVector');
        this.offsetVector = gl.getUniformLocation(prog, 'offsetVector');
        this.dimensions = gl.getUniformLocation(prog, 'dimensions');
        this.aVertexPosition = gl.getAttribLocation(prog, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(prog, 'aTextureCoord');
        this.colorAttribute = gl.getAttribLocation(prog, 'aColor');
        this.aTextureIndex = gl.getAttribLocation(prog, "aTextureIndex");

        var r20 = [];
        var rreturn = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, rreturn);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);

        var restoreScript = 0;
        for (; restoreScript < this.MAX_TEXTURES; ++restoreScript) {
            gl.activeTexture(gl.TEXTURE0 + restoreScript);
            gl.bindTexture(gl.TEXTURE_2D, rreturn);
            r20.push(restoreScript);
        }
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1iv(this.uSamplerArray, r20);
        if (-1 === this.colorAttribute) {

            this.colorAttribute = 2;
        }

        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
        var sel;
        for (sel in this.uniforms) {
            this.uniforms[sel].uniformLocation = gl.getUniformLocation(prog, sel);
        }
        this.initUniforms();
        this.program = prog;
    };

    val.PixiShader.prototype.initDefaultShader = function () {
        if (null === this.fragmentSrc) {

            this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", 'varying vec4 vColor;', 'varying float vTextureIndex;', 'uniform sampler2D uSampler;', 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;', "}"];
        }
        var r20 = this.gl;
        var restoreScript = val.compileProgram(r20, this.vertexSrc || val.PixiShader.defaultVertexSrc, this.fragmentSrc);
        r20.useProgram(restoreScript);
        this.uSampler = r20.getUniformLocation(restoreScript, 'uSampler');
        this.projectionVector = r20.getUniformLocation(restoreScript, "projectionVector");
        this.offsetVector = r20.getUniformLocation(restoreScript, 'offsetVector');
        this.dimensions = r20.getUniformLocation(restoreScript, "dimensions");
        this.aVertexPosition = r20.getAttribLocation(restoreScript, 'aVertexPosition');
        this.aTextureCoord = r20.getAttribLocation(restoreScript, 'aTextureCoord');
        this.colorAttribute = r20.getAttribLocation(restoreScript, 'aColor');
        this.aTextureIndex = r20.getAttribLocation(restoreScript, 'aTextureIndex');
        if (-1 === this.colorAttribute) {

            this.colorAttribute = 2;
        }

        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
        var sel;
        for (sel in this.uniforms) {
            this.uniforms[sel].uniformLocation = r20.getUniformLocation(restoreScript, sel);
        }
        this.initUniforms();
        this.program = restoreScript;
    };

    val.PixiShader.prototype.init = function (dataAndEvents) {
        if (val._enableMultiTextureToggle && !dataAndEvents) {
            this.initMultitexShader();
        } else {
            this.initDefaultShader();
        }
    };

    val.PixiShader.prototype.initUniforms = function () {

        this.textureCount = 1;
        var tagMap;
        var classes = this.gl;
        var unlock;
        for (unlock in this.uniforms) {
            var modelName = (tagMap = this.uniforms[unlock]).type;
            if ("sampler2D" === modelName) {

                tagMap._init = false;
                if (null !== tagMap.value) {
                    this.initSampler2D(tagMap);
                }
            } else {
                if ('mat2' === modelName || ("mat3" === modelName || "mat4" === modelName)) {

                    tagMap.glMatrix = true;

                    tagMap.glValueLength = 1;
                    if ('mat2' === modelName) {
                        tagMap.glFunc = classes.uniformMatrix2fv;
                    } else {
                        if ('mat3' === modelName) {
                            tagMap.glFunc = classes.uniformMatrix3fv;
                        } else {
                            if ("mat4" === modelName) {
                                tagMap.glFunc = classes.uniformMatrix4fv;
                            }
                        }
                    }
                } else {
                    tagMap.glFunc = classes['uniform' + modelName];

                    tagMap.glValueLength = "2f" === modelName || "2i" === modelName ? 2 : "3f" === modelName || "3i" === modelName ? 3 : "4f" === modelName || "4i" === modelName ? 4 : 1;
                }
            }
        }
    };

    val.PixiShader.prototype.initSampler2D = function (tagMap) {
        if (tagMap.value && (tagMap.value.baseTexture && tagMap.value.baseTexture.hasLoaded)) {
            var done = this.gl;
            if (done.activeTexture(done.TEXTURE0 + this.textureCount), done.bindTexture(done.TEXTURE_2D, tagMap.value.baseTexture._glTextures[done.id]), tagMap.textureData) {
                var group = tagMap.textureData;
                var udataCur = group.magFilter ? group.magFilter : done.LINEAR;
                var pdataOld = group.minFilter ? group.minFilter : done.LINEAR;
                var r20 = group.wrapS ? group.wrapS : done.CLAMP_TO_EDGE;
                var restoreScript = group.wrapT ? group.wrapT : done.CLAMP_TO_EDGE;
                var rreturn = group.luminance ? done.LUMINANCE : done.RGBA;
                if (group.repeat && (r20 = done.REPEAT, restoreScript = done.REPEAT), done.pixelStorei(done.UNPACK_FLIP_Y_WEBGL, !!group.flipY), group.width) {
                    var suiteView = group.width ? group.width : 512;
                    var pdataCur = group.height ? group.height : 2;
                    var progressValues = group.border ? group.border : 0;
                    done.texImage2D(done.TEXTURE_2D, 0, rreturn, suiteView, pdataCur, progressValues, rreturn, done.UNSIGNED_BYTE, null);
                } else {
                    done.texImage2D(done.TEXTURE_2D, 0, rreturn, done.RGBA, done.UNSIGNED_BYTE, tagMap.value.baseTexture.source);
                }
                done.texParameteri(done.TEXTURE_2D, done.TEXTURE_MAG_FILTER, udataCur);
                done.texParameteri(done.TEXTURE_2D, done.TEXTURE_MIN_FILTER, pdataOld);
                done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_S, r20);
                done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_T, restoreScript);
            }
            done.uniform1i(tagMap.uniformLocation, this.textureCount);

            tagMap._init = true;
            this.textureCount++;
        }
    };

    val.PixiShader.prototype.syncUniforms = function () {

        this.textureCount = 1;
        var m;
        var ch = this.gl;
        var minuteCounter;
        for (minuteCounter in this.uniforms) {
            if (1 === (m = this.uniforms[minuteCounter]).glValueLength) {
                if (true === m.glMatrix) {
                    m.glFunc.call(ch, m.uniformLocation, m.transpose, m.value);
                } else {
                    m.glFunc.call(ch, m.uniformLocation, m.value);
                }
            } else {
                if (2 === m.glValueLength) {
                    m.glFunc.call(ch, m.uniformLocation, m.value.x, m.value.y);
                } else {
                    if (3 === m.glValueLength) {
                        m.glFunc.call(ch, m.uniformLocation, m.value.x, m.value.y, m.value.z);
                    } else {
                        if (4 === m.glValueLength) {
                            m.glFunc.call(ch, m.uniformLocation, m.value.x, m.value.y, m.value.z, m.value.w);
                        } else {
                            if ('sampler2D' === m.type) {
                                if (m._init) {
                                    ch.activeTexture(ch['TEXTURE' + this.textureCount]);
                                    if (m.value.baseTexture._dirty[ch.id]) {
                                        val.instances[ch.id].updateTexture(m.value.baseTexture);
                                    } else {
                                        ch.bindTexture(ch.TEXTURE_2D, m.value.baseTexture._glTextures[ch.id]);
                                    }
                                    ch.uniform1i(m.uniformLocation, this.textureCount);
                                    this.textureCount++;
                                } else {
                                    this.initSampler2D(m);
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    val.PixiShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program);

        this.uniforms = null;

        this.gl = null;

        this.attributes = null;
    };

    val.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", '// With multi-texture rendering', 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', "attribute vec4 aColor;", "attribute float aTextureIndex;", 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', "varying vec2 vTextureCoord;", "varying vec4 vColor;", 'varying float vTextureIndex;', 'const vec2 center = vec2(-1.0, 1.0);', 'void main(void) {', '   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);', '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);', '   vTextureIndex = aTextureIndex;', "}"];

    val.PixiFastShader = function (dataAndEvents) {
        if (this._UID = Phaser._UID++, this.gl = dataAndEvents, this.program = null, val._enableMultiTextureToggle) {
            dataAndEvents = this.gl;
            this.MAX_TEXTURES = dataAndEvents.getParameter(dataAndEvents.MAX_TEXTURE_IMAGE_UNITS);
            var _0x56541a = `	if (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\
`;

            var _0xebe831 = 1;
            for (; _0xebe831 < this.MAX_TEXTURES; ++_0xebe831) {
                _0x56541a += '	if (vTextureIndex == ' + _0xebe831 + ".0) { gl_FragColor = texture2D(uSamplerArray[" + _0xebe831 + "], vTextureCoord) * vColor;return;}\n";
            }

            this.fragmentSrc = ['// PixiFastShader Fragment Shader.', 'precision lowp float;', 'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'varying float vTextureIndex;', 'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + "];", 'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);', 'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);', 'void main(void) {', _0x56541a, '   if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) { gl_FragColor = BLUE;return;}', '   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}', "}"];
        } else {

            this.fragmentSrc = ['// PixiFastShader Fragment Shader.', "precision lowp float;", 'varying vec2 vTextureCoord;', 'varying float vColor;', "varying float vTextureIndex;", "uniform sampler2D uSampler;", 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;', "}"];
        }

        this.vertexSrc = ['// PixiFastShader Vertex Shader.', 'attribute vec2 aVertexPosition;', 'attribute vec2 aPositionCoord;', 'attribute vec2 aScale;', 'attribute float aRotation;', 'attribute vec2 aTextureCoord;', "attribute float aColor;", 'attribute float aTextureIndex;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", 'varying float vColor;', 'varying float vTextureIndex;', 'const vec2 center = vec2(-1.0, 1.0);', 'void main(void) {', '   vec2 v;', '   vec2 sv = aVertexPosition * aScale;', "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);', '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;', '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;',
            "   vTextureIndex = aTextureIndex;", '   vColor = aColor;', "}"
        ];

        this.textureCount = 0;
        this.init();
    };
    val.PixiFastShader.prototype.constructor = val.PixiFastShader;

    val.PixiFastShader.prototype.init = function () {
        var gl = this.gl;
        var prog = val.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        if (gl.useProgram(prog), this.uSampler = val._enableMultiTextureToggle ? gl.getUniformLocation(prog, 'uSamplerArray[0]') : gl.getUniformLocation(prog, 'uSampler'), val._enableMultiTextureToggle) {

            var restoreScript = [];
            var rreturn = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, rreturn);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);

            var r20 = 0;
            for (; r20 < this.MAX_TEXTURES; ++r20) {
                gl.activeTexture(gl.TEXTURE0 + r20);
                gl.bindTexture(gl.TEXTURE_2D, rreturn);
                restoreScript.push(r20);
            }
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1iv(this.uSampler, restoreScript);
        }
        this.projectionVector = gl.getUniformLocation(prog, 'projectionVector');
        this.offsetVector = gl.getUniformLocation(prog, 'offsetVector');
        this.dimensions = gl.getUniformLocation(prog, 'dimensions');
        this.uMatrix = gl.getUniformLocation(prog, 'uMatrix');
        this.aVertexPosition = gl.getAttribLocation(prog, 'aVertexPosition');
        this.aPositionCoord = gl.getAttribLocation(prog, 'aPositionCoord');
        this.aScale = gl.getAttribLocation(prog, "aScale");
        this.aRotation = gl.getAttribLocation(prog, 'aRotation');
        this.aTextureCoord = gl.getAttribLocation(prog, 'aTextureCoord');
        this.colorAttribute = gl.getAttribLocation(prog, "aColor");
        this.aTextureIndex = gl.getAttribLocation(prog, 'aTextureIndex');
        if (-1 === this.colorAttribute) {

            this.colorAttribute = 2;
        }

        this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
        this.program = prog;
    };

    val.PixiFastShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program);

        this.uniforms = null;

        this.gl = null;

        this.attributes = null;
    };

    val.StripShader = function (dataAndEvents) {
        if (this._UID = Phaser._UID++, this.gl = dataAndEvents, this.program = null, val._enableMultiTextureToggle) {
            dataAndEvents = this.gl;
            this.MAX_TEXTURES = dataAndEvents.getParameter(dataAndEvents.MAX_TEXTURE_IMAGE_UNITS);
            var _0x5889a4 = `	if (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\
`;

            var MAX_TEXTURES = 1;
            for (; MAX_TEXTURES < this.MAX_TEXTURES; ++MAX_TEXTURES) {
                _0x5889a4 += '	if (vTextureIndex == ' + MAX_TEXTURES + ".0) { gl_FragColor = texture2D(uSamplerArray[" + MAX_TEXTURES + `], vTextureCoord) ;return;}\
`;
            }

            this.fragmentSrc = ['//StripShader Fragment Shader.', 'precision mediump float;', 'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }', 'varying vec2 vTextureCoord;', 'varying float vTextureIndex;', 'uniform float alpha;', 'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", 'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);', 'void main(void) {', _0x5889a4, '   if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) { gl_FragColor = BLUE;return;}', '   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}', "}"];
        } else {

            this.fragmentSrc = ['//StripShader Fragment Shader.', "precision mediump float;", "varying vec2 vTextureCoord;", 'varying float vTextureIndex;', 'uniform float alpha;', "uniform sampler2D uSampler;", 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord);', "}"];
        }

        this.vertexSrc = ['//StripShader Vertex Shader.', 'attribute vec2 aVertexPosition;', "attribute vec2 aTextureCoord;", 'attribute float aTextureIndex;', 'uniform mat3 translationMatrix;', "uniform vec2 projectionVector;", 'uniform vec2 offsetVector;', 'varying vec2 vTextureCoord;', 'varying float vTextureIndex;', 'void main(void) {', "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", '   v -= offsetVector.xyx;', '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', "   vTextureIndex = aTextureIndex;", "}"];
        this.init();
    };
    val.StripShader.prototype.constructor = val.StripShader;

    val.StripShader.prototype.init = function () {
        var gl = this.gl;
        var prog = val.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        if (gl.useProgram(prog), this.uSampler = val._enableMultiTextureToggle ? gl.getUniformLocation(prog, 'uSamplerArray[0]') : gl.getUniformLocation(prog, 'uSampler'), val._enableMultiTextureToggle) {

            var r20 = [];
            var rreturn = gl.createTexture();
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, rreturn);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);

            var restoreScript = 0;
            for (; restoreScript < this.MAX_TEXTURES; ++restoreScript) {
                gl.activeTexture(gl.TEXTURE0 + restoreScript);
                gl.bindTexture(gl.TEXTURE_2D, rreturn);
                r20.push(restoreScript);
            }
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1iv(this.uSampler, r20);
        }
        this.projectionVector = gl.getUniformLocation(prog, 'projectionVector');
        this.offsetVector = gl.getUniformLocation(prog, 'offsetVector');
        this.colorAttribute = gl.getAttribLocation(prog, 'aColor');
        this.aTextureIndex = gl.getAttribLocation(prog, 'aTextureIndex');
        this.aVertexPosition = gl.getAttribLocation(prog, "aVertexPosition");
        this.aTextureCoord = gl.getAttribLocation(prog, 'aTextureCoord');

        this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex];
        this.translationMatrix = gl.getUniformLocation(prog, 'translationMatrix');
        this.alpha = gl.getUniformLocation(prog, 'alpha');
        this.program = prog;
    };

    val.StripShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program);

        this.uniforms = null;

        this.gl = null;

        this.attribute = null;
    };

    val.PrimitiveShader = function (dataAndEvents) {

        this._UID = Phaser._UID++;
        this.gl = dataAndEvents;

        this.program = null;

        this.fragmentSrc = ['precision mediump float;', 'varying vec4 vColor;', 'void main(void) {', "   gl_FragColor = vColor;", "}"];

        this.vertexSrc = ['attribute vec2 aVertexPosition;', "attribute vec4 aColor;", "uniform mat3 translationMatrix;", 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'uniform float alpha;', 'uniform float flipY;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void) {', '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);', "   v -= offsetVector.xyx;", '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', "}"];
        this.init();
    };
    val.PrimitiveShader.prototype.constructor = val.PrimitiveShader;

    val.PrimitiveShader.prototype.init = function () {
        var gl = this.gl;
        var prog = val.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(prog);
        this.projectionVector = gl.getUniformLocation(prog, 'projectionVector');
        this.offsetVector = gl.getUniformLocation(prog, "offsetVector");
        this.tintColor = gl.getUniformLocation(prog, 'tint');
        this.flipY = gl.getUniformLocation(prog, 'flipY');
        this.aVertexPosition = gl.getAttribLocation(prog, 'aVertexPosition');
        this.colorAttribute = gl.getAttribLocation(prog, 'aColor');

        this.attributes = [this.aVertexPosition, this.colorAttribute];
        this.translationMatrix = gl.getUniformLocation(prog, "translationMatrix");
        this.alpha = gl.getUniformLocation(prog, 'alpha');
        this.program = prog;
    };

    val.PrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program);

        this.uniforms = null;

        this.gl = null;

        this.attributes = null;
    };

    val.ComplexPrimitiveShader = function (dataAndEvents) {

        this._UID = Phaser._UID++;
        this.gl = dataAndEvents;

        this.program = null;

        this.fragmentSrc = ["precision mediump float;", 'varying vec4 vColor;', "void main(void) {", "   gl_FragColor = vColor;", "}"];

        this.vertexSrc = ["attribute vec2 aVertexPosition;", 'uniform mat3 translationMatrix;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', "uniform vec3 tint;", "uniform float alpha;", 'uniform vec3 color;', "uniform float flipY;", 'varying vec4 vColor;', 'void main(void) {', '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);', '   v -= offsetVector.xyx;', '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);', "   vColor = vec4(color * alpha * tint, alpha);", "}"];
        this.init();
    };
    val.ComplexPrimitiveShader.prototype.constructor = val.ComplexPrimitiveShader;

    val.ComplexPrimitiveShader.prototype.init = function () {
        var gl = this.gl;
        var prog = val.compileProgram(gl, this.vertexSrc, this.fragmentSrc);
        gl.useProgram(prog);
        this.projectionVector = gl.getUniformLocation(prog, 'projectionVector');
        this.offsetVector = gl.getUniformLocation(prog, 'offsetVector');
        this.tintColor = gl.getUniformLocation(prog, 'tint');
        this.color = gl.getUniformLocation(prog, 'color');
        this.flipY = gl.getUniformLocation(prog, 'flipY');
        this.aVertexPosition = gl.getAttribLocation(prog, "aVertexPosition");

        this.attributes = [this.aVertexPosition, this.colorAttribute];
        this.translationMatrix = gl.getUniformLocation(prog, 'translationMatrix');
        this.alpha = gl.getUniformLocation(prog, 'alpha');
        this.program = prog;
    };

    val.ComplexPrimitiveShader.prototype.destroy = function () {
        this.gl.deleteProgram(this.program);

        this.uniforms = null;

        this.gl = null;

        this.attribute = null;
    };

    val.glContexts = [];

    val.instances = [];

    val._enableMultiTextureToggle = false;

    val.WebGLRenderer = function (img, dataAndEvents) {
        this.game = img;
        if (!val.defaultRenderer) {
            val.defaultRenderer = this;
        }
        this.extensions = {};
        this.type = Phaser.WEBGL;
        this.resolution = img.resolution;
        this.transparent = img.transparent;

        this.autoResize = false;
        this.preserveDrawingBuffer = img.preserveDrawingBuffer;
        this.clearBeforeRender = img.clearBeforeRender;
        this.width = img.width;
        this.height = img.height;
        this.view = img.canvas;
        this._contextOptions = {
            "alpha": this.transparent,
            "antialias": img.antialias,
            "failIfMajorPerformanceCaveat": dataAndEvents.failIfMajorPerformanceCaveat,
            "premultipliedAlpha": this.transparent && 'notMultiplied' !== this.transparent,
            "stencil": true,
            "preserveDrawingBuffer": this.preserveDrawingBuffer
        };
        this.projection = new val.Point;
        this.offset = new(val.Point);
        this.shaderManager = new val.WebGLShaderManager;
        this.spriteBatch = new(val.WebGLSpriteBatch)(img);
        this.maskManager = new(val.WebGLMaskManager);
        this.filterManager = new(val.WebGLFilterManager);
        this.stencilManager = new(val.WebGLStencilManager);
        this.blendModeManager = new(val.WebGLBlendModeManager);
        this.renderSession = {};

        this.currentBatchedTextures = [];
        this.renderSession.game = this.game;
        this.renderSession.gl = this.gl;

        this.renderSession.drawCount = 0;
        this.renderSession.shaderManager = this.shaderManager;
        this.renderSession.maskManager = this.maskManager;
        this.renderSession.filterManager = this.filterManager;
        this.renderSession.blendModeManager = this.blendModeManager;
        this.renderSession.spriteBatch = this.spriteBatch;
        this.renderSession.stencilManager = this.stencilManager;
        this.renderSession.renderer = this;
        this.renderSession.resolution = this.resolution;
        this.renderSession.roundPixels = dataAndEvents.roundPixels || false;

        this.renderSession.maxTextureAvailableSpace = null;
        this.initContext();
        this.mapBlendModes();
    };
    val.WebGLRenderer.prototype.constructor = val.WebGLRenderer;

    val.WebGLRenderer.prototype.initContext = function () {
        var merge = this.view.getContext('webgl', this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = merge, !merge) {
            throw new Error("This browser does not support webGL. Try using the canvas renderer");
        }
        this.maxTextures = merge.getParameter(merge.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = this.gl.getParameter(merge.MAX_TEXTURE_SIZE);

        this.glContextId = merge.id = val.WebGLRenderer.glContextId++;
        val.glContexts[this.glContextId] = merge;
        val.instances[this.glContextId] = this;
        merge.disable(merge.DEPTH_TEST);
        merge.disable(merge.CULL_FACE);
        merge.enable(merge.BLEND);
        this.shaderManager.setContext(merge);
        this.spriteBatch.setContext(merge);
        this.maskManager.setContext(merge);
        this.filterManager.setContext(merge);
        this.blendModeManager.setContext(merge);
        this.stencilManager.setContext(merge);
        this.renderSession.gl = this.gl;
        this.resize(this.width, this.height);
        this.extensions.compression = {};
        var ETC1 = merge.getExtension('WEBGL_compressed_texture_etc1') || merge.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');
        var _0x23d9fe = merge.getExtension("WEBGL_compressed_texture_pvrtc") || merge.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        var S3TC = merge.getExtension('WEBGL_compressed_texture_s3tc') || merge.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        if (ETC1) {
            this.extensions.compression.ETC1 = ETC1;
        }
        if (_0x23d9fe) {
            this.extensions.compression.PVRTC = _0x23d9fe;
        }
        if (S3TC) {
            this.extensions.compression.S3TC = S3TC;
        }
    };

    val.WebGLRenderer.prototype.setTexturePriority = function (exts) {
        if (val._enableMultiTextureToggle) {

            var report = function (failing_message) {
                return --failing_message, failing_message |= failing_message >> 1, failing_message |= failing_message >> 2, failing_message |= failing_message >> 4, failing_message |= failing_message >> 8, failing_message |= failing_message >> 16, ++failing_message;
            };
            var results = this.gl;
            var _0x2c2d41 = results.getParameter(results.MAX_TEXTURE_IMAGE_UNITS);
            var length = results.getParameter(results.MAX_TEXTURE_SIZE);
            var cache = this.game.cache._cache.image;

            var ext = null;

            var i = 0;
            for (; i < this.currentBatchedTextures.length; i++) {
                if ((ext = this.currentBatchedTextures[i]) in cache) {

                    cache[ext].base.textureIndex = 0;
                } else {
                    console.warn('setTexturePriority: There is no image "%s" in the image cache.', ext);
                }
            }

            var padLength = length - report(Math.max(this.width, this.height));

            this.currentBatchedTextures.length = 0;

            var ei = 0;
            for (; ei < exts.length; ++ei) {
                if ((ext = exts[ei]) in cache) {
                    var hash = cache[ext].base;
                    if ((padLength -= report(Math.max(hash.width, hash.height))) <= 0) {

                        hash.textureIndex = 0;
                        console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', ext, padLength);
                    } else {

                        hash.textureIndex = 1 + ei % (_0x2c2d41 - 1);
                    }
                    this.currentBatchedTextures.push(ext);
                } else {
                    console.warn('setTexturePriority: There is no image "%s" in the image cache.', ext);
                }
            }
            return this.renderSession.maxTextureAvailableSpace = padLength, this.currentBatchedTextures;
        }
        console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.");
    };

    val.WebGLRenderer.prototype.render = function (a) {
        if (!this.contextLost) {
            var options = this.gl;
            options.viewport(0, 0, this.width, this.height);
            options.bindFramebuffer(options.FRAMEBUFFER, null);
            if (this.game.clearBeforeRender) {
                options.clearColor(a._bgColor.r, a._bgColor.g, a._bgColor.b, a._bgColor.a);
                options.clear(options.COLOR_BUFFER_BIT);
            }
            this.offset.x = this.game.camera._shake.x;
            this.offset.y = this.game.camera._shake.y;
            this.renderDisplayObject(a, this.projection);
        }
    };

    val.WebGLRenderer.prototype.renderDisplayObject = function (dataAndEvents, deepDataAndEvents, walkers, opt_obj2) {
        this.renderSession.blendModeManager.setBlendMode(val.blendModes.NORMAL);

        this.renderSession.drawCount = 0;

        this.renderSession.flipY = walkers ? -1 : 1;
        this.renderSession.projection = deepDataAndEvents;
        this.renderSession.offset = this.offset;
        this.spriteBatch.begin(this.renderSession);
        this.filterManager.begin(this.renderSession, walkers);
        dataAndEvents._renderWebGL(this.renderSession, opt_obj2);
        this.spriteBatch.end();
    };

    val.WebGLRenderer.prototype.resize = function (dataAndEvents, deepDataAndEvents) {

        this.width = dataAndEvents * this.resolution;

        this.height = deepDataAndEvents * this.resolution;
        this.view.width = this.width;
        this.view.height = this.height;
        if (this.autoResize) {

            this.view.style.width = this.width / this.resolution + "px";

            this.view.style.height = this.height / this.resolution + "px";
        }
        this.gl.viewport(0, 0, this.width, this.height);

        this.projection.x = this.width / 2 / this.resolution;

        this.projection.y = -this.height / 2 / this.resolution;
    };

    val.WebGLRenderer.prototype.updateCompressedTexture = function (pcity) {
        if (!pcity.hasLoaded) {
            return false;
        }
        var punittype = this.gl;
        var size = pcity.source;
        return pcity._glTextures[punittype.id] || (pcity._glTextures[punittype.id] = punittype.createTexture()), punittype.activeTexture(punittype.TEXTURE0 + pcity.textureIndex), punittype.bindTexture(punittype.TEXTURE_2D, pcity._glTextures[punittype.id]), punittype.compressedTexImage2D(punittype.TEXTURE_2D, 0, size.glExtensionFormat, size.width, size.height, 0, size.textureData), punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_MAG_FILTER,
                pcity.scaleMode === val.scaleModes.LINEAR ? punittype.LINEAR : punittype.NEAREST), pcity.mipmap && Phaser.Math.isPowerOfTwo(pcity.width, pcity.height) ? (punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_MIN_FILTER, pcity.scaleMode === val.scaleModes.LINEAR ? punittype.LINEAR_MIPMAP_LINEAR : punittype.NEAREST_MIPMAP_NEAREST), punittype.generateMipmap(punittype.TEXTURE_2D)) :
            punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_MIN_FILTER, pcity.scaleMode === val.scaleModes.LINEAR ? punittype.LINEAR : punittype.NEAREST), pcity._powerOf2 ? (punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_WRAP_S, punittype.REPEAT), punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_WRAP_T, punittype.REPEAT)) : (punittype.texParameteri(punittype.TEXTURE_2D,
                punittype.TEXTURE_WRAP_S, punittype.CLAMP_TO_EDGE), punittype.texParameteri(punittype.TEXTURE_2D, punittype.TEXTURE_WRAP_T, punittype.CLAMP_TO_EDGE)), pcity._dirty[punittype.id] = false, true;
    };

    val.WebGLRenderer.prototype.updateTexture = function (o) {
        if (!o.hasLoaded) {
            return false;
        }
        if (o.source.compressionAlgorithm) {
            return this.updateCompressedTexture(o);
        }
        var done = this.gl;
        return o._glTextures[done.id] || (o._glTextures[done.id] = done.createTexture()), done.activeTexture(done.TEXTURE0 + o.textureIndex), done.bindTexture(done.TEXTURE_2D, o._glTextures[done.id]), done.pixelStorei(done.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultipliedAlpha), done.texImage2D(done.TEXTURE_2D, 0, done.RGBA, done.RGBA, done.UNSIGNED_BYTE, o.source), done.texParameteri(done.TEXTURE_2D, done.TEXTURE_MAG_FILTER,
                o.scaleMode === val.scaleModes.LINEAR ? done.LINEAR : done.NEAREST), o.mipmap && Phaser.Math.isPowerOfTwo(o.width, o.height) ? (done.texParameteri(done.TEXTURE_2D, done.TEXTURE_MIN_FILTER, o.scaleMode === val.scaleModes.LINEAR ? done.LINEAR_MIPMAP_LINEAR : done.NEAREST_MIPMAP_NEAREST), done.generateMipmap(done.TEXTURE_2D)) : done.texParameteri(done.TEXTURE_2D, done.TEXTURE_MIN_FILTER, o.scaleMode ===
                val.scaleModes.LINEAR ? done.LINEAR : done.NEAREST), o._powerOf2 ? (done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_S, done.REPEAT), done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_T, done.REPEAT)) : (done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_S, done.CLAMP_TO_EDGE), done.texParameteri(done.TEXTURE_2D, done.TEXTURE_WRAP_T, done.CLAMP_TO_EDGE)), o._dirty[done.id] =
            false, true;
    };

    val.WebGLRenderer.prototype.destroy = function () {

        val.glContexts[this.glContextId] = null;

        this.projection = null;

        this.offset = null;
        this.shaderManager.destroy();
        this.spriteBatch.destroy();
        this.maskManager.destroy();
        this.filterManager.destroy();

        this.shaderManager = null;

        this.spriteBatch = null;

        this.maskManager = null;

        this.filterManager = null;

        this.gl = null;

        this.renderSession = null;
        Phaser.CanvasPool.remove(this);

        val.instances[this.glContextId] = null;
        val.WebGLRenderer.glContextId--;
    };

    val.WebGLRenderer.prototype.mapBlendModes = function () {
        var gl = this.gl;
        if (!val.blendModesWebGL) {

            var opt_left = [];
            var raw = val.blendModes;

            opt_left[raw.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.ADD] = [gl.SRC_ALPHA, gl.DST_ALPHA];

            opt_left[raw.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.SCREEN] = [gl.SRC_ALPHA, gl.ONE];

            opt_left[raw.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            opt_left[raw.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];

            val.blendModesWebGL = opt_left;
        }
    };

    val.WebGLRenderer.prototype.getMaxTextureUnit = function () {
        var results = this.gl;
        return results.getParameter(results.MAX_TEXTURE_IMAGE_UNITS);
    };

    val.enableMultiTexture = function () {

        val._enableMultiTextureToggle = true;
    };

    val.WebGLRenderer.glContextId = 0;

    val.WebGLRenderer.textureArray = [];

    val.WebGLBlendModeManager = function () {

        this.currentBlendMode = 99999;
    };
    val.WebGLBlendModeManager.prototype.constructor = val.WebGLBlendModeManager;

    val.WebGLBlendModeManager.prototype.setContext = function (dataAndEvents) {
        this.gl = dataAndEvents;
    };

    val.WebGLBlendModeManager.prototype.setBlendMode = function (dataAndEvents) {
        if (this.currentBlendMode === dataAndEvents) {
            return false;
        }
        this.currentBlendMode = dataAndEvents;
        var _0x83d5d9 = val.blendModesWebGL[this.currentBlendMode];
        return _0x83d5d9 && this.gl.blendFunc(_0x83d5d9[0], _0x83d5d9[1]), true;
    };

    val.WebGLBlendModeManager.prototype.destroy = function () {

        this.gl = null;
    };

    val.WebGLMaskManager = function () {};
    val.WebGLMaskManager.prototype.constructor = val.WebGLMaskManager;

    val.WebGLMaskManager.prototype.setContext = function (dataAndEvents) {
        this.gl = dataAndEvents;
    };

    val.WebGLMaskManager.prototype.pushMask = function (pcity, deepDataAndEvents) {
        var merge = deepDataAndEvents.gl;
        if (pcity.dirty) {
            val.WebGLGraphics.updateGraphics(pcity, merge);
        }
        if (void 0 !== pcity._webGL[merge.id]) {
            if (void 0 !== pcity._webGL[merge.id].data) {
                if (0 !== pcity._webGL[merge.id].data.length) {
                    deepDataAndEvents.stencilManager.pushStencil(pcity, pcity._webGL[merge.id].data[0], deepDataAndEvents);
                }
            }
        }
    };

    val.WebGLMaskManager.prototype.popMask = function (pcity, deepDataAndEvents) {
        var punittype = this.gl;
        if (void 0 !== pcity._webGL[punittype.id]) {
            if (void 0 !== pcity._webGL[punittype.id].data) {
                if (0 !== pcity._webGL[punittype.id].data.length) {
                    deepDataAndEvents.stencilManager.popStencil(pcity, pcity._webGL[punittype.id].data[0], deepDataAndEvents);
                }
            }
        }
    };

    val.WebGLMaskManager.prototype.destroy = function () {

        this.gl = null;
    };

    val.WebGLStencilManager = function () {

        this.stencilStack = [];

        this.reverse = true;

        this.count = 0;
    };

    val.WebGLStencilManager.prototype.setContext = function (dataAndEvents) {
        this.gl = dataAndEvents;
    };

    val.WebGLStencilManager.prototype.pushStencil = function (deepDataAndEvents, dep, opt_obj2) {
        var next = this.gl;
        this.bindGraphics(deepDataAndEvents, dep, opt_obj2);
        if (0 === this.stencilStack.length) {
            next.enable(next.STENCIL_TEST);
            next.clear(next.STENCIL_BUFFER_BIT);

            this.reverse = true;

            this.count = 0;
        }
        this.stencilStack.push(dep);
        var r20 = this.count;
        next.colorMask(false, false, false, false);
        next.stencilFunc(next.ALWAYS, 0, 255);
        next.stencilOp(next.KEEP, next.KEEP, next.INVERT);
        if (1 === dep.mode) {
            next.drawElements(next.TRIANGLE_FAN, dep.indices.length - 4, next.UNSIGNED_SHORT, 0);
            if (this.reverse) {
                next.stencilFunc(next.EQUAL, 255 - r20, 255);
                next.stencilOp(next.KEEP, next.KEEP, next.DECR);
            } else {
                next.stencilFunc(next.EQUAL, r20, 255);
                next.stencilOp(next.KEEP, next.KEEP, next.INCR);
            }
            next.drawElements(next.TRIANGLE_FAN, 4, next.UNSIGNED_SHORT, 2 * (dep.indices.length - 4));
            if (this.reverse) {
                next.stencilFunc(next.EQUAL, 255 - (r20 + 1), 255);
            } else {
                next.stencilFunc(next.EQUAL, r20 + 1, 255);
            }

            this.reverse = !this.reverse;
        } else {
            if (this.reverse) {
                next.stencilFunc(next.EQUAL, r20, 255);
                next.stencilOp(next.KEEP, next.KEEP, next.INCR);
            } else {
                next.stencilFunc(next.EQUAL, 255 - r20, 255);
                next.stencilOp(next.KEEP, next.KEEP, next.DECR);
            }
            next.drawElements(next.TRIANGLE_STRIP, dep.indices.length, next.UNSIGNED_SHORT, 0);
            if (this.reverse) {
                next.stencilFunc(next.EQUAL, r20 + 1, 255);
            } else {
                next.stencilFunc(next.EQUAL, 255 - (r20 + 1), 255);
            }
        }
        next.colorMask(true, true, true, true);
        next.stencilOp(next.KEEP, next.KEEP, next.KEEP);
        this.count++;
    };

    val.WebGLStencilManager.prototype.bindGraphics = function (dataAndEvents, dataTransfer, params) {

        this._currentGraphics = dataAndEvents;
        var r20;
        var css = this.gl;
        var param = params.projection;
        var text = params.offset;
        if (1 === dataTransfer.mode) {
            r20 = params.shaderManager.complexPrimitiveShader;
            params.shaderManager.setShader(r20);
            css.uniform1f(r20.flipY, params.flipY);
            css.uniformMatrix3fv(r20.translationMatrix, false, dataAndEvents.worldTransform.toArray(true));
            css.uniform2f(r20.projectionVector, param.x, -param.y);
            css.uniform2f(r20.offsetVector, -text.x, -text.y);
            css.uniform3fv(r20.tintColor, Phaser.Color.hexToRGBArray(dataAndEvents.tint));
            css.uniform3fv(r20.color, dataTransfer.color);
            css.uniform1f(r20.alpha, dataAndEvents.worldAlpha * dataTransfer.alpha);
            css.bindBuffer(css.ARRAY_BUFFER, dataTransfer.buffer);
            css.vertexAttribPointer(r20.aVertexPosition, 2, css.FLOAT, false, 8, 0);
            css.bindBuffer(css.ELEMENT_ARRAY_BUFFER, dataTransfer.indexBuffer);
        } else {
            r20 = params.shaderManager.primitiveShader;
            params.shaderManager.setShader(r20);
            css.uniformMatrix3fv(r20.translationMatrix, false, dataAndEvents.worldTransform.toArray(true));
            css.uniform1f(r20.flipY, params.flipY);
            css.uniform2f(r20.projectionVector, param.x, -param.y);
            css.uniform2f(r20.offsetVector, -text.x, -text.y);
            css.uniform3fv(r20.tintColor, Phaser.Color.hexToRGBArray(dataAndEvents.tint));
            css.uniform1f(r20.alpha, dataAndEvents.worldAlpha);
            css.bindBuffer(css.ARRAY_BUFFER, dataTransfer.buffer);
            css.vertexAttribPointer(r20.aVertexPosition, 2, css.FLOAT, false, 24, 0);
            css.vertexAttribPointer(r20.colorAttribute, 4, css.FLOAT, false, 24, 8);
            css.bindBuffer(css.ELEMENT_ARRAY_BUFFER, dataTransfer.indexBuffer);
        }
    };

    val.WebGLStencilManager.prototype.popStencil = function (deepDataAndEvents, pp, opt_obj2) {
        var gl = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) {
            gl.disable(gl.STENCIL_TEST);
        } else {
            var r20 = this.count;
            this.bindGraphics(deepDataAndEvents, pp, opt_obj2);
            gl.colorMask(false, false, false, false);
            if (1 === pp.mode) {

                this.reverse = !this.reverse;
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, 255 - (r20 + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                } else {
                    gl.stencilFunc(gl.EQUAL, r20 + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                }
                gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, 2 * (pp.indices.length - 4));
                gl.stencilFunc(gl.ALWAYS, 0, 255);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.INVERT);
                gl.drawElements(gl.TRIANGLE_FAN, pp.indices.length - 4, gl.UNSIGNED_SHORT, 0);
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, r20, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, 255 - r20, 255);
                }
            } else {
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, r20 + 1, 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                } else {
                    gl.stencilFunc(gl.EQUAL, 255 - (r20 + 1), 255);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                }
                gl.drawElements(gl.TRIANGLE_STRIP, pp.indices.length, gl.UNSIGNED_SHORT, 0);
                if (this.reverse) {
                    gl.stencilFunc(gl.EQUAL, r20, 255);
                } else {
                    gl.stencilFunc(gl.EQUAL, 255 - r20, 255);
                }
            }
            gl.colorMask(true, true, true, true);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        }
    };

    val.WebGLStencilManager.prototype.destroy = function () {

        this.stencilStack = null;

        this.gl = null;
    };

    val.WebGLShaderManager = function () {

        this.maxAttibs = 10;

        this.attribState = [];

        this.tempAttribState = [];

        var unlock = 0;
        for (; unlock < this.maxAttibs; unlock++) {

            this.attribState[unlock] = false;
        }

        this.stack = [];
    };
    val.WebGLShaderManager.prototype.constructor = val.WebGLShaderManager;

    val.WebGLShaderManager.prototype.setContext = function (dataAndEvents) {
        this.gl = dataAndEvents;
        this.primitiveShader = new(val.PrimitiveShader)(dataAndEvents);
        this.complexPrimitiveShader = new val.ComplexPrimitiveShader(dataAndEvents);
        this.defaultShader = new(val.PixiShader)(dataAndEvents);
        this.fastShader = new(val.PixiFastShader)(dataAndEvents);
        this.stripShader = new(val.StripShader)(dataAndEvents);
        this.creatureShader = val.CreatureShader ? new(val.CreatureShader)(dataAndEvents) : null;
        this.setShader(this.defaultShader);
    };

    val.WebGLShaderManager.prototype.setAttribs = function (h) {
        var k;

        k = 0;
        for (; k < this.tempAttribState.length; k++) {

            this.tempAttribState[k] = false;
        }

        k = 0;
        for (; k < h.length; k++) {
            var cs = h[k];

            this.tempAttribState[cs] = true;
        }
        var el = this.gl;

        k = 0;
        for (; k < this.attribState.length; k++) {
            if (this.attribState[k] !== this.tempAttribState[k]) {
                this.attribState[k] = this.tempAttribState[k];
                if (this.tempAttribState[k]) {
                    el.enableVertexAttribArray(k);
                } else {
                    el.disableVertexAttribArray(k);
                }
            }
        }
    };

    val.WebGLShaderManager.prototype.setShader = function (dataAndEvents) {
        return this._currentId !== dataAndEvents._UID && (this._currentId = dataAndEvents._UID, this.currentShader = dataAndEvents, this.gl.useProgram(dataAndEvents.program), this.setAttribs(dataAndEvents.attributes), true);
    };

    val.WebGLShaderManager.prototype.destroy = function () {

        this.attribState = null;

        this.tempAttribState = null;
        this.primitiveShader.destroy();
        this.complexPrimitiveShader.destroy();
        this.defaultShader.destroy();
        this.fastShader.destroy();
        this.stripShader.destroy();
        if (this.creatureShader) {
            this.creatureShader.destroy();
        }

        this.gl = null;
    };

    val.WebGLSpriteBatch = function (dataAndEvents) {
        this.game = dataAndEvents;

        this.vertSize = 5;

        this.size = 2E3;

        this.vertexSize = 24;

        var l = this.vertexSize * this.size * 4;

        var bytes = 6 * this.size;

        this.vertices = new ArrayBuffer(l);

        this.positions = new Float32Array(this.vertices);

        this.colors = new Uint32Array(this.vertices);

        this.indices = new Uint16Array(bytes);

        this.lastIndexCount = 0;

        var i = 0;

        var j = 0;
        for (; i < bytes; i += 6, j += 4) {

            this.indices[i + 0] = j + 0;

            this.indices[i + 1] = j + 1;

            this.indices[i + 2] = j + 2;

            this.indices[i + 3] = j + 0;

            this.indices[i + 4] = j + 2;

            this.indices[i + 5] = j + 3;
        }

        this.drawing = false;

        this.currentBatchSize = 0;

        this.currentBaseTexture = null;

        this.dirty = true;

        this.textures = [];

        this.blendModes = [];

        this.shaders = [];

        this.sprites = [];

        this.defaultShader = null;
    };

    val.WebGLSpriteBatch.prototype.setContext = function (done) {
        if (this.MAX_TEXTURES = done.getParameter(done.MAX_TEXTURE_IMAGE_UNITS), this.gl = done, val._enableMultiTextureToggle) {
            var _0x47000f = `	if (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\
`;

            var _0x5d82de = 1;
            for (; _0x5d82de < this.MAX_TEXTURES; ++_0x5d82de) {
                _0x47000f += "\tif (vTextureIndex == " + _0x5d82de + '.0) {gl_FragColor = texture2D(uSamplerArray[' + _0x5d82de + `], vTextureCoord) * vColor;return;}\
`;
            }
            this.defaultShader = new Phaser.Filter(this.game, void 0, ['//WebGLSpriteBatch Fragment Shader.', 'precision lowp float;', "varying vec2 vTextureCoord;", 'varying vec4 vColor;', 'varying float vTextureIndex;', 'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + "];", 'void main(void) {', _0x47000f, '	gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;', "}"]);
        } else {
            this.defaultShader = new(Phaser.Filter)(this.game, void 0, ['//WebGLSpriteBatch Fragment Shader.', 'precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureIndex;', 'uniform sampler2D uSampler;', "void main(void) {", '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;', "}"]);
        }
        this.vertexBuffer = done.createBuffer();
        this.indexBuffer = done.createBuffer();
        done.bindBuffer(done.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        done.bufferData(done.ELEMENT_ARRAY_BUFFER, this.indices, done.STATIC_DRAW);
        done.bindBuffer(done.ARRAY_BUFFER, this.vertexBuffer);
        done.bufferData(done.ARRAY_BUFFER, this.vertices, done.DYNAMIC_DRAW);

        this.currentBlendMode = 99999;
        var uniforms = new val.PixiShader(done);
        uniforms.fragmentSrc = this.defaultShader.fragmentSrc;
        uniforms.uniforms = {};
        uniforms.init();
        this.defaultShader.shaders[done.id] = uniforms;
    };

    val.WebGLSpriteBatch.prototype.begin = function (dataAndEvents) {
        this.renderSession = dataAndEvents;
        this.shader = this.renderSession.shaderManager.defaultShader;
        this.start();
    };

    val.WebGLSpriteBatch.prototype.end = function () {
        this.flush();
    };

    val.WebGLSpriteBatch.prototype.render = function (data, type) {
        var array = data.texture;
        var doc = array.baseTexture;
        var done = this.gl;
        if (val.WebGLRenderer.textureArray[doc.textureIndex] != doc) {
            this.flush();
            done.activeTexture(done.TEXTURE0 + doc.textureIndex);
            done.bindTexture(done.TEXTURE_2D, doc._glTextures[done.id]);
            val.WebGLRenderer.textureArray[doc.textureIndex] = doc;
        }
        var msg = data.worldTransform;
        if (type) {

            msg = type;
        }
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = array.baseTexture;
        }
        var ranges = array._uvs;
        if (ranges) {
            var x;
            var b00;
            var y;
            var b10;
            var m = data.anchor.x;
            var item = data.anchor.y;
            if (array.trim) {
                var p1 = array.trim;
                x = (b00 = p1.x - m * p1.width) + array.crop.width;
                y = (b10 = p1.y - item * p1.height) + array.crop.height;
            } else {

                x = array.frame.width * (1 - m);

                b00 = array.frame.width * -m;

                y = array.frame.height * (1 - item);

                b10 = array.frame.height * -item;
            }

            var i = this.currentBatchSize * this.vertexSize;
            var rx = (this.currentBatchSize, array.baseTexture.resolution);
            var a12 = array.baseTexture.textureIndex;

            var a00 = msg.a / rx;

            var qz = msg.b / rx;

            var a01 = msg.c / rx;

            var qw = msg.d / rx;
            var b = msg.tx;
            var count = msg.ty;
            var t = (array.crop.width, array.crop.height);
            if (array.rotated) {
                var v = msg.a;
                var c = msg.b;
                var chunk = msg.c;
                var index = msg.d;

                var next = b00;
                var value = x;
                b = msg.c * t + b;
                count = msg.d * t + count;

                a00 = 6.123233995736766E-17 * v - chunk;

                qz = 6.123233995736766E-17 * c - index;
                a01 = v + 6.123233995736766E-17 * chunk;
                qw = c + 6.123233995736766E-17 * index;
                array._updateUvsInverted();
                x = y;

                b00 = b10;
                y = value;

                b10 = next;
            }
            var res = this.colors;
            var out = this.positions;
            var opcode = data.tint;

            var key = (opcode >> 16) + (65280 & opcode) + ((255 & opcode) << 16) + (255 * data.worldAlpha << 24);
            if (this.renderSession.roundPixels) {

                out[i++] = a00 * b00 + a01 * b10 + b | 0;

                out[i++] = qw * b10 + qz * b00 + count | 0;
                out[i++] = ranges.x0;
                out[i++] = ranges.y0;

                res[i++] = key;
                out[i++] = a12;

                out[i++] = a00 * x + a01 * b10 + b | 0;

                out[i++] = qw * b10 + qz * x + count | 0;
                out[i++] = ranges.x1;
                out[i++] = ranges.y1;

                res[i++] = key;
                out[i++] = a12;

                out[i++] = a00 * x + a01 * y + b | 0;

                out[i++] = qw * y + qz * x + count | 0;
                out[i++] = ranges.x2;
                out[i++] = ranges.y2;

                res[i++] = key;
                out[i++] = a12;

                out[i++] = a00 * b00 + a01 * y + b | 0;

                out[i++] = qw * y + qz * b00 + count | 0;
                out[i++] = ranges.x3;
                out[i++] = ranges.y3;

                res[i++] = key;
                out[i++] = a12;
            } else {
                out[i++] = a00 * b00 + a01 * b10 + b;
                out[i++] = qw * b10 + qz * b00 + count;
                out[i++] = ranges.x0;
                out[i++] = ranges.y0;

                res[i++] = key;
                out[i++] = a12;
                out[i++] = a00 * x + a01 * b10 + b;
                out[i++] = qw * b10 + qz * x + count;
                out[i++] = ranges.x1;
                out[i++] = ranges.y1;

                res[i++] = key;
                out[i++] = a12;
                out[i++] = a00 * x + a01 * y + b;
                out[i++] = qw * y + qz * x + count;
                out[i++] = ranges.x2;
                out[i++] = ranges.y2;

                res[i++] = key;
                out[i++] = a12;
                out[i++] = a00 * b00 + a01 * y + b;
                out[i++] = qw * y + qz * b00 + count;
                out[i++] = ranges.x3;
                out[i++] = ranges.y3;

                res[i++] = key;
                out[i++] = a12;
            }

            this.sprites[this.currentBatchSize++] = data;
        }
    };

    val.WebGLSpriteBatch.prototype.renderTilingSprite = function (data) {
        var style = data.tilingTexture;
        var value = style.baseTexture;
        var done = this.gl;
        var key = data.texture.baseTexture.textureIndex;
        if (val.WebGLRenderer.textureArray[key] != value) {
            this.flush();
            done.activeTexture(done.TEXTURE0 + key);
            done.bindTexture(done.TEXTURE_2D, value._glTextures[done.id]);
            val.WebGLRenderer.textureArray[key] = value;
        }
        if (this.currentBatchSize >= this.size) {
            this.flush();
            this.currentBaseTexture = style.baseTexture;
        }
        if (!data._uvs) {
            data._uvs = new val.TextureUvs;
        }
        var obj = data._uvs;
        var dw = style.baseTexture.width;
        var sign = style.baseTexture.height;
        data.tilePosition.x %= dw * data.tileScaleOffset.x;
        data.tilePosition.y %= sign * data.tileScaleOffset.y;

        var x2 = data.tilePosition.x / (dw * data.tileScaleOffset.x);

        var q = data.tilePosition.y / (sign * data.tileScaleOffset.y);

        var x1 = data.width / dw / (data.tileScale.x * data.tileScaleOffset.x);

        var l = data.height / sign / (data.tileScale.y * data.tileScaleOffset.y);

        obj.x0 = 0 - x2;

        obj.y0 = 0 - q;

        obj.x1 = 1 * x1 - x2;

        obj.y1 = 0 - q;

        obj.x2 = 1 * x1 - x2;

        obj.y2 = 1 * l - q;

        obj.x3 = 0 - x2;

        obj.y3 = 1 * l - q;
        var opcode = data.tint;

        var tmp = (opcode >> 16) + (65280 & opcode) + ((255 & opcode) << 16) + (255 * data.worldAlpha << 24);
        var res = this.positions;
        var elem = this.colors;
        var alpha = data.width;
        var cosVal = data.height;
        var r = data.anchor.x;
        var lumR = data.anchor.y;

        var b00 = alpha * (1 - r);

        var b01 = alpha * -r;

        var b11 = cosVal * (1 - lumR);

        var b10 = cosVal * -lumR;

        var i = this.currentBatchSize * this.vertexSize;
        var div = style.baseTexture.resolution;
        var m = data.worldTransform;

        var a20 = m.a / div;

        var a10 = m.b / div;

        var a21 = m.c / div;

        var a00 = m.d / div;
        var t = m.tx;
        var formula = m.ty;
        res[i++] = a20 * b01 + a21 * b10 + t;
        res[i++] = a00 * b10 + a10 * b01 + formula;
        res[i++] = obj.x0;
        res[i++] = obj.y0;

        elem[i++] = tmp;
        res[i++] = key;
        res[i++] = a20 * b00 + a21 * b10 + t;
        res[i++] = a00 * b10 + a10 * b00 + formula;
        res[i++] = obj.x1;
        res[i++] = obj.y1;

        elem[i++] = tmp;
        res[i++] = key;
        res[i++] = a20 * b00 + a21 * b11 + t;
        res[i++] = a00 * b11 + a10 * b00 + formula;
        res[i++] = obj.x2;
        res[i++] = obj.y2;

        elem[i++] = tmp;
        res[i++] = key;
        res[i++] = a20 * b01 + a21 * b11 + t;
        res[i++] = a00 * b11 + a10 * b01 + formula;
        res[i++] = obj.x3;
        res[i++] = obj.y3;

        elem[i++] = tmp;
        res[i++] = key;

        this.sprites[this.currentBatchSize++] = data;
    };

    val.WebGLSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
            var pObj;
            var done = this.gl;
            if (this.dirty) {

                this.dirty = false;
                pObj = this.defaultShader.shaders[done.id];
                done.activeTexture(done.TEXTURE0);
                done.bindBuffer(done.ARRAY_BUFFER, this.vertexBuffer);
                done.bindBuffer(done.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var r20 = this.vertexSize;
                done.vertexAttribPointer(pObj.aVertexPosition, 2, done.FLOAT, false, r20, 0);
                done.vertexAttribPointer(pObj.aTextureCoord, 2, done.FLOAT, false, r20, 8);
                done.vertexAttribPointer(pObj.colorAttribute, 4, done.UNSIGNED_BYTE, true, r20, 16);
                done.vertexAttribPointer(pObj.aTextureIndex, 1, done.FLOAT, false, r20, 20);
            }
            if (this.currentBatchSize > 0.5 * this.size) {
                done.bufferSubData(done.ARRAY_BUFFER, 0, this.vertices);
            } else {
                done.bindBuffer(done.ARRAY_BUFFER, this.vertexBuffer);
                var restoreScript = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                done.bufferSubData(done.ARRAY_BUFFER, 0, restoreScript);
            }
            var args;
            var sprites;
            var o;
            var draw2DCache;

            var udataCur = 0;

            var foundI = 0;

            var lastArgs = null;
            var rreturn = this.renderSession.blendModeManager.currentBlendMode;

            var options = null;

            var program = false;

            var inverse = false;

            var i = 0;
            var padLength = this.currentBatchSize;
            for (; i < padLength; i++) {
                args = (draw2DCache = this.sprites[i]).tilingTexture ? draw2DCache.tilingTexture.baseTexture : draw2DCache.texture.baseTexture;

                program = rreturn !== (sprites = draw2DCache.blendMode);

                inverse = options !== (o = draw2DCache.shader || this.defaultShader);
                var pageY = args.skipRender;
                if (pageY && (draw2DCache.children.length > 0 && (pageY = false)), (program || inverse) && (this.renderBatch(lastArgs, udataCur, foundI), foundI = i, udataCur = 0, lastArgs = args, program && (rreturn = sprites, this.renderSession.blendModeManager.setBlendMode(rreturn)), inverse)) {
                    if (!(pObj = (options = o).shaders[done.id])) {
                        (pObj = new(val.PixiShader)(done)).fragmentSrc = options.fragmentSrc;
                        pObj.uniforms = options.uniforms;
                        pObj.init();
                        options.shaders[done.id] = pObj;
                    }
                    this.renderSession.shaderManager.setShader(pObj);
                    if (pObj.dirty) {
                        pObj.syncUniforms();
                    }
                    var urls = this.renderSession.projection;
                    done.uniform2f(pObj.projectionVector, urls.x, urls.y);
                    var offset = this.renderSession.offset;
                    done.uniform2f(pObj.offsetVector, offset.x, offset.y);
                }
                udataCur++;
            }
            this.renderBatch(lastArgs, udataCur, foundI);

            this.currentBatchSize = 0;
        }
    };

    val.WebGLSpriteBatch.prototype.renderBatch = function (pcity, dataAndEvents, deepDataAndEvents) {
        if (0 !== dataAndEvents) {
            var punittype = this.gl;
            if (pcity._dirty[punittype.id]) {
                if (!this.renderSession.renderer.updateTexture(pcity)) {
                    return;
                }
            } else {
                punittype.bindTexture(punittype.TEXTURE_2D, pcity._glTextures[punittype.id]);
            }
            punittype.drawElements(punittype.TRIANGLES, 6 * dataAndEvents, punittype.UNSIGNED_SHORT, 6 * deepDataAndEvents * 2);
            this.renderSession.drawCount++;
        }
    };

    val.WebGLSpriteBatch.prototype.stop = function () {
        this.flush();

        this.dirty = true;
    };

    val.WebGLSpriteBatch.prototype.start = function () {

        this.dirty = true;
    };

    val.WebGLSpriteBatch.prototype.destroy = function () {

        this.vertices = null;

        this.indices = null;
        this.gl.deleteBuffer(this.vertexBuffer);
        this.gl.deleteBuffer(this.indexBuffer);

        this.currentBaseTexture = null;

        this.gl = null;
    };

    val.WebGLFastSpriteBatch = function (deepDataAndEvents) {

        this.vertSize = 11;

        this.maxSize = 6E3;
        this.size = this.maxSize;

        var uvs = 4 * this.size * this.vertSize;

        var bytes = 6 * this.maxSize;

        this.vertices = new Float32Array(uvs);

        this.indices = new Uint16Array(bytes);

        this.vertexBuffer = null;

        this.indexBuffer = null;

        this.lastIndexCount = 0;

        var i = 0;

        var j = 0;
        for (; i < bytes; i += 6, j += 4) {

            this.indices[i + 0] = j + 0;

            this.indices[i + 1] = j + 1;

            this.indices[i + 2] = j + 2;

            this.indices[i + 3] = j + 0;

            this.indices[i + 4] = j + 2;

            this.indices[i + 5] = j + 3;
        }

        this.drawing = false;

        this.currentBatchSize = 0;

        this.currentBaseTexture = null;

        this.currentBlendMode = 0;

        this.renderSession = null;

        this.shader = null;

        this.matrix = null;
        this.setContext(deepDataAndEvents);
    };
    val.WebGLFastSpriteBatch.prototype.constructor = val.WebGLFastSpriteBatch;

    val.WebGLFastSpriteBatch.prototype.setContext = function (dataAndEvents) {

        this.gl = dataAndEvents;
        this.vertexBuffer = dataAndEvents.createBuffer();
        this.indexBuffer = dataAndEvents.createBuffer();
        dataAndEvents.bindBuffer(dataAndEvents.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        dataAndEvents.bufferData(dataAndEvents.ELEMENT_ARRAY_BUFFER, this.indices, dataAndEvents.STATIC_DRAW);
        dataAndEvents.bindBuffer(dataAndEvents.ARRAY_BUFFER, this.vertexBuffer);
        dataAndEvents.bufferData(dataAndEvents.ARRAY_BUFFER, this.vertices, dataAndEvents.DYNAMIC_DRAW);
    };

    val.WebGLFastSpriteBatch.prototype.begin = function (dataAndEvents, deepDataAndEvents) {
        this.renderSession = deepDataAndEvents;
        this.shader = this.renderSession.shaderManager.fastShader;
        this.matrix = dataAndEvents.worldTransform.toArray(true);
        this.start();
    };

    val.WebGLFastSpriteBatch.prototype.end = function () {
        this.flush();
    };

    val.WebGLFastSpriteBatch.prototype.render = function (browserobj) {
        var result = browserobj.children;
        var message = result[0];
        if (message.texture._uvs) {
            this.currentBaseTexture = message.texture.baseTexture;
            if (message.blendMode !== this.renderSession.blendModeManager.currentBlendMode) {
                this.flush();
                this.renderSession.blendModeManager.setBlendMode(message.blendMode);
            }

            var j = 0;
            var jj = result.length;
            for (; j < jj; j++) {
                this.renderSprite(result[j]);
            }
            this.flush();
        }
    };

    val.WebGLFastSpriteBatch.prototype.renderSprite = function (options) {
        var elem = options.texture.baseTexture;
        var done = this.gl;
        var idx = options.texture.baseTexture.textureIndex;
        if ((val.WebGLRenderer.textureArray[idx] == elem || (!elem._glTextures[done.id] || (options.texture.baseTexture.skipRender || (this.flush(), done.activeTexture(done.TEXTURE0 + idx), done.bindTexture(done.TEXTURE_2D, elem._glTextures[done.id]), val.WebGLRenderer.textureArray[idx] = elem, options.texture._uvs)))) && options.visible) {
            var ranges;
            var e;
            var defaultValue;
            var protoVal;
            var scrubbed;
            var i;
            var self = this.vertices;
            if (ranges = options.texture._uvs, options.texture.frame.width, options.texture.frame.height, options.texture.trim) {
                var other = options.texture.trim;
                e = (defaultValue = other.x - options.anchor.x * other.width) + options.texture.crop.width;
                protoVal = (scrubbed = other.y - options.anchor.y * other.height) + options.texture.crop.height;
            } else {

                e = options.texture.frame.width * (1 - options.anchor.x);

                defaultValue = options.texture.frame.width * -options.anchor.x;

                protoVal = options.texture.frame.height * (1 - options.anchor.y);

                scrubbed = options.texture.frame.height * -options.anchor.y;
            }

            i = 4 * this.currentBatchSize * this.vertSize;

            self[i++] = defaultValue;

            self[i++] = scrubbed;
            self[i++] = options.position.x;
            self[i++] = options.position.y;
            self[i++] = options.scale.x;
            self[i++] = options.scale.y;
            self[i++] = options.rotation;
            self[i++] = ranges.x0;
            self[i++] = ranges.y1;
            self[i++] = options.alpha;
            self[i++] = idx;
            self[i++] = e;

            self[i++] = scrubbed;
            self[i++] = options.position.x;
            self[i++] = options.position.y;
            self[i++] = options.scale.x;
            self[i++] = options.scale.y;
            self[i++] = options.rotation;
            self[i++] = ranges.x1;
            self[i++] = ranges.y1;
            self[i++] = options.alpha;
            self[i++] = idx;
            self[i++] = e;
            self[i++] = protoVal;
            self[i++] = options.position.x;
            self[i++] = options.position.y;
            self[i++] = options.scale.x;
            self[i++] = options.scale.y;
            self[i++] = options.rotation;
            self[i++] = ranges.x2;
            self[i++] = ranges.y2;
            self[i++] = options.alpha;
            self[i++] = idx;

            self[i++] = defaultValue;
            self[i++] = protoVal;
            self[i++] = options.position.x;
            self[i++] = options.position.y;
            self[i++] = options.scale.x;
            self[i++] = options.scale.y;
            self[i++] = options.rotation;
            self[i++] = ranges.x3;
            self[i++] = ranges.y3;
            self[i++] = options.alpha;
            self[i++] = idx;
            if (++this.currentBatchSize >= this.size) {
                this.flush();
            }
        }
    };

    val.WebGLFastSpriteBatch.prototype.flush = function () {
        if (0 !== this.currentBatchSize) {
            var merge = this.gl;
            if (this.currentBaseTexture._glTextures[merge.id]) {
                if (this.currentBatchSize > 0.5 * this.size) {
                    merge.bufferSubData(merge.ARRAY_BUFFER, 0, this.vertices);
                } else {
                    var r20 = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    merge.bufferSubData(merge.ARRAY_BUFFER, 0, r20);
                }
                merge.drawElements(merge.TRIANGLES, 6 * this.currentBatchSize, merge.UNSIGNED_SHORT, 0);

                this.currentBatchSize = 0;
                this.renderSession.drawCount++;
            } else {
                this.renderSession.renderer.updateTexture(this.currentBaseTexture, merge);
            }
        }
    };

    val.WebGLFastSpriteBatch.prototype.stop = function () {
        this.flush();
    };

    val.WebGLFastSpriteBatch.prototype.start = function () {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var urls = this.renderSession.projection;
        gl.uniform2f(this.shader.projectionVector, urls.x, urls.y);
        gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);

        var r20 = 4 * this.vertSize;
        gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, r20, 0);
        gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, r20, 8);
        gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, r20, 16);
        gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, r20, 24);
        gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, r20, 28);
        gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, r20, 36);
        gl.vertexAttribPointer(this.shader.aTextureIndex, 1, gl.FLOAT, false, r20, 40);
    };

    val.WebGLFilterManager = function () {

        this.filterStack = [];

        this.offsetX = 0;

        this.offsetY = 0;
    };
    val.WebGLFilterManager.prototype.constructor = val.WebGLFilterManager;

    val.WebGLFilterManager.prototype.setContext = function (dataAndEvents) {
        this.gl = dataAndEvents;

        this.texturePool = [];
        this.initShaderBuffers();
    };

    val.WebGLFilterManager.prototype.begin = function (dataAndEvents, deepDataAndEvents) {
        this.renderSession = dataAndEvents;
        this.defaultShader = dataAndEvents.shaderManager.defaultShader;
        var urls = this.renderSession.projection;

        this.width = 2 * urls.x;

        this.height = 2 * -urls.y;
        this.buffer = deepDataAndEvents;
    };

    val.WebGLFilterManager.prototype.pushFilter = function (data) {
        var r20 = this.gl;
        var urls = this.renderSession.projection;
        var row = this.renderSession.offset;
        data._filterArea = data.target.filterArea || data.target.getBounds();
        data._previous_stencil_mgr = this.renderSession.stencilManager;
        this.renderSession.stencilManager = new(val.WebGLStencilManager);
        this.renderSession.stencilManager.setContext(r20);
        r20.disable(r20.STENCIL_TEST);
        this.filterStack.push(data);
        var coords = data.filterPasses[0];
        this.offsetX += data._filterArea.x;
        this.offsetY += data._filterArea.y;
        var element = this.texturePool.pop();
        if (element) {
            element.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
        } else {
            element = new(val.FilterTexture)(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
        }
        r20.bindTexture(r20.TEXTURE_2D, element.texture);
        var self = data._filterArea;
        var y = coords.padding;
        self.x -= y;
        self.y -= y;
        self.width += 2 * y;
        self.height += 2 * y;
        if (self.x < 0) {

            self.x = 0;
        }
        if (self.width > this.width) {
            self.width = this.width;
        }
        if (self.y < 0) {

            self.y = 0;
        }
        if (self.height > this.height) {
            self.height = this.height;
        }
        r20.bindFramebuffer(r20.FRAMEBUFFER, element.frameBuffer);
        r20.viewport(0, 0, self.width * this.renderSession.resolution, self.height * this.renderSession.resolution);

        urls.x = self.width / 2;

        urls.y = -self.height / 2;

        row.x = -self.x;

        row.y = -self.y;
        r20.colorMask(true, true, true, true);
        r20.clearColor(0, 0, 0, 0);
        r20.clear(r20.COLOR_BUFFER_BIT);
        data._glFilterTexture = element;
    };

    val.WebGLFilterManager.prototype.popFilter = function () {
        var gl = this.gl;
        var dicts = this.filterStack.pop();
        var dict = dicts._filterArea;
        var queuedFn = dicts._glFilterTexture;
        var urls = this.renderSession.projection;
        var attrs = this.renderSession.offset;
        if (dicts.filterPasses.length > 1) {
            gl.viewport(0, 0, dict.width * this.renderSession.resolution, dict.height * this.renderSession.resolution);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

            this.vertexArray[0] = 0;
            this.vertexArray[1] = dict.height;
            this.vertexArray[2] = dict.width;
            this.vertexArray[3] = dict.height;

            this.vertexArray[4] = 0;

            this.vertexArray[5] = 0;
            this.vertexArray[6] = dict.width;

            this.vertexArray[7] = 0;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

            this.uvArray[2] = dict.width / this.width;

            this.uvArray[5] = dict.height / this.height;

            this.uvArray[6] = dict.width / this.width;

            this.uvArray[7] = dict.height / this.height;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
            var fn = queuedFn;
            var tmp = this.texturePool.pop();
            if (!tmp) {
                tmp = new(val.FilterTexture)(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
            }
            tmp.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);
            gl.bindFramebuffer(gl.FRAMEBUFFER, tmp.frameBuffer);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.BLEND);

            var unlock = 0;
            for (; unlock < dicts.filterPasses.length - 1; unlock++) {
                var cache = dicts.filterPasses[unlock];
                gl.bindFramebuffer(gl.FRAMEBUFFER, tmp.frameBuffer);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fn.texture);
                this.applyFilterPass(cache, dict, dict.width, dict.height);
                var obj = fn;
                fn = tmp;
                tmp = obj;
            }
            gl.enable(gl.BLEND);
            queuedFn = fn;
            this.texturePool.push(tmp);
        }
        var r20 = dicts.filterPasses[dicts.filterPasses.length - 1];
        this.offsetX -= dict.x;
        this.offsetY -= dict.y;
        var width = this.width;
        var height = this.height;

        var x = 0;

        var value = 0;
        var restoreScript = this.buffer;
        if (0 === this.filterStack.length) {
            gl.colorMask(true, true, true, true);
        } else {
            var array = this.filterStack[this.filterStack.length - 1];
            width = (dict = array._filterArea).width;
            height = dict.height;
            x = dict.x;
            value = dict.y;
            restoreScript = array._glFilterTexture.frameBuffer;
        }

        urls.x = width / 2;

        urls.y = -height / 2;
        attrs.x = x;
        attrs.y = value;

        var dx0 = (dict = dicts._filterArea).x - x;

        var relPathStr = dict.y - value;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        this.vertexArray[0] = dx0;
        this.vertexArray[1] = relPathStr + dict.height;
        this.vertexArray[2] = dx0 + dict.width;
        this.vertexArray[3] = relPathStr + dict.height;

        this.vertexArray[4] = dx0;

        this.vertexArray[5] = relPathStr;
        this.vertexArray[6] = dx0 + dict.width;

        this.vertexArray[7] = relPathStr;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

        this.uvArray[2] = dict.width / this.width;

        this.uvArray[5] = dict.height / this.height;

        this.uvArray[6] = dict.width / this.width;

        this.uvArray[7] = dict.height / this.height;
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);
        gl.viewport(0, 0, width * this.renderSession.resolution, height * this.renderSession.resolution);
        gl.bindFramebuffer(gl.FRAMEBUFFER, restoreScript);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, queuedFn.texture);
        if (this.renderSession.stencilManager) {
            this.renderSession.stencilManager.destroy();
        }
        this.renderSession.stencilManager = dicts._previous_stencil_mgr;

        dicts._previous_stencil_mgr = null;
        if (this.renderSession.stencilManager.count > 0) {
            gl.enable(gl.STENCIL_TEST);
        } else {
            gl.disable(gl.STENCIL_TEST);
        }
        this.applyFilterPass(r20, dict, width, height);
        this.texturePool.push(queuedFn);

        dicts._glFilterTexture = null;
    };

    val.WebGLFilterManager.prototype.applyFilterPass = function (pcity, deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist) {
        var punittype = this.gl;
        var pObj = pcity.shaders[punittype.id];
        if (!pObj) {
            (pObj = new(val.PixiShader)(punittype)).fragmentSrc = pcity.fragmentSrc;
            pObj.uniforms = pcity.uniforms;
            pObj.init(true);
            pcity.shaders[punittype.id] = pObj;
        }
        this.renderSession.shaderManager.setShader(pObj);
        punittype.uniform2f(pObj.projectionVector, dataAndEvents / 2, -ignoreMethodDoesntExist / 2);
        punittype.uniform2f(pObj.offsetVector, 0, 0);
        if (pcity.uniforms.dimensions) {
            pcity.uniforms.dimensions.value[0] = this.width;
            pcity.uniforms.dimensions.value[1] = this.height;
            pcity.uniforms.dimensions.value[2] = this.vertexArray[0];
            pcity.uniforms.dimensions.value[3] = this.vertexArray[5];
        }
        pObj.syncUniforms();
        punittype.bindBuffer(punittype.ARRAY_BUFFER, this.vertexBuffer);
        punittype.vertexAttribPointer(pObj.aVertexPosition, 2, punittype.FLOAT, false, 0, 0);
        punittype.bindBuffer(punittype.ARRAY_BUFFER, this.uvBuffer);
        punittype.vertexAttribPointer(pObj.aTextureCoord, 2, punittype.FLOAT, false, 0, 0);
        punittype.bindBuffer(punittype.ARRAY_BUFFER, this.colorBuffer);
        punittype.vertexAttribPointer(pObj.colorAttribute, 2, punittype.FLOAT, false, 0, 0);
        punittype.bindBuffer(punittype.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        punittype.drawElements(punittype.TRIANGLES, 6, punittype.UNSIGNED_SHORT, 0);
        this.renderSession.drawCount++;
    };

    val.WebGLFilterManager.prototype.initShaderBuffers = function () {
        var action = this.gl;
        this.vertexBuffer = action.createBuffer();
        this.uvBuffer = action.createBuffer();
        this.colorBuffer = action.createBuffer();
        this.indexBuffer = action.createBuffer();

        this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        action.bindBuffer(action.ARRAY_BUFFER, this.vertexBuffer);
        action.bufferData(action.ARRAY_BUFFER, this.vertexArray, action.STATIC_DRAW);

        this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        action.bindBuffer(action.ARRAY_BUFFER, this.uvBuffer);
        action.bufferData(action.ARRAY_BUFFER, this.uvArray, action.STATIC_DRAW);

        this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]);
        action.bindBuffer(action.ARRAY_BUFFER, this.colorBuffer);
        action.bufferData(action.ARRAY_BUFFER, this.colorArray, action.STATIC_DRAW);
        action.bindBuffer(action.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        action.bufferData(action.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), action.STATIC_DRAW);
    };

    val.WebGLFilterManager.prototype.destroy = function () {
        var gl = this.gl;

        this.filterStack = null;

        this.offsetX = 0;

        this.offsetY = 0;

        var i = 0;
        for (; i < this.texturePool.length; i++) {
            this.texturePool[i].destroy();
        }

        this.texturePool = null;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.uvBuffer);
        gl.deleteBuffer(this.colorBuffer);
        gl.deleteBuffer(this.indexBuffer);
    };
    var args = {
        36054: 'Incomplete attachment',
        36055: 'Missing attachment',
        36057: "Incomplete dimensions",
        36061: "Framebuffer unsupported"
    };
    return val.FilterTexture = function (dataAndEvents, name, b, deepDataAndEvents, until) {
        until = 'number' == typeof until ? until : 0;

        this.gl = dataAndEvents;
        this.frameBuffer = push(dataAndEvents, name, b, deepDataAndEvents || val.scaleModes.DEFAULT, until);
        this.texture = this.frameBuffer.targetTexture;
        this.width = name;
        this.height = b;
        this.renderBuffer = this.frameBuffer.renderBuffer;
    }, val.FilterTexture.prototype.constructor = val.FilterTexture, val.FilterTexture.prototype.clear = function () {
        var results = this.gl;
        results.clearColor(0, 0, 0, 0);
        results.clear(results.COLOR_BUFFER_BIT);
    }, val.FilterTexture.prototype.resize = function (deepDataAndEvents, opt_obj2) {
        if (this.width !== deepDataAndEvents || this.height !== opt_obj2) {
            this.width = deepDataAndEvents;
            this.height = opt_obj2;
            var action = this.gl;
            action.bindTexture(action.TEXTURE_2D, this.texture);
            action.texImage2D(action.TEXTURE_2D, 0, action.RGBA, deepDataAndEvents, opt_obj2, 0, action.RGBA, action.UNSIGNED_BYTE, null);
            action.bindRenderbuffer(action.RENDERBUFFER, this.renderBuffer);
            action.renderbufferStorage(action.RENDERBUFFER, action.DEPTH_STENCIL, deepDataAndEvents, opt_obj2);
        }
    }, val.FilterTexture.prototype.destroy = function () {
        var gl = this.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        gl.deleteTexture(this.texture);

        this.frameBuffer = null;

        this.texture = null;
    }, val.CanvasBuffer = function (dataAndEvents, deepDataAndEvents) {
        this.width = dataAndEvents;
        this.height = deepDataAndEvents;
        this.canvas = Phaser.CanvasPool.create(this, this.width, this.height);
        this.context = this.canvas.getContext("2d");
        this.canvas.width = dataAndEvents;
        this.canvas.height = deepDataAndEvents;
    }, val.CanvasBuffer.prototype.constructor = val.CanvasBuffer, val.CanvasBuffer.prototype.clear = function () {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
    }, val.CanvasBuffer.prototype.resize = function (deepDataAndEvents, dataAndEvents) {
        this.width = this.canvas.width = deepDataAndEvents;
        this.height = this.canvas.height = dataAndEvents;
    }, val.CanvasBuffer.prototype.destroy = function () {
        Phaser.CanvasPool.remove(this);
    }, val.CanvasMaskManager = function () {}, val.CanvasMaskManager.prototype.constructor = val.CanvasMaskManager, val.CanvasMaskManager.prototype.pushMask = function (d, ca) {
        var r20 = ca.context;
        r20.save();
        var f = d.alpha;
        var g = d.worldTransform;
        var c = ca.resolution;
        r20.setTransform(g.a * c, g.b * c, g.c * c, g.d * c, g.tx * c, g.ty * c);
        val.CanvasGraphics.renderGraphicsMask(d, r20);
        r20.clip();
        d.worldAlpha = f;
    }, val.CanvasMaskManager.prototype.popMask = function (fn) {
        fn.context.restore();
    }, val.CanvasTinter = function () {}, val.CanvasTinter.getTintedTexture = function (dataAndEvents, deepDataAndEvents) {
        var r20 = dataAndEvents.tintedTexture || Phaser.CanvasPool.create(this);
        return val.CanvasTinter.tintMethod(dataAndEvents.texture, deepDataAndEvents, r20), r20;
    }, val.CanvasTinter.tintWithMultiply = function (args, dataAndEvents, obj) {
        var jQuery = obj.getContext("2d");
        var options = args.crop;
        var val = options.width;
        var value = options.height;
        if (args.rotated) {
            val = value;
            value = options.width;
        }
        if (!(obj.width === val && obj.height === value)) {
            obj.width = val;
            obj.height = value;
        }
        jQuery.clearRect(0, 0, val, value);
        jQuery.fillStyle = "#" + ('00000' + (0 | dataAndEvents).toString(16)).substr(-6);
        jQuery.fillRect(0, 0, val, value);
        jQuery.globalCompositeOperation = 'multiply';
        jQuery.drawImage(args.baseTexture.source, options.x, options.y, val, value, 0, 0, val, value);
        jQuery.globalCompositeOperation = 'destination-atop';
        jQuery.drawImage(args.baseTexture.source, options.x, options.y, val, value, 0, 0, val, value);
    }, val.CanvasTinter.tintWithPerPixel = function (dicts, l, style) {
        var target = style.getContext("2d");
        var dict = dicts.crop;
        var width = dict.width;
        var height = dict.height;
        if (dicts.rotated) {
            width = height;
            height = dict.width;
        }
        if (!(style.width === width && style.height === height)) {
            style.width = width;
            style.height = height;
        }

        target.globalCompositeOperation = "copy";
        target.drawImage(dicts.baseTexture.source, dict.x, dict.y, width, height, 0, 0, width, height);
        var args = Phaser.Color.hexToRGBArray(l);
        var next = args[0];
        var pageX = args[1];
        var pageY = args[2];
        var data = target.getImageData(0, 0, width, height);
        var result = data.data;

        var i = 0;
        for (; i < result.length; i += 4) {
            if (result[i + 0] *= next, result[i + 1] *= pageX, result[i + 2] *= pageY, !val.CanvasTinter.canHandleAlpha) {
                var message = result[i + 3];
                result[i + 0] /= 255 / message;
                result[i + 1] /= 255 / message;
                result[i + 2] /= 255 / message;
            }
        }
        target.putImageData(data, 0, 0);
    }, val.CanvasRenderer = function (options, dataAndEvents) {

        this.game = options;
        if (!val.defaultRenderer) {
            val.defaultRenderer = this;
        }
        this.type = Phaser.CANVAS;
        this.resolution = options.resolution;
        this.clearBeforeRender = options.clearBeforeRender;
        this.transparent = options.transparent;

        this.autoResize = false;

        this.width = options.width * this.resolution;

        this.height = options.height * this.resolution;
        this.view = options.canvas;
        this.context = this.view.getContext("2d", {
            "alpha": this.transparent
        });

        this.refresh = true;

        this.count = 0;
        this.maskManager = new(val.CanvasMaskManager);
        this.renderSession = {
            "context": this.context,
            "maskManager": this.maskManager,
            "scaleMode": null,
            "smoothProperty": Phaser.Canvas.getSmoothingPrefix(this.context),
            "roundPixels": dataAndEvents.roundPixels || false
        };
        this.mapBlendModes();
        this.resize(this.width, this.height);
    }, val.CanvasRenderer.prototype.constructor = val.CanvasRenderer, val.CanvasRenderer.prototype.render = function (deepDataAndEvents) {
        this.context.setTransform(1, 0, 0, 1, 0, 0);

        this.context.globalAlpha = 1;

        this.renderSession.currentBlendMode = 0;
        this.renderSession.shakeX = this.game.camera._shake.x;
        this.renderSession.shakeY = this.game.camera._shake.y;
        this.context.globalCompositeOperation = 'source-over';
        if (navigator.isCocoonJS) {
            if (this.view.screencanvas) {
                this.context.fillStyle = 'black';
                this.context.clear();
            }
        }
        if (this.clearBeforeRender) {
            if (this.transparent) {
                this.context.clearRect(0, 0, this.width, this.height);
            } else {
                if (deepDataAndEvents._bgColor) {
                    this.context.fillStyle = deepDataAndEvents._bgColor.rgba;
                    this.context.fillRect(0, 0, this.width, this.height);
                }
            }
        }
        this.renderDisplayObject(deepDataAndEvents);
    }, val.CanvasRenderer.prototype.setTexturePriority = function (dataAndEvents) {}, val.CanvasRenderer.prototype.destroy = function (dataAndEvents) {
        if (void 0 === dataAndEvents) {

            dataAndEvents = true;
        }
        if (dataAndEvents) {
            if (this.view.parent) {
                this.view.parent.removeChild(this.view);
            }
        }

        this.view = null;

        this.context = null;

        this.maskManager = null;

        this.renderSession = null;
    }, val.CanvasRenderer.prototype.resize = function (dataAndEvents, deepDataAndEvents) {

        this.width = dataAndEvents * this.resolution;

        this.height = deepDataAndEvents * this.resolution;
        this.view.width = this.width;
        this.view.height = this.height;
        if (this.autoResize) {

            this.view.style.width = this.width / this.resolution + "px";

            this.view.style.height = this.height / this.resolution + "px";
        }
        if (this.renderSession.smoothProperty) {

            this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === val.scaleModes.LINEAR;
        }
    }, val.CanvasRenderer.prototype.renderDisplayObject = function (dataAndEvents, deepDataAndEvents, opt_obj2) {
        this.renderSession.context = deepDataAndEvents || this.context;
        this.renderSession.resolution = this.resolution;
        dataAndEvents._renderCanvas(this.renderSession, opt_obj2);
    }, val.CanvasRenderer.prototype.mapBlendModes = function () {
        if (!val.blendModesCanvas) {

            var opt_left = [];
            var raw = val.blendModes;
            var source_over = this.game.device.canUseMultiply;
            opt_left[raw.NORMAL] = 'source-over';
            opt_left[raw.ADD] = 'lighter';

            opt_left[raw.MULTIPLY] = source_over ? "multiply" : "source-over";
            opt_left[raw.SCREEN] = source_over ? 'screen' : 'source-over';
            opt_left[raw.OVERLAY] = source_over ? 'overlay' : 'source-over';
            opt_left[raw.DARKEN] = source_over ? 'darken' : 'source-over';
            opt_left[raw.LIGHTEN] = source_over ? 'lighten' : 'source-over';
            opt_left[raw.COLOR_DODGE] = source_over ? 'color-dodge' : 'source-over';
            opt_left[raw.COLOR_BURN] = source_over ? 'color-burn' : "source-over";
            opt_left[raw.HARD_LIGHT] = source_over ? 'hard-light' : "source-over";
            opt_left[raw.SOFT_LIGHT] = source_over ? 'soft-light' : "source-over";
            opt_left[raw.DIFFERENCE] = source_over ? 'difference' : 'source-over';
            opt_left[raw.EXCLUSION] = source_over ? "exclusion" : 'source-over';
            opt_left[raw.HUE] = source_over ? "hue" : 'source-over';
            opt_left[raw.SATURATION] = source_over ? 'saturation' : "source-over";
            opt_left[raw.COLOR] = source_over ? 'color' : "source-over";
            opt_left[raw.LUMINOSITY] = source_over ? "luminosity" : 'source-over';

            val.blendModesCanvas = opt_left;
        }
    }, val.BaseTexture = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
        this.resolution = ignoreMethodDoesntExist || 1;

        this.width = 100;

        this.height = 100;
        this.scaleMode = deepDataAndEvents || val.scaleModes.DEFAULT;

        this.hasLoaded = false;
        this.source = dataAndEvents;

        this.premultipliedAlpha = true;

        this._glTextures = [];

        this.mipmap = false;

        this.textureIndex = 0;

        this._dirty = [true, true, true, true];
        if (dataAndEvents) {
            if (this.source.complete || this.source.getContext) {
                if (this.source.width) {
                    if (this.source.height) {

                        this.hasLoaded = true;
                        this.width = this.source.naturalWidth || this.source.width;
                        this.height = this.source.naturalHeight || this.source.height;
                        this.dirty();
                    }
                }
            }

            this.skipRender = false;

            this._powerOf2 = false;
        }
    }, val.BaseTexture.prototype.constructor = val.BaseTexture, val.BaseTexture.prototype.forceLoaded = function (dataAndEvents, deepDataAndEvents) {

        this.hasLoaded = true;
        this.width = dataAndEvents;
        this.height = deepDataAndEvents;
        this.dirty();
    }, val.BaseTexture.prototype.destroy = function () {
        if (this.source) {
            Phaser.CanvasPool.removeByCanvas(this.source);
        }

        this.source = null;
        this.unloadFromGPU();
    }, val.BaseTexture.prototype.dirty = function () {

        var unlock = 0;
        for (; unlock < this._glTextures.length; unlock++) {

            this._dirty[unlock] = true;
        }
    }, val.BaseTexture.prototype.unloadFromGPU = function () {
        this.dirty();

        var i = this._glTextures.length - 1;
        for (; i >= 0; i--) {
            var seg = this._glTextures[i];
            var programWrapper = val.glContexts[i];
            if (programWrapper) {
                if (seg) {
                    programWrapper.deleteTexture(seg);
                }
            }
        }

        this._glTextures.length = 0;
        this.dirty();
    }, val.BaseTexture.fromCanvas = function (newStyle, dataAndEvents, details) {
        return 0 === newStyle.width && (newStyle.width = 1), 0 === newStyle.height && (newStyle.height = 1), details = details || 1, new(val.BaseTexture)(newStyle, dataAndEvents, details);
    }, val.TextureSilentFail = false, val.Texture = function (oldPos, time, dataAndEvents, deepDataAndEvents) {

        this.noFrame = false;
        if (!time) {

            this.noFrame = true;
            time = new(val.Rectangle)(0, 0, 1, 1);
        }
        if (oldPos instanceof val.Texture) {
            oldPos = oldPos.baseTexture;
        }

        this.baseTexture = oldPos;

        this.frame = time;
        this.trim = deepDataAndEvents;

        this.valid = false;

        this.isTiling = false;

        this.requiresUpdate = false;

        this.requiresReTint = false;

        this._uvs = null;

        this.width = 0;

        this.height = 0;
        this.crop = dataAndEvents || new(val.Rectangle)(0, 0, 1, 1);

        this.rotated = false;
        if (oldPos.hasLoaded) {
            if (this.noFrame) {
                time = new(val.Rectangle)(0, 0, oldPos.width, oldPos.height);
            }
            this.setFrame(time);
        }
    }, val.Texture.prototype.constructor = val.Texture, val.Texture.prototype.onBaseTextureLoaded = function () {
        var baseTexture = this.baseTexture;
        if (this.noFrame) {
            this.frame = new(val.Rectangle)(0, 0, baseTexture.width, baseTexture.height);
        }
        this.setFrame(this.frame);
    }, val.Texture.prototype.destroy = function (dataAndEvents) {
        if (dataAndEvents) {
            this.baseTexture.destroy();
        }

        this.valid = false;
    }, val.Texture.prototype.setFrame = function (value) {
        if (this.noFrame = false, this.frame = value, this.width = value.width, this.height = value.height, this.crop.x = value.x, this.crop.y = value.y, this.crop.width = value.width, this.crop.height = value.height, this.trim || !(value.x + value.width > this.baseTexture.width || value.y + value.height > this.baseTexture.height)) {
            this.valid = value && (value.width && (value.height && (this.baseTexture.source && this.baseTexture.hasLoaded)));
            if (this.trim) {
                this.width = this.trim.width;
                this.height = this.trim.height;
                this.frame.width = this.trim.width;
                this.frame.height = this.trim.height;
            }
            if (this.valid) {
                this._updateUvs();
            }
        } else {
            if (!val.TextureSilentFail) {
                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);
            }

            this.valid = false;
        }
    }, val.Texture.prototype._updateUvs = function () {
        if (!this._uvs) {
            this._uvs = new(val.TextureUvs);
        }
        var size = this.crop;
        var dw = this.baseTexture.width;
        var devicePixelRatio = this.baseTexture.height;

        this._uvs.x0 = size.x / dw;

        this._uvs.y0 = size.y / devicePixelRatio;

        this._uvs.x1 = (size.x + size.width) / dw;

        this._uvs.y1 = size.y / devicePixelRatio;

        this._uvs.x2 = (size.x + size.width) / dw;

        this._uvs.y2 = (size.y + size.height) / devicePixelRatio;

        this._uvs.x3 = size.x / dw;

        this._uvs.y3 = (size.y + size.height) / devicePixelRatio;
    }, val.Texture.prototype._updateUvsInverted = function () {
        if (!this._uvs) {
            this._uvs = new(val.TextureUvs);
        }
        var value = this.crop;
        var devicePixelRatio = this.baseTexture.width;
        var d = this.baseTexture.height;

        this._uvs.x0 = value.x / devicePixelRatio;

        this._uvs.y0 = value.y / d;

        this._uvs.x1 = (value.x + value.height) / devicePixelRatio;

        this._uvs.y1 = value.y / d;

        this._uvs.x2 = (value.x + value.height) / devicePixelRatio;

        this._uvs.y2 = (value.y + value.width) / d;

        this._uvs.x3 = value.x / devicePixelRatio;

        this._uvs.y3 = (value.y + value.width) / d;
    }, val.Texture.fromCanvas = function ($rootScope, protoProps) {
        var child = val.BaseTexture.fromCanvas($rootScope, protoProps);
        return new val.Texture(child);
    }, val.TextureUvs = function () {

        this.x0 = 0;

        this.y0 = 0;

        this.x1 = 0;

        this.y1 = 0;

        this.x2 = 0;

        this.y2 = 0;

        this.x3 = 0;

        this.y3 = 0;
    }, 'undefined' != typeof exports ? ("undefined" != typeof module && (module.exports && (exports = module.exports = val)), exports.PIXI = val) : 'undefined' != typeof define && define.amd ? define('PIXI', res.PIXI = val) : res.PIXI = val, val;
}).call(this),
    function () {

        function clone(dataAndEvents, deepDataAndEvents) {
            this._scaleFactor = dataAndEvents;
            this._deltaMode = deepDataAndEvents;

            this.originalEvent = null;
        }
        var a = this;
        var $ = $ || {
            "VERSION": '2.10.1',
            "GAMES": [],
            "AUTO": 0,
            "CANVAS": 1,
            "WEBGL": 2,
            "HEADLESS": 3,
            "WEBGL_MULTI": 4,
            "NONE": 0,
            "LEFT": 1,
            "RIGHT": 2,
            "UP": 3,
            "DOWN": 4,
            "SPRITE": 0,
            "BUTTON": 1,
            "IMAGE": 2,
            "GRAPHICS": 3,
            "TEXT": 4,
            "TILESPRITE": 5,
            "BITMAPTEXT": 6,
            "GROUP": 7,
            "RENDERTEXTURE": 8,
            "TILEMAP": 9,
            "TILEMAPLAYER": 10,
            "EMITTER": 11,
            "POLYGON": 12,
            "BITMAPDATA": 13,
            "CANVAS_FILTER": 14,
            "WEBGL_FILTER": 15,
            "ELLIPSE": 16,
            "SPRITEBATCH": 17,
            "RETROFONT": 18,
            "POINTER": 19,
            "ROPE": 20,
            "CIRCLE": 21,
            "RECTANGLE": 22,
            "LINE": 23,
            "MATRIX": 24,
            "POINT": 25,
            "ROUNDEDRECTANGLE": 26,
            "CREATURE": 27,
            "VIDEO": 28,
            "PENDING_ATLAS": -1,
            "HORIZONTAL": 0,
            "VERTICAL": 1,
            "LANDSCAPE": 0,
            "PORTRAIT": 1,
            "ANGLE_UP": 270,
            "ANGLE_DOWN": 90,
            "ANGLE_LEFT": 180,
            "ANGLE_RIGHT": 0,
            "ANGLE_NORTH_EAST": 315,
            "ANGLE_NORTH_WEST": 225,
            "ANGLE_SOUTH_EAST": 45,
            "ANGLE_SOUTH_WEST": 135,
            "TOP_LEFT": 0,
            "TOP_CENTER": 1,
            "TOP_RIGHT": 2,
            "LEFT_TOP": 3,
            "LEFT_CENTER": 4,
            "LEFT_BOTTOM": 5,
            "CENTER": 6,
            "RIGHT_TOP": 7,
            "RIGHT_CENTER": 8,
            "RIGHT_BOTTOM": 9,
            "BOTTOM_LEFT": 10,
            "BOTTOM_CENTER": 11,
            "BOTTOM_RIGHT": 12,
            "blendModes": {
                "NORMAL": 0,
                "ADD": 1,
                "MULTIPLY": 2,
                "SCREEN": 3,
                "OVERLAY": 4,
                "DARKEN": 5,
                "LIGHTEN": 6,
                "COLOR_DODGE": 7,
                "COLOR_BURN": 8,
                "HARD_LIGHT": 9,
                "SOFT_LIGHT": 10,
                "DIFFERENCE": 11,
                "EXCLUSION": 12,
                "HUE": 13,
                "SATURATION": 14,
                "COLOR": 15,
                "LUMINOSITY": 16
            },
            "scaleModes": {
                "DEFAULT": 0,
                "LINEAR": 0,
                "NEAREST": 1
            },
            "PIXI": PIXI || {},
            "_UID": 0
        };
        if (Math.trunc || (Math.trunc = function (from) {
                return from < 0 ? Math.ceil(from) : Math.floor(from);
            }), Function.prototype.bind || (Function.prototype.bind = function () {
                var _0x3af092 = Array.prototype.slice;
                return function (context) {

                    function jQuery() {
                        var options = resolveValues.concat(_0x3af092.call(arguments));
                        collection.apply(this instanceof jQuery ? this : context, options);
                    }
                    var collection = this;
                    var resolveValues = _0x3af092.call(arguments, 1);
                    if ('function' != typeof collection) {
                        throw new TypeError;
                    }
                    return jQuery.prototype = function first(elem) {
                        if (elem && (first.prototype = elem), !(this instanceof first)) {
                            return new first;
                        }
                    }(collection.prototype), jQuery;
                };
            }()), Array.isArray || (Array.isArray = function (success) {
                return '[object Array]' === Object.prototype.toString.call(success);
            }), Array.prototype.forEach || (Array.prototype.forEach = function (fn) {
                if (void 0 === this || null === this) {
                    throw new TypeError;
                }
                var t = Object(this);

                var kl = t.length >>> 0;
                if ("function" != typeof fn) {
                    throw new TypeError;
                }
                var r20 = arguments.length >= 2 ? arguments[1] : void 0;

                var k = 0;
                for (; k < kl; k++) {
                    if (k in t) {
                        fn.call(r20, t[k], k, t);
                    }
                }
            }), "function" != typeof window.Uint32Array && 'object' != typeof window.Uint32Array) {

            var Event = function (type) {

                var other = new Array;

                window[type] = function (iterable) {
                    if ('number' == typeof iterable) {
                        Array.call(this, iterable);

                        this.length = iterable;

                        key = 0;
                        for (; key < this.length; key++) {

                            this[key] = 0;
                        }
                    } else {
                        Array.call(this, iterable.length);
                        this.length = iterable.length;

                        var key = 0;
                        for (; key < this.length; key++) {
                            this[key] = iterable[key];
                        }
                    }
                };

                window[type].prototype = other;
                window[type].constructor = window[type];
            };
            Event("Float32Array");
            Event("Uint32Array");
            Event('Uint16Array');
            Event('Int16Array');
            Event("ArrayBuffer");
        }
        if (!window.console) {
            window.console = {};

            window.console.log = window.console.assert = function () {};

            window.console.warn = window.console.assert = function () {};
        }
        if (!Object.assign) {

            Object.assign = function (arr, dataAndEvents) {
                if (null == arr) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                var object = Object(arr);
                var options = Object.prototype.hasOwnProperty;

                var argsIndex = 1;
                for (; argsIndex < arguments.length; argsIndex++) {
                    var iterable = arguments[argsIndex];
                    if (null != iterable) {
                        var key;
                        for (key in iterable) {
                            if (options.call(iterable, key)) {
                                object[key] = iterable[key];
                            }
                        }
                    }
                }
                return object;
            };
        }
        $.Utils = {

            "reverseString": function (dataAndEvents) {
                return dataAndEvents.split("").reverse().join("");
            },

            "getProperty": function (obj, expr) {
                var atr = expr.split(".");
                switch (atr.length) {
                case 1:
                    return obj[expr];
                case 2:
                    return obj[atr[0]][atr[1]];
                case 3:
                    return obj[atr[0]][atr[1]][atr[2]];
                case 4:
                    return obj[atr[0]][atr[1]][atr[2]][atr[3]];
                default:
                    return this._getProperty(obj, expr);
                }
            },

            "setProperties": function (into, a) {
                var prefix;
                for (prefix in a) {
                    this.setProperty(into, prefix, a[prefix]);
                }
                return into;
            },

            "setProperty": function (child, k, v) {
                var key = k.split(".");
                switch (key.length) {
                case 1:
                    child[k] = v;
                    break;
                case 2:
                    child[key[0]][key[1]] = v;
                    break;
                case 3:
                    child[key[0]][key[1]][key[2]] = v;
                    break;
                case 4:
                    child[key[0]][key[1]][key[2]][key[3]] = v;
                    break;
                default:
                    this._setProperty(child, k, v);
                }
            },

            "_getProperty": function (obj, oControl) {
                var parts = oControl.split(".");
                var last = parts.length;

                var i = 0;

                var cur = obj;
                for (; i < last;) {
                    var part = parts[i];
                    if (null == cur) {
                        return;
                    }
                    cur = cur[part];
                    i++;
                }
                return cur;
            },

            "_setProperty": function (target, key, value) {
                var parts = key.split(".");
                var count = parts.length;

                var i = 0;

                var tmp = target;
                var part = parts[0];
                if (1 === count) {
                    target[key] = value;
                } else {
                    for (; i < count - 1;) {
                        tmp = tmp[part];
                        part = parts[++i];
                    }
                    tmp[part] = value;
                }
                return target;
            },

            "chanceRoll": function (dataAndEvents) {
                return void 0 === dataAndEvents && (dataAndEvents = 50), dataAndEvents > 0 && 100 * Math.random() <= dataAndEvents;
            },

            "randomChoice": function (dataAndEvents, options) {
                return Math.random() < 0.5 ? dataAndEvents : options;
            },

            "parseDimension": function (line, dataAndEvents) {

                var innerWidth = 0;

                var pos = 0;
                return "string" == typeof line ? "%" === line.substr(-1) ? (innerWidth = parseInt(line, 10) / 100, pos = 0 === dataAndEvents ? window.innerWidth * innerWidth : window.innerHeight * innerWidth) : pos = parseInt(line, 10) : pos = line, pos;
            },

            "pad": function (str, c, chr, n) {
                if (void 0 === c) {

                    c = 0;
                }
                if (void 0 === chr) {

                    chr = " ";
                }
                if (void 0 === n) {

                    n = 3;
                }

                var r = 0;
                if (c + 1 >= (str = str.toString()).length) {
                    switch (n) {
                    case 1:
                        str = (new Array(c + 1 - str.length)).join(chr) + str;
                        break;
                    case 3:
                        var l = Math.ceil((r = c - str.length) / 2);

                        var d = r - l;
                        str = (new Array(d + 1)).join(chr) + str + (new Array(l + 1)).join(chr);
                        break;
                    default:
                        str += (new Array(c + 1 - str.length)).join(chr);
                    }
                }
                return str;
            },

            "isPlainObject": function (obj) {
                if ("object" != typeof obj || (obj.nodeType || obj === obj.window)) {
                    return false;
                }
                try {
                    if (obj.constructor && !{} ['hasOwnProperty'].call(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                } catch (_0x1657bc) {
                    return false;
                }
                return true;
            },

            "extend": function () {
                var options;
                var name;
                var src;
                var copy;
                var copyIsArray;
                var clone;
                var target = arguments[0] || {};

                var i = 1;
                var length = arguments.length;

                var deep = false;
                if ("boolean" == typeof target) {

                    deep = target;
                    target = arguments[1] || {};

                    i = 2;
                }
                if (length === i) {
                    target = this;
                    --i;
                }
                for (; i < length; i++) {
                    if (null != (options = arguments[i])) {
                        for (name in options) {
                            src = target[name];
                            if (target !== (copy = options[name])) {
                                if (deep && (copy && ($.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))) {
                                    if (copyIsArray) {

                                        copyIsArray = false;
                                        clone = src && Array.isArray(src) ? src : [];
                                    } else {
                                        clone = src && $.Utils.isPlainObject(src) ? src : {};
                                    }
                                    target[name] = $.Utils.extend(deep, clone, copy);
                                } else {
                                    if (void 0 !== copy) {
                                        target[name] = copy;
                                    }
                                }
                            }
                        }
                    }
                }
                return target;
            },

            "mixinPrototype": function (target, obj, val) {
                if (void 0 === val) {

                    val = false;
                }
                var x = Object.keys(obj);

                var j = 0;
                for (; j < x.length; j++) {
                    var name = x[j];
                    var copy = obj[name];
                    if (!(!val && name in target)) {
                        if (!copy || 'function' != typeof copy.get && 'function' != typeof copy.set) {
                            target[name] = copy;
                        } else {
                            if ("function" == typeof copy.clone) {
                                target[name] = copy.clone();
                            } else {
                                Object.defineProperty(target, name, copy);
                            }
                        }
                    }
                }
            },

            "mixin": function (source, target) {
                if (!source || 'object' != typeof source) {
                    return target;
                }
                var key;
                for (key in source) {
                    var value = source[key];
                    if (!value.childNodes && !value.cloneNode) {

                        var value2 = typeof source[key];
                        if (source[key] && 'object' === value2) {
                            if (typeof target[key] === value2) {
                                target[key] = $.Utils.mixin(source[key], target[key]);
                            } else {
                                target[key] = $.Utils.mixin(source[key], new(value.constructor));
                            }
                        } else {
                            target[key] = source[key];
                        }
                    }
                }
                return target;
            }
        };

        $.Circle = function (ch, col, dataAndEvents) {
            ch = ch || 0;
            col = col || 0;
            dataAndEvents = dataAndEvents || 0;

            this.x = ch;

            this.y = col;

            this._diameter = dataAndEvents;

            this._radius = 0;
            if (dataAndEvents > 0) {

                this._radius = 0.5 * dataAndEvents;
            }
            this.type = $.CIRCLE;
        };
        $.Circle.prototype = {

            "circumference": function () {
                return Math.PI * this._radius * 2;
            },

            "random": function (param) {
                if (void 0 === param) {
                    param = new($.Point);
                }

                var currentValue = 2 * Math.PI * Math.random();
                var u = Math.random() + Math.random();
                var column = u > 1 ? 2 - u : u;

                var left = column * Math.cos(currentValue);

                var i = column * Math.sin(currentValue);
                return param.x = this.x + left * this.radius, param.y = this.y + i * this.radius, param;
            },

            "getBounds": function () {
                return new($.Rectangle)(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter);
            },

            "setTo": function (x, y, to) {
                return this.x = x, this.y = y, this._diameter = to, this._radius = 0.5 * to, this;
            },

            "copyFrom": function (text) {
                return this.setTo(text.x, text.y, text.diameter);
            },

            "copyTo": function (text) {
                return text.x = this.x, text.y = this.y, text.diameter = this._diameter, text;
            },

            "distance": function (a, round) {
                var value = $.Math.distance(this.x, this.y, a.x, a.y);
                return round ? Math.round(value) : value;
            },

            "clone": function (dataAndEvents) {
                return void 0 === dataAndEvents || null === dataAndEvents ? dataAndEvents = new($.Circle)(this.x, this.y, this.diameter) : dataAndEvents.setTo(this.x, this.y, this.diameter), dataAndEvents;
            },

            "contains": function (ss, descendant) {
                return $.Circle.contains(this, ss, descendant);
            },

            "circumferencePoint": function (asDegrees, angle, a) {
                return $.Circle.circumferencePoint(this, asDegrees, angle, a);
            },

            "sample": function (b, scheduler, guard, geometry, n) {
                if (!b) {

                    b = 60;
                }
                if (null == scheduler) {

                    scheduler = 0;
                }
                if (null == guard) {
                    guard = $.Math.PI2;
                }
                if (!n) {

                    n = [];
                }

                var a = 0;
                for (; a < b;) {
                    this.circumferencePoint($.Math.linear(scheduler, guard, a / b), geometry, n[a] || (n[a] = new $.Point));
                    a += 1;
                }
                return n;
            },

            "offset": function (x, y) {
                return this.x += x, this.y += y, this;
            },

            "offsetPoint": function (point) {
                return this.offset(point.x, point.y);
            },

            "toString": function () {
                return '[{Phaser.Circle (x=' + this.x + ' y=' + this.y + ' diameter=' + this.diameter + ' radius=' + this.radius + ')}]';
            }
        };
        $.Circle.prototype.constructor = $.Circle;
        Object.defineProperty($.Circle.prototype, "diameter", {

            "get": function () {
                return this._diameter;
            },

            "set": function (mL) {
                if (mL > 0) {

                    this._diameter = mL;

                    this._radius = 0.5 * mL;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, 'radius', {

            "get": function () {
                return this._radius;
            },

            "set": function (mL) {
                if (mL > 0) {

                    this._radius = mL;

                    this._diameter = 2 * mL;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, 'left', {

            "get": function () {
                return this.x - this._radius;
            },

            "set": function (x) {
                if (x > this.x) {

                    this._radius = 0;

                    this._diameter = 0;
                } else {

                    this.radius = this.x - x;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, "right", {

            "get": function () {
                return this.x + this._radius;
            },

            "set": function (x) {
                if (x < this.x) {

                    this._radius = 0;

                    this._diameter = 0;
                } else {

                    this.radius = x - this.x;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, "top", {

            "get": function () {
                return this.y - this._radius;
            },

            "set": function (y) {
                if (y > this.y) {

                    this._radius = 0;

                    this._diameter = 0;
                } else {

                    this.radius = this.y - y;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, 'bottom', {

            "get": function () {
                return this.y + this._radius;
            },

            "set": function (y) {
                if (y < this.y) {

                    this._radius = 0;

                    this._diameter = 0;
                } else {

                    this.radius = y - this.y;
                }
            }
        });
        Object.defineProperty($.Circle.prototype, 'area', {

            "get": function () {
                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0;
            }
        });
        Object.defineProperty($.Circle.prototype, 'empty', {

            "get": function () {
                return 0 === this._diameter;
            },

            "set": function (mL) {
                if (true === mL) {
                    this.setTo(0, 0, 0);
                }
            }
        });

        $.Circle.contains = function (point, x, y) {
            return point.radius > 0 && (x >= point.left && (x <= point.right && (y >= point.top && (y <= point.bottom && (point.x - x) * (point.x - x) + (point.y - y) * (point.y - y) <= point.radius * point.radius))));
        };

        $.Circle.equals = function (dest, a) {
            return dest.x === a.x && (dest.y === a.y && dest.diameter === a.diameter);
        };

        $.Circle.intersects = function (left, right) {
            return $.Math.distance(left.x, left.y, right.x, right.y) <= left.radius + right.radius;
        };

        $.Circle.circumferencePoint = function (o, basis, dataAndEvents, row) {
            return void 0 === dataAndEvents && (dataAndEvents = false), void 0 === row && (row = new($.Point)), true === dataAndEvents && (basis = $.Math.degToRad(basis)), row.x = o.x + o.radius * Math.cos(basis), row.y = o.y + o.radius * Math.sin(basis), row;
        };

        $.Circle.intersectsRectangle = function (p2, p1) {
            var xValue = Math.abs(p2.x - p1.x - p1.halfWidth);
            if (xValue > p1.halfWidth + p2.radius) {
                return false;
            }
            var eyey = Math.abs(p2.y - p1.y - p1.halfHeight);
            if (eyey > p1.halfHeight + p2.radius) {
                return false;
            }
            if (xValue <= p1.halfWidth || eyey <= p1.halfHeight) {
                return true;
            }

            var z0 = xValue - p1.halfWidth;

            var z1 = eyey - p1.halfHeight;
            return z0 * z0 + z1 * z1 <= p2.radius * p2.radius;
        };

        $.Circle.intersectsLine = function (p, data, dataAndEvents) {
            var x2 = p.x;
            var t = p.y;

            var yp = (data.end.y - data.start.y) / (data.end.x - data.start.x);

            var offsetX = data.end.y - yp * data.end.x;
            var rx = p.radius;
            var score = p.radius;

            var x1 = offsetX + yp * x2;

            var count = (x2 * (score * score) - yp * (rx * rx) * (offsetX - t) + rx * score * Math.sqrt(rx * rx * (yp * yp) + score * score - x1 * x1 - t * t + 2 * x1 * t)) / (rx * rx * (yp * yp) + score * score);

            var key = (x2 * (score * score) - yp * (rx * rx) * (offsetX - t) - rx * score * Math.sqrt(rx * rx * (yp * yp) + score * score - x1 * x1 - t * t + 2 * x1 * t)) / (rx * rx * (yp * yp) + score * score);

            var originalX = yp * count + offsetX;

            var x = yp * key + offsetX;
            var args = new($.Point)(count, originalX);
            var node = new($.Point)(key, x);
            var na = data.pointOnSegment(args.x, args.y, 0.01);
            var nb = data.pointOnSegment(node.x, node.y, 0.01);
            return na && nb ? !dataAndEvents || [args, node] : na ? !dataAndEvents || [args] : nb ? !dataAndEvents || [node] : !!dataAndEvents && [];
        };
        PIXI.Circle = $.Circle;

        $.Ellipse = function (ch, col, dataAndEvents, height) {
            ch = ch || 0;
            col = col || 0;
            dataAndEvents = dataAndEvents || 0;
            height = height || 0;

            this.x = ch;

            this.y = col;

            this.width = dataAndEvents;

            this.height = height;
            this.type = $.ELLIPSE;
        };
        $.Ellipse.prototype = {

            "setTo": function (x, y, to, v) {
                return this.x = x, this.y = y, this.width = to, this.height = v, this;
            },

            "getBounds": function () {
                return new($.Rectangle)(this.x - this.width, this.y - this.height, this.width, this.height);
            },

            "copyFrom": function (text) {
                return this.setTo(text.x, text.y, text.width, text.height);
            },

            "copyTo": function (text) {
                return text.x = this.x, text.y = this.y, text.width = this.width, text.height = this.height, text;
            },

            "clone": function (dataAndEvents) {
                return void 0 === dataAndEvents || null === dataAndEvents ? dataAndEvents = new $.Ellipse(this.x, this.y, this.width, this.height) : dataAndEvents.setTo(this.x, this.y, this.width, this.height), dataAndEvents;
            },

            "contains": function (ss, descendant) {
                return $.Ellipse.contains(this, ss, descendant);
            },

            "random": function (param) {
                if (void 0 === param) {
                    param = new($.Point);
                }

                var y = Math.random() * Math.PI * 2;
                var x = Math.random();
                return param.x = Math.sqrt(x) * Math.cos(y), param.y = Math.sqrt(x) * Math.sin(y), param.x = this.x + param.x * this.width / 2, param.y = this.y + param.y * this.height / 2, param;
            },

            "toString": function () {
                return "[{Phaser.Ellipse (x=" + this.x + ' y=' + this.y + ' width=' + this.width + " height=" + this.height + ")}]";
            }
        };
        $.Ellipse.prototype.constructor = $.Ellipse;
        Object.defineProperty($.Ellipse.prototype, "left", {

            "get": function () {
                return this.x;
            },

            "set": function (v) {
                this.x = v;
            }
        });
        Object.defineProperty($.Ellipse.prototype, "right", {

            "get": function () {
                return this.x + this.width;
            },

            "set": function (x) {
                if (x < this.x) {

                    this.width = 0;
                } else {

                    this.width = x - this.x;
                }
            }
        });
        Object.defineProperty($.Ellipse.prototype, 'top', {

            "get": function () {
                return this.y;
            },

            "set": function (value) {
                this.y = value;
            }
        });
        Object.defineProperty($.Ellipse.prototype, 'bottom', {

            "get": function () {
                return this.y + this.height;
            },

            "set": function (y) {
                if (y < this.y) {

                    this.height = 0;
                } else {

                    this.height = y - this.y;
                }
            }
        });
        Object.defineProperty($.Ellipse.prototype, "empty", {

            "get": function () {
                return 0 === this.width || 0 === this.height;
            },

            "set": function (mL) {
                if (true === mL) {
                    this.setTo(0, 0, 0, 0);
                }
            }
        });

        $.Ellipse.contains = function (xy, x, y) {
            if (xy.width <= 0 || xy.height <= 0) {
                return false;
            }

            var r = (x - xy.x) / xy.width - 0.5;

            var b = (y - xy.y) / xy.height - 0.5;
            return r *= r, b *= b, r + b < 0.25;
        };

        $.Ellipse.intersectsLine = function (map, data, dataAndEvents) {
            var val = map.x;
            var x = map.y;

            var yp = (data.end.y - data.start.y) / (data.end.x - data.start.x);

            var px = data.end.y - yp * data.end.x;

            var rx = map.width / 2;

            var diffX = map.height / 2;

            var times = px + yp * val;

            var cols = (val * (diffX * diffX) - yp * (rx * rx) * (px - x) + rx * diffX * Math.sqrt(rx * rx * (yp * yp) + diffX * diffX - times * times - x * x + 2 * times * x)) / (rx * rx * (yp * yp) + diffX * diffX);

            var count = (val * (diffX * diffX) - yp * (rx * rx) * (px - x) - rx * diffX * Math.sqrt(rx * rx * (yp * yp) + diffX * diffX - times * times - x * x + 2 * times * x)) / (rx * rx * (yp * yp) + diffX * diffX);

            var tabPageHeight = yp * cols + px;

            var indentation = yp * count + px;
            var row = new $.Point(cols, tabPageHeight);
            var args = new($.Point)(count, indentation);
            var na = data.pointOnSegment(row.x, row.y, 0.01);
            var nb = data.pointOnSegment(args.x, args.y, 0.01);
            return na && nb ? !dataAndEvents || [row, args] : na ? !dataAndEvents || [row] : nb ? !dataAndEvents || [args] : !!dataAndEvents && [];
        };
        PIXI.Ellipse = $.Ellipse;

        $.Line = function (context, dataAndEvents, sync, details) {
            context = context || 0;
            dataAndEvents = dataAndEvents || 0;
            sync = sync || 0;
            details = details || 0;
            this.start = new($.Point)(context, dataAndEvents);
            this.end = new($.Point)(sync, details);
            this.type = $.LINE;
        };
        $.Line.prototype = {

            "setTo": function (bottom, to, v, x) {
                return this.start.setTo(bottom, to), this.end.setTo(v, x), this;
            },

            "fromPoints": function (p2, p1) {
                return this.setTo(p2.x, p2.y, p1.x, p1.y), this;
            },

            "fromSprite": function (key, deepDataAndEvents, opt_keys) {
                return void 0 === opt_keys && (opt_keys = false), opt_keys ? this.setTo(key.centerX, key.centerY, deepDataAndEvents.centerX, deepDataAndEvents.centerY) : this.fromPoints(key, deepDataAndEvents);
            },

            "fromAngle": function (x, angle, y, _width) {
                return this.start.setTo(x, angle), this.end.setTo(x + Math.cos(y) * _width, angle + Math.sin(y) * _width), this;
            },

            "rotate": function (radians, mat) {

                var r20 = (this.start.x + this.end.x) / 2;

                var restoreScript = (this.start.y + this.end.y) / 2;
                return this.start.rotate(r20, restoreScript, radians, mat), this.end.rotate(r20, restoreScript, radians, mat), this;
            },

            "rotateAround": function (program, fs, angle, x) {
                return this.start.rotate(program, fs, angle, x), this.end.rotate(program, fs, angle, x), this;
            },

            "intersects": function (a, geometry, resolver) {
                return $.Line.intersectsPoints(this.start, this.end, a.start, a.end, geometry, resolver);
            },

            "reflect": function (N) {
                return $.Line.reflect(this, N);
            },

            "midPoint": function (row) {
                return void 0 === row && (row = new($.Point)), row.x = (this.start.x + this.end.x) / 2, row.y = (this.start.y + this.end.y) / 2, row;
            },

            "centerOn": function (y, x) {

                var distY = y - (this.start.x + this.end.x) / 2;

                var distX = x - (this.start.y + this.end.y) / 2;
                this.start.add(distY, distX);
                this.end.add(distY, distX);
            },

            "pointOnLine": function (b, a, dataAndEvents) {
                return $.Math.fuzzyEqual((b - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (a - this.start.y), dataAndEvents || 0);
            },

            "pointOnSegment": function (index, obj, deepDataAndEvents) {
                var inputLength = Math.min(this.start.x, this.end.x);
                var firingIndex = Math.max(this.start.x, this.end.x);
                var start = Math.min(this.start.y, this.end.y);
                var finish = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(index, obj, deepDataAndEvents) && (index >= inputLength && (index <= firingIndex && (obj >= start && obj <= finish)));
            },

            "random": function (param) {
                if (void 0 === param) {
                    param = new($.Point);
                }
                var decay = Math.random();
                return param.x = this.start.x + decay * (this.end.x - this.start.x), param.y = this.start.y + decay * (this.end.y - this.start.y), param;
            },

            "coordinatesOnLine": function (b, res) {
                if (void 0 === b) {

                    b = 1;
                }
                if (void 0 === res) {

                    res = [];
                }
                var left = Math.round(this.start.x);
                var x = Math.round(this.start.y);
                var right = Math.round(this.end.x);
                var y = Math.round(this.end.y);
                var len = Math.abs(right - left);
                var offset = Math.abs(y - x);

                var scrollbarWidth = left < right ? 1 : -1;

                var chunk = x < y ? 1 : -1;

                var n = len - offset;
                res.push([left, x]);

                var a = 1;
                for (; left !== right || x !== y;) {

                    var i = n << 1;
                    if (i > -offset) {
                        n -= offset;
                        left += scrollbarWidth;
                    }
                    if (i < len) {
                        n += len;
                        x += chunk;
                    }
                    if (a % b == 0) {
                        res.push([left, x]);
                    }
                    a++;
                }
                return res;
            },

            "clone": function (dataAndEvents) {
                return void 0 === dataAndEvents || null === dataAndEvents ? dataAndEvents = new($.Line)(this.start.x, this.start.y, this.end.x, this.end.y) : dataAndEvents.setTo(this.start.x, this.start.y, this.end.x, this.end.y), dataAndEvents;
            }
        };
        Object.defineProperty($.Line.prototype, 'length', {

            "get": function () {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));
            }
        });
        Object.defineProperty($.Line.prototype, 'angle', {

            "get": function () {
                return $.Point.angle(this.end, this.start);
            }
        });
        Object.defineProperty($.Line.prototype, 'slope', {

            "get": function () {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x);
            }
        });
        Object.defineProperty($.Line.prototype, 'perpSlope', {

            "get": function () {
                return -(this.end.x - this.start.x) / (this.end.y - this.start.y);
            }
        });
        Object.defineProperty($.Line.prototype, "x", {

            "get": function () {
                return Math.min(this.start.x, this.end.x);
            }
        });
        Object.defineProperty($.Line.prototype, "y", {

            "get": function () {
                return Math.min(this.start.y, this.end.y);
            }
        });
        Object.defineProperty($.Line.prototype, 'left', {

            "get": function () {
                return Math.min(this.start.x, this.end.x);
            }
        });
        Object.defineProperty($.Line.prototype, 'right', {

            "get": function () {
                return Math.max(this.start.x, this.end.x);
            }
        });
        Object.defineProperty($.Line.prototype, "top", {

            "get": function () {
                return Math.min(this.start.y, this.end.y);
            }
        });
        Object.defineProperty($.Line.prototype, 'bottom', {

            "get": function () {
                return Math.max(this.start.y, this.end.y);
            }
        });
        Object.defineProperty($.Line.prototype, 'width', {

            "get": function () {
                return Math.abs(this.start.x - this.end.x);
            }
        });
        Object.defineProperty($.Line.prototype, 'height', {

            "get": function () {
                return Math.abs(this.start.y - this.end.y);
            }
        });
        Object.defineProperty($.Line.prototype, 'normalX', {

            "get": function () {
                return Math.cos(this.angle - 1.5707963267948966);
            }
        });
        Object.defineProperty($.Line.prototype, 'normalY', {

            "get": function () {
                return Math.sin(this.angle - 1.5707963267948966);
            }
        });
        Object.defineProperty($.Line.prototype, 'normalAngle', {

            "get": function () {
                return $.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI);
            }
        });

        $.Line.intersectsPoints = function (a, b, p1, p2, dataAndEvents, row) {
            if (void 0 === dataAndEvents) {

                dataAndEvents = true;
            }
            if (void 0 === row) {
                row = new($.Point);
            }

            var a2 = b.y - a.y;

            var a1 = p2.y - p1.y;

            var m00 = a.x - b.x;

            var m10 = p1.x - p2.x;

            var b1 = b.x * a.y - a.x * b.y;

            var b3 = p2.x * p1.y - p1.x * p2.y;

            var d = a2 * m10 - a1 * m00;
            if (0 === d) {
                return null;
            }
            if (row.x = (m00 * b3 - m10 * b1) / d, row.y = (a1 * b1 - a2 * b3) / d, dataAndEvents) {

                var time = (p2.y - p1.y) * (b.x - a.x) - (p2.x - p1.x) * (b.y - a.y);

                var vx = ((p2.x - p1.x) * (a.y - p1.y) - (p2.y - p1.y) * (a.x - p1.x)) / time;

                var speed = ((b.x - a.x) * (a.y - p1.y) - (b.y - a.y) * (a.x - p1.x)) / time;
                return vx >= 0 && (vx <= 1 && (speed >= 0 && speed <= 1)) ? row : null;
            }
            return row;
        };

        $.Line.intersects = function (dataAndEvents, arr, deepDataAndEvents, opt_obj2) {
            return $.Line.intersectsPoints(dataAndEvents.start, dataAndEvents.end, arr.start, arr.end, deepDataAndEvents, opt_obj2);
        };

        $.Line.intersectsRectangle = function (data, args) {
            if (0 === data.length || args.empty) {
                return false;
            }
            var start = data.start.x;
            var i = data.start.y;
            var cur = data.end.x;
            var val = data.end.y;
            var stop = args.x;
            var min = args.y;
            var end = args.right;
            var max = args.bottom;

            var value = 0;
            if (start >= stop && (start <= end && (i >= min && i <= max)) || cur >= stop && (cur <= end && (val >= min && val <= max))) {
                return true;
            }
            if (start < stop && cur >= stop) {
                if ((value = i + (val - i) * (stop - start) / (cur - start)) > min && value <= max) {
                    return true;
                }
            } else {
                if (start > end && (cur <= end && ((value = i + (val - i) * (end - start) / (cur - start)) >= min && value <= max))) {
                    return true;
                }
            }
            if (i < min && val >= min) {
                if ((value = start + (cur - start) * (min - i) / (val - i)) >= stop && value <= end) {
                    return true;
                }
            } else {
                if (i > max && (val <= max && ((value = start + (cur - start) * (max - i) / (val - i)) >= stop && value <= end))) {
                    return true;
                }
            }
            return false;
        };

        $.Line.intersectionWithRectangle = function (dataAndEvents, row, element) {
            var dirs = $.Line.intersectionWithRectangle;
            if (!element) {
                element = new($.Point);
            }
            if (!dirs.edges) {

                dirs.edges = [new($.Line), new $.Line, new($.Line), new $.Line];
            }
            if (!dirs.edgeIntersection) {
                dirs.edgeIntersection = new($.Point);
            }
            var dir = dirs.edges;
            var type = dirs.edgeIntersection.set(0);
            var tile = row.x;
            var val = row.y;
            var subtoc = row.right;
            var serializedException = row.bottom;

            var bulk = 1 / 0;
            dir[0].setTo(tile, val, subtoc, val);
            dir[1].setTo(tile, serializedException, subtoc, serializedException);
            dir[2].setTo(tile, val, tile, serializedException);
            dir[3].setTo(subtoc, val, subtoc, serializedException);
            var itemWithLeastDistance;

            var j = 0;
            for (; itemWithLeastDistance = dir[j]; j++) {
                if (dataAndEvents.intersects(itemWithLeastDistance, true, type)) {
                    var fn = dataAndEvents.start.distance(type);
                    if (fn < bulk) {
                        bulk = fn;
                        element.copyFrom(type);
                    }
                }
            }
            return null != fn ? element : null;
        };

        $.Line.reflect = function (valueMap, dataAndEvents) {
            return 2 * dataAndEvents.normalAngle - 3.141592653589793 - valueMap.angle;
        };

        $.Matrix = function (current, dataAndEvents, val, num, minor, new_name) {
            if (!(void 0 !== current && null !== current)) {

                current = 1;
            }
            if (!(void 0 !== dataAndEvents && null !== dataAndEvents)) {

                dataAndEvents = 0;
            }
            if (!(void 0 !== val && null !== val)) {

                val = 0;
            }
            if (!(void 0 !== num && null !== num)) {

                num = 1;
            }
            if (!(void 0 !== minor && null !== minor)) {

                minor = 0;
            }
            if (!(void 0 !== new_name && null !== new_name)) {

                new_name = 0;
            }

            this.a = current;

            this.b = dataAndEvents;

            this.c = val;

            this.d = num;

            this.tx = minor;

            this.ty = new_name;
            this.type = $.MATRIX;
        };
        $.Matrix.prototype = {

            "fromArray": function (reverseAxisOrder) {
                return this.setTo(reverseAxisOrder[0], reverseAxisOrder[1], reverseAxisOrder[3], reverseAxisOrder[4], reverseAxisOrder[2], reverseAxisOrder[5]);
            },

            "setTo": function (v, to, pos, x, diameter, new_name) {
                return this.a = v, this.b = to, this.c = pos, this.d = x, this.tx = diameter, this.ty = new_name, this;
            },

            "clone": function (c) {
                return void 0 === c || null === c ? c = new($.Matrix)(this.a, this.b, this.c, this.d, this.tx, this.ty) : (c.a = this.a, c.b = this.b, c.c = this.c, c.d = this.d, c.tx = this.tx, c.ty = this.ty), c;
            },

            "copyTo": function (parent) {
                return parent.copyFrom(this), parent;
            },

            "copyFrom": function (data) {
                return this.a = data.a, this.b = data.b, this.c = data.c, this.d = data.d, this.tx = data.tx, this.ty = data.ty, this;
            },

            "toArray": function (obj, c) {
                return void 0 === c && (c = new Float32Array(9)), obj ? (c[0] = this.a, c[1] = this.b, c[2] = 0, c[3] = this.c, c[4] = this.d, c[5] = 0, c[6] = this.tx, c[7] = this.ty, c[8] = 1) : (c[0] = this.a, c[1] = this.c, c[2] = this.tx, c[3] = this.b, c[4] = this.d, c[5] = this.ty, c[6] = 0, c[7] = 0, c[8] = 1), c;
            },

            "apply": function (text, offset) {
                return void 0 === offset && (offset = new($.Point)), offset.x = this.a * text.x + this.c * text.y + this.tx, offset.y = this.b * text.x + this.d * text.y + this.ty, offset;
            },

            "applyInverse": function (p, row) {
                if (void 0 === row) {
                    row = new($.Point);
                }

                var c = 1 / (this.a * this.d + this.c * -this.b);
                var s = p.x;
                var t = p.y;
                return row.x = this.d * c * s + -this.c * c * t + (this.ty * this.c - this.tx * this.d) * c, row.y = this.a * c * t + -this.b * c * s + (-this.ty * this.a + this.tx * this.b) * c, row;
            },

            "translate": function (aX, aY) {
                return this.tx += aX, this.ty += aY, this;
            },

            "scale": function (a, b) {
                return this.a *= a, this.d *= b, this.c *= a, this.b *= b, this.tx *= a, this.ty *= b, this;
            },

            "rotate": function (angle) {
                var s = Math.cos(angle);
                var c = Math.sin(angle);
                var b = this.a;
                var m20 = this.c;
                var m30 = this.tx;
                return this.a = b * s - this.b * c, this.b = b * c + this.b * s, this.c = m20 * s - this.d * c, this.d = m20 * c + this.d * s, this.tx = m30 * s - this.ty * c, this.ty = m30 * c + this.ty * s, this;
            },

            "append": function (e) {
                var c = this.a;
                var a = this.b;
                var d = this.c;
                var b = this.d;
                return this.a = e.a * c + e.b * d, this.b = e.a * a + e.b * b, this.c = e.c * c + e.d * d, this.d = e.c * a + e.d * b, this.tx = e.tx * c + e.ty * d + this.tx, this.ty = e.tx * a + e.ty * b + this.ty, this;
            },

            "identity": function () {
                return this.setTo(1, 0, 0, 1, 0, 0);
            }
        };
        $.identityMatrix = new $.Matrix;

        $.Point = function (ch, col) {
            ch = ch || 0;
            col = col || 0;

            this.x = ch;

            this.y = col;
            this.type = $.POINT;
        };
        $.Point.prototype = {

            "copyFrom": function (text) {
                return this.setTo(text.x, text.y);
            },

            "invert": function () {
                return this.setTo(this.y, this.x);
            },

            "setTo": function (bottom, to) {
                return $.Point.set(this, bottom, to);
            },

            "set": function (opt_path, opt_domain) {
                return $.Point.set(this, opt_path, opt_domain);
            },

            "setToPolar": function (basis, dataAndEvents, deepDataAndEvents) {
                return null == dataAndEvents && (dataAndEvents = 1), deepDataAndEvents && (basis = $.Math.degToRad(basis)), this.setTo(Math.cos(basis) * dataAndEvents, Math.sin(basis) * dataAndEvents);
            },

            "add": function (vec0, j) {
                return this.x += vec0, this.y += j, this;
            },

            "subtract": function (x, y) {
                return this.x -= x, this.y -= y, this;
            },

            "multiply": function (x, quat2) {
                return this.x *= x, this.y *= quat2, this;
            },

            "divide": function (n, vecB) {
                return this.x /= n, this.y /= vecB, this;
            },

            "clampX": function (x, r) {
                return this.x = $.Math.clamp(this.x, x, r), this;
            },

            "clampY": function (y, deepDataAndEvents) {
                return this.y = $.Math.clamp(this.y, y, deepDataAndEvents), this;
            },

            "clamp": function (x, y) {
                return this.x = $.Math.clamp(this.x, x, y), this.y = $.Math.clamp(this.y, x, y), this;
            },

            "clip": function (array) {
                var one = array.left;
                var value = array.top;
                var x = array.right;
                var h = array.bottom;
                return this.x < one ? this.x = one : this.x > x && (this.x = x), this.y < value ? this.y = value : this.y > h && (this.y = h), this;
            },

            "clone": function (dataAndEvents) {
                return void 0 === dataAndEvents || null === dataAndEvents ? dataAndEvents = new($.Point)(this.x, this.y) : dataAndEvents.setTo(this.x, this.y), dataAndEvents;
            },

            "copyTo": function (text) {
                return text.x = this.x, text.y = this.y, text;
            },

            "distance": function (l2, vector) {
                return $.Point.distance(this, l2, vector);
            },

            "equals": function (other) {
                return other.x === this.x && other.y === this.y;
            },

            "equalsXY": function (a, b) {
                return this.x === a && this.y === b;
            },

            "fuzzyEquals": function (deepDataAndEvents, opt_obj2) {
                return $.Point.fuzzyEquals(this, deepDataAndEvents, opt_obj2);
            },

            "fuzzyEqualsXY": function (deepDataAndEvents, opt_obj2, walkers) {
                return $.Point.fuzzyEqualsXY(this, deepDataAndEvents, opt_obj2, walkers);
            },

            "angle": function (other, origin) {
                return this.angleXY(other.x, other.y, origin);
            },

            "angleXY": function (dataAndEvents, deepDataAndEvents, iterator) {
                var array = Math.atan2(deepDataAndEvents - this.y, dataAndEvents - this.x);
                return iterator ? $.Math.radToDeg(array) : array;
            },

            "atan": function (callback) {
                var promiseOrValue = Math.atan2(this.y, this.x);
                return callback ? $.Math.radToDeg(promiseOrValue) : promiseOrValue;
            },

            "rotate": function (radians, mat, origin, aRot, deg) {
                return $.Point.rotate(this, radians, mat, origin, aRot, deg);
            },

            "getMagnitude": function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },

            "getMagnitudeSq": function () {
                return this.x * this.x + this.y * this.y;
            },

            "setMagnitude": function (deepDataAndEvents) {
                return this.normalize().multiply(deepDataAndEvents, deepDataAndEvents);
            },

            "normalize": function () {
                if (!this.isZero()) {
                    var _0x247c51 = this.getMagnitude();
                    this.x /= _0x247c51;
                    this.y /= _0x247c51;
                }
                return this;
            },

            "limit": function (res) {
                return this.getMagnitudeSq() > res * res && this.setMagnitude(res), this;
            },

            "expand": function (y0) {
                return this.getMagnitudeSq() < y0 * y0 && this.setMagnitude(y0), this;
            },

            "isZero": function () {
                return 0 === this.x && 0 === this.y;
            },

            "dot": function (other) {
                return this.x * other.x + this.y * other.y;
            },

            "cross": function (other) {
                return this.x * other.y - this.y * other.x;
            },

            "perp": function () {
                return this.setTo(-this.y, this.x);
            },

            "rperp": function () {
                return this.setTo(this.y, -this.x);
            },

            "normalRightHand": function () {
                return this.setTo(-1 * this.y, this.x);
            },

            "floor": function () {
                return this.setTo(Math.floor(this.x), Math.floor(this.y));
            },

            "ceil": function () {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y));
            },

            "round": function () {
                return this.setTo(Math.round(this.x), Math.round(this.y));
            },

            "toString": function () {
                return "[{Point (x=" + this.x + ' y=' + this.y + ')}]';
            }
        };
        $.Point.prototype.constructor = $.Point;

        $.Point.add = function (offset, size, row) {
            return void 0 === row && (row = new($.Point)), row.x = offset.x + size.x, row.y = offset.y + size.y, row;
        };

        $.Point.subtract = function (p2, p1, row) {
            return void 0 === row && (row = new($.Point)), row.x = p2.x - p1.x, row.y = p2.y - p1.y, row;
        };

        $.Point.multiply = function (pos, size, row) {
            return void 0 === row && (row = new $.Point), row.x = pos.x * size.x, row.y = pos.y * size.y, row;
        };

        $.Point.divide = function (left, right, row) {
            return void 0 === row && (row = new($.Point)), row.x = left.x / right.x, row.y = left.y / right.y, row;
        };

        $.Point.equals = function (b, a) {
            return b.x === a.x && b.y === a.y;
        };

        $.Point.equalsXY = function (el, a, b) {
            return el.x === a && el.y === b;
        };

        $.Point.fuzzyEquals = function (row, text, deepDataAndEvents) {
            return $.Math.fuzzyEquals(row.x, text.x, deepDataAndEvents) && $.Math.fuzzyEquals(row.y, text.y, deepDataAndEvents);
        };

        $.Point.fuzzyEqualsXY = function (row, center, deepDataAndEvents, radius) {
            return $.Math.fuzzyEquals(row.x, center, radius) && $.Math.fuzzyEquals(row.y, deepDataAndEvents, radius);
        };

        $.Point.angle = function (p2, p1) {
            return Math.atan2(p2.y - p1.y, p2.x - p1.x);
        };

        $.Point.negative = function (row, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Point)), dataAndEvents.setTo(-row.x, -row.y);
        };

        $.Point.multiplyAdd = function (prevState, row, part, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Point)), dataAndEvents.setTo(prevState.x + row.x * part, prevState.y + row.y * part);
        };

        $.Point.interpolate = function (prevState, nextState, part, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Point)), dataAndEvents.setTo(prevState.x + (nextState.x - prevState.x) * part, prevState.y + (nextState.y - prevState.y) * part);
        };

        $.Point.perp = function (row, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Point)), dataAndEvents.setTo(-row.y, row.x);
        };

        $.Point.rperp = function (row, col) {
            return void 0 === col && (col = new($.Point)), col.setTo(row.y, -row.x);
        };

        $.Point.distance = function (row, text, asNumber) {
            var value = $.Math.distance(row.x, row.y, text.x, text.y);
            return asNumber ? Math.round(value) : value;
        };

        $.Point.project = function (doc, text, dataAndEvents) {
            if (void 0 === dataAndEvents) {
                dataAndEvents = new($.Point);
            }

            var amt = doc.dot(text) / text.getMagnitudeSq();
            return 0 !== amt && dataAndEvents.setTo(amt * text.x, amt * text.y), dataAndEvents;
        };

        $.Point.projectUnit = function (deepDataAndEvents, other, dataAndEvents) {
            if (void 0 === dataAndEvents) {
                dataAndEvents = new($.Point);
            }
            var amt = deepDataAndEvents.dot(other);
            return 0 !== amt && dataAndEvents.setTo(amt * other.x, amt * other.y), dataAndEvents;
        };

        $.Point.normalRightHand = function (row, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Point)), dataAndEvents.setTo(-1 * row.y, row.x);
        };

        $.Point.normalize = function (self, dataAndEvents) {
            if (void 0 === dataAndEvents) {
                dataAndEvents = new($.Point);
            }
            var devicePixelRatio = self.getMagnitude();
            return 0 !== devicePixelRatio && dataAndEvents.setTo(self.x / devicePixelRatio, self.y / devicePixelRatio), dataAndEvents;
        };

        $.Point.rotate = function (args, i, y, basis, dataAndEvents, width) {
            if (dataAndEvents && (basis = $.Math.degToRad(basis)), void 0 === width) {
                args.subtract(i, y);
                var a01 = Math.sin(basis);
                var a11 = Math.cos(basis);

                var _ = a11 * args.x - a01 * args.y;

                var a = a01 * args.x + a11 * args.y;
                args.x = _ + i;
                args.y = a + y;
            } else {
                var rad = basis + Math.atan2(args.y - y, args.x - i);
                args.x = i + width * Math.cos(rad);
                args.y = y + width * Math.sin(rad);
            }
            return args;
        };

        $.Point.centroid = function (properties, self) {
            if (void 0 === self && (self = new($.Point)), '[object Array]' !== Object.prototype.toString.call(properties)) {
                throw new Error("Phaser.Point. Parameter 'points' must be an array");
            }
            var event = properties.length;
            if (event < 1) {
                throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            }
            if (1 === event) {
                return self.copyFrom(properties[0]), self;
            }

            var cap = 0;
            for (; cap < event; cap++) {
                $.Point.add(self, properties[cap], self);
            }
            return self.divide(event, event), self;
        };

        $.Point.parse = function (row, x, v) {
            x = x || "x";
            v = v || "y";
            var dims = new($.Point);
            return row[x] && (dims.x = parseInt(row[x], 10)), row[v] && (dims.y = parseInt(row[v], 10)), dims;
        };

        $.Point.isPoint = function (row) {
            return null != row && ('number' == typeof row.x && "number" == typeof row.y);
        };

        $.Point.set = function (target, x, y) {
            return target.x = x || 0, target.y = y || (0 !== y ? target.x : 0), target;
        };

        $.Point.sortClockwise = function (handler, pos) {
            if (!pos) {
                pos = this.centroid(handler);
            }
            var x = pos.x;
            var y = pos.y;
            return handler.sort(function (right, left) {
                if (right.x - x >= 0 && left.x - x < 0) {
                    return -1;
                }
                if (right.x - x < 0 && left.x - x >= 0) {
                    return 1;
                }
                if (right.x - x == 0 && left.x - x == 0) {
                    return right.y - y >= 0 || left.y - y >= 0 ? right.y > left.y ? 1 : -1 : left.y > right.y ? 1 : -1;
                }

                var _0x48795f = (right.x - x) * -(left.y - y) - (left.x - x) * -(right.y - y);
                return _0x48795f < 0 ? -1 : _0x48795f > 0 ? 1 : (right.x - x) * (right.x - x) + (right.y - y) * (right.y - y) > (left.x - x) * (left.x - x) + (left.y - y) * (left.y - y) ? -1 : 1;
            });
        };
        PIXI.Point = $.Point;

        $.Polygon = function () {

            this.area = 0;

            this._points = [];
            if (arguments.length > 0) {
                this.setTo.apply(this, arguments);
            }

            this.closed = true;

            this.flattened = false;
            this.type = $.POLYGON;
        };
        $.Polygon.prototype = {

            "toNumberArray": function (object) {
                if (void 0 === object) {

                    object = [];
                }

                var i = 0;
                for (; i < this._points.length; i++) {
                    if ("number" == typeof this._points[i]) {
                        object.push(this._points[i]);
                        object.push(this._points[i + 1]);
                        i++;
                    } else {
                        object.push(this._points[i].x);
                        object.push(this._points[i].y);
                    }
                }
                return object;
            },

            "flatten": function () {
                return this._points = this.toNumberArray(), this.flattened = true, this;
            },

            "clone": function (obj) {
                var name = this._points.slice();
                return void 0 === obj || null === obj ? obj = new $.Polygon(name) : obj.setTo(name), obj;
            },

            "contains": function (ss, i) {

                var inside = false;
                if (this.flattened) {

                    var x = -2;

                    var z = this._points.length - 2;
                    for (;
                        (x += 2) < this._points.length; z = x) {
                        var asset = this._points[x];
                        var l = this._points[x + 1];
                        var child = this._points[z];
                        var row = this._points[z + 1];
                        if (l <= i && i < row || row <= i && i < l) {
                            if (ss < (child - asset) * (i - l) / (row - l) + asset) {

                                inside = !inside;
                            }
                        }
                    }
                } else {

                    x = -1;

                    z = this._points.length - 1;
                    for (; ++x < this._points.length; z = x) {
                        asset = this._points[x].x;
                        l = this._points[x].y;
                        child = this._points[z].x;
                        row = this._points[z].y;
                        if (l <= i && i < row || row <= i && i < l) {
                            if (ss < (child - asset) * (i - l) / (row - l) + asset) {

                                inside = !inside;
                            }
                        }
                    }
                }
                return inside;
            },

            "setTo": function (data) {
                if (this.area = 0, this._points = [], arguments.length > 0) {
                    if (!Array.isArray(data)) {
                        data = Array.prototype.slice.call(arguments);
                    }
                    var minY = Number.MAX_VALUE;

                    var i = 0;
                    var selectorsCount = data.length;
                    for (; i < selectorsCount; i++) {
                        if ('number' == typeof data[i]) {
                            point = new(PIXI.Point)(data[i], data[i + 1]);
                            i++;
                        } else {
                            if (Array.isArray(data[i])) {
                                point = new(PIXI.Point)(data[i][0], data[i][1]);
                            } else {
                                var point = new(PIXI.Point)(data[i].x, data[i].y)
                            }
                        }
                        this._points.push(point);
                        if (point.y < minY) {
                            minY = point.y;
                        }
                    }
                    this.calculateArea(minY);
                }
                return this;
            },

            "calculateArea": function (y) {
                var p2;
                var p1;
                var a1;
                var b4;

                var j = 0;
                var subLn = this._points.length;
                for (; j < subLn; j++) {
                    p2 = this._points[j];
                    p1 = j === subLn - 1 ? this._points[0] : this._points[j + 1];

                    a1 = (p2.y - y + (p1.y - y)) / 2;

                    b4 = p2.x - p1.x;
                    this.area += a1 * b4;
                }
                return this.area;
            }
        };
        $.Polygon.prototype.constructor = $.Polygon;
        Object.defineProperty($.Polygon.prototype, 'points', {

            "get": function () {
                return this._points;
            }
        });
        PIXI.Polygon = $.Polygon;

        $.Rectangle = function (ch, col, dataAndEvents, height) {
            ch = ch || 0;
            col = col || 0;
            dataAndEvents = dataAndEvents || 0;
            height = height || 0;

            this.x = ch;

            this.y = col;

            this.width = dataAndEvents;

            this.height = height;
            this.type = $.RECTANGLE;
        };
        $.Rectangle.prototype = {

            "offset": function (x, y) {
                return this.x += x, this.y += y, this;
            },

            "offsetPoint": function (point) {
                return this.offset(point.x, point.y);
            },

            "setTo": function (x, y, to, v) {
                return this.x = x, this.y = y, this.width = to, this.height = v, this;
            },

            "scale": function (_, height) {
                return void 0 === height && (height = _), this.width *= _, this.height *= height, this;
            },

            "centerOn": function (x, y) {
                return this.centerX = x, this.centerY = y, this;
            },

            "floor": function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
            },

            "floorAll": function () {
                this.x = Math.floor(this.x);
                this.y = Math.floor(this.y);
                this.width = Math.floor(this.width);
                this.height = Math.floor(this.height);
            },

            "ceil": function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
            },

            "ceilAll": function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                this.width = Math.ceil(this.width);
                this.height = Math.ceil(this.height);
            },

            "copyFrom": function (text) {
                return this.setTo(text.x, text.y, text.width, text.height);
            },

            "copyFromBounds": function (dataAndEvents) {
                return this.setTo(dataAndEvents.left, dataAndEvents.top, dataAndEvents.width, dataAndEvents.height);
            },

            "copyTo": function (text) {
                return text.x = this.x, text.y = this.y, text.width = this.width, text.height = this.height, text;
            },

            "inflate": function (writer, compressedData) {
                return $.Rectangle.inflate(this, writer, compressedData);
            },

            "size": function (obj) {
                return $.Rectangle.size(this, obj);
            },

            "resize": function (event, height) {
                return this.width = event, this.height = height, this;
            },

            "clone": function (deepDataAndEvents) {
                return $.Rectangle.clone(this, deepDataAndEvents);
            },

            "contains": function (ss, descendant) {
                return $.Rectangle.contains(this, ss, descendant);
            },

            "containsRect": function (rect) {
                return $.Rectangle.containsRect(rect, this);
            },

            "equals": function (other) {
                return $.Rectangle.equals(this, other);
            },

            "intersection": function (array, col) {
                return $.Rectangle.intersection(this, array, col);
            },

            "intersects": function (geometry) {
                return $.Rectangle.intersects(this, geometry);
            },

            "intersectsRaw": function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
                return $.Rectangle.intersectsRaw(this, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope);
            },

            "union": function (region, patterns) {
                return $.Rectangle.union(this, region, patterns);
            },

            "random": function (param) {
                return void 0 === param && (param = new $.Point), param.x = this.randomX, param.y = this.randomY, param;
            },

            "getPoint": function (allowNull, node) {
                switch (void 0 === node && (node = new($.Point)), allowNull) {
                default:
                    ;
                case $.TOP_LEFT:
                    return node.set(this.x, this.y);
                case $.TOP_CENTER:
                    return node.set(this.centerX, this.y);
                case $.TOP_RIGHT:
                    return node.set(this.right, this.y);
                case $.LEFT_CENTER:
                    return node.set(this.x, this.centerY);
                case $.CENTER:
                    return node.set(this.centerX, this.centerY);
                case $.RIGHT_CENTER:
                    return node.set(this.right, this.centerY);
                case $.BOTTOM_LEFT:
                    return node.set(this.x, this.bottom);
                case $.BOTTOM_CENTER:
                    return node.set(this.centerX, this.bottom);
                case $.BOTTOM_RIGHT:
                    return node.set(this.right, this.bottom);
                }
            },

            "sides": function (ctx, el, handle, els) {
                if (!arguments.length) {
                    ctx = new($.Line);
                    el = new($.Line);
                    handle = new($.Line);
                    els = new($.Line);
                }
                var s = this.x;
                var v = this.y;
                var k = this.right;
                var postData = this.bottom;
                return ctx.setTo(s, v, k, v), el.setTo(k, v, k, postData), handle.setTo(s, postData, k, postData), els.setTo(s, v, s, postData), arguments.length ? null : [ctx, el, handle, els];
            },

            "toString": function () {
                return '[{Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + " height=" + this.height + ' empty=' + this.empty + ')}]';
            }
        };
        Object.defineProperty($.Rectangle.prototype, 'halfWidth', {

            "get": function () {
                return Math.round(this.width / 2);
            }
        });
        Object.defineProperty($.Rectangle.prototype, "halfHeight", {

            "get": function () {
                return Math.round(this.height / 2);
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'bottom', {

            "get": function () {
                return this.y + this.height;
            },

            "set": function (y) {
                if (y <= this.y) {

                    this.height = 0;
                } else {

                    this.height = y - this.y;
                }
            }
        });
        Object.defineProperty($.Rectangle.prototype, "bottomLeft", {

            "get": function () {
                return new($.Point)(this.x, this.bottom);
            },

            "set": function (style) {
                this.x = style.x;
                this.bottom = style.y;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'bottomRight', {

            "get": function () {
                return new($.Point)(this.right, this.bottom);
            },

            "set": function (ps) {
                this.right = ps.x;
                this.bottom = ps.y;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'left', {

            "get": function () {
                return this.x;
            },

            "set": function (v) {
                if (v >= this.right) {

                    this.width = 0;
                } else {

                    this.width = this.right - v;
                }
                this.x = v;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'right', {

            "get": function () {
                return this.x + this.width;
            },

            "set": function (now) {
                if (now <= this.x) {

                    this.width = 0;
                } else {

                    this.width = now - this.x;
                }
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'volume', {

            "get": function () {
                return this.width * this.height;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'perimeter', {

            "get": function () {
                return 2 * this.width + 2 * this.height;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'centerX', {

            "get": function () {
                return this.x + this.halfWidth;
            },

            "set": function (mL) {

                this.x = mL - this.halfWidth;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'centerY', {

            "get": function () {
                return this.y + this.halfHeight;
            },

            "set": function (mL) {

                this.y = mL - this.halfHeight;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'randomX', {

            "get": function () {
                return this.x + Math.random() * this.width;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'randomY', {

            "get": function () {
                return this.y + Math.random() * this.height;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'top', {

            "get": function () {
                return this.y;
            },

            "set": function (value) {
                if (value >= this.bottom) {

                    this.height = 0;
                    this.y = value;
                } else {

                    this.height = this.bottom - value;
                }
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'topLeft', {

            "get": function () {
                return new($.Point)(this.x, this.y);
            },

            "set": function (style) {
                this.x = style.x;
                this.y = style.y;
            }
        });
        Object.defineProperty($.Rectangle.prototype, 'topRight', {

            "get": function () {
                return new($.Point)(this.x + this.width, this.y);
            },

            "set": function (ps) {
                this.right = ps.x;
                this.y = ps.y;
            }
        });
        Object.defineProperty($.Rectangle.prototype, "empty", {

            "get": function () {
                return !this.width || !this.height;
            },

            "set": function (mL) {
                if (true === mL) {
                    this.setTo(0, 0, 0, 0);
                }
            }
        });
        $.Rectangle.prototype.constructor = $.Rectangle;

        $.Rectangle.inflate = function (a, x, y) {
            return a.x -= x, a.width += 2 * x, a.y -= y, a.height += 2 * y, a;
        };

        $.Rectangle.inflatePoint = function (deepDataAndEvents, row) {
            return $.Rectangle.inflate(deepDataAndEvents, row.x, row.y);
        };

        $.Rectangle.size = function (args, element) {
            return void 0 === element || null === element ? element = new($.Point)(args.width, args.height) : element.setTo(args.width, args.height), element;
        };

        $.Rectangle.clone = function (args, obj) {
            return void 0 === obj || null === obj ? obj = new($.Rectangle)(args.x, args.y, args.width, args.height) : obj.setTo(args.x, args.y, args.width, args.height), obj;
        };

        $.Rectangle.createFromBounds = function (text, doc) {
            return void 0 !== doc && null !== doc || (doc = new($.Rectangle)(text.x, text.y, text.width, text.height)), doc.copyFromBounds(text);
        };

        $.Rectangle.contains = function (frames, lastTime, time) {
            return !(frames.width <= 0 || frames.height <= 0) && (lastTime >= frames.x && (lastTime < frames.right && (time >= frames.y && time < frames.bottom)));
        };

        $.Rectangle.containsRaw = function (x2, reference, width2, size, x1, x) {
            return x1 >= x2 && (x1 < x2 + width2 && (x >= reference && x < reference + size));
        };

        $.Rectangle.containsPoint = function (deepDataAndEvents, row) {
            return $.Rectangle.contains(deepDataAndEvents, row.x, row.y);
        };

        $.Rectangle.containsRect = function (a, b) {
            return !(a.volume > b.volume) && (a.x >= b.x && (a.y >= b.y && (a.right < b.right && a.bottom < b.bottom)));
        };

        $.Rectangle.equals = function (b, a) {
            return b.x === a.x && (b.y === a.y && (b.width === a.width && b.height === a.height));
        };

        $.Rectangle.sameDimensions = function (a, ar) {
            return a.width === ar.width && a.height === ar.height;
        };

        $.Rectangle.intersection = function (urls, row, hash) {
            return void 0 === hash && (hash = new($.Rectangle)), $.Rectangle.intersects(urls, row) && (hash.x = Math.max(urls.x, row.x), hash.y = Math.max(urls.y, row.y), hash.width = Math.min(urls.right, row.right) - hash.x, hash.height = Math.min(urls.bottom, row.bottom) - hash.y), hash;
        };

        $.Rectangle.intersects = function (a, b) {
            return !(a.width <= 0 || (a.height <= 0 || (b.width <= 0 || (b.height <= 0 || (a.right < b.x || (a.bottom < b.y || (a.x > b.right || a.y > b.bottom)))))));
        };

        $.Rectangle.intersectsRaw = function (view, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, right) {
            return void 0 === right && (right = 0), !(dataAndEvents > view.right + right || (deepDataAndEvents < view.left - right || (ignoreMethodDoesntExist > view.bottom + right || textAlt < view.top - right)));
        };

        $.Rectangle.union = function (bitmap, row, dataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = new($.Rectangle)), dataAndEvents.setTo(Math.min(bitmap.x, row.x), Math.min(bitmap.y, row.y), Math.max(bitmap.right, row.right) - Math.min(bitmap.left, row.left), Math.max(bitmap.bottom, row.bottom) - Math.min(bitmap.top, row.top));
        };

        $.Rectangle.aabb = function (dataAndEvents, console) {
            if (void 0 === console) {
                console = new($.Rectangle);
            }
            var maxX = Number.NEGATIVE_INFINITY;
            var x = Number.POSITIVE_INFINITY;
            var y = Number.NEGATIVE_INFINITY;
            var minY = Number.POSITIVE_INFINITY;
            return dataAndEvents.forEach(function (point) {
                if (point.x > maxX) {
                    maxX = point.x;
                }
                if (point.x < x) {
                    x = point.x;
                }
                if (point.y > y) {
                    y = point.y;
                }
                if (point.y < minY) {
                    minY = point.y;
                }
            }), console.setTo(x, minY, maxX - x, y - minY), console;
        };
        PIXI.Rectangle = $.Rectangle;
        PIXI.EmptyRectangle = new($.Rectangle)(0, 0, 0, 0);

        $.RoundedRectangle = function (v, sum, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            if (void 0 === v) {

                v = 0;
            }
            if (void 0 === sum) {

                sum = 0;
            }
            if (void 0 === dataAndEvents) {

                dataAndEvents = 0;
            }
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = 0;
            }
            if (void 0 === ignoreMethodDoesntExist) {

                ignoreMethodDoesntExist = 20;
            }

            this.x = v;

            this.y = sum;

            this.width = dataAndEvents;

            this.height = deepDataAndEvents;
            this.radius = ignoreMethodDoesntExist || 20;
            this.type = $.ROUNDEDRECTANGLE;
        };
        $.RoundedRectangle.prototype = {

            "clone": function () {
                return new($.RoundedRectangle)(this.x, this.y, this.width, this.height, this.radius);
            },

            "contains": function (mouseY, ey) {
                if (this.width <= 0 || this.height <= 0) {
                    return false;
                }
                var top = this.x;
                if (mouseY >= top && mouseY <= top + this.width) {
                    var gy = this.y;
                    if (ey >= gy && ey <= gy + this.height) {
                        return true;
                    }
                }
                return false;
            }
        };
        $.RoundedRectangle.prototype.constructor = $.RoundedRectangle;
        PIXI.RoundedRectangle = $.RoundedRectangle;

        $.Camera = function (dataAndEvents, keepData, context, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
            this.game = dataAndEvents;
            this.world = dataAndEvents.world;

            this.id = 0;
            this.view = new($.Rectangle)(context, deepDataAndEvents, ignoreMethodDoesntExist, textAlt);
            this.bounds = new($.Rectangle)(context, deepDataAndEvents, ignoreMethodDoesntExist, textAlt);

            this.deadzone = null;

            this.visible = true;

            this.roundPx = true;
            this.atLimit = {
                "x": false,
                "y": false
            };

            this.target = null;

            this.displayObject = null;

            this.scale = null;

            this.totalInView = 0;
            this.lerp = new($.Point)(1, 1);
            this.onShakeComplete = new($.Signal);
            this.onFlashComplete = new($.Signal);
            this.onFadeComplete = new $.Signal;

            this.fx = null;
            this._targetPosition = new($.Point);

            this._edge = 0;
            this._position = new($.Point);
            this._shake = {
                "intensity": 0,
                "duration": 0,
                "horizontal": false,
                "vertical": false,
                "shakeBounds": true,
                "x": 0,
                "y": 0
            };

            this._fxDuration = 0;

            this._fxType = 0;
            this._fixedView = new $.Rectangle;
        };

        $.Camera.FOLLOW_LOCKON = 0;

        $.Camera.FOLLOW_PLATFORMER = 1;

        $.Camera.FOLLOW_TOPDOWN = 2;

        $.Camera.FOLLOW_TOPDOWN_TIGHT = 3;

        $.Camera.SHAKE_BOTH = 4;

        $.Camera.SHAKE_HORIZONTAL = 5;

        $.Camera.SHAKE_VERTICAL = 6;

        $.Camera.ENABLE_FX = true;
        $.Camera.prototype = {

            "boot": function () {
                this.displayObject = this.game.world;
                this.scale = this.game.world.scale;
                this.game.camera = this;
                if ($.Graphics) {
                    if ($.Camera.ENABLE_FX) {
                        this.fx = new($.Graphics)(this.game);
                        this.game.stage.addChild(this.fx);
                    }
                }
            },

            "preUpdate": function () {

                this.totalInView = 0;
            },

            "follow": function (cs1, lerp, sep, entity) {
                if (void 0 === lerp) {
                    lerp = $.Camera.FOLLOW_LOCKON;
                }
                if (void 0 === sep) {

                    sep = 1;
                }
                if (void 0 === entity) {

                    entity = 1;
                }
                this.target = cs1;
                this.lerp.set(sep, entity);
                var _0xa2e79a;
                switch (lerp) {
                case $.Camera.FOLLOW_PLATFORMER:

                    var bCEdgeC = this.width / 8;

                    var _0x9dbefa = this.height / 3;
                    this.deadzone = new($.Rectangle)((this.width - bCEdgeC) / 2, (this.height - _0x9dbefa) / 2 - 0.25 * _0x9dbefa, bCEdgeC, _0x9dbefa);
                    break;
                case $.Camera.FOLLOW_TOPDOWN:

                    _0xa2e79a = Math.max(this.width, this.height) / 4;
                    this.deadzone = new($.Rectangle)((this.width - _0xa2e79a) / 2, (this.height - _0xa2e79a) / 2, _0xa2e79a, _0xa2e79a);
                    break;
                case $.Camera.FOLLOW_TOPDOWN_TIGHT:

                    _0xa2e79a = Math.max(this.width, this.height) / 8;
                    this.deadzone = new $.Rectangle((this.width - _0xa2e79a) / 2, (this.height - _0xa2e79a) / 2, _0xa2e79a, _0xa2e79a);
                    break;
                case $.Camera.FOLLOW_LOCKON:
                    ;
                default:

                    this.deadzone = null;
                }
            },

            "unfollow": function () {

                this.target = null;
            },

            "focusOn": function (point) {
                this.setPosition(Math.round(point.x - this.view.halfWidth), Math.round(point.y - this.view.halfHeight));
            },

            "focusOnXY": function (x, y) {
                this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));
            },

            "shake": function (shakeXtimes, times, motion, direction, strength) {
                return void 0 === shakeXtimes && (shakeXtimes = 0.05), void 0 === times && (times = 500), void 0 === motion && (motion = true), void 0 === direction && (direction = $.Camera.SHAKE_BOTH), void 0 === strength && (strength = true), !(!motion && this._shake.duration > 0 || (this._shake.intensity = shakeXtimes, this._shake.duration = times, this._shake.shakeBounds = strength, this._shake.x = 0, this._shake.y =
                    0, this._shake.horizontal = direction === $.Camera.SHAKE_BOTH || direction === $.Camera.SHAKE_HORIZONTAL, this._shake.vertical = direction === $.Camera.SHAKE_BOTH || direction === $.Camera.SHAKE_VERTICAL, 0));
            },

            "flash": function (easing, message, type, selection) {
                return void 0 === easing && (easing = 16777215), void 0 === message && (message = 500), void 0 === type && (type = false), void 0 === selection && (selection = 1), !(!this.fx || (!type && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill(easing, selection), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = message, this._fxType =
                    0, 0)));
            },

            "fade": function ($cont, $slides, amount, done) {
                return void 0 === $cont && ($cont = 0), void 0 === $slides && ($slides = 500), void 0 === amount && (amount = false), void 0 === done && (done = 1), !(!this.fx || (!amount && this._fxDuration > 0 || (this.fx.clear(), this.fx.beginFill($cont, done), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = $slides, this._fxType = 1, 0)));
            },

            "update": function () {
                if (this._fxDuration > 0) {
                    this.updateFX();
                }
                if (this._shake.duration > 0) {
                    this.updateShake();
                }
                if (this.bounds) {
                    this.checkBounds();
                }
                if (this.roundPx) {
                    this.view.floor();
                    this._shake.x = Math.floor(this._shake.x);
                    this._shake.y = Math.floor(this._shake.y);
                }

                this.displayObject.position.x = -this.view.x;

                this.displayObject.position.y = -this.view.y;
            },

            "updateFX": function () {
                if (0 === this._fxType) {
                    this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration;
                    if (this.fx.alpha <= 0) {

                        this._fxDuration = 0;

                        this.fx.alpha = 0;
                        this.onFlashComplete.dispatch();
                    }
                } else {
                    this.fx.alpha += this.game.time.elapsedMS / this._fxDuration;
                    if (this.fx.alpha >= 1) {

                        this._fxDuration = 0;

                        this.fx.alpha = 1;
                        this.onFadeComplete.dispatch();
                    }
                }
            },

            "updateShake": function () {
                this._shake.duration -= this.game.time.elapsedMS;
                if (this._shake.duration <= 0) {
                    this.onShakeComplete.dispatch();

                    this._shake.x = 0;

                    this._shake.y = 0;
                } else {
                    if (this._shake.horizontal) {

                        this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width;
                    }
                    if (this._shake.vertical) {

                        this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height;
                    }
                }
            },

            "updateTarget": function () {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x;
                this._targetPosition.y = this.view.y + this.target.worldPosition.y;
                if (this.deadzone) {

                    this._edge = this._targetPosition.x - this.view.x;
                    if (this._edge < this.deadzone.left) {
                        this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x);
                    } else {
                        if (this._edge > this.deadzone.right) {
                            this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x);
                        }
                    }

                    this._edge = this._targetPosition.y - this.view.y;
                    if (this._edge < this.deadzone.top) {
                        this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y);
                    } else {
                        if (this._edge > this.deadzone.bottom) {
                            this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y);
                        }
                    }
                } else {
                    this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x);
                    this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y);
                }
                if (this.bounds) {
                    this.checkBounds();
                }
                if (this.roundPx) {
                    this.view.floor();
                }

                this.displayObject.position.x = -this.view.x;

                this.displayObject.position.y = -this.view.y;
            },

            "setBoundsToWorld": function () {
                if (this.bounds) {
                    this.bounds.copyFrom(this.game.world.bounds);
                }
            },

            "checkBounds": function () {

                this.atLimit.x = false;

                this.atLimit.y = false;
                var _0x277098 = this.view.x + this._shake.x;
                var _0x50251f = this.view.right + this._shake.x;
                var _0x268f1f = this.view.y + this._shake.y;
                var _0x5692b7 = this.view.bottom + this._shake.y;
                if (_0x277098 <= this.bounds.x * this.scale.x) {

                    this.atLimit.x = true;

                    this.view.x = this.bounds.x * this.scale.x;
                    if (!this._shake.shakeBounds) {

                        this._shake.x = 0;
                    }
                } else {
                    if (_0x50251f >= this.bounds.right * this.scale.x) {

                        this.atLimit.x = true;

                        this.view.x = this.bounds.right * this.scale.x - this.width;
                        if (!this._shake.shakeBounds) {

                            this._shake.x = 0;
                        }
                    }
                }
                if (_0x268f1f <= this.bounds.top * this.scale.y) {

                    this.atLimit.y = true;

                    this.view.y = this.bounds.top * this.scale.y;
                    if (!this._shake.shakeBounds) {

                        this._shake.y = 0;
                    }
                } else {
                    if (_0x5692b7 >= this.bounds.bottom * this.scale.y) {

                        this.atLimit.y = true;

                        this.view.y = this.bounds.bottom * this.scale.y - this.height;
                        if (!this._shake.shakeBounds) {

                            this._shake.y = 0;
                        }
                    }
                }
            },

            "setPosition": function (y, x) {
                this.view.x = y;
                this.view.y = x;
                if (this.bounds) {
                    this.checkBounds();
                }
            },

            "setSize": function (width, height) {
                this.view.width = width;
                this.view.height = height;
            },

            "reset": function () {

                this.target = null;

                this.view.x = 0;

                this.view.y = 0;

                this._shake.duration = 0;

                this._shake.x = 0;

                this._shake.y = 0;
                this.resetFX();
            },

            "resetFX": function () {
                if (this.fx) {
                    this.fx.clear();

                    this.fx.alpha = 0;
                }

                this._fxDuration = 0;
            }
        };
        $.Camera.prototype.constructor = $.Camera;
        Object.defineProperty($.Camera.prototype, "x", {

            "get": function () {
                return this.view.x;
            },

            "set": function (v) {
                this.view.x = v;
                if (this.bounds) {
                    this.checkBounds();
                }
            }
        });
        Object.defineProperty($.Camera.prototype, "y", {

            "get": function () {
                return this.view.y;
            },

            "set": function (value) {
                this.view.y = value;
                if (this.bounds) {
                    this.checkBounds();
                }
            }
        });
        Object.defineProperty($.Camera.prototype, 'position', {

            "get": function () {
                return this._position.set(this.view.x, this.view.y), this._position;
            },

            "set": function (style) {
                if (void 0 !== style.x) {
                    this.view.x = style.x;
                }
                if (void 0 !== style.y) {
                    this.view.y = style.y;
                }
                if (this.bounds) {
                    this.checkBounds();
                }
            }
        });
        Object.defineProperty($.Camera.prototype, "width", {

            "get": function () {
                return this.view.width;
            },

            "set": function (mL) {
                this.view.width = mL;
            }
        });
        Object.defineProperty($.Camera.prototype, "height", {

            "get": function () {
                return this.view.height;
            },

            "set": function (mL) {
                this.view.height = mL;
            }
        });
        Object.defineProperty($.Camera.prototype, "shakeIntensity", {

            "get": function () {
                return this._shake.intensity;
            },

            "set": function (mL) {
                this._shake.intensity = mL;
            }
        });
        Object.defineProperty($.Camera.prototype, 'fixedView', {

            "get": function () {
                return this._fixedView.setTo(0, 0, this.view.width, this.view.height), this._fixedView;
            }
        });

        $.State = function () {

            this.game = null;

            this.key = "";

            this.add = null;

            this.make = null;

            this.camera = null;

            this.cache = null;

            this.input = null;

            this.load = null;

            this.math = null;

            this.sound = null;

            this.scale = null;

            this.stage = null;

            this.state = null;

            this.time = null;

            this.tweens = null;

            this.world = null;

            this.particles = null;

            this.physics = null;

            this.rnd = null;
        };
        $.State.prototype = {

            "init": function () {},

            "preload": function () {},

            "loadUpdate": function () {},

            "loadRender": function () {},

            "create": function () {},

            "update": function () {},

            "preRender": function () {},

            "render": function () {},

            "resize": function () {},

            "paused": function () {},

            "resumed": function () {},

            "pauseUpdate": function () {},

            "shutdown": function () {}
        };
        $.State.prototype.constructor = $.State;

        $.StateManager = function (dataAndEvents, deepDataAndEvents) {
            this.game = dataAndEvents;
            this.states = {};

            this._pendingState = null;
            if (void 0 !== deepDataAndEvents) {
                if (null !== deepDataAndEvents) {

                    this._pendingState = deepDataAndEvents;
                }
            }

            this._clearWorld = false;

            this._clearCache = false;

            this._created = false;

            this._args = [];

            this.current = "";
            this.onStateChange = new($.Signal);

            this.onInitCallback = null;

            this.onPreloadCallback = null;

            this.onCreateCallback = null;

            this.onUpdateCallback = null;

            this.onRenderCallback = null;

            this.onResizeCallback = null;

            this.onPreRenderCallback = null;

            this.onLoadUpdateCallback = null;

            this.onLoadRenderCallback = null;

            this.onPausedCallback = null;

            this.onResumedCallback = null;

            this.onPauseUpdateCallback = null;

            this.onShutDownCallback = null;
        };
        $.StateManager.prototype = {

            "boot": function () {
                this.game.onPause.add(this.pause, this);
                this.game.onResume.add(this.resume, this);
                if (null !== this._pendingState) {
                    if ('string' != typeof this._pendingState) {
                        this.add('default', this._pendingState, true);
                    }
                }
            },

            "add": function (path, selector, vec0) {
                if (void 0 === vec0) {

                    vec0 = false;
                }
                var fn;
                return selector instanceof $.State ? fn = selector : 'object' == typeof selector ? (fn = selector).game = this.game : "function" == typeof selector && (fn = new selector(this.game)), this.states[path] = fn, vec0 && (this.game.isBooted ? this.start(path) : this._pendingState = path), fn;
            },

            "remove": function (testname) {
                if (this.current === testname) {

                    this.callbackContext = null;

                    this.onInitCallback = null;

                    this.onShutDownCallback = null;

                    this.onPreloadCallback = null;

                    this.onLoadRenderCallback = null;

                    this.onLoadUpdateCallback = null;

                    this.onCreateCallback = null;

                    this.onUpdateCallback = null;

                    this.onPreRenderCallback = null;

                    this.onRenderCallback = null;

                    this.onResizeCallback = null;

                    this.onPausedCallback = null;

                    this.onResumedCallback = null;

                    this.onPauseUpdateCallback = null;
                }
                delete this.states[testname];
            },

            "start": function (persistent, ui, onFailed) {
                if (void 0 === ui) {

                    ui = true;
                }
                if (void 0 === onFailed) {

                    onFailed = false;
                }
                if (this.checkState(persistent)) {
                    this._pendingState = persistent;

                    this._clearWorld = ui;

                    this._clearCache = onFailed;
                    if (arguments.length > 3) {
                        this._args = Array.prototype.splice.call(arguments, 3);
                    }
                }
            },

            "restart": function (monitors, suppressEvents) {
                if (void 0 === monitors) {

                    monitors = true;
                }
                if (void 0 === suppressEvents) {

                    suppressEvents = false;
                }
                this._pendingState = this.current;

                this._clearWorld = monitors;

                this._clearCache = suppressEvents;
                if (arguments.length > 2) {
                    this._args = Array.prototype.slice.call(arguments, 2);
                }
            },

            "dummy": function () {},

            "preUpdate": function () {
                if (this._pendingState && this.game.isBooted) {
                    var r20 = this.current;
                    if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, r20), this.current !== this._pendingState) {
                        return;
                    }

                    this._pendingState = null;
                    if (this.onPreloadCallback) {
                        this.game.load.reset(true);
                        this.onPreloadCallback.call(this.callbackContext, this.game);
                        if (0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks()) {
                            this.loadComplete();
                        } else {
                            this.game.load.start();
                        }
                    } else {
                        this.loadComplete();
                    }
                }
            },

            "clearCurrentState": function () {
                if (this.current) {
                    if (this.onShutDownCallback) {
                        this.onShutDownCallback.call(this.callbackContext, this.game);
                    }
                    this.game.tweens.removeAll();
                    this.game.camera.reset();
                    this.game.input.reset(true);
                    this.game.physics.clear();
                    this.game.time.removeAll();
                    this.game.scale.reset(this._clearWorld);
                    if (this.game.debug) {
                        this.game.debug.reset();
                    }
                    if (this._clearWorld) {
                        this.game.world.shutdown();
                        if (this._clearCache) {
                            this.game.cache.destroy();
                        }
                    }
                }
            },

            "checkState": function (name) {
                var set = this.states[name];
                return set ? !!(set.preload || (set.create || (set.update || set.render))) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), false) : (console.warn('Phaser.StateManager - No state found with the key: ' + name), false);
            },

            "link": function (text) {
                var modules = this.states[text];
                modules.game = this.game;
                modules.add = this.game.add;
                modules.make = this.game.make;
                modules.camera = this.game.camera;
                modules.cache = this.game.cache;
                modules.input = this.game.input;
                modules.load = this.game.load;
                modules.math = this.game.math;
                modules.sound = this.game.sound;
                modules.scale = this.game.scale;
                modules.state = this;
                modules.stage = this.game.stage;
                modules.time = this.game.time;
                modules.tweens = this.game.tweens;
                modules.world = this.game.world;
                modules.particles = this.game.particles;
                modules.rnd = this.game.rnd;
                modules.physics = this.game.physics;
                modules.key = text;
            },

            "unlink": function (path) {
                var cb = this.states[path];
                if (cb) {

                    cb.game = null;

                    cb.add = null;

                    cb.make = null;

                    cb.camera = null;

                    cb.cache = null;

                    cb.input = null;

                    cb.load = null;

                    cb.math = null;

                    cb.sound = null;

                    cb.scale = null;

                    cb.state = null;

                    cb.stage = null;

                    cb.time = null;

                    cb.tweens = null;

                    cb.world = null;

                    cb.particles = null;

                    cb.rnd = null;

                    cb.physics = null;
                }
            },

            "setCurrentState": function (key) {
                var label = this.states[key];
                this.callbackContext = label;
                this.link(key);
                this.onInitCallback = label.init || this.dummy;
                this.onPreloadCallback = label.preload || null;
                this.onLoadRenderCallback = label.loadRender || null;
                this.onLoadUpdateCallback = label.loadUpdate || null;
                this.onCreateCallback = label.create || null;
                this.onUpdateCallback = label.update || null;
                this.onPreRenderCallback = label.preRender || null;
                this.onRenderCallback = label.render || null;
                this.onResizeCallback = label.resize || null;
                this.onPausedCallback = label.paused || null;
                this.onResumedCallback = label.resumed || null;
                this.onPauseUpdateCallback = label.pauseUpdate || null;
                this.onShutDownCallback = label.shutdown || this.dummy;
                if ("" !== this.current) {
                    this.game.physics.reset();
                }
                this.current = key;

                this._created = false;
                this.onInitCallback.apply(this.callbackContext, this._args);
                if (key === this._pendingState) {

                    this._args = [];
                }

                this.game._kickstart = true;
            },

            "getCurrentState": function () {
                return this.states[this.current];
            },

            "loadComplete": function () {
                if (false === this._created && this.onCreateCallback) {

                    this._created = true;
                    this.onCreateCallback.call(this.callbackContext, this.game);
                } else {

                    this._created = true;
                }
            },

            "loadUpdate": function () {
                if (false === this._created) {
                    if (this.onLoadUpdateCallback) {
                        this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "pause": function () {
                if (this._created) {
                    if (this.onPausedCallback) {
                        this.onPausedCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "resume": function () {
                if (this._created) {
                    if (this.onResumedCallback) {
                        this.onResumedCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "update": function () {
                if (this._created) {
                    if (this.onUpdateCallback) {
                        this.onUpdateCallback.call(this.callbackContext, this.game);
                    }
                } else {
                    if (this.onLoadUpdateCallback) {
                        this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "pauseUpdate": function () {
                if (this._created) {
                    if (this.onPauseUpdateCallback) {
                        this.onPauseUpdateCallback.call(this.callbackContext, this.game);
                    }
                } else {
                    if (this.onLoadUpdateCallback) {
                        this.onLoadUpdateCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "preRender": function (scene) {
                if (this._created) {
                    if (this.onPreRenderCallback) {
                        this.onPreRenderCallback.call(this.callbackContext, this.game, scene);
                    }
                }
            },

            "resize": function (event, height) {
                if (this.onResizeCallback) {
                    this.onResizeCallback.call(this.callbackContext, event, height);
                }
            },

            "render": function () {
                if (this._created) {
                    if (this.onRenderCallback) {
                        if (this.game.renderType === $.CANVAS) {
                            this.game.context.save();
                            this.game.context.setTransform(1, 0, 0, 1, 0, 0);
                            this.onRenderCallback.call(this.callbackContext, this.game);
                            this.game.context.restore();
                        } else {
                            this.onRenderCallback.call(this.callbackContext, this.game);
                        }
                    }
                } else {
                    if (this.onLoadRenderCallback) {
                        this.onLoadRenderCallback.call(this.callbackContext, this.game);
                    }
                }
            },

            "destroy": function () {

                this._clearWorld = true;

                this._clearCache = true;
                this.clearCurrentState();

                this.callbackContext = null;

                this.onInitCallback = null;

                this.onShutDownCallback = null;

                this.onPreloadCallback = null;

                this.onLoadRenderCallback = null;

                this.onLoadUpdateCallback = null;

                this.onCreateCallback = null;

                this.onUpdateCallback = null;

                this.onRenderCallback = null;

                this.onPausedCallback = null;

                this.onResumedCallback = null;

                this.onPauseUpdateCallback = null;

                this.game = null;
                this.states = {};

                this._pendingState = null;

                this.current = "";
            }
        };
        $.StateManager.prototype.constructor = $.StateManager;
        Object.defineProperty($.StateManager.prototype, 'created', {

            "get": function () {
                return this._created;
            }
        });

        $.Signal = function () {};
        $.Signal.prototype = {
            "_bindings": null,
            "_prevParams": null,
            "memorize": false,
            "_shouldPropagate": true,
            "active": true,
            "_boundDispatch": false,

            "validateListener": function (listener, fnName) {
                if ('function' != typeof listener) {
                    throw new Error('Phaser.Signal: listener is a required param of {fn}() and should be a Function.' ['replace']("{fn}", fnName));
                }
            },

            "_registerListener": function (owner, isOnce, scope, priority, listener) {
                var binding;
                var unlock = this._indexOfListener(owner, scope);
                if (-1 !== unlock) {
                    if ((binding = this._bindings[unlock]).isOnce() !== isOnce) {
                        throw new Error('You cannot add' + (isOnce ? "" : "Once") + "() then add" + (isOnce ? 'Once' : "") + '() the same listener without removing the relationship first.');
                    }
                } else {
                    binding = new $.SignalBinding(this, owner, isOnce, scope, priority, listener);
                    this._addBinding(binding);
                }
                return this.memorize && (this._prevParams && binding.execute(this._prevParams)), binding;
            },

            "_addBinding": function (platform) {
                if (!this._bindings) {

                    this._bindings = [];
                }
                var unlock = this._bindings.length;
                do {
                    unlock--;
                } while (this._bindings[unlock] && platform._priority <= this._bindings[unlock]._priority);
                this._bindings.splice(unlock + 1, 0, platform);
            },

            "_indexOfListener": function (listener, context) {
                if (!this._bindings) {
                    return -1;
                }
                if (void 0 === context) {

                    context = null;
                }
                var fn;
                var i = this._bindings.length;
                for (; i--;) {
                    if ((fn = this._bindings[i])._listener === listener && fn.context === context) {
                        return i;
                    }
                }
                return -1;
            },

            "has": function (property, attr) {
                return -1 !== this._indexOfListener(property, attr);
            },

            "add": function (vec0, vec1, fake) {
                this.validateListener(vec0, "add");

                var _args = [];
                if (arguments.length > 3) {

                    var i = 3;
                    for (; i < arguments.length; i++) {
                        _args.push(arguments[i]);
                    }
                }
                return this._registerListener(vec0, false, vec1, fake, _args);
            },

            "addOnce": function (priority, scope, listener) {
                this.validateListener(priority, 'addOnce');

                var _args = [];
                if (arguments.length > 3) {

                    var i = 3;
                    for (; i < arguments.length; i++) {
                        _args.push(arguments[i]);
                    }
                }
                return this._registerListener(priority, true, scope, listener, _args);
            },

            "remove": function (selector, keepData) {
                this.validateListener(selector, 'remove');
                var sel = this._indexOfListener(selector, keepData);
                return -1 !== sel && (this._bindings[sel]._destroy(), this._bindings.splice(sel, 1)), selector;
            },

            "removeAll": function (silent) {
                if (void 0 === silent && (silent = null), this._bindings) {
                    var sel = this._bindings.length;
                    for (; sel--;) {
                        if (silent) {
                            if (this._bindings[sel].context === silent) {
                                this._bindings[sel]._destroy();
                                this._bindings.splice(sel, 1);
                            }
                        } else {
                            this._bindings[sel]._destroy();
                        }
                    }
                    if (!silent) {

                        this._bindings.length = 0;
                    }
                }
            },

            "getNumListeners": function () {
                return this._bindings ? this._bindings.length : 0;
            },

            "halt": function () {

                this._shouldPropagate = false;
            },

            "dispatch": function () {
                if (this.active && this._bindings) {
                    var map;
                    var expectedArgs = Array.prototype.slice.call(arguments);
                    var objUid = this._bindings.length;
                    if (this.memorize && (this._prevParams = expectedArgs), objUid) {
                        map = this._bindings.slice();

                        this._shouldPropagate = true;
                        do {
                            objUid--;
                        } while (map[objUid] && (this._shouldPropagate && false !== map[objUid].execute(expectedArgs)));
                    }
                }
            },

            "forget": function () {
                if (this._prevParams) {

                    this._prevParams = null;
                }
            },

            "dispose": function () {
                this.removeAll();

                this._bindings = null;
                if (this._prevParams) {

                    this._prevParams = null;
                }
            },

            "toString": function () {
                return '[Phaser.Signal active:' + this.active + " numListeners:" + this.getNumListeners() + "]";
            }
        };
        Object.defineProperty($.Signal.prototype, 'boundDispatch', {

            "get": function () {
                var r20 = this;
                return this._boundDispatch || (this._boundDispatch = function () {
                    return r20.dispatch.apply(r20, arguments);
                });
            }
        });
        $.Signal.prototype.constructor = $.Signal;

        $.SignalBinding = function (deepDataAndEvents, textAlt, keepData, opt_attributes, ignoreMethodDoesntExist, dataAndEvents) {
            this._listener = textAlt;
            if (keepData) {

                this._isOnce = true;
            }
            if (null != opt_attributes) {

                this.context = opt_attributes;
            }
            this._signal = deepDataAndEvents;
            if (ignoreMethodDoesntExist) {
                this._priority = ignoreMethodDoesntExist;
            }
            if (dataAndEvents) {
                if (dataAndEvents.length) {
                    this._args = dataAndEvents;
                }
            }
        };
        $.SignalBinding.prototype = {
            "context": null,
            "_isOnce": false,
            "_priority": 0,
            "_args": null,
            "callCount": 0,
            "active": true,
            "params": null,

            "execute": function (onComplete) {
                var pdataCur;
                var pdataOld;
                return this.active && (this._listener && (pdataOld = this.params ? this.params.concat(onComplete) : onComplete, this._args && (pdataOld = pdataOld.concat(this._args)), pdataCur = this._listener.apply(this.context, pdataOld), this.callCount++, this._isOnce && this.detach())), pdataCur;
            },

            "detach": function () {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
            },

            "isBound": function () {
                return !!this._signal && !!this._listener;
            },

            "isOnce": function () {
                return this._isOnce;
            },

            "getListener": function () {
                return this._listener;
            },

            "getSignal": function () {
                return this._signal;
            },

            "_destroy": function () {
                delete this._signal;
                delete this._listener;
                delete this.context;
            },

            "toString": function () {
                return '[Phaser.SignalBinding isOnce:' + this._isOnce + ", isBound:" + this.isBound() + ', active:' + this.active + "]";
            }
        };
        $.SignalBinding.prototype.constructor = $.SignalBinding;

        $.Filter = function (deepDataAndEvents, helper, dataAndEvents) {
            this.game = deepDataAndEvents;
            this.type = $.WEBGL_FILTER;

            this.passes = [this];

            this.shaders = [];

            this.dirty = true;

            this.padding = 0;
            this.prevPoint = new($.Point);

            var against = new Date;
            if (this.uniforms = {
                    "resolution": {
                        "type": "2f",
                        "value": {
                            "x": 256,
                            "y": 256
                        }
                    },
                    "time": {
                        "type": "1f",
                        "value": 0
                    },
                    "mouse": {
                        "type": "2f",
                        "value": {
                            "x": 0,
                            "y": 0
                        }
                    },
                    "date": {
                        "type": '4fv',
                        "value": [against.getFullYear(), against.getMonth(), against.getDate(), 60 * against.getHours() * 60 + 60 * against.getMinutes() + against.getSeconds()]
                    },
                    "sampleRate": {
                        "type": "1f",
                        "value": 44100
                    },
                    "iChannel0": {
                        "type": 'sampler2D',
                        "value": null,
                        "textureData": {
                            "repeat": true
                        }
                    },
                    "iChannel1": {
                        "type": "sampler2D",
                        "value": null,
                        "textureData": {
                            "repeat": true
                        }
                    },
                    "iChannel2": {
                        "type": 'sampler2D',
                        "value": null,
                        "textureData": {
                            "repeat": true
                        }
                    },
                    "iChannel3": {
                        "type": 'sampler2D',
                        "value": null,
                        "textureData": {
                            "repeat": true
                        }
                    }
                }, helper) {
                var key;
                for (key in helper) {
                    this.uniforms[key] = helper[key];
                }
            }
            if ('string' == typeof dataAndEvents) {
                dataAndEvents = dataAndEvents.split("\n");
            }
            this.fragmentSrc = dataAndEvents || [];
        };
        $.Filter.prototype = {

            "init": function () {},

            "setResolution": function (v, sum) {
                this.uniforms.resolution.value.x = v;
                this.uniforms.resolution.value.y = sum;
            },

            "update": function (position) {
                if (position) {

                    var r20 = position.x / this.game.width;

                    var restoreScript = 1 - position.y / this.game.height;
                    if (!(r20 === this.prevPoint.x && restoreScript === this.prevPoint.y)) {
                        this.uniforms.mouse.value.x = r20.toFixed(2);
                        this.uniforms.mouse.value.y = restoreScript.toFixed(2);
                        this.prevPoint.set(r20, restoreScript);
                    }
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds();
            },

            "addToWorld": function (a, options, method, node, deepDataAndEvents, opt_obj2) {
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = 0;
                }
                if (void 0 === opt_obj2) {

                    opt_obj2 = 0;
                }
                if (void 0 !== method && null !== method) {

                    this.width = method;
                } else {
                    method = this.width;
                }
                if (void 0 !== node && null !== node) {

                    this.height = node;
                } else {
                    node = this.height;
                }
                var hash = this.game.add.image(a, options, $.Cache.DEFAULT);
                return hash.width = method, hash.height = node, hash.anchor.set(deepDataAndEvents, opt_obj2), hash.filters = [this], hash;
            },

            "syncUniforms": function () {

                var i = 0;
                for (; i < this.shaders.length; i++) {

                    this.shaders[i].dirty = true;
                }
            },

            "destroy": function () {

                this.passes.length = 0;

                this.shaders.length = 0;

                this.fragmentSrc.length = 0;

                this.game = null;

                this.uniforms = null;

                this.prevPoint = null;
            }
        };
        $.Filter.prototype.constructor = $.Filter;
        Object.defineProperty($.Filter.prototype, 'width', {

            "get": function () {
                return this.uniforms.resolution.value.x;
            },

            "set": function (v) {
                this.uniforms.resolution.value.x = v;
            }
        });
        Object.defineProperty($.Filter.prototype, 'height', {

            "get": function () {
                return this.uniforms.resolution.value.y;
            },

            "set": function (value) {
                this.uniforms.resolution.value.y = value;
            }
        });

        $.Plugin = function (dataAndEvents, deepDataAndEvents) {
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = null;
            }
            this.game = dataAndEvents;

            this.parent = deepDataAndEvents;

            this.active = false;

            this.visible = false;

            this.hasPreUpdate = false;

            this.hasUpdate = false;

            this.hasPostUpdate = false;

            this.hasRender = false;

            this.hasPostRender = false;
        };
        $.Plugin.prototype = {

            "preUpdate": function () {},

            "update": function () {},

            "render": function () {},

            "postRender": function () {},

            "destroy": function () {

                this.game = null;

                this.parent = null;

                this.active = false;

                this.visible = false;
            }
        };
        $.Plugin.prototype.constructor = $.Plugin;

        $.PluginManager = function (dataAndEvents) {
            this.game = dataAndEvents;

            this.plugins = [];

            this._len = 0;

            this._i = 0;
        };
        $.PluginManager.prototype = {

            "add": function (plugin) {
                var expectedArgs = Array.prototype.slice.call(arguments, 1);

                var _0x1bdd2d = false;
                return 'function' == typeof plugin ? plugin = new plugin(this.game, this) : (plugin.game = this.game, plugin.parent = this), 'function' == typeof plugin.preUpdate && (plugin.hasPreUpdate = true, _0x1bdd2d = true), 'function' == typeof plugin.update && (plugin.hasUpdate = true, _0x1bdd2d = true), 'function' == typeof plugin.postUpdate && (plugin.hasPostUpdate = true, _0x1bdd2d = true), 'function' ==
                    typeof plugin.render && (plugin.hasRender = true, _0x1bdd2d = true), 'function' == typeof plugin.postRender && (plugin.hasPostRender = true, _0x1bdd2d = true), _0x1bdd2d ? ((plugin.hasPreUpdate || (plugin.hasUpdate || plugin.hasPostUpdate)) && (plugin.active = true), (plugin.hasRender || plugin.hasPostRender) && (plugin.visible = true), this._len = this.plugins.push(plugin), 'function' ==
                        typeof plugin.init && plugin.init.apply(plugin, expectedArgs), plugin) : null;
            },

            "remove": function (keepData, stopHere) {
                if (void 0 === stopHere) {

                    stopHere = true;
                }
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i] === keepData) {
                        return stopHere && keepData.destroy(), this.plugins.splice(this._i, 1), void this._len--;
                    }
                }
            },

            "removeAll": function () {
                this._i = this._len;
                for (; this._i--;) {
                    this.plugins[this._i].destroy();
                }

                this.plugins.length = 0;

                this._len = 0;
            },

            "preUpdate": function () {
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i].active) {
                        if (this.plugins[this._i].hasPreUpdate) {
                            this.plugins[this._i].preUpdate();
                        }
                    }
                }
            },

            "update": function () {
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i].active) {
                        if (this.plugins[this._i].hasUpdate) {
                            this.plugins[this._i].update();
                        }
                    }
                }
            },

            "postUpdate": function () {
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i].active) {
                        if (this.plugins[this._i].hasPostUpdate) {
                            this.plugins[this._i].postUpdate();
                        }
                    }
                }
            },

            "render": function () {
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i].visible) {
                        if (this.plugins[this._i].hasRender) {
                            this.plugins[this._i].render();
                        }
                    }
                }
            },

            "postRender": function () {
                this._i = this._len;
                for (; this._i--;) {
                    if (this.plugins[this._i].visible) {
                        if (this.plugins[this._i].hasPostRender) {
                            this.plugins[this._i].postRender();
                        }
                    }
                }
            },

            "destroy": function () {
                this.removeAll();

                this.game = null;
            }
        };
        $.PluginManager.prototype.constructor = $.PluginManager;

        $.Stage = function (dataAndEvents) {
            this.game = dataAndEvents;
            PIXI.DisplayObjectContainer.call(this);
            this.name = '_stage_root';

            this.disableVisibilityChange = false;

            this.exists = true;
            this.worldTransform = new($.Matrix);
            this.stage = this;

            this.currentRenderOrderID = 0;

            this._hiddenVar = "hidden";

            this._onChange = null;
            this._bgColor = {
                "r": 0,
                "g": 0,
                "b": 0,
                "a": 0,
                "color": 0,
                "rgba": '#000000'
            };
            if (!this.game.transparent) {

                this._bgColor.a = 1;
            }
            if (dataAndEvents.config) {
                this.parseConfig(dataAndEvents.config);
            }
        };
        $.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
        $.Stage.prototype.constructor = $.Stage;

        $.Stage.prototype.parseConfig = function (dataAndEvents) {
            if (dataAndEvents.disableVisibilityChange) {
                this.disableVisibilityChange = dataAndEvents.disableVisibilityChange;
            }
            if (dataAndEvents.backgroundColor) {
                this.setBackgroundColor(dataAndEvents.backgroundColor);
            }
        };

        $.Stage.prototype.boot = function () {
            $.DOM.getOffset(this.game.canvas, this.offset);
            $.Canvas.setUserSelect(this.game.canvas, 'none');
            $.Canvas.setTouchAction(this.game.canvas, 'none');
            this.checkVisibility();
        };

        $.Stage.prototype.preUpdate = function () {

            this.currentRenderOrderID = 0;

            var i = 0;
            for (; i < this.children.length;) {
                var plugin = this.children[i];
                plugin.preUpdate();
                if (this === plugin.parent) {
                    i++;
                }
            }
        };

        $.Stage.prototype.update = function () {
            var unlock = this.children.length;
            for (; unlock--;) {
                this.children[unlock].update();
            }
        };

        $.Stage.prototype.postUpdate = function () {
            this.game.camera.update();
            if (this.game.camera.target) {
                this.game.camera.target.postUpdate();
                this.updateTransform();
                this.game.camera.updateTarget();
            }

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                this.children[unlock].postUpdate();
            }
            this.updateTransform();
        };

        $.Stage.prototype.updateTransform = function () {

            this.worldAlpha = 1;

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                this.children[unlock].updateTransform();
            }
        };

        $.Stage.prototype.checkVisibility = function () {
            if (void 0 !== document.hidden) {

                this._hiddenVar = "visibilitychange";
            } else {
                if (void 0 !== document.webkitHidden) {
                    this._hiddenVar = 'webkitvisibilitychange';
                } else {
                    if (void 0 !== document.mozHidden) {
                        this._hiddenVar = 'mozvisibilitychange';
                    } else {
                        if (void 0 !== document.msHidden) {
                            this._hiddenVar = 'msvisibilitychange';
                        } else {

                            this._hiddenVar = null;
                        }
                    }
                }
            }
            var r20 = this;

            this._onChange = function (deepDataAndEvents) {
                return r20.visibilityChange(deepDataAndEvents);
            };

            this._onClick = function (deepDataAndEvents) {
                if (!(void 0 === document.hasFocus)) {
                    if (!document.hasFocus()) {
                        r20.visibilityChange(deepDataAndEvents);
                    }
                }
            };
            if (this._hiddenVar) {
                document.addEventListener(this._hiddenVar, this._onChange, false);
            }
            window.onblur = this._onChange;
            window.onfocus = this._onChange;
            window.onpagehide = this._onChange;
            window.onpageshow = this._onChange;
            window.addEventListener('click', this._onClick);
            if (this.game.device.cocoonJSApp) {
                CocoonJS.App.onSuspended.addEventListener(function () {
                    $.Stage.prototype.visibilityChange.call(r20, {
                        "type": 'pause'
                    });
                });
                CocoonJS.App.onActivated.addEventListener(function () {
                    $.Stage.prototype.visibilityChange.call(r20, {
                        "type": 'resume'
                    });
                });
            }
        };

        $.Stage.prototype.visibilityChange = function (deepDataAndEvents) {
            switch (deepDataAndEvents.type) {
            case 'blur':
                ;
            case "pagehide":
                return void this.game.focusLoss(deepDataAndEvents);
            case 'click':
                ;
            case 'focus':
                ;
            case 'pageshow':
                return void this.game.focusGain(deepDataAndEvents);
            }
            if (!this.disableVisibilityChange) {
                if (document.hidden || (document.mozHidden || (document.msHidden || (document.webkitHidden || 'pause' === deepDataAndEvents.type)))) {
                    this.game.gamePaused(deepDataAndEvents);
                } else {
                    this.game.gameResumed(deepDataAndEvents);
                }
            }
        };

        $.Stage.prototype.setBackgroundColor = function (deepDataAndEvents) {
            if (!this.game.transparent) {
                $.Color.valueToColor(deepDataAndEvents, this._bgColor);
                $.Color.updateColor(this._bgColor);
                this._bgColor.r /= 255;
                this._bgColor.g /= 255;
                this._bgColor.b /= 255;

                this._bgColor.a = 1;
            }
        };

        $.Stage.prototype.destroy = function () {
            if (this._hiddenVar) {
                document.removeEventListener(this._hiddenVar, this._onChange, false);
            }

            window.onpagehide = null;

            window.onpageshow = null;

            window.onblur = null;

            window.onfocus = null;
            window.removeEventListener('click', this._onClick);
        };

        $.Stage.prototype.add = function (selector, dataAndEvents, string) {
            return selector.parent === this ? selector : (selector.body && (selector.parent && (selector.parent.hash && selector.parent.removeFromHash(selector))), void 0 === string ? this.addChild(selector) : this.addChildAt(selector, string), selector);
        };
        Object.defineProperty($.Stage.prototype, "backgroundColor", {

            "get": function () {
                return this._bgColor.color;
            },

            "set": function (opt_path) {
                this.setBackgroundColor(opt_path);
            }
        });
        Object.defineProperty($.Stage.prototype, 'smoothed', {

            "get": function () {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR;
            },

            "set": function (mL) {
                PIXI.scaleModes.DEFAULT = mL ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST;
            }
        });

        $.Group = function (opt_nodes, node, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = false;
            }
            if (void 0 === ignoreMethodDoesntExist) {

                ignoreMethodDoesntExist = false;
            }
            if (void 0 === textAlt) {
                textAlt = $.Physics.ARCADE;
            }
            this.game = opt_nodes;
            if (void 0 === node) {
                node = opt_nodes.world;
            }
            this.name = dataAndEvents || 'group';

            this.z = 0;
            PIXI.DisplayObjectContainer.call(this);
            if (deepDataAndEvents) {
                this.game.stage.addChild(this);
                this.z = this.game.stage.children.length;
            } else {
                if (node) {
                    node.addChild(this);
                    this.z = node.children.length;
                }
            }
            this.type = $.GROUP;
            this.physicsType = $.GROUP;

            this.alive = true;

            this.exists = true;

            this.ignoreDestroy = false;

            this.pendingDestroy = false;
            this.classType = $.Sprite;

            this.cursor = null;

            this.inputEnableChildren = false;

            this.updateOnlyExistingChildren = false;
            this.onChildInputDown = new($.Signal);
            this.onChildInputUp = new($.Signal);
            this.onChildInputOver = new($.Signal);
            this.onChildInputOut = new($.Signal);

            this.enableBody = ignoreMethodDoesntExist;

            this.enableBodyDebug = false;

            this.physicsBodyType = textAlt;

            this.physicsSortDirection = null;
            this.onDestroy = new $.Signal;

            this.cursorIndex = 0;

            this.fixedToCamera = false;
            this.cameraOffset = new($.Point);

            this.hash = [];

            this._sortProperty = "z";
        };
        $.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);
        $.Group.prototype.constructor = $.Group;

        $.Group.RETURN_NONE = 0;

        $.Group.RETURN_TOTAL = 1;

        $.Group.RETURN_CHILD = 2;

        $.Group.RETURN_ALL = 3;

        $.Group.SORT_ASCENDING = -1;

        $.Group.SORT_DESCENDING = 1;

        $.Group.prototype.add = function (map, dataAndEvents, deepDataAndEvents) {
            return void 0 === dataAndEvents && (dataAndEvents = false), map.parent === this ? map : (map.body && (map.parent && (map.parent.hash && map.parent.removeFromHash(map))), void 0 === deepDataAndEvents ? (map.z = this.children.length, this.addChild(map)) : (this.addChildAt(map, deepDataAndEvents), this.updateZ()), this.enableBody && (map.hasOwnProperty('body') && null === map.body) ?
                this.game.physics.enable(map, this.physicsBodyType) : map.body && this.addToHash(map), !this.inputEnableChildren || (map.input && !map.inputEnabled || (map.inputEnabled = true)), !dataAndEvents && (map.events && map.events.onAddedToGroup$dispatch(map, this)), null === this.cursor && (this.cursor = map), map);
        };

        $.Group.prototype.addAt = function (deepDataAndEvents, opt_obj2, walkers) {
            return this.add(deepDataAndEvents, walkers, opt_obj2);
        };

        $.Group.prototype.addToHash = function (args) {
            return args.parent === this && (-1 === this.hash.indexOf(args) && (this.hash.push(args), true));
        };

        $.Group.prototype.removeFromHash = function (key) {
            if (key) {
                var camelKey = this.hash.indexOf(key);
                if (-1 !== camelKey) {
                    return this.hash.splice(camelKey, 1), true;
                }
            }
            return false;
        };

        $.Group.prototype.addMultiple = function (data, deepDataAndEvents) {
            if (data instanceof $.Group) {
                data.moveAll(this, deepDataAndEvents);
            } else {
                if (Array.isArray(data)) {

                    var i = 0;
                    for (; i < data.length; i++) {
                        this.add(data[i], deepDataAndEvents);
                    }
                }
            }
            return data;
        };

        $.Group.prototype.getAt = function (deepDataAndEvents) {
            return deepDataAndEvents < 0 || deepDataAndEvents >= this.children.length ? -1 : this.getChildAt(deepDataAndEvents);
        };

        $.Group.prototype.create = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, opcode, opt_obj2) {
            if (void 0 === opcode) {

                opcode = true;
            }
            var outputBuffer = new(this.classType)(this.game, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt);
            return outputBuffer.exists = opcode, outputBuffer.visible = opcode, outputBuffer.alive = opcode, this.add(outputBuffer, false, opt_obj2);
        };

        $.Group.prototype.createMultiple = function (textAlt, data, contexts, deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist) {
            if (void 0 === contexts) {

                contexts = 0;
            }
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = false;
            }
            if (!Array.isArray(data)) {

                data = [data];
            }
            if (!Array.isArray(contexts)) {

                contexts = [contexts];
            }
            var SELF = this;

            var missing = [];
            return data.forEach(function (param) {
                contexts.forEach(function (err) {

                    var r20 = 0;
                    for (; r20 < textAlt; r20++) {
                        var dep = SELF.create(0, 0, param, err, deepDataAndEvents);
                        if (dataAndEvents) {
                            dataAndEvents.call(ignoreMethodDoesntExist || dep, dep, r20);
                        }
                        missing.push(dep);
                    }
                });
            }), missing;
        };

        $.Group.prototype.updateZ = function () {
            var x = this.children.length;
            for (; x--;) {
                this.children[x].z = x;
            }
        };

        $.Group.prototype.align = function (a3, a4, b2, b1, before, lineStart) {
            if (void 0 === before && (before = $.TOP_LEFT), void 0 === lineStart && (lineStart = 0), 0 === this.children.length || (lineStart > this.children.length || -1 === a3 && -1 === a4)) {
                return false;
            }
            var el = new($.Rectangle)(0, 0, b2, b1);

            var a = a3 * b2;

            var node = a4 * b1;

            var j = lineStart;
            for (; j < this.children.length; j++) {
                var func = this.children[j];
                if (func.alignIn) {
                    if (func.alignIn(el, before), -1 === a3) {
                        el.y += b1;
                        if (el.y === node) {
                            el.x += b2;

                            el.y = 0;
                        }
                    } else {
                        if (-1 === a4) {
                            el.x += b2;
                            if (el.x === a) {

                                el.x = 0;
                                el.y += b1;
                            }
                        } else {
                            if (el.x += b2, el.x === a && (el.x = 0, el.y += b1, el.y === node)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return true;
        };

        $.Group.prototype.resetCursor = function (dataAndEvents) {
            if (void 0 === dataAndEvents && (dataAndEvents = 0), dataAndEvents > this.children.length - 1 && (dataAndEvents = 0), this.cursor) {
                return this.cursorIndex = dataAndEvents, this.cursor = this.children[this.cursorIndex], this.cursor;
            }
        };

        $.Group.prototype.next = function () {
            if (this.cursor) {
                return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor;
            }
        };

        $.Group.prototype.previous = function () {
            if (this.cursor) {
                return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor;
            }
        };

        $.Group.prototype.swap = function (deepDataAndEvents, opt_obj2) {
            this.swapChildren(deepDataAndEvents, opt_obj2);
            this.updateZ();
        };

        $.Group.prototype.bringToTop = function (program) {
            return program.parent === this && (this.getIndex(program) < this.children.length && (this.remove(program, false, true), this.add(program, true))), program;
        };

        $.Group.prototype.sendToBack = function (entity) {
            return entity.parent === this && (this.getIndex(entity) > 0 && (this.remove(entity, false, true), this.addAt(entity, 0, true))), entity;
        };

        $.Group.prototype.moveUp = function (owner) {
            if (owner.parent === this && this.getIndex(owner) < this.children.length - 1) {
                var unlock = this.getIndex(owner);
                var r20 = this.getAt(unlock + 1);
                if (r20) {
                    this.swap(owner, r20);
                }
            }
            return owner;
        };

        $.Group.prototype.moveDown = function (owner) {
            if (owner.parent === this && this.getIndex(owner) > 0) {
                var unlock = this.getIndex(owner);
                var r20 = this.getAt(unlock - 1);
                if (r20) {
                    this.swap(owner, r20);
                }
            }
            return owner;
        };

        $.Group.prototype.xy = function (cl, v, sum) {
            if (cl < 0 || cl > this.children.length) {
                return -1;
            }
            this.getChildAt(cl).x = v;
            this.getChildAt(cl).y = sum;
        };

        $.Group.prototype.reverse = function () {
            this.children.reverse();
            this.updateZ();
        };

        $.Group.prototype.getIndex = function (oldItem) {
            return this.children.indexOf(oldItem);
        };

        $.Group.prototype.getByName = function (val) {

            var i = 0;
            for (; i < this.children.length; i++) {
                if (this.children[i].name === val) {
                    return this.children[i];
                }
            }
            return null;
        };

        $.Group.prototype.replace = function (key, entity) {
            var camelKey = this.getIndex(key);
            if (-1 !== camelKey) {
                return entity.parent && (entity.parent instanceof $.Group ? entity.parent.remove(entity) : entity.parent.removeChild(entity)), this.remove(key), this.addAt(entity, camelKey), key;
            }
        };

        $.Group.prototype.hasProperty = function (data, s) {
            var k = s.length;
            return 1 === k && s[0] in data || (2 === k && (s[0] in data && s[1] in data[s[0]]) || (3 === k && (s[0] in data && (s[1] in data[s[0]] && s[2] in data[s[0]][s[1]])) || 4 === k && (s[0] in data && (s[1] in data[s[0]] && (s[2] in data[s[0]][s[1]] && s[3] in data[s[0]][s[1]][s[2]])))));
        };

        $.Group.prototype.setProperty = function (target, path, s, mtime, lastModified) {
            if (void 0 === lastModified && (lastModified = false), mtime = mtime || 0, !this.hasProperty(target, path) && (!lastModified || mtime > 0)) {
                return false;
            }
            var ii = path.length;
            return 1 === ii ? 0 === mtime ? target[path[0]] = s : 1 === mtime ? target[path[0]] += s : 2 === mtime ? target[path[0]] -= s : 3 === mtime ? target[path[0]] *= s : 4 === mtime && (target[path[0]] /= s) : 2 === ii ? 0 === mtime ? target[path[0]][path[1]] = s : 1 === mtime ? target[path[0]][path[1]] += s : 2 === mtime ? target[path[0]][path[1]] -= s : 3 === mtime ? target[path[0]][path[1]] *= s : 4 === mtime && (target[path[0]][path[1]] /= s) : 3 === ii ? 0 === mtime ? target[path[0]][path[1]][path[2]] =
                s : 1 === mtime ? target[path[0]][path[1]][path[2]] += s : 2 === mtime ? target[path[0]][path[1]][path[2]] -= s : 3 === mtime ? target[path[0]][path[1]][path[2]] *= s : 4 === mtime && (target[path[0]][path[1]][path[2]] /= s) : 4 === ii && (0 === mtime ? target[path[0]][path[1]][path[2]][path[3]] = s : 1 === mtime ? target[path[0]][path[1]][path[2]][path[3]] += s : 2 === mtime ? target[path[0]][path[1]][path[2]][path[3]] -= s : 3 === mtime ? target[path[0]][path[1]][path[2]][path[3]] *= s : 4 ===
                    mtime && (target[path[0]][path[1]][path[2]][path[3]] /= s)), true;
        };

        $.Group.prototype.checkProperty = function (obj, choices, dataAndEvents, value) {
            if (void 0 === value && (value = false), this !== obj.parent) {
                return false;
            }
            var string = $.Utils.getProperty(obj, choices);
            return !(void 0 === string && value || string !== dataAndEvents);
        };

        $.Group.prototype.set = function (opt_obj2, deepDataAndEvents, walkers, dataAndEvents, ignoreMethodDoesntExist, isXML, next_scope) {
            if (void 0 === next_scope && (next_scope = false), deepDataAndEvents = deepDataAndEvents.split("."), void 0 === dataAndEvents && (dataAndEvents = false), void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = false), (false === dataAndEvents || dataAndEvents && opt_obj2.alive) && (false === ignoreMethodDoesntExist || ignoreMethodDoesntExist && opt_obj2.visible)) {
                return this.setProperty(opt_obj2, deepDataAndEvents, walkers, isXML, next_scope);
            }
        };

        $.Group.prototype.setAll = function (deepDataAndEvents, opt_obj2, dataAndEvents, ignoreMethodDoesntExist, made, walkers) {
            if (void 0 === dataAndEvents) {

                dataAndEvents = false;
            }
            if (void 0 === ignoreMethodDoesntExist) {

                ignoreMethodDoesntExist = false;
            }
            if (void 0 === walkers) {

                walkers = false;
            }
            deepDataAndEvents = deepDataAndEvents.split(".");
            made = made || 0;

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                if (!dataAndEvents || dataAndEvents && this.children[unlock].alive) {
                    if (!ignoreMethodDoesntExist || ignoreMethodDoesntExist && this.children[unlock].visible) {
                        this.setProperty(this.children[unlock], deepDataAndEvents, opt_obj2, made, walkers);
                    }
                }
            }
        };

        $.Group.prototype.setAllChildren = function (deepDataAndEvents, walkers, opt_obj2, attributeValue, made, isXML) {
            if (void 0 === opt_obj2) {

                opt_obj2 = false;
            }
            if (void 0 === attributeValue) {

                attributeValue = false;
            }
            if (void 0 === isXML) {

                isXML = false;
            }
            made = made || 0;

            var i = 0;
            for (; i < this.children.length; i++) {
                if (!opt_obj2 || opt_obj2 && this.children[i].alive) {
                    if (!attributeValue || attributeValue && this.children[i].visible) {
                        if (this.children[i] instanceof $.Group) {
                            this.children[i].setAllChildren(deepDataAndEvents, walkers, opt_obj2, attributeValue, made, isXML);
                        } else {
                            this.setProperty(this.children[i], deepDataAndEvents.split("."), walkers, made, isXML);
                        }
                    }
                }
            }
        };

        $.Group.prototype.checkAll = function (opt_obj2, walkers, cid, val, deepDataAndEvents) {
            if (void 0 === cid) {

                cid = false;
            }
            if (void 0 === val) {

                val = false;
            }
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = false;
            }

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                var cache = this.children[unlock];
                if ((!cid || cid && cache.alive) && ((!val || val && cache.visible) && !this.checkProperty(cache, opt_obj2, walkers, deepDataAndEvents))) {
                    return false;
                }
            }
            return true;
        };

        $.Group.prototype.checkAny = function (deepDataAndEvents, opt_obj2, val, cid) {
            if (void 0 === val) {

                val = false;
            }
            if (void 0 === cid) {

                cid = false;
            }

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                var cache = this.children[unlock];
                if ((!val || val && cache.alive) && ((!cid || cid && cache.visible) && this.checkProperty(cache, deepDataAndEvents, opt_obj2))) {
                    return true;
                }
            }
            return false;
        };

        $.Group.prototype.addAll = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
            this.setAll(deepDataAndEvents, opt_obj2, walkers, isXML, 1);
        };

        $.Group.prototype.subAll = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
            this.setAll(deepDataAndEvents, opt_obj2, walkers, isXML, 2);
        };

        $.Group.prototype.multiplyAll = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
            this.setAll(deepDataAndEvents, opt_obj2, walkers, isXML, 3);
        };

        $.Group.prototype.divideAll = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
            this.setAll(deepDataAndEvents, opt_obj2, walkers, isXML, 4);
        };

        $.Group.prototype.kill = function () {

            this.alive = false;

            this.exists = false;

            this.visible = false;
        };

        $.Group.prototype.killAll = function () {
            this.callAllExists("kill", true);
        };

        $.Group.prototype.revive = function () {

            this.alive = true;

            this.exists = true;

            this.visible = true;
        };

        $.Group.prototype.reviveAll = function () {
            this.callAllExists('revive', false);
        };

        $.Group.prototype.resetAll = function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
            this.forEach(this.resetChild, this, next_scope, deepDataAndEvents, opt_obj2, walkers, isXML);
        };

        $.Group.prototype.callAllExists = function (methodname, dataAndEvents) {
            var _args;
            if (arguments.length > 2) {

                _args = [];

                i = 2;
                for (; i < arguments.length; i++) {
                    _args.push(arguments[i]);
                }
            }

            var i = 0;
            for (; i < this.children.length; i++) {
                if (this.children[i].exists === dataAndEvents) {
                    if (this.children[i][methodname]) {
                        this.children[i][methodname].apply(this.children[i], _args);
                    }
                }
            }
        };

        $.Group.prototype.callbackFromArray = function (result, item, dataAndEvents) {
            if (1 === dataAndEvents) {
                if (result[item[0]]) {
                    return result[item[0]];
                }
            } else {
                if (2 === dataAndEvents) {
                    if (result[item[0]][item[1]]) {
                        return result[item[0]][item[1]];
                    }
                } else {
                    if (3 === dataAndEvents) {
                        if (result[item[0]][item[1]][item[2]]) {
                            return result[item[0]][item[1]][item[2]];
                        }
                    } else {
                        if (4 === dataAndEvents) {
                            if (result[item[0]][item[1]][item[2]][item[3]]) {
                                return result[item[0]][item[1]][item[2]][item[3]];
                            }
                        } else {
                            if (result[item]) {
                                return result[item];
                            }
                        }
                    }
                }
            }
            return false;
        };

        $.Group.prototype.callAll = function (wink, value) {
            if (void 0 !== wink) {
                var r20 = (wink = wink.split(".")).length;
                if (void 0 === value || (null === value || "" === value)) {

                    value = null;
                } else {
                    if ("string" == typeof value) {
                        var len = (value = value.split(".")).length
                    }
                }
                var _args;
                if (arguments.length > 2) {

                    _args = [];

                    i = 2;
                    for (; i < arguments.length; i++) {
                        _args.push(arguments[i]);
                    }
                }

                var $ = null;

                var ret = null;

                var i = 0;
                for (; i < this.children.length; i++) {
                    $ = this.callbackFromArray(this.children[i], wink, r20);
                    if (value && $) {
                        ret = this.callbackFromArray(this.children[i], value, len);
                        if ($) {
                            $.apply(ret, _args);
                        }
                    } else {
                        if ($) {
                            $.apply(this.children[i], _args);
                        }
                    }
                }
            }
        };

        $.Group.prototype.preUpdate = function () {
            if (this.pendingDestroy) {
                return this.destroy(), false;
            }
            if (!this.exists || !this.parent.exists) {
                return this.renderOrderID = -1, false;
            }

            var unlock = 0;
            for (; unlock < this.children.length;) {
                var cache = this.children[unlock];
                cache.preUpdate();
                if (this === cache.parent) {
                    unlock++;
                }
            }
            return true;
        };

        $.Group.prototype.update = function () {
            var i = this.children.length;
            for (; i--;) {
                var strLen = this.children.length;
                if (i >= strLen) {

                    i = strLen - 1;
                }
                var seg = this.children[i];
                if (!(this.updateOnlyExistingChildren && !seg.exists)) {
                    seg.update();
                }
            }
        };

        $.Group.prototype.postUpdate = function () {
            if (this.fixedToCamera) {

                this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;

                this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
            }

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                this.children[unlock].postUpdate();
            }
        };

        $.Group.prototype.filter = function (callback, id) {

            var index = -1;
            var length = this.children.length;

            var listeners = [];
            for (; ++index < length;) {
                var data = this.children[index];
                if (!id || id && data.exists) {
                    if (callback(data, index, this.children)) {
                        listeners.push(data);
                    }
                }
            }
            return new($.ArraySet)(listeners);
        };

        $.Group.prototype.forEach = function (walker, p, val) {
            if (void 0 === val && (val = false), arguments.length <= 3) {

                i = 0;
                for (; i < this.children.length; i++) {
                    if (!val || val && this.children[i].exists) {
                        walker.call(p, this.children[i]);
                    }
                }
            } else {

                var e = [null];

                var i = 3;
                for (; i < arguments.length; i++) {
                    e.push(arguments[i]);
                }

                i = 0;
                for (; i < this.children.length; i++) {
                    if (!val || val && this.children[i].exists) {
                        e[0] = this.children[i];
                        walker.apply(p, e);
                    }
                }
            }
        };

        $.Group.prototype.forEachExists = function (deepDataAndEvents, opt_obj2) {
            var _args;
            if (arguments.length > 2) {

                _args = [null];

                var i = 2;
                for (; i < arguments.length; i++) {
                    _args.push(arguments[i]);
                }
            }
            this.iterate('exists', true, $.Group.RETURN_TOTAL, deepDataAndEvents, opt_obj2, _args);
        };

        $.Group.prototype.forEachAlive = function (deepDataAndEvents, opt_obj2) {
            var _args;
            if (arguments.length > 2) {

                _args = [null];

                var i = 2;
                for (; i < arguments.length; i++) {
                    _args.push(arguments[i]);
                }
            }
            this.iterate("alive", true, $.Group.RETURN_TOTAL, deepDataAndEvents, opt_obj2, _args);
        };

        $.Group.prototype.forEachDead = function (deepDataAndEvents, opt_obj2) {
            var _args;
            if (arguments.length > 2) {

                _args = [null];

                var i = 2;
                for (; i < arguments.length; i++) {
                    _args.push(arguments[i]);
                }
            }
            this.iterate('alive', false, $.Group.RETURN_TOTAL, deepDataAndEvents, opt_obj2, _args);
        };

        $.Group.prototype.sort = function (minz, dataAndEvents) {
            if (!(this.children.length < 2)) {
                if (void 0 === minz) {

                    minz = "z";
                }
                if (void 0 === dataAndEvents) {
                    dataAndEvents = $.Group.SORT_ASCENDING;
                }

                this._sortProperty = minz;
                if (dataAndEvents === $.Group.SORT_ASCENDING) {
                    this.children.sort(this.ascendingSortHandler.bind(this));
                } else {
                    this.children.sort(this.descendingSortHandler.bind(this));
                }
                this.updateZ();
            }
        };

        $.Group.prototype.customSort = function (collection, resp) {
            if (!(this.children.length < 2)) {
                this.children.sort(collection.bind(resp));
                this.updateZ();
            }
        };

        $.Group.prototype.ascendingSortHandler = function (a, b) {
            return a[this._sortProperty] < b[this._sortProperty] ? -1 : a[this._sortProperty] > b[this._sortProperty] ? 1 : a.z < b.z ? -1 : 1;
        };

        $.Group.prototype.descendingSortHandler = function (a, b) {
            return a[this._sortProperty] < b[this._sortProperty] ? 1 : a[this._sortProperty] > b[this._sortProperty] ? -1 : 0;
        };

        $.Group.prototype.iterate = function (j, elem, b, element, type, fn) {
            if (0 === this.children.length) {
                if (b === $.Group.RETURN_TOTAL) {
                    return 0;
                }
                if (b === $.Group.RETURN_ALL) {
                    return [];
                }
            }

            var PACKBUF = 0;
            if (b === $.Group.RETURN_ALL) {

                var e = []
            }

            var i = 0;
            for (; i < this.children.length; i++) {
                if (this.children[i][j] === elem) {
                    if (PACKBUF++, element && (fn ? (fn[0] = this.children[i], element.apply(type, fn)) : element.call(type, this.children[i])), b === $.Group.RETURN_CHILD) {
                        return this.children[i];
                    }
                    if (b === $.Group.RETURN_ALL) {
                        e.push(this.children[i]);
                    }
                }
            }
            return b === $.Group.RETURN_TOTAL ? PACKBUF : b === $.Group.RETURN_ALL ? e : null;
        };

        $.Group.prototype.getFirst = function (deepDataAndEvents, opt_obj2) {
            return this.iterate(deepDataAndEvents, opt_obj2, $.Group.RETURN_CHILD);
        };

        $.Group.prototype.getFirstExists = function (config, dataAndEvents, deepDataAndEvents, opt_obj2, walkers, isXML) {
            if (void 0 === dataAndEvents) {

                dataAndEvents = false;
            }
            if ('boolean' != typeof config) {

                config = true;
            }
            var oldconfig = this.getFirst("exists", config);
            return null === oldconfig && dataAndEvents ? this.create(deepDataAndEvents, opt_obj2, walkers, isXML) : this.resetChild(oldconfig, deepDataAndEvents, opt_obj2, walkers, isXML);
        };

        $.Group.prototype.getFirstAlive = function (dataAndEvents, deepDataAndEvents, opt_obj2, walkers, isXML) {
            if (void 0 === dataAndEvents) {

                dataAndEvents = false;
            }
            var r20 = this.getFirst('alive', true);
            return null === r20 && dataAndEvents ? this.create(deepDataAndEvents, opt_obj2, walkers, isXML) : this.resetChild(r20, deepDataAndEvents, opt_obj2, walkers, isXML);
        };

        $.Group.prototype.getFirstDead = function (dataAndEvents, deepDataAndEvents, opt_obj2, walkers, isXML) {
            if (void 0 === dataAndEvents) {

                dataAndEvents = false;
            }
            var r20 = this.getFirst('alive', false);
            return null === r20 && dataAndEvents ? this.create(deepDataAndEvents, opt_obj2, walkers, isXML) : this.resetChild(r20, deepDataAndEvents, opt_obj2, walkers, isXML);
        };

        $.Group.prototype.resetChild = function (_, filters, descendant, obj, obj2) {
            return null === _ ? null : (void 0 === filters && (filters = null), void 0 === descendant && (descendant = null), null !== filters && (null !== descendant && _.reset(filters, descendant)), void 0 !== obj && _.loadTexture(obj, obj2), _);
        };

        $.Group.prototype.getTop = function () {
            if (this.children.length > 0) {
                return this.children[this.children.length - 1];
            }
        };

        $.Group.prototype.getBottom = function () {
            if (this.children.length > 0) {
                return this.children[0];
            }
        };

        $.Group.prototype.getClosestTo = function (n, execClass, success) {
            var fn = Number.MAX_VALUE;

            var params = 0;

            var type = null;

            var i = 0;
            for (; i < this.children.length; i++) {
                var fx = this.children[i];
                if (fx.exists) {
                    if ((params = Math.abs($.Point.distance(n, fx))) < fn) {
                        if (!execClass || execClass.call(success, fx, params)) {
                            fn = params;
                            type = fx;
                        }
                    }
                }
            }
            return type;
        };

        $.Group.prototype.getFurthestFrom = function (n, collection, resp) {

            var max_len = 0;

            var len = 0;

            var error = null;

            var unlock = 0;
            for (; unlock < this.children.length; unlock++) {
                var a2 = this.children[unlock];
                if (a2.exists) {
                    if ((len = Math.abs($.Point.distance(n, a2))) > max_len) {
                        if (!collection || collection.call(resp, a2, len)) {
                            max_len = len;
                            error = a2;
                        }
                    }
                }
            }
            return error;
        };

        $.Group.prototype.count = function (deepDataAndEvents, opt_obj2) {
            return this.iterate(deepDataAndEvents, opt_obj2, $.Group.RETURN_TOTAL);
        };

        $.Group.prototype.countLiving = function () {
            return this.count('alive', true);
        };

        $.Group.prototype.countDead = function () {
            return this.count("alive", false);
        };

        $.Group.prototype.getRandom = function (deepDataAndEvents, opt_obj2) {
            return void 0 === deepDataAndEvents && (deepDataAndEvents = 0), void 0 === opt_obj2 && (opt_obj2 = this.children.length), 0 === opt_obj2 ? null : $.ArrayUtils.getRandomItem(this.children, deepDataAndEvents, opt_obj2);
        };

        $.Group.prototype.getRandomExists = function (until, deepDataAndEvents) {
            var matched = this.getAll('exists', true, until, deepDataAndEvents);
            return this.game.rnd.pick(matched);
        };

        $.Group.prototype.getAll = function (k, searchElement, fromIndex, kbytes) {
            if (void 0 === fromIndex) {

                fromIndex = 0;
            }
            if (void 0 === kbytes) {
                kbytes = this.children.length;
            }

            var interpolators = [];

            var i = fromIndex;
            for (; i < kbytes; i++) {
                var t = this.children[i];
                if (k) {
                    if (t[k] === searchElement) {
                        interpolators.push(t);
                    }
                } else {
                    interpolators.push(t);
                }
            }
            return interpolators;
        };

        $.Group.prototype.remove = function (defaults, deep, dataAndEvents) {
            if (void 0 === deep && (deep = false), void 0 === dataAndEvents && (dataAndEvents = false), 0 === this.children.length || -1 === this.children.indexOf(defaults)) {
                return false;
            }
            if (!dataAndEvents) {
                if (!!defaults.events) {
                    if (!defaults.destroyPhase) {
                        defaults.events.onRemovedFromGroup$dispatch(defaults, this);
                    }
                }
            }
            var copy = this.removeChild(defaults);
            return this.removeFromHash(defaults), this.updateZ(), this.cursor === defaults && this.next(), deep && (copy && copy.destroy(true)), true;
        };

        $.Group.prototype.moveAll = function (dataAndEvents, deepDataAndEvents) {
            if (void 0 === deepDataAndEvents && (deepDataAndEvents = false), this.children.length > 0 && dataAndEvents instanceof $.Group) {
                do {
                    dataAndEvents.add(this.children[0], deepDataAndEvents);
                } while (this.children.length > 0);

                this.hash = [];

                this.cursor = null;
            }
            return dataAndEvents;
        };

        $.Group.prototype.removeAll = function (dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents) {
            if (void 0 === dataAndEvents && (dataAndEvents = false), void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = false), void 0 === deepDataAndEvents && (deepDataAndEvents = false), 0 !== this.children.length) {
                do {
                    if (!ignoreMethodDoesntExist) {
                        if (this.children[0].events) {
                            this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        }
                    }
                    var r20 = this.removeChild(this.children[0]);
                    this.removeFromHash(r20);
                    if (dataAndEvents) {
                        if (r20) {
                            r20.destroy(true, deepDataAndEvents);
                        }
                    }
                } while (this.children.length > 0);

                this.hash = [];

                this.cursor = null;
            }
        };

        $.Group.prototype.removeBetween = function (end, start, dataAndEvents, deepDataAndEvents) {
            if (void 0 === start && (start = this.children.length - 1), void 0 === dataAndEvents && (dataAndEvents = false), void 0 === deepDataAndEvents && (deepDataAndEvents = false), 0 !== this.children.length) {
                if (end > start || (end < 0 || start > this.children.length)) {
                    return false;
                }

                var i = start;
                for (; i >= end;) {
                    if (!deepDataAndEvents) {
                        if (this.children[i].events) {
                            this.children[i].events.onRemovedFromGroup$dispatch(this.children[i], this);
                        }
                    }
                    var r20 = this.removeChild(this.children[i]);
                    this.removeFromHash(r20);
                    if (dataAndEvents) {
                        if (r20) {
                            r20.destroy(true);
                        }
                    }
                    if (this.cursor === this.children[i]) {

                        this.cursor = null;
                    }
                    i--;
                }
                this.updateZ();
            }
        };

        $.Group.prototype.scatter = function (dataAndEvents, deepDataAndEvents) {
            if (null == dataAndEvents) {
                dataAndEvents = this.game.world.bounds;
            }
            this.forEach(function (deepDataAndEvents) {
                deepDataAndEvents.position.set(dataAndEvents.randomX, dataAndEvents.randomY);
            }, null, deepDataAndEvents);
        };

        $.Group.prototype.shuffle = function () {
            $.ArrayUtils.shuffle(this.children);
            this.updateZ();
        };

        $.Group.prototype.destroy = function (deepDataAndEvents, opt_obj2) {
            if (!(null === this.game)) {
                if (!this.ignoreDestroy) {
                    if (void 0 === deepDataAndEvents) {

                        deepDataAndEvents = true;
                    }
                    if (void 0 === opt_obj2) {

                        opt_obj2 = false;
                    }
                    this.onDestroy.dispatch(this, deepDataAndEvents, opt_obj2);
                    this.removeAll(deepDataAndEvents);

                    this.cursor = null;

                    this.filters = null;

                    this.pendingDestroy = false;
                    if (!opt_obj2) {
                        if (this.parent) {
                            this.parent.removeChild(this);
                        }

                        this.game = null;

                        this.exists = false;
                    }
                }
            }
        };
        Object.defineProperty($.Group.prototype, "total", {

            "get": function () {
                return this.iterate("exists", true, $.Group.RETURN_TOTAL);
            }
        });
        Object.defineProperty($.Group.prototype, 'length', {

            "get": function () {
                return this.children.length;
            }
        });
        Object.defineProperty($.Group.prototype, 'angle', {

            "get": function () {
                return $.Math.radToDeg(this.rotation);
            },

            "set": function (opt_path) {
                this.rotation = $.Math.degToRad(opt_path);
            }
        });
        Object.defineProperty($.Group.prototype, "centerX", {

            "get": function () {
                return this.getBounds(this.parent).centerX;
            },

            "set": function (base) {
                var a = this.getBounds(this.parent);

                var post = this.x - a.x;

                this.x = base + post - a.halfWidth;
            }
        });
        Object.defineProperty($.Group.prototype, 'centerY', {

            "get": function () {
                return this.getBounds(this.parent).centerY;
            },

            "set": function (base) {
                var wordsCount = this.getBounds(this.parent);

                var post = this.y - wordsCount.y;

                this.y = base + post - wordsCount.halfHeight;
            }
        });
        Object.defineProperty($.Group.prototype, 'left', {

            "get": function () {
                return this.getBounds(this.parent).left;
            },

            "set": function (_) {
                var a = this.getBounds(this.parent);

                var name = this.x - a.x;
                this.x = _ + name;
            }
        });
        Object.defineProperty($.Group.prototype, 'right', {

            "get": function () {
                return this.getBounds(this.parent).right;
            },

            "set": function (base) {
                var a = this.getBounds(this.parent);

                var post = this.x - a.x;

                this.x = base + post - a.width;
            }
        });
        Object.defineProperty($.Group.prototype, 'top', {

            "get": function () {
                return this.getBounds(this.parent).top;
            },

            "set": function (row) {
                var wordsCount = this.getBounds(this.parent);

                var index = this.y - wordsCount.y;
                this.y = row + index;
            }
        });
        Object.defineProperty($.Group.prototype, 'bottom', {

            "get": function () {
                return this.getBounds(this.parent).bottom;
            },

            "set": function (base) {
                var wordsCount = this.getBounds(this.parent);

                var post = this.y - wordsCount.y;

                this.y = base + post - wordsCount.height;
            }
        });

        $.World = function (deepDataAndEvents) {
            $.Group.call(this, deepDataAndEvents, null, '__world', false);
            this.bounds = new($.Rectangle)(0, 0, deepDataAndEvents.width, deepDataAndEvents.height);

            this.camera = null;

            this._definedSize = false;
            this._width = deepDataAndEvents.width;
            this._height = deepDataAndEvents.height;
            this.game.state.onStateChange.add(this.stateChange, this);
        };
        $.World.prototype = Object.create($.Group.prototype);
        $.World.prototype.constructor = $.World;

        $.World.prototype.boot = function () {
            this.camera = new($.Camera)(this.game, 0, 0, 0, this.game.width, this.game.height);
            this.game.stage.addChild(this);
            this.camera.boot();
        };

        $.World.prototype.stateChange = function () {

            this.x = 0;

            this.y = 0;
            this.camera.reset();
        };

        $.World.prototype.setBounds = function (rx, letter, currentValue, rad) {

            this._definedSize = true;
            this._width = currentValue;
            this._height = rad;
            this.bounds.setTo(rx, letter, currentValue, rad);
            this.x = rx;
            this.y = letter;
            if (this.camera.bounds) {
                this.camera.bounds.setTo(rx, letter, Math.max(currentValue, this.game.width), Math.max(rad, this.game.height));
            }
            this.game.physics.setBoundsToWorld();
        };

        $.World.prototype.resize = function (dataAndEvents, deepDataAndEvents) {
            if (this._definedSize) {
                if (dataAndEvents < this._width) {
                    dataAndEvents = this._width;
                }
                if (deepDataAndEvents < this._height) {
                    deepDataAndEvents = this._height;
                }
            }

            this.bounds.width = dataAndEvents;

            this.bounds.height = deepDataAndEvents;
            this.game.camera.setBoundsToWorld();
            this.game.physics.setBoundsToWorld();
        };

        $.World.prototype.shutdown = function () {
            this.destroy(true, true);
        };

        $.World.prototype.wrap = function (coords, y, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
            if (void 0 === y) {

                y = 0;
            }
            if (void 0 === dataAndEvents) {

                dataAndEvents = false;
            }
            if (void 0 === deepDataAndEvents) {

                deepDataAndEvents = true;
            }
            if (void 0 === ignoreMethodDoesntExist) {

                ignoreMethodDoesntExist = true;
            }
            if (dataAndEvents) {
                coords.getBounds();
                if (deepDataAndEvents) {
                    if (coords.x + coords._currentBounds.width < this.bounds.x) {
                        coords.x = this.bounds.right;
                    } else {
                        if (coords.x > this.bounds.right) {
                            coords.x = this.bounds.left;
                        }
                    }
                }
                if (ignoreMethodDoesntExist) {
                    if (coords.y + coords._currentBounds.height < this.bounds.top) {
                        coords.y = this.bounds.bottom;
                    } else {
                        if (coords.y > this.bounds.bottom) {
                            coords.y = this.bounds.top;
                        }
                    }
                }
            } else {
                if (deepDataAndEvents && coords.x + y < this.bounds.x) {
                    coords.x = this.bounds.right + y;
                } else {
                    if (deepDataAndEvents) {
                        if (coords.x - y > this.bounds.right) {

                            coords.x = this.bounds.left - y;
                        }
                    }
                }
                if (ignoreMethodDoesntExist && coords.y + y < this.bounds.top) {
                    coords.y = this.bounds.bottom + y;
                } else {
                    if (ignoreMethodDoesntExist) {
                        if (coords.y - y > this.bounds.bottom) {

                            coords.y = this.bounds.top - y;
                        }
                    }
                }
            }
        };

        $.World.prototype.wrapAll = function (dataAndEvents, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
            dataAndEvents.forEach(this.wrap, this, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope);
        };
        Object.defineProperty($.World.prototype, "width", {

            "get": function () {
                return this.bounds.width;
            },

            "set": function (mL) {
                if (mL < this.game.width) {
                    mL = this.game.width;
                }

                this.bounds.width = mL;

                this._width = mL;

                this._definedSize = true;
            }
        });
        Object.defineProperty($.World.prototype, 'height', {

            "get": function () {
                return this.bounds.height;
            },

            "set": function (mL) {
                if (mL < this.game.height) {
                    mL = this.game.height;
                }

                this.bounds.height = mL;

                this._height = mL;

                this._definedSize = true;
            }
        });
        Object.defineProperty($.World.prototype, "centerX", {

            "get": function () {
                return this.bounds.halfWidth + this.bounds.x;
            }
        });
        Object.defineProperty($.World.prototype, 'centerY', {

            "get": function () {
                return this.bounds.halfHeight + this.bounds.y;
            }
        });
        Object.defineProperty($.World.prototype, 'randomX', {

            "get": function () {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width);
            }
        });
        Object.defineProperty($.World.prototype, 'randomY', {

            "get": function () {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height);
            }
        });

        $.Game = function (dataAndEvents, deepDataAndEvents, textAlt, keepData, ignoreMethodDoesntExist, opt_attributes, matcherFunction, execResult) {
            return this.id = $.GAMES.push(this) - 1, this.config = null, this.physicsConfig = execResult, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = false, this.antialias = true, this.multiTexture = false, this.preserveDrawingBuffer = false, this.clearBeforeRender = true, this.renderer = null, this.renderType = $.AUTO,
                this.state = null, this.isBooted = false, this.isRunning = false, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics =
                null, this.plugins = null, this.rnd = null, this.device = $.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = false, this.pendingDestroy = false, this.stepping = false, this.pendingStep = false, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur =
                null, this.onFocus = null, this._paused = false, this._codePaused = false, this.currentUpdateID = 0, this.updatesThisFrame = 1, this.rendersThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = true, this.fpsProblemNotifier = new($.Signal), this.forceSingleUpdate = true, this.forceSingleRender = true, this.dropFrames = false, this._nextFpsNotification = 0, 1 === arguments.length &&
                'object' == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                        "enableDebug": true
                    }, void 0 !== dataAndEvents && (this._width = dataAndEvents), void 0 !== deepDataAndEvents && (this._height = deepDataAndEvents), void 0 !== textAlt && (this.renderType = textAlt), void 0 !== keepData && (this.parent = keepData), void 0 !== opt_attributes && (this.transparent = opt_attributes), void 0 !== matcherFunction && (this.antialias = matcherFunction), this.rnd = new($.RandomDataGenerator)([(Date.now() * Math.random()).toString()]),
                    this.state = new($.StateManager)(this, ignoreMethodDoesntExist)), this.device.whenReady(this.boot, this), this;
        };
        $.Game.prototype = {

            "parseConfig": function (element) {

                this.config = element;
                if (void 0 === element.enableDebug) {

                    this.config.enableDebug = true;
                }
                if (element.width) {
                    this._width = element.width;
                }
                if (element.height) {
                    this._height = element.height;
                }
                if (element.renderer) {
                    this.renderType = element.renderer;
                }
                if (element.parent) {
                    this.parent = element.parent;
                }
                if (void 0 !== element.transparent) {
                    this.transparent = element.transparent;
                }
                if (void 0 !== element.antialias) {
                    this.antialias = element.antialias;
                }
                if (void 0 !== element.multiTexture) {
                    this.multiTexture = element.multiTexture;
                }
                if (element.resolution) {
                    this.resolution = element.resolution;
                }
                if (void 0 !== element.preserveDrawingBuffer) {
                    this.preserveDrawingBuffer = element.preserveDrawingBuffer;
                }
                if (element.physicsConfig) {
                    this.physicsConfig = element.physicsConfig;
                }

                var thisel = [(Date.now() * Math.random()).toString()];
                if (element.seed) {
                    thisel = element.seed;
                }
                this.rnd = new($.RandomDataGenerator)(thisel);

                var callbacks = null;
                if (element.state) {
                    callbacks = element.state;
                }
                this.state = new($.StateManager)(this, callbacks);
            },

            "boot": function () {
                if (!this.isBooted) {
                    this.onPause = new($.Signal);
                    this.onResume = new($.Signal);
                    this.onBlur = new $.Signal;
                    this.onFocus = new $.Signal;

                    this.isBooted = true;
                    PIXI.game = this;
                    this.math = $.Math;
                    this.scale = new $.ScaleManager(this, this._width, this._height);
                    this.stage = new($.Stage)(this);
                    this.setUpRenderer();
                    this.world = new($.World)(this);
                    this.add = new($.GameObjectFactory)(this);
                    this.make = new($.GameObjectCreator)(this);
                    this.cache = new $.Cache(this);
                    this.load = new($.Loader)(this);
                    this.time = new($.Time)(this);
                    this.tweens = new($.TweenManager)(this);
                    this.input = new $.Input(this);
                    this.sound = new($.SoundManager)(this);
                    this.physics = new($.Physics)(this, this.physicsConfig);
                    this.particles = new $.Particles(this);
                    this.create = new $.Create(this);
                    this.plugins = new($.PluginManager)(this);
                    this.net = new($.Net)(this);
                    this.time.boot();
                    this.stage.boot();
                    this.world.boot();
                    this.scale.boot();
                    this.input.boot();
                    this.sound.boot();
                    this.state.boot();
                    if (this.config.enableDebug) {
                        this.debug = new($.Utils.Debug)(this);
                        this.debug.boot();
                    } else {
                        this.debug = {

                            "preUpdate": function () {},

                            "update": function () {},

                            "reset": function () {},
                            "isDisabled": true
                        };
                    }
                    this.showDebugHeader();

                    this.isRunning = true;
                    if (this.config && this.config.forceSetTimeOut) {
                        this.raf = new($.RequestAnimationFrame)(this, this.config.forceSetTimeOut);
                    } else {
                        this.raf = new($.RequestAnimationFrame)(this, false);
                    }

                    this._kickstart = true;
                    if (window.focus) {
                        if (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) {
                            window.focus();
                        }
                    }
                    if (!this.config.disableStart) {
                        if (this.cache.isReady) {
                            this.raf.start();
                        } else {
                            this.cache.onReady.addOnce(function () {
                                this.raf.start();
                            }, this);
                        }
                    }
                }
            },

            "showDebugHeader": function () {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var _0x48c237 = $.VERSION;
                    var el = 'Canvas';
                    var mtd = 'HTML Audio';

                    var i = 1;
                    if (this.renderType === $.WEBGL ? (el = 'WebGL', i++) : this.renderType === $.HEADLESS && (el = 'Headless'), this.device.webAudio && (mtd = 'WebAudio', i++), this.device.ie) {
                        if (window.console) {
                            console.log("Phaser v" + _0x48c237 + " | Pixi.js | " + el + ' | ' + mtd + ' | http://phaser.io');
                        }
                    } else {

                        var missing = ['%c %c %c Phaser CE v' + _0x48c237 + ' | Pixi.js | ' + el + ' | ' + mtd + "  %c %c %c http://phaser.io %câ™¥%câ™¥%câ™¥", "background: #fb8cb3", 'background: #d44a52', 'color: #ffffff; background: #871905;', 'background: #d44a52', "background: #fb8cb3", 'background: #ffffff'];

                        var lasti = 0;
                        for (; lasti < 3; lasti++) {
                            if (lasti < i) {
                                missing.push('color: #ff2424; background: #fff');
                            } else {
                                missing.push("color: #959595; background: #fff");
                            }
                        }
                        console.log.apply(console, missing);
                    }
                }
            },

            "setUpRenderer": function () {
                if (!this.device.canvas) {
                    throw new Error('Phaser.Game - Cannot create Canvas 2d context, aborting.');
                }
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = $.Canvas.create(this, this.width, this.height, this.config.canvasID, true), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style['-webkit-full-screen'] = 'width: 100%; height: 100%', this.config.crisp &&
                    $.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === $.WEBGL || (this.renderType === $.WEBGL_MULTI || this.renderType === $.AUTO && this.device.webGL)) {
                    if (this.multiTexture || this.renderType === $.WEBGL_MULTI) {
                        PIXI.enableMultiTexture();

                        this.multiTexture = true;
                    }
                    try {
                        this.renderer = new(PIXI.WebGLRenderer)(this, this.config);
                        this.renderType = $.WEBGL;

                        this.context = null;
                        this.canvas.addEventListener('webglcontextlost', this.contextLost.bind(this), false);
                        this.canvas.addEventListener('webglcontextrestored', this.contextRestored.bind(this), false);
                    } catch (_0x57c527) {
                        if (this.renderer = null, this.multiTexture = false, PIXI._enableMultiTextureToggle = false, this.renderType === $.WEBGL) {
                            throw _0x57c527;
                        }
                    }
                }
                if (!this.renderer) {
                    this.renderer = new(PIXI.CanvasRenderer)(this, this.config);
                    this.context = this.renderer.context;
                    if (this.renderType === $.AUTO) {
                        this.renderType = $.CANVAS;
                    }
                }
                if (this.device.cocoonJS) {

                    this.canvas.screencanvas = this.renderType === $.CANVAS;
                }
                if (this.renderType !== $.HEADLESS) {
                    this.stage.smoothed = this.antialias;
                    $.Canvas.addToDOM(this.canvas, this.parent, false);
                    $.Canvas.setTouchAction(this.canvas);
                }
            },

            "contextLost": function (event) {
                event.preventDefault();

                this.renderer.contextLost = true;
            },

            "contextRestored": function () {
                this.renderer.initContext();
                this.cache.clearGLTextures();

                this.renderer.contextLost = false;
            },

            "update": function (bytes) {
                if (this.pendingDestroy) {
                    this.destroy();
                } else {
                    if (this.time.update(bytes), this._kickstart) {
                        return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = false);
                    }
                    if (this._spiraling > 1 && !this.forceSingleUpdate) {
                        if (this.time.time > this._nextFpsNotification) {
                            this._nextFpsNotification = this.time.time + 1E4;
                            this.fpsProblemNotifier.dispatch();
                        }

                        this._deltaTime = 0;

                        this._spiraling = 0;
                        if (this.dropFrames) {

                            this.rendersThisFrame = 0;
                        } else {
                            this.updateRender(this.time.slowMotion * this.time.desiredFps);

                            this.rendersThisFrame = 1;
                        }
                    } else {

                        var lowestDeltaXY = 1E3 * this.time.slowMotion / this.time.desiredFps;
                        this._deltaTime += Math.max(Math.min(3 * lowestDeltaXY, this.time.elapsed), 0);

                        var _0x3d4280 = 0;
                        this.updatesThisFrame = Math.floor(this._deltaTime / lowestDeltaXY);
                        if (this.forceSingleUpdate) {
                            this.updatesThisFrame = Math.min(1, this.updatesThisFrame);
                        }
                        if (this.forceSingleRender) {

                            this.rendersThisFrame = 1;
                        } else {
                            this.rendersThisFrame = Math.min(1, this.updatesThisFrame);
                        }
                        for (; this._deltaTime >= lowestDeltaXY && (this._deltaTime -= lowestDeltaXY, this.currentUpdateID = _0x3d4280, this.updateLogic(this.time.desiredFpsMult), _0x3d4280++, !this.forceSingleUpdate || 1 !== _0x3d4280);) {
                            this.time.refresh();
                        }
                        if (_0x3d4280 > this._lastCount) {
                            this._spiraling++;
                        } else {
                            if (_0x3d4280 < this._lastCount) {

                                this._spiraling = 0;
                            }
                        }

                        this._lastCount = _0x3d4280;
                        if (this.rendersThisFrame > 0) {
                            this.updateRender(this._deltaTime / lowestDeltaXY);
                        }
                    }
                }
            },

            "updateLogic": function (deepDataAndEvents) {
                if (this._paused || this.pendingStep) {
                    this.scale.pauseUpdate();
                    this.state.pauseUpdate(deepDataAndEvents);
                    this.debug.preUpdate();
                    this.input.pauseUpdate();
                } else {
                    if (this.stepping) {

                        this.pendingStep = true;
                    }
                    this.time.countUpdate();
                    this.scale.preUpdate();
                    this.debug.preUpdate();
                    this.camera.preUpdate();
                    this.physics.preUpdate();
                    this.state.preUpdate(deepDataAndEvents);
                    this.plugins.preUpdate(deepDataAndEvents);
                    this.stage.preUpdate();
                    this.state.update();
                    this.stage.update();
                    this.tweens.update();
                    this.sound.update();
                    this.input.update();
                    this.physics.update();
                    this.plugins.update();
                    this.stage.postUpdate();
                    this.plugins.postUpdate();
                }
                this.stage.updateTransform();
            },

            "updateRender": function (renderCount) {
                if (!this.lockRender) {
                    this.time.countRender();
                    this.state.preRender(renderCount);
                    if (this.renderType !== $.HEADLESS) {
                        this.renderer.render(this.stage);
                        this.plugins.render(renderCount);
                        this.state.render(renderCount);
                    }
                    this.plugins.postRender(renderCount);
                }
            },

            "enableStep": function () {

                this.stepping = true;

                this.pendingStep = false;

                this.stepCount = 0;
            },

            "disableStep": function () {

                this.stepping = false;

                this.pendingStep = false;
            },

            "step": function () {

                this.pendingStep = false;
                this.stepCount++;
            },

            "destroy": function () {
                this.raf.stop();
                if (this.debug.destroy) {
                    this.debug.destroy();
                }
                this.state.destroy();
                this.sound.destroy();
                this.scale.destroy();
                this.stage.destroy();
                this.input.destroy();
                this.physics.destroy();
                this.plugins.destroy();

                this.debug = null;

                this.state = null;

                this.sound = null;

                this.scale = null;

                this.stage = null;

                this.input = null;

                this.physics = null;

                this.plugins = null;

                this.cache = null;

                this.load = null;

                this.time = null;

                this.world = null;

                this.isBooted = false;
                this.renderer.destroy(false);
                $.Canvas.removeFromDOM(this.canvas);

                PIXI.defaultRenderer = null;

                $.GAMES[this.id] = null;
            },

            "gamePaused": function (deepDataAndEvents) {
                if (!this._paused) {

                    this._paused = true;
                    this.time.gamePaused();
                    if (this.sound.muteOnPause) {
                        this.sound.setMute();
                    }
                    this.onPause.dispatch(deepDataAndEvents);
                    if (this.device.cordova) {
                        if (this.device.iOS) {

                            this.lockRender = true;
                        }
                    }
                }
            },

            "gameResumed": function (deepDataAndEvents) {
                if (this._paused) {
                    if (!this._codePaused) {

                        this._paused = false;
                        this.time.gameResumed();
                        this.input.reset();
                        if (this.sound.muteOnPause) {
                            this.sound.unsetMute();
                        }
                        this.onResume.dispatch(deepDataAndEvents);
                        if (this.device.cordova) {
                            if (this.device.iOS) {

                                this.lockRender = false;
                            }
                        }
                    }
                }
            },

            "focusLoss": function (deepDataAndEvents) {
                this.onBlur.dispatch(deepDataAndEvents);
                if (!this.stage.disableVisibilityChange) {
                    this.gamePaused(deepDataAndEvents);
                }
            },

            "focusGain": function (deepDataAndEvents) {
                this.onFocus.dispatch(deepDataAndEvents);
                if (!this.stage.disableVisibilityChange) {
                    this.gameResumed(deepDataAndEvents);
                }
            }
        };
        $.Game.prototype.constructor = $.Game;
        Object.defineProperty($.Game.prototype, 'paused', {

            "get": function () {
                return this._paused;
            },

            "set": function (mL) {
                if (true === mL) {
                    if (false === this._paused) {

                        this._paused = true;
                        this.sound.setMute();
                        this.time.gamePaused();
                        this.onPause.dispatch(this);
                    }

                    this._codePaused = true;
                } else {
                    if (this._paused) {

                        this._paused = false;
                        this.input.reset();
                        this.sound.unsetMute();
                        this.time.gameResumed();
                        this.onResume.dispatch(this);
                    }

                    this._codePaused = false;
                }
            }
        });

        $.Input = function (dataAndEvents) {
            this.game = dataAndEvents;

            this.hitCanvas = null;

            this.hitContext = null;

            this.moveCallbacks = [];

            this.customCandidateHandler = null;

            this.customCandidateHandlerContext = null;

            this.pollRate = 0;

            this.enabled = true;
            this.multiInputOverride = $.Input.MOUSE_TOUCH_COMBINE;

            this.position = null;

            this.speed = null;

            this.circle = null;

            this.scale = null;

            this.maxPointers = -1;

            this.tapRate = 200;

            this.doubleTapRate = 300;

            this.holdRate = 2E3;

            this.justPressedRate = 200;

            this.justReleasedRate = 200;

            this.recordPointerHistory = false;

            this.recordRate = 100;

            this.recordLimit = 100;

            this.touchLockCallbacks = [];

            this.pointer1 = null;

            this.pointer2 = null;

            this.pointer3 = null;

            this.pointer4 = null;

            this.pointer5 = null;

            this.pointer6 = null;

            this.pointer7 = null;

            this.pointer8 = null;

            this.pointer9 = null;

            this.pointer10 = null;

            this.pointers = [];

            this.activePointer = null;

            this.mousePointer = null;

            this.mouse = null;

            this.keyboard = null;

            this.touch = null;

            this.mspointer = null;

            this.gamepad = null;

            this.resetLocked = false;

            this.onDown = null;

            this.onUp = null;

            this.onTap = null;

            this.onHold = null;

            this.minPriorityID = 0;
            this.interactiveItems = new $.ArraySet;
            this._localPoint = new($.Point);

            this._pollCounter = 0;

            this._oldPosition = null;

            this._x = 0;

            this._y = 0;
        };

        $.Input.MOUSE_OVERRIDES_TOUCH = 0;

        $.Input.TOUCH_OVERRIDES_MOUSE = 1;

        $.Input.MOUSE_TOUCH_COMBINE = 2;

        $.Input.MAX_POINTERS = 10;
        $.Input.prototype = {

            "boot": function () {
                this.mousePointer = new $.Pointer(this.game, 0, $.PointerMode.CURSOR);
                this.addPointer();
                this.addPointer();
                this.mouse = new $.Mouse(this.game);
                this.touch = new($.Touch)(this.game);
                this.mspointer = new $.MSPointer(this.game);
                if ($.Keyboard) {
                    this.keyboard = new $.Keyboard(this.game);
                }
                if ($.Gamepad) {
                    this.gamepad = new($.Gamepad)(this.game);
                }
                this.onDown = new($.Signal);
                this.onUp = new $.Signal;
                this.onTap = new $.Signal;
                this.onHold = new($.Signal);
                this.scale = new($.Point)(1, 1);
                this.speed = new($.Point);
                this.position = new($.Point);
                this._oldPosition = new $.Point;
                this.circle = new($.Circle)(0, 0, 44);
                this.activePointer = this.mousePointer;
                this.hitCanvas = $.CanvasPool.create(this, 1, 1);
                this.hitContext = this.hitCanvas.getContext("2d");
                this.mouse.start();
                if (!this.game.device.mspointer) {
                    this.touch.start();
                }
                this.mspointer.start();

                this.mousePointer.active = true;
                if (this.keyboard) {
                    this.keyboard.start();
                }
                var collection = this;

                this._onClickTrampoline = function (resp) {
                    collection.onClickTrampoline(resp);
                };
                this.game.canvas.addEventListener("click", this._onClickTrampoline, false);
            },

            "destroy": function () {
                this.mouse.stop();
                this.touch.stop();
                this.mspointer.stop();
                if (this.keyboard) {
                    this.keyboard.stop();
                }
                if (this.gamepad) {
                    this.gamepad.stop();
                }

                this.moveCallbacks = [];
                $.CanvasPool.remove(this);
                this.game.canvas.removeEventListener('click', this._onClickTrampoline);
            },

            "setInteractiveCandidateHandler": function (deepDataAndEvents, dataAndEvents) {
                this.customCandidateHandler = deepDataAndEvents;
                this.customCandidateHandlerContext = dataAndEvents;
            },

            "addMoveCallback": function (callback, context) {
                this.moveCallbacks.push({

                    "callback": callback,
                    "context": context
                });
            },

            "addTouchLockCallback": function (callback, context, onEnd) {
                if (void 0 === onEnd) {

                    onEnd = false;
                }
                this.touchLockCallbacks.push({

                    "callback": callback,
                    "context": context,
                    "onEnd": onEnd
                });
            },

            "removeTouchLockCallback": function (collection, dataAndEvents) {
                var i = this.touchLockCallbacks.length;
                for (; i--;) {
                    if (this.touchLockCallbacks[i].callback === collection && this.touchLockCallbacks[i].context === dataAndEvents) {
                        return this.touchLockCallbacks.splice(i, 1), true;
                    }
                }
                return false;
            },

            "executeTouchLockCallbacks": function (dataAndEvents, deepDataAndEvents) {
                var fnName = this.touchLockCallbacks.length;
                for (; fnName--;) {
                    var fn = this.touchLockCallbacks[fnName];
                    if (fn.onEnd === dataAndEvents) {
                        if (fn.callback.call(fn.context, this, deepDataAndEvents)) {
                            this.touchLockCallbacks.splice(fnName, 1);
                        }
                    }
                }
            },

            "deleteMoveCallback": function (dataAndEvents, deepDataAndEvents) {
                var ii = this.moveCallbacks.length;
                for (; ii--;) {
                    if (this.moveCallbacks[ii].callback === dataAndEvents && this.moveCallbacks[ii].context === deepDataAndEvents) {
                        return void this.moveCallbacks.splice(ii, 1);
                    }
                }
            },

            "addPointer": function () {
                if (this.pointers.length >= $.Input.MAX_POINTERS) {
                    return console.warn('Phaser.Input.addPointer: Maximum limit of ' + $.Input.MAX_POINTERS + ' pointers reached.'), null;
                }
                var timeout = this.pointers.length + 1;
                var waitsFunc = new($.Pointer)(this.game, timeout, $.PointerMode.CONTACT);
                return this.pointers.push(waitsFunc), this['pointer' + timeout] = waitsFunc, waitsFunc;
            },

            "update": function () {
                if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) {
                    this._pollCounter++;
                } else {

                    this.speed.x = this.position.x - this._oldPosition.x;

                    this.speed.y = this.position.y - this._oldPosition.y;
                    this._oldPosition.copyFrom(this.position);
                    this.mousePointer.update();
                    if (this.gamepad) {
                        if (this.gamepad.active) {
                            this.gamepad.update();
                        }
                    }

                    var bindingKey = 0;
                    for (; bindingKey < this.pointers.length; bindingKey++) {
                        this.pointers[bindingKey].update();
                    }

                    this._pollCounter = 0;
                }
            },

            "pauseUpdate": function () {
                if (this.gamepad) {
                    if (this.gamepad.active) {
                        this.gamepad.update();
                    }
                }
            },

            "reset": function (models) {
                if (this.game.isBooted && !this.resetLocked) {
                    if (void 0 === models) {

                        models = false;
                    }
                    this.mousePointer.reset();
                    if (this.keyboard) {
                        this.keyboard.reset(models);
                    }

                    var unlock = 0;
                    for (; unlock < this.pointers.length; unlock++) {
                        this.pointers[unlock].reset();
                    }
                    if ('none' !== this.game.canvas.style.cursor) {

                        this.game.canvas.style.cursor = "";
                    }
                    if (models) {
                        this.onDown.dispose();
                        this.onUp.dispose();
                        this.onTap.dispose();
                        this.onHold.dispose();
                        this.onDown = new($.Signal);
                        this.onUp = new($.Signal);
                        this.onTap = new($.Signal);
                        this.onHold = new($.Signal);

                        this.moveCallbacks = [];
                    }

                    this._pollCounter = 0;
                }
            },

            "resetSpeed": function (deepDataAndEvents, opt_obj2) {
                this._oldPosition.setTo(deepDataAndEvents, opt_obj2);
                this.speed.setTo(0, 0);
            },

            "startPointer": function (data) {
                if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) {
                    return null;
                }
                if (!this.pointer1.active) {
                    return this.pointer1.start(data);
                }
                if (!this.pointer2.active) {
                    return this.pointer2.start(data);
                }

                var unlock = 2;
                for (; unlock < this.pointers.length; unlock++) {
                    var cache = this.pointers[unlock];
                    if (!cache.active) {
                        return cache.start(data);
                    }
                }
                return null;
            },

            "updatePointer": function (type) {
                if (this.pointer1.active && this.pointer1.identifier === type.identifier) {
                    return this.pointer1.move(type);
                }
                if (this.pointer2.active && this.pointer2.identifier === type.identifier) {
                    return this.pointer2.move(type);
                }

                var elementArgumentPos = 2;
                for (; elementArgumentPos < this.pointers.length; elementArgumentPos++) {
                    var element = this.pointers[elementArgumentPos];
                    if (element.active && element.identifier === type.identifier) {
                        return element.move(type);
                    }
                }
                return null;
            },

            "stopPointer": function (selector) {
                if (this.pointer1.active && this.pointer1.identifier === selector.identifier) {
                    return this.pointer1.stop(selector);
                }
                if (this.pointer2.active && this.pointer2.identifier === selector.identifier) {
                    return this.pointer2.stop(selector);
                }

                var i = 2;
                for (; i < this.pointers.length; i++) {
                    var element = this.pointers[i];
                    if (element.active && element.identifier === selector.identifier) {
                        return element.stop(selector);
                    }
                }
                return null;
            },

            "countActivePointers": function (max) {
                if (void 0 === max) {
                    max = this.pointers.length;
                }

                var min = max;

                var i = 0;
                for (; i < this.pointers.length && min > 0; i++) {
                    if (this.pointers[i].active) {
                        min--;
                    }
                }
                return max - min;
            },

            "getPointer": function (base) {
                if (void 0 === base) {

                    base = false;
                }

                var unlock = 0;
                for (; unlock < this.pointers.length; unlock++) {
                    var cache = this.pointers[unlock];
                    if (cache.active === base) {
                        return cache;
                    }
                }
                return null;
            },

            "getPointerFromIdentifier": function (base) {

                var unlock = 0;
                for (; unlock < this.pointers.length; unlock++) {
                    var cache = this.pointers[unlock];
                    if (cache.identifier === base) {
                        return cache;
                    }
                }
                return null;
            },

            "getPointerFromId": function (pointerId) {

                var touchIndex = 0;
                for (; touchIndex < this.pointers.length; touchIndex++) {
                    var touch = this.pointers[touchIndex];
                    if (touch.pointerId === pointerId) {
                        return touch;
                    }
                }
                return null;
            },

            "getLocalPosition": function (res, p, x) {
                if (void 0 === x) {
                    x = new $.Point;
                }
                var m = res.worldTransform;

                var c = 1 / (m.a * m.d + m.c * -m.b);
                return x.setTo(m.d * c * p.x + -m.c * c * p.y + (m.ty * m.c - m.tx * m.d) * c, m.a * c * p.y + -m.b * c * p.x + (-m.ty * m.a + m.tx * m.b) * c);
            },

            "hitTest": function (data, prevState, x) {
                if (!data.worldVisible) {
                    return false;
                }
                if (this.getLocalPosition(data, prevState, this._localPoint), x.copyFrom(this._localPoint), data.hitArea && data.hitArea.contains) {
                    return data.hitArea.contains(this._localPoint.x, this._localPoint.y);
                }
                if ($.Creature && data instanceof $.Creature) {
                    var point = Math.abs(data.width);
                    var num = Math.abs(data.height);

                    var kTimeBetweenGemAdds = data.x - point * data.anchorX;
                    if (this.game.camera.x + prevState.x >= kTimeBetweenGemAdds && (this.game.camera.x + prevState.x < kTimeBetweenGemAdds + point && (memo = data.y - num * data.anchorY, this.game.camera.y + prevState.y >= memo && this.game.camera.y + prevState.y < memo + num))) {
                        return true;
                    }
                } else {
                    if (data instanceof $.TileSprite) {
                        point = data.width;
                        num = data.height;

                        kTimeBetweenGemAdds = -point * data.anchor.x;
                        if (this._localPoint.x >= kTimeBetweenGemAdds && (this._localPoint.x < kTimeBetweenGemAdds + point && (memo = -num * data.anchor.y, this._localPoint.y >= memo && this._localPoint.y < memo + num))) {
                            return true;
                        }
                    } else {
                        if (data instanceof PIXI.Sprite) {

                            point = data.texture.frame.width / data.texture.baseTexture.resolution;

                            num = data.texture.frame.height / data.texture.baseTexture.resolution;

                            kTimeBetweenGemAdds = -point * data.anchor.x;
                            if (this._localPoint.x >= kTimeBetweenGemAdds && this._localPoint.x < kTimeBetweenGemAdds + point) {

                                var memo = -num * data.anchor.y;
                                if (this._localPoint.y >= memo && this._localPoint.y < memo + num) {
                                    return true;
                                }
                            }
                        } else {
                            if (data instanceof $.Graphics) {

                                unlock = 0;
                                for (; unlock < data.graphicsData.length; unlock++) {
                                    var cache = data.graphicsData[unlock];
                                    if (cache.fill && (cache.shape && cache.shape.contains(this._localPoint.x, this._localPoint.y))) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }

                var unlock = 0;
                for (; unlock < data.children.length; unlock++) {
                    if (this.hitTest(data.children[unlock], prevState, x)) {
                        return true;
                    }
                }
                return false;
            },

            "onClickTrampoline": function () {
                this.activePointer.processClickTrampolines();
            }
        };
        $.Input.prototype.constructor = $.Input;
        Object.defineProperty($.Input.prototype, "x", {

            "get": function () {
                return this._x;
            },

            "set": function (value) {
                this._x = Math.floor(value);
            }
        });
        Object.defineProperty($.Input.prototype, "y", {

            "get": function () {
                return this._y;
            },

            "set": function (value) {
                this._y = Math.floor(value);
            }
        });
        Object.defineProperty($.Input.prototype, "pollLocked", {

            "get": function () {
                return this.pollRate > 0 && this._pollCounter < this.pollRate;
            }
        });
        Object.defineProperty($.Input.prototype, 'totalInactivePointers', {

            "get": function () {
                return this.pointers.length - this.countActivePointers();
            }
        });
        Object.defineProperty($.Input.prototype, "totalActivePointers", {

            "get": function () {
                return this.countActivePointers();
            }
        });
        Object.defineProperty($.Input.prototype, "worldX", {

            "get": function () {
                return this.game.camera.view.x + this.x;
            }
        });
        Object.defineProperty($.Input.prototype, 'worldY', {

            "get": function () {
                return this.game.camera.view.y + this.y;
            }
        });

        $.Mouse = function (dataAndEvents) {
            this.game = dataAndEvents;
            this.input = dataAndEvents.input;
            this.callbackContext = this.game;

            this.mouseDownCallback = null;

            this.mouseUpCallback = null;

            this.mouseOutCallback = null;

            this.mouseOverCallback = null;

            this.mouseWheelCallback = null;

            this.capture = false;

            this.button = -1;

            this.wheelDelta = 0;

            this.enabled = true;

            this.locked = false;

            this.stopOnGameOut = false;
            this.pointerLock = new($.Signal);

            this.event = null;

            this._onMouseDown = null;

            this._onMouseMove = null;

            this._onMouseUp = null;

            this._onMouseOut = null;

            this._onMouseOver = null;

            this._onMouseWheel = null;

            this._wheelEvent = null;
        };

        $.Mouse.NO_BUTTON = -1;

        $.Mouse.LEFT_BUTTON = 0;

        $.Mouse.MIDDLE_BUTTON = 1;

        $.Mouse.RIGHT_BUTTON = 2;

        $.Mouse.BACK_BUTTON = 3;

        $.Mouse.FORWARD_BUTTON = 4;

        $.Mouse.WHEEL_UP = 1;

        $.Mouse.WHEEL_DOWN = -1;
        $.Mouse.prototype = {

            "start": function () {
                if ((!this.game.device.android || false !== this.game.device.chrome) && null === this._onMouseDown) {
                    var onMouseDown = this;

                    this._onMouseDown = function (deepDataAndEvents) {
                        return onMouseDown.onMouseDown(deepDataAndEvents);
                    };

                    this._onMouseMove = function (deepDataAndEvents) {
                        return onMouseDown.onMouseMove(deepDataAndEvents);
                    };

                    this._onMouseUp = function (deepDataAndEvents) {
                        return onMouseDown.onMouseUp(deepDataAndEvents);
                    };

                    this._onMouseUpGlobal = function (deepDataAndEvents) {
                        return onMouseDown.onMouseUpGlobal(deepDataAndEvents);
                    };

                    this._onMouseOutGlobal = function (deepDataAndEvents) {
                        return onMouseDown.onMouseOutGlobal(deepDataAndEvents);
                    };

                    this._onMouseOut = function (deepDataAndEvents) {
                        return onMouseDown.onMouseOut(deepDataAndEvents);
                    };

                    this._onMouseOver = function (deepDataAndEvents) {
                        return onMouseDown.onMouseOver(deepDataAndEvents);
                    };

                    this._onMouseWheel = function (deepDataAndEvents) {
                        return onMouseDown.onMouseWheel(deepDataAndEvents);
                    };
                    var collection = this.game.canvas;
                    collection.addEventListener('mousedown', this._onMouseDown, true);
                    collection.addEventListener('mousemove', this._onMouseMove, true);
                    collection.addEventListener('mouseup', this._onMouseUp, true);
                    if (!this.game.device.cocoonJS) {
                        window.addEventListener('mouseup', this._onMouseUpGlobal, true);
                        window.addEventListener("mouseout", this._onMouseOutGlobal, true);
                        collection.addEventListener('mouseover', this._onMouseOver, true);
                        collection.addEventListener('mouseout', this._onMouseOut, true);
                    }
                    var resp = this.game.device.wheelEvent;
                    if (resp) {
                        collection.addEventListener(resp, this._onMouseWheel, true);
                        if ("mousewheel" === resp) {
                            this._wheelEvent = new clone(-0.025, 1);
                        } else {
                            if ('DOMMouseScroll' === resp) {
                                this._wheelEvent = new clone(1, 1);
                            }
                        }
                    }
                }
            },

            "onMouseDown": function (e) {
                this.event = e;
                if (this.capture) {
                    e.preventDefault();
                }
                if (this.mouseDownCallback) {
                    this.mouseDownCallback.call(this.callbackContext, e);
                }
                if (this.input.enabled) {
                    if (this.enabled) {

                        e.identifier = 0;
                        this.input.mousePointer.start(e);
                    }
                }
            },

            "onMouseMove": function (event) {

                this.event = event;
                if (this.capture) {
                    event.preventDefault();
                }
                if (this.mouseMoveCallback) {
                    this.mouseMoveCallback.call(this.callbackContext, event);
                }
                if (this.input.enabled) {
                    if (this.enabled) {

                        event.identifier = 0;
                        this.input.mousePointer.move(event);
                    }
                }
            },

            "onMouseUp": function ($event) {
                this.event = $event;
                if (this.capture) {
                    $event.preventDefault();
                }
                if (this.mouseUpCallback) {
                    this.mouseUpCallback.call(this.callbackContext, $event);
                }
                if (this.input.enabled) {
                    if (this.enabled) {

                        $event.identifier = 0;
                        this.input.mousePointer.stop($event);
                    }
                }
            },

            "onMouseUpGlobal": function (deepDataAndEvents) {
                if (!this.input.mousePointer.withinGame) {
                    if (this.mouseUpCallback) {
                        this.mouseUpCallback.call(this.callbackContext, deepDataAndEvents);
                    }

                    deepDataAndEvents.identifier = 0;
                    this.input.mousePointer.stop(deepDataAndEvents);
                }
            },

            "onMouseOutGlobal": function (listener) {
                this.event = listener;
                if (this.capture) {
                    listener.preventDefault();
                }

                this.input.mousePointer.withinGame = false;
                if (this.input.enabled) {
                    if (this.enabled) {
                        this.input.mousePointer.stop(listener);
                        this.input.mousePointer.resetButtons();
                    }
                }
            },

            "onMouseOut": function (e) {
                if (this.event = e, this.capture && e.preventDefault(), this.input.mousePointer.withinGame = false, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, e), this.input.enabled && this.enabled) {
                    if (this.stopOnGameOut) {

                        e.identifier = 0;
                        this.input.mousePointer.stop(e);
                    }
                    var index0;
                    for (index0 in this.input.interactiveItems.list) {
                        if (true === this.input.interactiveItems.list[index0].enabled) {
                            this.input.interactiveItems.list[index0]._pointerOutHandler(this.input.mousePointer);
                        }
                    }
                }
            },

            "onMouseOver": function (cm) {
                this.event = cm;
                if (this.capture) {
                    cm.preventDefault();
                }

                this.input.mousePointer.withinGame = true;
                if (this.mouseOverCallback) {
                    this.mouseOverCallback.call(this.callbackContext, cm);
                }
            },

            "onMouseWheel": function (basis) {
                if (this._wheelEvent) {
                    basis = this._wheelEvent.bindEvent(basis);
                }

                this.event = basis;
                if (this.capture) {
                    basis.preventDefault();
                }
                this.wheelDelta = $.Math.clamp(-basis.deltaY, -1, 1);
                if (this.mouseWheelCallback) {
                    this.mouseWheelCallback.call(this.callbackContext, basis);
                }
            },

            "requestPointerLock": function () {
                if (this.game.device.pointerLock) {
                    var extract = this.game.canvas;
                    extract.requestPointerLock = extract.requestPointerLock || (extract.mozRequestPointerLock || extract.webkitRequestPointerLock);
                    extract.requestPointerLock();
                    var collection = this;

                    this._pointerLockChange = function (resp) {
                        return collection.pointerLockChange(resp);
                    };
                    document.addEventListener("pointerlockchange", this._pointerLockChange, true);
                    document.addEventListener('mozpointerlockchange', this._pointerLockChange, true);
                    document.addEventListener("webkitpointerlockchange", this._pointerLockChange, true);
                }
            },

            "pointerLockChange": function (event) {
                var preceding = this.game.canvas;
                if (document.pointerLockElement === preceding || (document.mozPointerLockElement === preceding || document.webkitPointerLockElement === preceding)) {

                    this.locked = true;
                    this.pointerLock.dispatch(true, event);
                } else {

                    this.locked = false;
                    this.pointerLock.dispatch(false, event);
                }
            },

            "releasePointerLock": function () {
                document.exitPointerLock = document.exitPointerLock || (document.mozExitPointerLock || document.webkitExitPointerLock);
                document.exitPointerLock();
                document.removeEventListener('pointerlockchange', this._pointerLockChange, true);
                document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true);
            },

            "stop": function () {
                var ElementPrototype = this.game.canvas;
                ElementPrototype.removeEventListener('mousedown', this._onMouseDown, true);
                ElementPrototype.removeEventListener('mousemove', this._onMouseMove, true);
                ElementPrototype.removeEventListener('mouseup', this._onMouseUp, true);
                ElementPrototype.removeEventListener('mouseover', this._onMouseOver, true);
                ElementPrototype.removeEventListener('mouseout', this._onMouseOut, true);
                var r20 = this.game.device.wheelEvent;
                if (r20) {
                    ElementPrototype.removeEventListener(r20, this._onMouseWheel, true);
                }
                window.removeEventListener('mouseup', this._onMouseUpGlobal, true);
                window.removeEventListener('mouseout', this._onMouseOutGlobal, true);
                document.removeEventListener('pointerlockchange', this._pointerLockChange, true);
                document.removeEventListener("mozpointerlockchange", this._pointerLockChange, true);
                document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true);
            }
        };
        $.Mouse.prototype.constructor = $.Mouse;

        (clone.prototype = {}).constructor = clone;

        clone.prototype.bindEvent = function (thisValue) {
            if (!clone._stubsGenerated && thisValue) {
                var prop;
                for (prop in thisValue) {
                    if (!(prop in clone.prototype)) {
                        Object.defineProperty(clone.prototype, prop, {
                            "get": function (methodName) {
                                return function () {
                                    var func = this.originalEvent[methodName];
                                    return 'function' != typeof func ? func : func.bind(this.originalEvent);
                                };
                            }(prop)
                        });
                    }
                }

                clone._stubsGenerated = true;
            }
            return this.originalEvent = thisValue, this;
        };
        Object.defineProperties(clone.prototype, {
            "type": {
                "value": "wheel"
            },
            "deltaMode": {

                "get": function () {
                    return this._deltaMode;
                }
            },
            "deltaY": {

                "get": function () {
                    return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0;
                }
            },
            "deltaX": {

                "get": function () {
                    return this._scaleFactor * this.originalEvent.wheelDeltaX || 0;
                }
            },
            "deltaZ": {
                "value": 0
            }
        });

        $.MSPointer = function (dataAndEvents) {
            this.game = dataAndEvents;
            this.input = dataAndEvents.input;
            this.callbackContext = this.game;

            this.pointerDownCallback = null;

            this.pointerMoveCallback = null;

            this.pointerUpCallback = null;

            this.capture = true;

            this.button = -1;

            this.event = null;

            this.enabled = true;

            this._onMSPointerDown = null;

            this._onMSPointerMove = null;

            this._onMSPointerUp = null;

            this._onMSPointerUpGlobal = null;

            this._onMSPointerOut = null;

            this._onMSPointerOver = null;
        };
        $.MSPointer.prototype = {

            "start": function () {
                if (null === this._onMSPointerDown) {
                    var collection = this;
                    if (this.game.device.mspointer) {

                        this._onMSPointerDown = function (resp) {
                            return collection.onPointerDown(resp);
                        };

                        this._onMSPointerMove = function (resp) {
                            return collection.onPointerMove(resp);
                        };

                        this._onMSPointerUp = function (resp) {
                            return collection.onPointerUp(resp);
                        };

                        this._onMSPointerUpGlobal = function (resp) {
                            return collection.onPointerUpGlobal(resp);
                        };

                        this._onMSPointerOut = function (resp) {
                            return collection.onPointerOut(resp);
                        };

                        this._onMSPointerOver = function (resp) {
                            return collection.onPointerOver(resp);
                        };
                        var element = this.game.canvas;
                        element.addEventListener('MSPointerDown', this._onMSPointerDown, false);
                        element.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                        element.addEventListener('MSPointerUp', this._onMSPointerUp, false);
                        element.addEventListener("pointerdown", this._onMSPointerDown, false);
                        element.addEventListener("pointermove", this._onMSPointerMove, false);
                        element.addEventListener("pointerup", this._onMSPointerUp, false);

                        element.style['-ms-content-zooming'] = "none";

                        element.style["-ms-touch-action"] = "none";
                        if (!this.game.device.cocoonJS) {
                            window.addEventListener('MSPointerUp', this._onMSPointerUpGlobal, true);
                            element.addEventListener('MSPointerOver', this._onMSPointerOver, true);
                            element.addEventListener('MSPointerOut', this._onMSPointerOut, true);
                            window.addEventListener('pointerup', this._onMSPointerUpGlobal, true);
                            element.addEventListener('pointerover', this._onMSPointerOver, true);
                            element.addEventListener('pointerout', this._onMSPointerOut, true);
                        }
                    }
                }
            },

            "onPointerDown": function (event) {
                this.game.input.executeTouchLockCallbacks(false, event);

                this.event = event;
                if (this.capture) {
                    event.preventDefault();
                }
                if (this.pointerDownCallback) {
                    this.pointerDownCallback.call(this.callbackContext, event);
                }
                if (this.input.enabled) {
                    if (this.enabled) {
                        event.identifier = event.pointerId;
                        if ('mouse' === event.pointerType || 4 === event.pointerType) {
                            this.input.mousePointer.start(event);
                        } else {
                            this.input.startPointer(event);
                        }
                    }
                }
            },

            "onPointerMove": function (state) {
                this.event = state;
                if (this.capture) {
                    state.preventDefault();
                }
                if (this.pointerMoveCallback) {
                    this.pointerMoveCallback.call(this.callbackContext, state);
                }
                if (this.input.enabled) {
                    if (this.enabled) {
                        state.identifier = state.pointerId;
                        if ('mouse' === state.pointerType || 4 === state.pointerType) {
                            this.input.mousePointer.move(state);
                        } else {
                            this.input.updatePointer(state);
                        }
                    }
                }
            },

            "onPointerUp": function (e) {
                this.game.input.executeTouchLockCallbacks(true, e);

                this.event = e;
                if (this.capture) {
                    e.preventDefault();
                }
                if (this.pointerUpCallback) {
                    this.pointerUpCallback.call(this.callbackContext, e);
                }
                if (this.input.enabled) {
                    if (this.enabled) {
                        e.identifier = e.pointerId;
                        if ('mouse' === e.pointerType || 4 === e.pointerType) {
                            this.input.mousePointer.stop(e);
                        } else {
                            this.input.stopPointer(e);
                        }
                    }
                }
            },

            "onPointerUpGlobal": function (types) {
                if ('mouse' !== types.pointerType && 4 !== types.pointerType || this.input.mousePointer.withinGame) {
                    var withinGame = this.input.getPointerFromIdentifier(types.identifier);
                    if (withinGame) {
                        if (withinGame.withinGame) {
                            this.onPointerUp(types);
                        }
                    }
                } else {
                    this.onPointerUp(types);
                }
            },

            "onPointerOut": function (event) {
                if (this.event = event, this.capture && event.preventDefault(), 'mouse' === event.pointerType || 4 === event.pointerType) {

                    this.input.mousePointer.withinGame = false;
                } else {
                    var self = this.input.getPointerFromIdentifier(event.identifier);
                    if (self) {

                        self.withinGame = false;
                    }
                }
                if (this.input.mouse.mouseOutCallback) {
                    this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, event);
                }
                if (this.input.enabled) {
                    if (this.enabled) {
                        if (this.input.mouse.stopOnGameOut) {

                            event.identifier = 0;
                            if (self) {
                                self.stop(event);
                            } else {
                                this.input.mousePointer.stop(event);
                            }
                        }
                    }
                }
            },

            "onPointerOver": function (evt) {
                if (this.event = evt, this.capture && evt.preventDefault(), 'mouse' === evt.pointerType || 4 === evt.pointerType) {

                    this.input.mousePointer.withinGame = true;
                } else {
                    var _0x5a661a = this.input.getPointerFromIdentifier(evt.identifier);
                    if (_0x5a661a) {

                        _0x5a661a.withinGame = true;
                    }
                }
                if (this.input.mouse.mouseOverCallback) {
                    this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, evt);
                }
            },

            "stop": function () {
                var ElementPrototype = this.game.canvas;
                ElementPrototype.removeEventListener('MSPointerDown', this._onMSPointerDown, false);
                ElementPrototype.removeEventListener('MSPointerMove', this._onMSPointerMove, false);
                ElementPrototype.removeEventListener("MSPointerUp", this._onMSPointerUp, false);
                ElementPrototype.removeEventListener('pointerdown', this._onMSPointerDown, false);
                ElementPrototype.removeEventListener('pointermove', this._onMSPointerMove, false);
                ElementPrototype.removeEventListener('pointerup', this._onMSPointerUp, false);
                window.removeEventListener('MSPointerUp', this._onMSPointerUpGlobal, true);
                ElementPrototype.removeEventListener('MSPointerOver', this._onMSPointerOver, true);
                ElementPrototype.removeEventListener('MSPointerOut', this._onMSPointerOut, true);
                window.removeEventListener('pointerup', this._onMSPointerUpGlobal, true);
                ElementPrototype.removeEventListener("pointerover", this._onMSPointerOver, true);
                ElementPrototype.removeEventListener('pointerout', this._onMSPointerOut, true);
            }
        };
        $.MSPointer.prototype.constructor = $.MSPointer;

        $.DeviceButton = function (dataAndEvents, deepDataAndEvents) {
            this.parent = dataAndEvents;
            this.game = dataAndEvents.game;

            this.event = null;

            this.isDown = false;

            this.isUp = true;

            this.timeDown = 0;

            this.timeUp = 0;

            this.repeats = 0;

            this.altKey = false;

            this.shiftKey = false;

            this.ctrlKey = false;

            this.value = 0;
            this.buttonCode = deepDataAndEvents;
            this.onDown = new($.Signal);
            this.onUp = new($.Signal);
            this.onFloat = new($.Signal);
        };
        $.DeviceButton.prototype = {

            "start": function (ui, persistent) {
                if (!this.isDown) {

                    this.isDown = true;

                    this.isUp = false;
                    this.timeDown = this.game.time.time;

                    this.repeats = 0;
                    this.event = ui;
                    this.value = persistent;
                    if (ui) {
                        this.altKey = ui.altKey;
                        this.shiftKey = ui.shiftKey;
                        this.ctrlKey = ui.ctrlKey;
                    }
                    this.onDown.dispatch(this, persistent);
                }
            },

            "stop": function (event, gotoEnd) {
                if (!this.isUp) {

                    this.isDown = false;

                    this.isUp = true;
                    this.timeUp = this.game.time.time;

                    this.event = event;
                    this.value = gotoEnd;
                    if (event) {
                        this.altKey = event.altKey;
                        this.shiftKey = event.shiftKey;
                        this.ctrlKey = event.ctrlKey;
                    }
                    this.onUp.dispatch(this, gotoEnd);
                }
            },

            "startStop": function (e, deepDataAndEvents, opt_obj2) {
                if (e) {
                    this.start(deepDataAndEvents, opt_obj2);
                } else {
                    this.stop(deepDataAndEvents, opt_obj2);
                }
            },

            "padFloat": function (deepDataAndEvents) {

                this.isDown = false;

                this.isUp = false;
                this.value = deepDataAndEvents;
                this.onFloat.dispatch(this, deepDataAndEvents);
            },

            "justPressed": function (duration) {
                return duration = duration || 250, this.isDown && this.timeDown + duration > this.game.time.time;
            },

            "justReleased": function (duration) {
                return duration = duration || 250, this.isUp && this.timeUp + duration > this.game.time.time;
            },

            "reset": function () {

                this.isDown = false;

                this.isUp = true;
                this.timeDown = this.game.time.time;

                this.repeats = 0;

                this.altKey = false;

                this.shiftKey = false;

                this.ctrlKey = false;
            },

            "destroy": function () {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onFloat.dispose();

                this.parent = null;

                this.game = null;
            }
        };
        $.DeviceButton.prototype.constructor = $.DeviceButton;
        Object.defineProperty($.DeviceButton.prototype, 'duration', {

            "get": function () {
                return this.isUp ? -1 : this.game.time.time - this.timeDown;
            }
        });

        $.Pointer = function (dataAndEvents, proxyObj, deepDataAndEvents) {
            this.game = dataAndEvents;

            this.id = proxyObj;
            this.type = $.POINTER;

            this.exists = true;

            this.identifier = 0;

            this.pointerId = null;
            this.pointerMode = deepDataAndEvents || $.PointerMode.CURSOR | $.PointerMode.CONTACT;

            this.target = null;

            this.button = null;
            this.leftButton = new($.DeviceButton)(this, $.Pointer.LEFT_BUTTON);
            this.middleButton = new($.DeviceButton)(this, $.Pointer.MIDDLE_BUTTON);
            this.rightButton = new $.DeviceButton(this, $.Pointer.RIGHT_BUTTON);
            this.backButton = new($.DeviceButton)(this, $.Pointer.BACK_BUTTON);
            this.forwardButton = new $.DeviceButton(this, $.Pointer.FORWARD_BUTTON);
            this.eraserButton = new $.DeviceButton(this, $.Pointer.ERASER_BUTTON);

            this._holdSent = false;

            this._history = [];

            this._nextDrop = 0;

            this._stateReset = false;

            this.withinGame = false;

            this.clientX = -1;

            this.clientY = -1;

            this.pageX = -1;

            this.pageY = -1;

            this.screenX = -1;

            this.screenY = -1;

            this.rawMovementX = 0;

            this.rawMovementY = 0;

            this.movementX = 0;

            this.movementY = 0;

            this.x = -1;

            this.y = -1;

            this.isMouse = 0 === proxyObj;

            this.isDown = false;

            this.isUp = true;

            this.timeDown = 0;

            this.timeUp = 0;

            this.previousTapTime = 0;

            this.totalTouches = 0;
            this.msSinceLastClick = Number.MAX_VALUE;

            this.targetObject = null;

            this.interactiveCandidates = [];

            this.active = false;

            this.dirty = false;
            this.position = new($.Point);
            this.positionDown = new($.Point);
            this.positionUp = new($.Point);
            this.circle = new($.Circle)(0, 0, 44);

            this._clickTrampolines = null;

            this._trampolineTargetObject = null;
        };

        $.Pointer.NO_BUTTON = 0;

        $.Pointer.LEFT_BUTTON = 1;

        $.Pointer.RIGHT_BUTTON = 2;

        $.Pointer.MIDDLE_BUTTON = 4;

        $.Pointer.BACK_BUTTON = 8;

        $.Pointer.FORWARD_BUTTON = 16;

        $.Pointer.ERASER_BUTTON = 32;
        $.Pointer.prototype = {

            "resetButtons": function () {

                this.isDown = false;

                this.isUp = true;
                if (this.isMouse) {
                    this.leftButton.reset();
                    this.middleButton.reset();
                    this.rightButton.reset();
                    this.backButton.reset();
                    this.forwardButton.reset();
                    this.eraserButton.reset();
                }
            },

            "processButtonsDown": function (dataAndEvents, startCoords) {
                if (dataAndEvents === $.Mouse.LEFT_BUTTON) {
                    this.leftButton.start(startCoords);
                }
                if (dataAndEvents === $.Mouse.RIGHT_BUTTON) {
                    this.rightButton.start(startCoords);
                }
                if (dataAndEvents === $.Mouse.MIDDLE_BUTTON) {
                    this.middleButton.start(startCoords);
                }
                if (dataAndEvents === $.Mouse.BACK_BUTTON) {
                    this.backButton.start(startCoords);
                }
                if (dataAndEvents === $.Mouse.FORWARD_BUTTON) {
                    this.forwardButton.start(startCoords);
                }
            },

            "processButtonsUp": function (dataAndEvents, deepDataAndEvents) {
                if (dataAndEvents === $.Mouse.LEFT_BUTTON) {
                    this.leftButton.stop(deepDataAndEvents);
                }
                if (dataAndEvents === $.Mouse.RIGHT_BUTTON) {
                    this.rightButton.stop(deepDataAndEvents);
                }
                if (dataAndEvents === $.Mouse.MIDDLE_BUTTON) {
                    this.middleButton.stop(deepDataAndEvents);
                }
                if (dataAndEvents === $.Mouse.BACK_BUTTON) {
                    this.backButton.stop(deepDataAndEvents);
                }
                if (dataAndEvents === $.Mouse.FORWARD_BUTTON) {
                    this.forwardButton.stop(deepDataAndEvents);
                }
            },

            "processButtonsUpDown": function (dataAndEvents, opts) {

                var down = "down" === opts.type.toLowerCase().substr(-4);

                var _0x4af883 = 'move' === opts.type.toLowerCase().substr(-4);
                if (void 0 !== dataAndEvents) {
                    if (down) {
                        if (1 === dataAndEvents) {
                            if (opts.ctrlKey) {

                                dataAndEvents = 2;
                            }
                        }
                    }
                    this.leftButton.startStop($.Pointer.LEFT_BUTTON & dataAndEvents, opts);
                    this.rightButton.startStop($.Pointer.RIGHT_BUTTON & dataAndEvents, opts);
                    this.middleButton.startStop($.Pointer.MIDDLE_BUTTON & dataAndEvents, opts);
                    this.backButton.startStop($.Pointer.BACK_BUTTON & dataAndEvents, opts);
                    this.forwardButton.startStop($.Pointer.FORWARD_BUTTON & dataAndEvents, opts);
                    this.eraserButton.startStop($.Pointer.ERASER_BUTTON & dataAndEvents, opts);
                } else {
                    if (void 0 !== opts.button) {
                        if (down && (opts.ctrlKey && 0 === opts.button)) {
                            this.rightButton.start(opts);
                        } else {
                            if (down) {
                                this.processButtonsDown(opts.button, opts);
                            } else {
                                if (!_0x4af883) {
                                    this.processButtonsUp(opts.button, opts);
                                }
                            }
                        }
                    } else {
                        if (down) {
                            if (opts.ctrlKey) {
                                this.rightButton.start(opts);
                            } else {
                                this.leftButton.start(opts);
                            }
                        } else {
                            this.leftButton.stop(opts);
                            this.rightButton.stop(opts);
                        }
                    }
                }
            },

            "updateButtons": function (e) {
                this.button = e.button;
                this.processButtonsUpDown(e.buttons, e);

                this.isUp = true;

                this.isDown = false;
                if (this.leftButton.isDown || (this.rightButton.isDown || (this.middleButton.isDown || (this.backButton.isDown || (this.forwardButton.isDown || this.eraserButton.isDown))))) {

                    this.isUp = false;

                    this.isDown = true;
                }
            },

            "start": function (event) {
                var self = this.game.input;
                return event.pointerId && (this.pointerId = event.pointerId), this.identifier = event.identifier, this.target = event.target, this.isMouse ? this.updateButtons(event) : (this.isDown = true, this.isUp = false), this.active = true, this.withinGame = true, this.dirty = false, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick =
                    this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = false, this.move(event, true), this.positionDown.setTo(this.x, this.y), (self.multiInputOverride === $.Input.MOUSE_OVERRIDES_TOUCH || (self.multiInputOverride === $.Input.MOUSE_TOUCH_COMBINE || self.multiInputOverride === $.Input.TOUCH_OVERRIDES_MOUSE &&
                        0 === self.totalActivePointers)) && (self.x = this.x, self.y = this.y, self.position.setTo(this.x, this.y), self.onDown.dispatch(this, event), self.resetSpeed(this.x, this.y)), this._stateReset = false, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this;
            },

            "update": function () {
                var total = this.game.input;
                if (this.active) {
                    if (this.dirty) {
                        if (total.interactiveItems.total > 0) {
                            this.processInteractiveObjects(false);
                        }

                        this.dirty = false;
                    }
                    if (false === this._holdSent) {
                        if (this.duration >= total.holdRate) {
                            if (total.multiInputOverride === $.Input.MOUSE_OVERRIDES_TOUCH || (total.multiInputOverride === $.Input.MOUSE_TOUCH_COMBINE || total.multiInputOverride === $.Input.TOUCH_OVERRIDES_MOUSE && 0 === total.totalActivePointers)) {
                                total.onHold.dispatch(this);
                            }

                            this._holdSent = true;
                        }
                    }
                    if (total.recordPointerHistory) {
                        if (this.game.time.time >= this._nextDrop) {
                            this._nextDrop = this.game.time.time + total.recordRate;
                            this._history.push({
                                "x": this.position.x,
                                "y": this.position.y
                            });
                            if (this._history.length > total.recordLimit) {
                                this._history.shift();
                            }
                        }
                    }
                }
            },

            "move": function (animationCompleted, speed) {
                var data = this.game.input;
                if (!data.pollLocked) {
                    if (void 0 === speed) {

                        speed = false;
                    }
                    if (void 0 !== animationCompleted.button) {
                        this.button = animationCompleted.button;
                    }
                    if (this.isMouse) {
                        this.updateButtons(animationCompleted);
                    }
                    this.clientX = animationCompleted.clientX;
                    this.clientY = animationCompleted.clientY;
                    this.pageX = animationCompleted.pageX;
                    this.pageY = animationCompleted.pageY;
                    this.screenX = animationCompleted.screenX;
                    this.screenY = animationCompleted.screenY;
                    if (this.isMouse) {
                        if (data.mouse.locked) {
                            if (!speed) {
                                this.rawMovementX = animationCompleted.movementX || (animationCompleted.mozMovementX || (animationCompleted.webkitMovementX || 0));
                                this.rawMovementY = animationCompleted.movementY || (animationCompleted.mozMovementY || (animationCompleted.webkitMovementY || 0));
                                this.movementX += this.rawMovementX;
                                this.movementY += this.rawMovementY;
                            }
                        }
                    }

                    this.x = (this.pageX - this.game.scale.offset.x) * data.scale.x;

                    this.y = (this.pageY - this.game.scale.offset.y) * data.scale.y;
                    this.position.setTo(this.x, this.y);
                    this.circle.x = this.x;
                    this.circle.y = this.y;
                    if (data.multiInputOverride === $.Input.MOUSE_OVERRIDES_TOUCH || (data.multiInputOverride === $.Input.MOUSE_TOUCH_COMBINE || data.multiInputOverride === $.Input.TOUCH_OVERRIDES_MOUSE && 0 === data.totalActivePointers)) {
                        data.activePointer = this;
                        data.x = this.x;
                        data.y = this.y;
                        data.position.setTo(data.x, data.y);
                        data.circle.x = data.x;
                        data.circle.y = data.y;
                    }
                    this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                    var value_idx = data.moveCallbacks.length;
                    for (; value_idx--;) {
                        data.moveCallbacks[value_idx].callback.call(data.moveCallbacks[value_idx].context, this, this.x, this.y, speed);
                    }
                    return null === this.targetObject || (this.game.paused && !this.targetObject.noPause || true !== this.targetObject.isDragged) ? data.interactiveItems.total > 0 && this.processInteractiveObjects(speed) : false === this.targetObject.update(this) && (this.targetObject = null), this;
                }
            },

            "processInteractiveObjects": function (dataAndEvents) {

                var restoreScript = 0;

                var r20 = -1;

                var rreturn = null;
                var e0 = this.game.input.interactiveItems.first;

                this.interactiveCandidates = [];
                for (; e0;) {

                    e0.checked = false;
                    if (!!e0.validForInput(r20, restoreScript, false)) {
                        if (!(this.game.paused && !e0.sprite.noPause)) {

                            e0.checked = true;
                            if (dataAndEvents && e0.checkPointerDown(this, true) || !dataAndEvents && e0.checkPointerOver(this, true)) {
                                restoreScript = e0.sprite.renderOrderID;
                                r20 = e0.priorityID;
                                rreturn = e0;
                                this.interactiveCandidates.push(e0);
                            }
                        }
                    }
                    e0 = this.game.input.interactiveItems.next;
                }
                e0 = this.game.input.interactiveItems.first;
                for (; e0;) {
                    if (!e0.checked) {
                        if (e0.validForInput(r20, restoreScript, true)) {
                            if (dataAndEvents && e0.checkPointerDown(this, false) || !dataAndEvents && e0.checkPointerOver(this, false)) {
                                restoreScript = e0.sprite.renderOrderID;
                                r20 = e0.priorityID;
                                rreturn = e0;
                                this.interactiveCandidates.push(e0);
                            }
                        }
                    }
                    e0 = this.game.input.interactiveItems.next;
                }
                return this.game.input.customCandidateHandler && (rreturn = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, rreturn)), this.swapTarget(rreturn, false), null !== this.targetObject;
            },

            "swapTarget": function (obj, callback) {
                if (void 0 === callback) {

                    callback = false;
                }
                if (null === obj) {
                    if (this.targetObject) {
                        this.targetObject._pointerOutHandler(this, callback);

                        this.targetObject = null;
                    }
                } else {
                    if (null === this.targetObject) {

                        this.targetObject = obj;
                        obj._pointerOverHandler(this, callback);
                    } else {
                        if (this.targetObject === obj) {
                            if (false === obj.update(this)) {

                                this.targetObject = null;
                            }
                        } else {
                            this.targetObject._pointerOutHandler(this, callback);

                            this.targetObject = obj;
                            this.targetObject._pointerOverHandler(this, callback);
                        }
                    }
                }
            },

            "leave": function (animationCompleted) {

                this.withinGame = false;
                this.move(animationCompleted, false);
            },

            "stop": function (gotoEnd) {
                var options = this.game.input;
                if (!this._stateReset || !this.withinGame) {
                    return this.timeUp = this.game.time.time, (options.multiInputOverride === $.Input.MOUSE_OVERRIDES_TOUCH || (options.multiInputOverride === $.Input.MOUSE_TOUCH_COMBINE || options.multiInputOverride === $.Input.TOUCH_OVERRIDES_MOUSE && 0 === options.totalActivePointers)) && (options.onUp.dispatch(this, gotoEnd), this.duration >= 0 && (this.duration <= options.tapRate && (this.timeUp -
                            this.previousTapTime < options.doubleTapRate ? options.onTap.dispatch(this, true) : options.onTap.dispatch(this, false), this.previousTapTime = this.timeUp))), this.isMouse ? this.updateButtons(gotoEnd) : (this.isDown = false, this.isUp = true), this.id > 0 && (this.active = false), this.withinGame = this.game.scale.bounds.contains(gotoEnd.pageX, gotoEnd.pageY),
                        this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), false === this.isMouse && options.currentPointers--, options.interactiveItems.callAll('_releasedHandler', this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                }
                gotoEnd.preventDefault();
            },

            "justPressed": function (duration) {
                return duration = duration || this.game.input.justPressedRate, true === this.isDown && this.timeDown + duration > this.game.time.time;
            },

            "justReleased": function (duration) {
                return duration = duration || this.game.input.justReleasedRate, this.isUp && this.timeUp + duration > this.game.time.time;
            },

            "addClickTrampoline": function (errorName, callback, dataAndEvents, deepDataAndEvents) {
                if (this.isDown) {
                    var el = this._clickTrampolines = this._clickTrampolines || [];

                    var k = 0;
                    for (; k < el.length; k++) {
                        if (el[k].name === errorName) {
                            el.splice(k, 1);
                            break;
                        }
                    }
                    el.push({
                        "name": errorName,
                        "targetObject": this.targetObject,

                        "callback": callback,
                        "callbackContext": dataAndEvents,
                        "callbackArgs": deepDataAndEvents
                    });
                }
            },

            "processClickTrampolines": function () {
                var parts = this._clickTrampolines;
                if (parts) {

                    var j = 0;
                    for (; j < parts.length; j++) {
                        var part = parts[j];
                        if (part.targetObject === this._trampolineTargetObject) {
                            part.callback.apply(part.callbackContext, part.callbackArgs);
                        }
                    }

                    this._clickTrampolines = null;

                    this._trampolineTargetObject = null;
                }
            },

            "reset": function () {
                if (false === this.isMouse) {

                    this.active = false;
                }

                this.pointerId = null;

                this.identifier = null;

                this.dirty = false;

                this.totalTouches = 0;

                this._holdSent = false;

                this._history.length = 0;

                this._stateReset = true;
                this.resetButtons();
                if (this.targetObject) {
                    this.targetObject._releasedHandler(this);
                }

                this.targetObject = null;
            },

            "resetMovement": function () {

                this.movementX = 0;

                this.movementY = 0;
            }
        };
        $.Pointer.prototype.constructor = $.Pointer;
        Object.defineProperty($.Pointer.prototype, "duration", {

            "get": function () {
                return this.isUp ? -1 : this.game.time.time - this.timeDown;
            }
        });
        Object.defineProperty($.Pointer.prototype, 'worldX', {

            "get": function () {
                return this.game.world.camera.x + this.x;
            }
        });
        Object.defineProperty($.Pointer.prototype, 'worldY', {

            "get": function () {
                return this.game.world.camera.y + this.y;
            }
        });
        $.PointerMode = {
            "CURSOR": 1,
            "CONTACT": 2
        };

        $.Touch = function (dataAndEvents) {
            this.game = dataAndEvents;

            this.enabled = true;
            this.callbackContext = this.game;

            this.touchStartCallback = null;

            this.touchMoveCallback = null;

            this.touchEndCallback = null;

            this.touchEnterCallback = null;

            this.touchLeaveCallback = null;

            this.touchCancelCallback = null;

            this.preventDefault = true;

            this.event = null;

            this._onTouchStart = null;

            this._onTouchMove = null;

            this._onTouchEnd = null;

            this._onTouchEnter = null;

            this._onTouchLeave = null;

            this._onTouchCancel = null;

            this._onTouchMove = null;
        };
        $.Touch.prototype = {

            "start": function () {
                if (null === this._onTouchStart) {
                    var collection = this;
                    if (this.game.device.touch) {

                        this._onTouchStart = function (resp) {
                            return collection.onTouchStart(resp);
                        };

                        this._onTouchMove = function (resp) {
                            return collection.onTouchMove(resp);
                        };

                        this._onTouchEnd = function (resp) {
                            return collection.onTouchEnd(resp);
                        };

                        this._onTouchEnter = function (resp) {
                            return collection.onTouchEnter(resp);
                        };

                        this._onTouchLeave = function (resp) {
                            return collection.onTouchLeave(resp);
                        };

                        this._onTouchCancel = function (resp) {
                            return collection.onTouchCancel(resp);
                        };
                        this.game.canvas.addEventListener('touchstart', this._onTouchStart, false);
                        this.game.canvas.addEventListener('touchmove', this._onTouchMove, false);
                        this.game.canvas.addEventListener('touchend', this._onTouchEnd, false);
                        this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, false);
                        if (!this.game.device.cocoonJS) {
                            this.game.canvas.addEventListener("touchenter", this._onTouchEnter, false);
                            this.game.canvas.addEventListener('touchleave', this._onTouchLeave, false);
                        }
                    }
                }
            },

            "consumeDocumentTouches": function () {

                this._documentTouchMove = function (event) {
                    event.preventDefault();
                };
                document.addEventListener('touchmove', this._documentTouchMove, false);
            },

            "onTouchStart": function (event) {
                if (this.game.input.executeTouchLockCallbacks(false, event), this.event = event, this.game.input.enabled && this.enabled) {
                    if (this.touchStartCallback) {
                        this.touchStartCallback.call(this.callbackContext, event);
                    }
                    if (this.preventDefault) {
                        event.preventDefault();
                    }

                    var j = 0;
                    for (; j < event.changedTouches.length; j++) {
                        this.game.input.startPointer(event.changedTouches[j]);
                    }
                }
            },

            "onTouchCancel": function (event) {
                if (this.event = event, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, event), this.game.input.enabled && this.enabled) {
                    if (this.preventDefault) {
                        event.preventDefault();
                    }

                    var j = 0;
                    for (; j < event.changedTouches.length; j++) {
                        this.game.input.stopPointer(event.changedTouches[j]);
                    }
                }
            },

            "onTouchEnter": function (listener) {
                this.event = listener;
                if (this.touchEnterCallback) {
                    this.touchEnterCallback.call(this.callbackContext, listener);
                }
                if (this.game.input.enabled) {
                    if (this.enabled) {
                        if (this.preventDefault) {
                            listener.preventDefault();
                        }
                    }
                }
            },

            "onTouchLeave": function (event) {
                this.event = event;
                if (this.touchLeaveCallback) {
                    this.touchLeaveCallback.call(this.callbackContext, event);
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }
            },

            "onTouchMove": function (e) {
                this.event = e;
                if (this.touchMoveCallback) {
                    this.touchMoveCallback.call(this.callbackContext, e);
                }
                if (this.preventDefault) {
                    e.preventDefault();
                }

                var i = 0;
                for (; i < e.changedTouches.length; i++) {
                    this.game.input.updatePointer(e.changedTouches[i]);
                }
            },

            "onTouchEnd": function (event) {
                this.game.input.executeTouchLockCallbacks(true, event);

                this.event = event;
                if (this.touchEndCallback) {
                    this.touchEndCallback.call(this.callbackContext, event);
                }
                if (this.preventDefault) {
                    event.preventDefault();
                }

                var j = 0;
                for (; j < event.changedTouches.length; j++) {
                    this.game.input.stopPointer(event.changedTouches[j]);
                }
            },

            "stop": function () {
                if (this.game.device.touch) {
                    this.game.canvas.removeEventListener('touchstart', this._onTouchStart);
                    this.game.canvas.removeEventListener('touchmove', this._onTouchMove);
                    this.game.canvas.removeEventListener('touchend', this._onTouchEnd);
                    this.game.canvas.removeEventListener('touchenter', this._onTouchEnter);
                    this.game.canvas.removeEventListener('touchleave', this._onTouchLeave);
                    this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel);
                }
            }
        };
        $.Touch.prototype.constructor = $.Touch;

        $.InputHandler = function (dataAndEvents) {
            this.sprite = dataAndEvents;
            this.game = dataAndEvents.game;

            this.enabled = false;

            this.checked = false;

            this.priorityID = 0;

            this.useHandCursor = false;

            this._setHandCursor = false;

            this.isDragged = false;

            this.allowHorizontalDrag = true;

            this.allowVerticalDrag = true;

            this.bringToTop = false;

            this.snapOffset = null;

            this.snapOnDrag = false;

            this.snapOnRelease = false;

            this.snapX = 0;

            this.snapY = 0;

            this.snapOffsetX = 0;

            this.snapOffsetY = 0;

            this.pixelPerfectOver = false;

            this.pixelPerfectClick = false;

            this.pixelPerfectAlpha = 255;

            this.draggable = false;

            this.boundsRect = null;

            this.boundsSprite = null;

            this.scaleLayer = false;
            this.dragOffset = new($.Point);

            this.dragFromCenter = false;

            this.dragStopBlocksInputUp = false;
            this.dragStartPoint = new $.Point;

            this.dragDistanceThreshold = 0;

            this.dragTimeThreshold = 0;
            this.downPoint = new($.Point);
            this.snapPoint = new($.Point);
            this._dragPoint = new($.Point);

            this._dragPhase = false;

            this._pendingDrag = false;

            this._dragTimePass = false;

            this._dragDistancePass = false;

            this._wasEnabled = false;
            this._tempPoint = new $.Point;

            this._pointerData = [];
            this._pointerData.push({
                "id": 0,
                "x": 0,
                "y": 0,
                "camX": 0,
                "camY": 0,
                "isDown": false,
                "isUp": false,
                "isOver": false,
                "isOut": false,
                "timeOver": 0,
                "timeOut": 0,
                "timeDown": 0,
                "timeUp": 0,
                "downDuration": 0,
                "isDragged": false
            });
        };
        $.InputHandler.prototype = {

            "start": function (ui, onFailed) {
                if (ui = ui || 0, void 0 === onFailed && (onFailed = false), false === this.enabled) {
                    this.game.input.interactiveItems.add(this);

                    this.useHandCursor = onFailed;

                    this.priorityID = ui;

                    var i = 0;
                    for (; i < 10; i++) {
                        this._pointerData[i] = {
                            "id": i,
                            "x": 0,
                            "y": 0,
                            "isDown": false,
                            "isUp": false,
                            "isOver": false,
                            "isOut": false,
                            "timeOver": 0,
                            "timeOut": 0,
                            "timeDown": 0,
                            "timeUp": 0,
                            "downDuration": 0,
                            "isDragged": false
                        };
                    }
                    this.snapOffset = new($.Point);

                    this.enabled = true;

                    this._wasEnabled = true;
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite;
            },

            "addedToGroup": function () {
                if (!this._dragPhase) {
                    if (this._wasEnabled) {
                        if (!this.enabled) {
                            this.start();
                        }
                    }
                }
            },

            "removedFromGroup": function () {
                if (!this._dragPhase) {
                    if (this.enabled) {

                        this._wasEnabled = true;
                        this.stop();
                    } else {

                        this._wasEnabled = false;
                    }
                }
            },

            "reset": function () {

                this.enabled = false;

                var i = 0;
                for (; i < 10; i++) {
                    this._pointerData[i] = {
                        "id": i,
                        "x": 0,
                        "y": 0,
                        "isDown": false,
                        "isUp": false,
                        "isOver": false,
                        "isOut": false,
                        "timeOver": 0,
                        "timeOut": 0,
                        "timeDown": 0,
                        "timeUp": 0,
                        "downDuration": 0,
                        "isDragged": false
                    };
                }
            },

            "stop": function () {
                if (false !== this.enabled) {

                    this.enabled = false;
                    this.game.input.interactiveItems.remove(this);
                }
            },

            "destroy": function () {
                if (this.sprite) {
                    if (this._setHandCursor) {

                        this.game.canvas.style.cursor = "";

                        this._setHandCursor = false;
                    }

                    this.enabled = false;
                    this.game.input.interactiveItems.remove(this);

                    this._pointerData.length = 0;

                    this.boundsRect = null;

                    this.boundsSprite = null;

                    this.sprite = null;
                }
            },

            "validForInput": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
                return void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = true), !(!this.enabled || (0 === this.sprite.scale.x || (0 === this.sprite.scale.y || (this.priorityID < this.game.input.minPriorityID || (this.sprite.parent && this.sprite.parent.ignoreChildInput || (!ignoreMethodDoesntExist && (this.pixelPerfectClick || this.pixelPerfectOver) || !(this.priorityID > dataAndEvents ||
                    this.priorityID === dataAndEvents && this.sprite.renderOrderID > deepDataAndEvents)))))));
            },

            "isPixelPerfect": function () {
                return this.pixelPerfectClick || this.pixelPerfectOver;
            },

            "pointerX": function (ev) {
                return ev = ev || 0, this._pointerData[ev].x;
            },

            "pointerY": function (z) {
                return z = z || 0, this._pointerData[z].y;
            },

            "pointerDown": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].isDown;
            },

            "pointerUp": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].isUp;
            },

            "pointerTimeDown": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].timeDown;
            },

            "pointerTimeUp": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].timeUp;
            },

            "pointerOver": function (event) {
                if (!this.enabled) {
                    return false;
                }
                if (void 0 === event) {

                    var unlock = 0;
                    for (; unlock < 10; unlock++) {
                        if (this._pointerData[unlock].isOver) {
                            return true;
                        }
                    }
                    return false;
                }
                return this._pointerData[event].isOver;
            },

            "pointerOut": function (event) {
                if (!this.enabled) {
                    return false;
                }
                if (void 0 !== event) {
                    return this._pointerData[event].isOut;
                }

                var unlock = 0;
                for (; unlock < 10; unlock++) {
                    if (this._pointerData[unlock].isOut) {
                        return true;
                    }
                }
            },

            "pointerTimeOver": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].timeOver;
            },

            "pointerTimeOut": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].timeOut;
            },

            "pointerDragged": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].isDragged;
            },

            "checkPointerDown": function (deepDataAndEvents, dataAndEvents) {
                return !!(deepDataAndEvents.isDown && (this.enabled && (this.sprite && (this.sprite.parent && (this.sprite.visible && (this.sprite.parent.visible && (0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y))))))) && (!!this.game.input.hitTest(this.sprite, deepDataAndEvents, this._tempPoint) && (void 0 === dataAndEvents && (dataAndEvents =
                    false), !(!dataAndEvents && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)));
            },

            "checkPointerOver": function (pointer, dataAndEvents) {
                return !!(this.enabled && (this.sprite && (this.sprite.parent && (this.sprite.visible && (this.sprite.parent.visible && (0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y)))))) && (!!this.game.input.hitTest(this.sprite, pointer, this._tempPoint) && (void 0 === dataAndEvents && (dataAndEvents = false), !(!dataAndEvents && this.pixelPerfectOver) ||
                    this.checkPixel(this._tempPoint.x, this._tempPoint.y)));
            },

            "checkPixel": function (x, y, deepDataAndEvents) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === x && null === y) {
                        this.game.input.getLocalPosition(this.sprite, deepDataAndEvents, this._tempPoint);
                        x = this._tempPoint.x;
                        y = this._tempPoint.y;
                    }
                    if (0 !== this.sprite.anchor.x && (x -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (y -= -this.sprite.texture.frame.height * this.sprite.anchor.y), x += this.sprite.texture.frame.x, y += this.sprite.texture.frame.y, this.sprite.texture.trim &&
                        (x -= this.sprite.texture.trim.x, y -= this.sprite.texture.trim.y, x < this.sprite.texture.crop.x || (x > this.sprite.texture.crop.right || (y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom)))) {
                        return this._dx = x, this._dy = y, false;
                    }
                    if (this._dx = x, this._dy = y, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) {
                        return true;
                    }
                }
                return false;
            },

            "update": function (names) {
                if (null !== this.sprite && void 0 !== this.sprite.parent) {
                    return this.enabled && (this.sprite.visible && this.sprite.parent.visible) ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = $.Math.distance(names.x, names.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && (this._dragTimePass && this.startDrag(names)), true) : this.draggable && this._draggedPointerID === names.id ?
                        this.updateDrag(names, false) : this._pointerData[names.id].isOver ? this.checkPointerOver(names) ? (this._pointerData[names.id].x = names.x - this.sprite.x, this._pointerData[names.id].y = names.y - this.sprite.y, true) : (this._pointerOutHandler(names), false) : void 0 : (this._pointerOutHandler(names), false);
                }
            },

            "_pointerOverHandler": function (p2, dataAndEvents) {
                if (null !== this.sprite) {
                    var urls = this._pointerData[p2.id];
                    if (false === urls.isOver || p2.dirty) {

                        var _0x2d010e = false === urls.isOver;

                        urls.isOver = true;

                        urls.isOut = false;
                        urls.timeOver = this.game.time.time;

                        urls.x = p2.x - this.sprite.x;

                        urls.y = p2.y - this.sprite.y;
                        if (this.useHandCursor) {
                            if (false === urls.isDragged) {

                                this.game.canvas.style.cursor = "pointer";

                                this._setHandCursor = true;
                            }
                        }
                        if (!dataAndEvents) {
                            if (_0x2d010e) {
                                if (this.sprite) {
                                    if (this.sprite.events) {
                                        this.sprite.events.onInputOver$dispatch(this.sprite, p2);
                                    }
                                }
                            }
                        }
                        if (this.sprite.parent) {
                            if (this.sprite.parent.onChildInputOver) {
                                this.sprite.parent.onChildInputOver.dispatch(this.sprite, p2);
                            }
                        }
                    }
                }
            },

            "_pointerOutHandler": function (done, dataAndEvents) {
                if (null !== this.sprite) {
                    var isDragged = this._pointerData[done.id];

                    isDragged.isOver = false;

                    isDragged.isOut = true;
                    isDragged.timeOut = this.game.time.time;
                    if (this.useHandCursor) {
                        if (false === isDragged.isDragged) {

                            this.game.canvas.style.cursor = "";

                            this._setHandCursor = false;
                        }
                    }
                    if (!dataAndEvents) {
                        if (this.sprite) {
                            if (this.sprite.events) {
                                this.sprite.events.onInputOut$dispatch(this.sprite, done);
                                if (this.sprite) {
                                    if (this.sprite.parent) {
                                        if (this.sprite.parent.onChildInputOut) {
                                            this.sprite.parent.onChildInputOut.dispatch(this.sprite, done);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            "_touchedHandler": function (urls) {
                if (null !== this.sprite) {
                    var currentMonster = this._pointerData[urls.id];
                    if (!currentMonster.isDown && currentMonster.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, urls)) {
                            return;
                        }
                        if (currentMonster.isDown = true, currentMonster.isUp = false, currentMonster.timeDown = this.game.time.time, this.downPoint.set(urls.x, urls.y), urls.dirty = true, this.sprite && (this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, urls), this.sprite && (this.sprite.parent && (this.sprite.parent.onChildInputDown &&
                                this.sprite.parent.onChildInputDown.dispatch(this.sprite, urls))), null === this.sprite))) {
                            return;
                        }
                        if (this.draggable) {
                            if (false === this.isDragged) {
                                if (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold) {
                                    this.startDrag(urls);
                                } else {

                                    this._pendingDrag = true;

                                    this._dragDistancePass = 0 === this.dragDistanceThreshold;
                                    if (this.dragTimeThreshold > 0) {

                                        this._dragTimePass = false;
                                        this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, urls);
                                    } else {

                                        this._dragTimePass = true;
                                    }
                                }
                            }
                        }
                        if (this.bringToTop) {
                            this.sprite.bringToTop();
                        }
                    }
                }
            },

            "dragTimeElapsed": function (deepDataAndEvents) {

                this._dragTimePass = true;
                if (this._pendingDrag) {
                    if (this.sprite) {
                        if (this._dragDistancePass) {
                            this.startDrag(deepDataAndEvents);
                        }
                    }
                }
            },

            "_releasedHandler": function (current) {
                if (null !== this.sprite) {
                    var newPoints = this._pointerData[current.id];
                    if (newPoints.isDown && current.isUp) {

                        newPoints.isDown = false;

                        newPoints.isUp = true;
                        newPoints.timeUp = this.game.time.time;

                        newPoints.downDuration = newPoints.timeUp - newPoints.timeDown;
                        var delimiter_index = this.checkPointerOver(current);
                        if (this.sprite) {
                            if (this.sprite.events) {
                                if (!(this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && (this.isDragged && this._draggedPointerID === current.id)))) {
                                    this.sprite.events.onInputUp$dispatch(this.sprite, current, delimiter_index);
                                }
                                if (this.sprite) {
                                    if (this.sprite.parent) {
                                        if (this.sprite.parent.onChildInputUp) {
                                            this.sprite.parent.onChildInputUp.dispatch(this.sprite, current, delimiter_index);
                                        }
                                    }
                                }
                                if (delimiter_index) {
                                    delimiter_index = this.checkPointerOver(current);
                                }
                            }
                        }
                        newPoints.isOver = delimiter_index;
                        if (!delimiter_index) {
                            if (this.useHandCursor) {
                                this.game.canvas.style.cursor = 'default';

                                this._setHandCursor = false;
                            }
                        }

                        current.dirty = true;

                        this._pendingDrag = false;
                        if (this.draggable) {
                            if (this.isDragged) {
                                if (this._draggedPointerID === current.id) {
                                    this.stopDrag(current);
                                }
                            }
                        }
                    }
                }
            },

            "updateDrag": function (done, pointer) {
                if (void 0 === pointer && (pointer = false), done.isUp) {
                    return this.stopDrag(done), false;
                }
                var s = this.globalToLocal(done);
                if (this.sprite.fixedToCamera) {
                    var x = this.game.camera.scale.x * s.x + this._dragPoint.x + this.dragOffset.x;
                    var y = this.game.camera.scale.y * s.y + this._dragPoint.y + this.dragOffset.y;
                } else {
                    x = s.x + this._dragPoint.x + this.dragOffset.x;
                    y = s.y + this._dragPoint.y + this.dragOffset.y;
                }
                if (this.sprite.fixedToCamera) {
                    if (this.allowHorizontalDrag) {

                        this.sprite.cameraOffset.x = x - this.game.camera.x;
                    }
                    if (this.allowVerticalDrag) {

                        this.sprite.cameraOffset.y = y - this.game.camera.y;
                    }
                    if (this.boundsRect) {
                        this.checkBoundsRect();
                    }
                    if (this.boundsSprite) {
                        this.checkBoundsSprite();
                    }
                    if (this.snapOnDrag) {

                        this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;

                        this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                        this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y);
                    }
                } else {

                    var delta = this.game.camera.x - this._pointerData[done.id].camX;

                    var padding = this.game.camera.y - this._pointerData[done.id].camY;
                    if (this.allowHorizontalDrag) {
                        this.sprite.x = x + delta;
                    }
                    if (this.allowVerticalDrag) {
                        this.sprite.y = y + padding;
                    }
                    if (this.boundsRect) {
                        this.checkBoundsRect();
                    }
                    if (this.boundsSprite) {
                        this.checkBoundsSprite();
                    }
                    if (this.snapOnDrag) {

                        this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;

                        this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                        this.snapPoint.set(this.sprite.x, this.sprite.y);
                    }
                }
                return this.sprite.events.onDragUpdate.dispatch(this.sprite, done, x, y, this.snapPoint, pointer), true;
            },

            "justOver": function (pointer, delay) {
                return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isOver && this.overDuration(pointer) < delay;
            },

            "justOut": function (pointer, delay) {
                return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isOut && this.game.time.time - this._pointerData[pointer].timeOut < delay;
            },

            "justPressed": function (pointer, delay) {
                return pointer = pointer || 0, delay = delay || 500, this._pointerData[pointer].isDown && this.downDuration(pointer) < delay;
            },

            "justReleased": function (duration, pointer) {
                return duration = duration || 0, pointer = pointer || 500, this._pointerData[duration].isUp && this.game.time.time - this._pointerData[duration].timeUp < pointer;
            },

            "overDuration": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].isOver ? this.game.time.time - this._pointerData[pointer].timeOver : -1;
            },

            "downDuration": function (pointer) {
                return pointer = pointer || 0, this._pointerData[pointer].isDown ? this.game.time.time - this._pointerData[pointer].timeDown : -1;
            },

            "enableDrag": function (alphaThreshold, bringToTop, lockCenter, boundsSprite, boundsRect, pixelPerfect) {
                if (void 0 === alphaThreshold) {

                    alphaThreshold = false;
                }
                if (void 0 === bringToTop) {

                    bringToTop = false;
                }
                if (void 0 === lockCenter) {

                    lockCenter = false;
                }
                if (void 0 === boundsSprite) {

                    boundsSprite = 255;
                }
                if (void 0 === boundsRect) {

                    boundsRect = null;
                }
                if (void 0 === pixelPerfect) {

                    pixelPerfect = null;
                }
                this._dragPoint = new($.Point);

                this.draggable = true;

                this.bringToTop = bringToTop;
                this.dragOffset = new $.Point;

                this.dragFromCenter = alphaThreshold;

                this.pixelPerfectClick = lockCenter;

                this.pixelPerfectAlpha = boundsSprite;
                if (boundsRect) {

                    this.boundsRect = boundsRect;
                }
                if (pixelPerfect) {

                    this.boundsSprite = pixelPerfect;
                }
            },

            "disableDrag": function () {
                if (this._pointerData) {

                    var unlock = 0;
                    for (; unlock < 10; unlock++) {

                        this._pointerData[unlock].isDragged = false;
                    }
                }

                this.draggable = false;

                this.isDragged = false;

                this._draggedPointerID = -1;

                this._pendingDrag = false;
            },

            "startDrag": function (p1) {
                var val = this.sprite.x;
                var typename = this.sprite.y;
                var ad = this.globalToLocal(p1);
                if (this.isDragged = true, this._draggedPointerID = p1.id, this._pointerData[p1.id].camX = this.game.camera.x, this._pointerData[p1.id].camY = this.game.camera.y, this._pointerData[p1.id].isDragged = true, this.sprite.fixedToCamera) {
                    if (this.dragFromCenter) {
                        var _0x25e103 = this.sprite.getBounds();
                        var pointB = this.globalToLocal(new($.Point)(_0x25e103.centerX, _0x25e103.centerY));
                        this.sprite.cameraOffset.x = ad.x + (this.sprite.cameraOffset.x - pointB.x);
                        this.sprite.cameraOffset.y = ad.y + (this.sprite.cameraOffset.y - pointB.y);
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - p1.x, this.sprite.cameraOffset.y - p1.y);
                } else {
                    if (this.dragFromCenter) {
                        _0x25e103 = this.sprite.getBounds();
                        pointB = this.globalToLocal(new($.Point)(_0x25e103.centerX, _0x25e103.centerY));
                        this.sprite.x = ad.x + (this.sprite.x - pointB.x);
                        this.sprite.y = ad.y + (this.sprite.y - pointB.y);
                    }
                    this._dragPoint.setTo(this.sprite.x - ad.x, this.sprite.y - ad.y);
                }
                this.updateDrag(p1, true);
                if (this.bringToTop) {

                    this._dragPhase = true;
                    this.sprite.bringToTop();
                }
                this.dragStartPoint.set(val, typename);
                this.sprite.events.onDragStart$dispatch(this.sprite, p1, val, typename);

                this._pendingDrag = false;
            },

            "globalToLocalX": function (dataAndEvents) {
                return this.scaleLayer && (dataAndEvents -= this.game.scale.grid.boundsFluid.x, dataAndEvents *= this.game.scale.grid.scaleFluidInversed.x), dataAndEvents;
            },

            "globalToLocalY": function (dataAndEvents) {
                return this.scaleLayer && (dataAndEvents -= this.game.scale.grid.boundsFluid.y, dataAndEvents *= this.game.scale.grid.scaleFluidInversed.y), dataAndEvents;
            },

            "globalToLocal": function (verts) {
                return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                    "x": verts.x,
                    "y": verts.y
                }) : verts;
            },

            "stopDrag": function (done) {

                this.isDragged = false;

                this._draggedPointerID = -1;

                this._pointerData[done.id].isDragged = false;

                this._dragPhase = false;

                this._pendingDrag = false;
                if (this.snapOnRelease) {
                    if (this.sprite.fixedToCamera) {

                        this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;

                        this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                    } else {

                        this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX;

                        this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY;
                    }
                }
                this.sprite.events.onDragStop$dispatch(this.sprite, done);
                if (false === this.checkPointerOver(done)) {
                    this._pointerOutHandler(done);
                }
            },

            "setDragLock": function (allowHorizontal, allowVertical) {
                if (void 0 === allowHorizontal) {

                    allowHorizontal = true;
                }
                if (void 0 === allowVertical) {

                    allowVertical = true;
                }

                this.allowHorizontalDrag = allowHorizontal;

                this.allowVerticalDrag = allowVertical;
            },

            "enableSnap": function (snapX, snapY, dataAndEvents, onDrag, deepDataAndEvents, onRelease) {
                if (void 0 === dataAndEvents) {

                    dataAndEvents = true;
                }
                if (void 0 === onDrag) {

                    onDrag = false;
                }
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = 0;
                }
                if (void 0 === onRelease) {

                    onRelease = 0;
                }
                this.snapX = snapX;
                this.snapY = snapY;

                this.snapOffsetX = deepDataAndEvents;

                this.snapOffsetY = onRelease;

                this.snapOnDrag = dataAndEvents;

                this.snapOnRelease = onDrag;
            },

            "disableSnap": function () {

                this.snapOnDrag = false;

                this.snapOnRelease = false;
            },

            "checkBoundsRect": function () {
                if (this.sprite.fixedToCamera) {
                    if (this.sprite.cameraOffset.x < this.boundsRect.left) {
                        this.sprite.cameraOffset.x = this.boundsRect.left;
                    } else {
                        if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right) {

                            this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;
                        }
                    }
                    if (this.sprite.cameraOffset.y < this.boundsRect.top) {
                        this.sprite.cameraOffset.y = this.boundsRect.top;
                    } else {
                        if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom) {

                            this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;
                        }
                    }
                } else {
                    if (this.sprite.left < this.boundsRect.left) {
                        this.sprite.x = this.boundsRect.x + this.sprite.offsetX;
                    } else {
                        if (this.sprite.right > this.boundsRect.right) {

                            this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX);
                        }
                    }
                    if (this.sprite.top < this.boundsRect.top) {
                        this.sprite.y = this.boundsRect.top + this.sprite.offsetY;
                    } else {
                        if (this.sprite.bottom > this.boundsRect.bottom) {

                            this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY);
                        }
                    }
                }
            },

            "checkBoundsSprite": function () {
                if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) {
                    if (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x) {
                        this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x;
                    } else {
                        if (this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width) {

                            this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width;
                        }
                    }
                    if (this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y) {
                        this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y;
                    } else {
                        if (this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height) {

                            this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height;
                        }
                    }
                } else {
                    if (this.sprite.left < this.boundsSprite.left) {
                        this.sprite.x = this.boundsSprite.left + this.sprite.offsetX;
                    } else {
                        if (this.sprite.right > this.boundsSprite.right) {

                            this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX);
                        }
                    }
                    if (this.sprite.top < this.boundsSprite.top) {
                        this.sprite.y = this.boundsSprite.top + this.sprite.offsetY;
                    } else {
                        if (this.sprite.bottom > this.boundsSprite.bottom) {

                            this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY);
                        }
                    }
                }
            }
        };
        $.InputHandler.prototype.constructor = $.InputHandler;

        $.Gamepad = function (dataAndEvents) {
            this.game = dataAndEvents;
            this._gamepadIndexMap = {};

            this._rawPads = [];

            this._active = false;

            this.enabled = true;

            this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || (!!navigator.webkitGamepads || (-1 !== navigator.userAgent.indexOf('Firefox/') || !!navigator.getGamepads));

            this._prevRawGamepadTypes = [];

            this._prevTimestamps = [];
            this.callbackContext = this;

            this.onConnectCallback = null;

            this.onDisconnectCallback = null;

            this.onDownCallback = null;

            this.onUpCallback = null;

            this.onAxisCallback = null;

            this.onFloatCallback = null;

            this._ongamepadconnected = null;

            this._gamepaddisconnected = null;

            this._gamepads = [new $.SinglePad(dataAndEvents, this), new $.SinglePad(dataAndEvents, this), new $.SinglePad(dataAndEvents, this), new($.SinglePad)(dataAndEvents, this)];
        };
        $.Gamepad.prototype = {

            "addCallbacks": function (opt_scope, eb) {
                if (void 0 !== eb) {
                    this.onConnectCallback = 'function' == typeof eb.onConnect ? eb.onConnect : this.onConnectCallback;
                    this.onDisconnectCallback = 'function' == typeof eb.onDisconnect ? eb.onDisconnect : this.onDisconnectCallback;
                    this.onDownCallback = "function" == typeof eb.onDown ? eb.onDown : this.onDownCallback;
                    this.onUpCallback = 'function' == typeof eb.onUp ? eb.onUp : this.onUpCallback;
                    this.onAxisCallback = 'function' == typeof eb.onAxis ? eb.onAxis : this.onAxisCallback;
                    this.onFloatCallback = 'function' == typeof eb.onFloat ? eb.onFloat : this.onFloatCallback;
                    this.callbackContext = opt_scope;
                }
            },

            "start": function () {
                if (!this._active) {

                    this._active = true;
                    var collection = this;

                    this._onGamepadConnected = function (resp) {
                        return collection.onGamepadConnected(resp);
                    };

                    this._onGamepadDisconnected = function (resp) {
                        return collection.onGamepadDisconnected(resp);
                    };
                    window.addEventListener('gamepadconnected', this._onGamepadConnected, false);
                    window.addEventListener('gamepaddisconnected', this._onGamepadDisconnected, false);
                }
            },

            "onGamepadConnected": function (deps) {
                var dep = deps.gamepad;
                this._rawPads.push(dep);
                this._gamepads[dep.index].connect(dep);
            },

            "onGamepadDisconnected": function ($cookies) {
                var value = $cookies.gamepad;
                var eventType;
                for (eventType in this._rawPads) {
                    if (this._rawPads[eventType].index === value.index) {
                        this._rawPads.splice(eventType, 1);
                    }
                }
                this._gamepads[value.index].disconnect();
            },

            "update": function () {
                this._pollGamepads();
                this.pad1.pollStatus();
                this.pad2.pollStatus();
                this.pad3.pollStatus();
                this.pad4.pollStatus();
            },

            "_pollGamepads": function () {
                if (this._active) {
                    if (navigator.getGamepads) {
                        o = navigator.getGamepads();
                    } else {
                        if (navigator.webkitGetGamepads) {
                            o = navigator.webkitGetGamepads();
                        } else {
                            if (navigator.webkitGamepads) {
                                var o = navigator.webkitGamepads()
                            }
                        }
                    }
                    if (o) {

                        this._rawPads = [];

                        var _0x3003dc = false;

                        var m = 0;
                        for (; m < o.length && (typeof o[m] !== this._prevRawGamepadTypes[m] && (_0x3003dc = true, this._prevRawGamepadTypes[m] = typeof o[m]), o[m] && this._rawPads.push(o[m]), 3 !== m); m++) {}

                        var unlock = 0;
                        for (; unlock < this._gamepads.length; unlock++) {
                            this._gamepads[unlock]._rawPad = this._rawPads[unlock];
                        }
                        if (_0x3003dc) {
                            var route;
                            var results = {
                                "rawIndices": {},
                                "padIndices": {}
                            };

                            var j = 0;
                            for (; j < this._gamepads.length; j++) {
                                if ((route = this._gamepads[j]).connected) {

                                    var i = 0;
                                    for (; i < this._rawPads.length; i++) {
                                        if (this._rawPads[i].index === route.index) {

                                            results.rawIndices[route.index] = true;

                                            results.padIndices[j] = true;
                                        }
                                    }
                                }
                            }

                            var key = 0;
                            for (; key < this._gamepads.length; key++) {
                                if (route = this._gamepads[key], !results.padIndices[key]) {
                                    if (this._rawPads.length < 1) {
                                        route.disconnect();
                                    }

                                    var argsIndex = 0;
                                    for (; argsIndex < this._rawPads.length && !results.padIndices[key]; argsIndex++) {
                                        var iteratee = this._rawPads[argsIndex];
                                        if (iteratee) {
                                            if (results.rawIndices[iteratee.index]) {
                                                route.disconnect();
                                                continue;
                                            }
                                            route.connect(iteratee);

                                            results.rawIndices[iteratee.index] = true;

                                            results.padIndices[key] = true;
                                        } else {
                                            route.disconnect();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            "setDeadZones": function (dataAndEvents) {

                var unlock = 0;
                for (; unlock < this._gamepads.length; unlock++) {
                    this._gamepads[unlock].deadZone = dataAndEvents;
                }
            },

            "stop": function () {

                this._active = false;
                window.removeEventListener("gamepadconnected", this._onGamepadConnected);
                window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnected);
            },

            "reset": function () {
                this.update();

                var unlock = 0;
                for (; unlock < this._gamepads.length; unlock++) {
                    this._gamepads[unlock].reset();
                }
            },

            "justPressed": function (delay, pointer) {

                var unlock = 0;
                for (; unlock < this._gamepads.length; unlock++) {
                    if (true === this._gamepads[unlock].justPressed(delay, pointer)) {
                        return true;
                    }
                }
                return false;
            },

            "justReleased": function (delay, pointer) {

                var unlock = 0;
                for (; unlock < this._gamepads.length; unlock++) {
                    if (true === this._gamepads[unlock].justReleased(delay, pointer)) {
                        return true;
                    }
                }
                return false;
            },

            "isDown": function (keyCode) {

                var i = 0;
                for (; i < this._gamepads.length; i++) {
                    if (true === this._gamepads[i].isDown(keyCode)) {
                        return true;
                    }
                }
                return false;
            },

            "destroy": function () {
                this.stop();

                var unlock = 0;
                for (; unlock < this._gamepads.length; unlock++) {
                    this._gamepads[unlock].destroy();
                }
            }
        };
        $.Gamepad.prototype.constructor = $.Gamepad;
        Object.defineProperty($.Gamepad.prototype, 'active', {

            "get": function () {
                return this._active;
            }
        });
        Object.defineProperty($.Gamepad.prototype, "supported", {

            "get": function () {
                return this._gamepadSupportAvailable;
            }
        });
        Object.defineProperty($.Gamepad.prototype, 'padsConnected', {

            "get": function () {
                return this._rawPads.length;
            }
        });
        Object.defineProperty($.Gamepad.prototype, "pad1", {

            "get": function () {
                return this._gamepads[0];
            }
        });
        Object.defineProperty($.Gamepad.prototype, 'pad2', {

            "get": function () {
                return this._gamepads[1];
            }
        });
        Object.defineProperty($.Gamepad.prototype, "pad3", {

            "get": function () {
                return this._gamepads[2];
            }
        });
        Object.defineProperty($.Gamepad.prototype, 'pad4', {

            "get": function () {
                return this._gamepads[3];
            }
        });

        $.Gamepad.BUTTON_0 = 0;

        $.Gamepad.BUTTON_1 = 1;

        $.Gamepad.BUTTON_2 = 2;

        $.Gamepad.BUTTON_3 = 3;

        $.Gamepad.BUTTON_4 = 4;

        $.Gamepad.BUTTON_5 = 5;

        $.Gamepad.BUTTON_6 = 6;

        $.Gamepad.BUTTON_7 = 7;

        $.Gamepad.BUTTON_8 = 8;

        $.Gamepad.BUTTON_9 = 9;

        $.Gamepad.BUTTON_10 = 10;

        $.Gamepad.BUTTON_11 = 11;

        $.Gamepad.BUTTON_12 = 12;

        $.Gamepad.BUTTON_13 = 13;

        $.Gamepad.BUTTON_14 = 14;

        $.Gamepad.BUTTON_15 = 15;

        $.Gamepad.AXIS_0 = 0;

        $.Gamepad.AXIS_1 = 1;

        $.Gamepad.AXIS_2 = 2;

        $.Gamepad.AXIS_3 = 3;

        $.Gamepad.AXIS_4 = 4;

        $.Gamepad.AXIS_5 = 5;

        $.Gamepad.AXIS_6 = 6;

        $.Gamepad.AXIS_7 = 7;

        $.Gamepad.AXIS_8 = 8;

        $.Gamepad.AXIS_9 = 9;

        $.Gamepad.XBOX360_A = 0;

        $.Gamepad.XBOX360_B = 1;

        $.Gamepad.XBOX360_X = 2;

        $.Gamepad.XBOX360_Y = 3;

        $.Gamepad.XBOX360_LEFT_BUMPER = 4;

        $.Gamepad.XBOX360_RIGHT_BUMPER = 5;

        $.Gamepad.XBOX360_LEFT_TRIGGER = 6;

        $.Gamepad.XBOX360_RIGHT_TRIGGER = 7;

        $.Gamepad.XBOX360_BACK = 8;

        $.Gamepad.XBOX360_START = 9;

        $.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;

        $.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;

        $.Gamepad.XBOX360_DPAD_LEFT = 14;

        $.Gamepad.XBOX360_DPAD_RIGHT = 15;

        $.Gamepad.XBOX360_DPAD_UP = 12;

        $.Gamepad.XBOX360_DPAD_DOWN = 13;

        $.Gamepad.XBOX360_STICK_LEFT_X = 0;

        $.Gamepad.XBOX360_STICK_LEFT_Y = 1;

        $.Gamepad.XBOX360_STICK_RIGHT_X = 2;

        $.Gamepad.XBOX360_STICK_RIGHT_Y = 3;

        $.Gamepad.PS3XC_X = 0;

        $.Gamepad.PS3XC_CIRCLE = 1;

        $.Gamepad.PS3XC_SQUARE = 2;

        $.Gamepad.PS3XC_TRIANGLE = 3;

        $.Gamepad.PS3XC_L1 = 4;

        $.Gamepad.PS3XC_R1 = 5;

        $.Gamepad.PS3XC_L2 = 6;

        $.Gamepad.PS3XC_R2 = 7;

        $.Gamepad.PS3XC_SELECT = 8;

        $.Gamepad.PS3XC_START = 9;

        $.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10;

        $.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11;

        $.Gamepad.PS3XC_DPAD_UP = 12;

        $.Gamepad.PS3XC_DPAD_DOWN = 13;

        $.Gamepad.PS3XC_DPAD_LEFT = 14;

        $.Gamepad.PS3XC_DPAD_RIGHT = 15;

        $.Gamepad.PS3XC_STICK_LEFT_X = 0;

        $.Gamepad.PS3XC_STICK_LEFT_Y = 1;

        $.Gamepad.PS3XC_STICK_RIGHT_X = 2;

        $.Gamepad.PS3XC_STICK_RIGHT_Y = 3;

        $.SinglePad = function (dataAndEvents, deepDataAndEvents) {
            this.game = dataAndEvents;

            this.index = null;

            this.connected = false;
            this.callbackContext = this;

            this.onConnectCallback = null;

            this.onDisconnectCallback = null;

            this.onDownCallback = null;

            this.onUpCallback = null;

            this.onAxisCallback = null;

            this.onFloatCallback = null;

            this.deadZone = 0.26;
            this._padParent = deepDataAndEvents;

            this._rawPad = null;

            this._prevTimestamp = null;

            this._buttons = [];

            this._buttonsLen = 0;

            this._axes = [];

            this._axesLen = 0;
        };
        $.SinglePad.prototype = {

            "addCallbacks": function (opt_scope, eb) {
                if (void 0 !== eb) {
                    this.onConnectCallback = 'function' == typeof eb.onConnect ? eb.onConnect : this.onConnectCallback;
                    this.onDisconnectCallback = "function" == typeof eb.onDisconnect ? eb.onDisconnect : this.onDisconnectCallback;
                    this.onDownCallback = "function" == typeof eb.onDown ? eb.onDown : this.onDownCallback;
                    this.onUpCallback = 'function' == typeof eb.onUp ? eb.onUp : this.onUpCallback;
                    this.onAxisCallback = "function" == typeof eb.onAxis ? eb.onAxis : this.onAxisCallback;
                    this.onFloatCallback = 'function' == typeof eb.onFloat ? eb.onFloat : this.onFloatCallback;
                    this.callbackContext = opt_scope;
                }
            },

            "getButton": function (ev) {
                return this._buttons[ev] ? this._buttons[ev] : null;
            },

            "pollStatus": function () {
                if (this.connected && (this.game.input.enabled && (this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)))) {

                    var i = 0;
                    for (; i < this._buttonsLen; i++) {
                        var r20 = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i];
                        if (r20 !== this._buttons[i].value) {
                            if (1 === r20) {
                                this.processButtonDown(i, r20);
                            } else {
                                if (0 === r20) {
                                    this.processButtonUp(i, r20);
                                } else {
                                    this.processButtonFloat(i, r20);
                                }
                            }
                        }
                    }

                    var lastIndex = 0;
                    for (; lastIndex < this._axesLen; lastIndex++) {
                        var target = this._rawPad.axes[lastIndex];
                        if (target > 0 && target > this.deadZone || target < 0 && target < -this.deadZone) {
                            this.processAxisChange(lastIndex, target);
                        } else {
                            this.processAxisChange(lastIndex, 0);
                        }
                    }
                    this._prevTimestamp = this._rawPad.timestamp;
                }
            },

            "connect": function (res) {

                var _0x5166e2 = !this.connected;

                this.connected = true;
                this.index = res.index;
                this._rawPad = res;

                this._buttons = [];
                this._buttonsLen = res.buttons.length;

                this._axes = [];
                this._axesLen = res.axes.length;

                var length = 0;
                for (; length < this._axesLen; length++) {
                    this._axes[length] = res.axes[length];
                }
                var mode;
                for (mode in res.buttons) {

                    mode = parseInt(mode, 10);
                    this._buttons[mode] = new($.DeviceButton)(this, mode);
                }
                if (_0x5166e2) {
                    if (this._padParent.onConnectCallback) {
                        this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index);
                    }
                }
                if (_0x5166e2) {
                    if (this.onConnectCallback) {
                        this.onConnectCallback.call(this.callbackContext);
                    }
                }
            },

            "disconnect": function () {
                var connected = this.connected;
                var r20 = this.index;

                this.connected = false;

                this.index = null;
                this._rawPad = void 0;

                var unlock = 0;
                for (; unlock < this._buttonsLen; unlock++) {
                    this._buttons[unlock].destroy();
                }

                this._buttons = [];

                this._buttonsLen = 0;

                this._axes = [];

                this._axesLen = 0;
                if (connected) {
                    if (this._padParent.onDisconnectCallback) {
                        this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, r20);
                    }
                }
                if (connected) {
                    if (this.onDisconnectCallback) {
                        this.onDisconnectCallback.call(this.callbackContext);
                    }
                }
            },

            "destroy": function () {
                this._rawPad = void 0;

                var unlock = 0;
                for (; unlock < this._buttonsLen; unlock++) {
                    this._buttons[unlock].destroy();
                }

                this._buttons = [];

                this._buttonsLen = 0;

                this._axes = [];

                this._axesLen = 0;

                this.onConnectCallback = null;

                this.onDisconnectCallback = null;

                this.onDownCallback = null;

                this.onUpCallback = null;

                this.onAxisCallback = null;

                this.onFloatCallback = null;
            },

            "processAxisChange": function (name, s) {
                if (this._axes[name] !== s) {
                    this._axes[name] = s;
                    if (this._padParent.onAxisCallback) {
                        this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, name, s);
                    }
                    if (this.onAxisCallback) {
                        this.onAxisCallback.call(this.callbackContext, this, name, s);
                    }
                }
            },

            "processButtonDown": function ($conditional, deepDataAndEvents) {
                if (this._buttons[$conditional]) {
                    this._buttons[$conditional].start(null, deepDataAndEvents);
                }
                if (this._padParent.onDownCallback) {
                    this._padParent.onDownCallback.call(this._padParent.callbackContext, $conditional, deepDataAndEvents, this.index);
                }
                if (this.onDownCallback) {
                    this.onDownCallback.call(this.callbackContext, $conditional, deepDataAndEvents);
                }
            },

            "processButtonUp": function ($conditional, deepDataAndEvents) {
                if (this._padParent.onUpCallback) {
                    this._padParent.onUpCallback.call(this._padParent.callbackContext, $conditional, deepDataAndEvents, this.index);
                }
                if (this.onUpCallback) {
                    this.onUpCallback.call(this.callbackContext, $conditional, deepDataAndEvents);
                }
                if (this._buttons[$conditional]) {
                    this._buttons[$conditional].stop(null, deepDataAndEvents);
                }
            },

            "processButtonFloat": function ($conditional, deepDataAndEvents) {
                if (this._padParent.onFloatCallback) {
                    this._padParent.onFloatCallback.call(this._padParent.callbackContext, $conditional, deepDataAndEvents, this.index);
                }
                if (this.onFloatCallback) {
                    this.onFloatCallback.call(this.callbackContext, $conditional, deepDataAndEvents);
                }
                if (this._buttons[$conditional]) {
                    this._buttons[$conditional].padFloat(deepDataAndEvents);
                }
            },

            "axis": function (axis) {
                return !!this._axes[axis] && this._axes[axis];
            },

            "isDown": function (keycode) {
                return !!this._buttons[keycode] && this._buttons[keycode].isDown;
            },

            "isUp": function (key) {
                return !!this._buttons[key] && this._buttons[key].isUp;
            },

            "justReleased": function (keycode, delay) {
                if (this._buttons[keycode]) {
                    return this._buttons[keycode].justReleased(delay);
                }
            },

            "justPressed": function (keycode, delay) {
                if (this._buttons[keycode]) {
                    return this._buttons[keycode].justPressed(delay);
                }
            },

            "buttonValue": function (timeoutKey) {
                return this._buttons[timeoutKey] ? this._buttons[timeoutKey].value : null;
            },

            "reset": function () {

                var unlock = 0;
                for (; unlock < this._axes.length; unlock++) {

                    this._axes[unlock] = 0;
                }
            }
        };
        $.SinglePad.prototype.constructor = $.SinglePad;

        $.Key = function (dataAndEvents, deepDataAndEvents) {
            this.game = dataAndEvents;

            this._enabled = true;

            this.event = null;

            this.isDown = false;

            this.isUp = true;

            this.altKey = false;

            this.ctrlKey = false;

            this.shiftKey = false;

            this.timeDown = 0;

            this.duration = 0;

            this.timeUp = -2500;

            this.durationUp = -2500;

            this.repeats = 0;
            this.keyCode = deepDataAndEvents;
            this.onDown = new $.Signal;

            this.onHoldCallback = null;

            this.onHoldContext = null;
            this.onUp = new($.Signal);

            this._justDown = false;

            this._justUp = false;
        };
        $.Key.prototype = {

            "update": function () {
                if (this._enabled) {
                    if (this.isDown) {

                        this.duration = this.game.time.time - this.timeDown;
                        this.repeats++;
                        if (this.onHoldCallback) {
                            this.onHoldCallback.call(this.onHoldContext, this);
                        }
                    } else {

                        this.durationUp = this.game.time.time - this.timeUp;
                    }
                }
            },

            "processKeyDown": function (listener) {
                if (this._enabled) {
                    this.event = listener;
                    if (!this.isDown) {
                        this.altKey = listener.altKey;
                        this.ctrlKey = listener.ctrlKey;
                        this.shiftKey = listener.shiftKey;

                        this.isDown = true;

                        this.isUp = false;
                        this.timeDown = this.game.time.time;

                        this.duration = 0;

                        this.durationUp = this.game.time.time - this.timeUp;

                        this.repeats = 0;

                        this._justDown = true;
                        this.onDown.dispatch(this);
                    }
                }
            },

            "processKeyUp": function (listener) {
                if (this._enabled) {
                    this.event = listener;
                    if (!this.isUp) {

                        this.isDown = false;

                        this.isUp = true;
                        this.timeUp = this.game.time.time;

                        this.duration = this.game.time.time - this.timeDown;

                        this.durationUp = 0;

                        this._justUp = true;
                        this.onUp.dispatch(this);
                    }
                }
            },

            "reset": function (models) {
                if (void 0 === models) {

                    models = true;
                }

                this.isDown = false;

                this.isUp = true;
                this.timeUp = this.game.time.time;

                this.duration = 0;

                this.durationUp = -2500;

                this._enabled = true;

                this._justDown = false;

                this._justUp = false;
                if (models) {
                    this.onDown.removeAll();
                    this.onUp.removeAll();

                    this.onHoldCallback = null;

                    this.onHoldContext = null;
                }
            },

            "downDuration": function (dataAndEvents) {
                return void 0 === dataAndEvents && (dataAndEvents = 50), this.isDown && this.duration < dataAndEvents;
            },

            "upDuration": function (dataAndEvents) {
                return void 0 === dataAndEvents && (dataAndEvents = 50), !this.isDown && this.game.time.time - this.timeUp < dataAndEvents;
            },

            "justPressed": function () {
                return this.isDown && 0 === this.duration;
            },

            "justReleased": function () {
                return !this.isDown && 0 === this.durationUp;
            }
        };
        Object.defineProperty($.Key.prototype, 'justDown', {

            "get": function () {
                var _0x3e4e70 = this._justDown;
                return this._justDown = false, _0x3e4e70;
            }
        });
        Object.defineProperty($.Key.prototype, 'justUp', {

            "get": function () {
                var _0x479360 = this._justUp;
                return this._justUp = false, _0x479360;
            }
        });
        Object.defineProperty($.Key.prototype, 'enabled', {

            "get": function () {
                return this._enabled;
            },

            "set": function (mL) {
                if ((mL = !!mL) !== this._enabled) {
                    if (!mL) {
                        this.reset(false);
                    }

                    this._enabled = mL;
                }
            }
        });
        $.Key.prototype.constructor = $.Key;

        $.Keyboard = function (dataAndEvents) {
            this.game = dataAndEvents;

            this.enabled = true;

            this.event = null;

            this.pressEvent = null;
            this.callbackContext = this;

            this.onDownCallback = null;

            this.onPressCallback = null;

            this.onUpCallback = null;

            this._keys = [];

            this._capture = [];

            this._onKeyDown = null;

            this._onKeyPress = null;

            this._onKeyUp = null;

            this._i = 0;

            this._k = 0;
        };
        $.Keyboard.prototype = {

            "addCallbacks": function (eb, opt_scope, cb, onlyNew) {
                this.callbackContext = eb;
                if (void 0 !== opt_scope) {
                    if (null !== opt_scope) {

                        this.onDownCallback = opt_scope;
                    }
                }
                if (void 0 !== cb) {
                    if (null !== cb) {

                        this.onUpCallback = cb;
                    }
                }
                if (void 0 !== onlyNew) {
                    if (null !== onlyNew) {

                        this.onPressCallback = onlyNew;
                    }
                }
            },

            "removeCallbacks": function () {
                this.callbackContext = this;

                this.onDownCallback = null;

                this.onUpCallback = null;

                this.onPressCallback = null;
            },

            "addKey": function (key) {
                return this._keys[key] || (this._keys[key] = new($.Key)(this.game, key), this.addKeyCapture(key)), this._keys[key];
            },

            "addKeys": function (helper) {
                var $cookies = {};
                var key;
                for (key in helper) {
                    $cookies[key] = this.addKey(helper[key]);
                }
                return $cookies;
            },

            "removeKey": function (key) {
                if (this._keys[key]) {

                    this._keys[key] = null;
                    this.removeKeyCapture(key);
                }
            },

            "createCursorKeys": function () {
                return this.addKeys({
                    "up": $.KeyCode.UP,
                    "down": $.KeyCode.DOWN,
                    "left": $.KeyCode.LEFT,
                    "right": $.KeyCode.RIGHT
                });
            },

            "start": function () {
                if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                    var collection = this;

                    this._onKeyDown = function (resp) {
                        return collection.processKeyDown(resp);
                    };

                    this._onKeyUp = function (resp) {
                        return collection.processKeyUp(resp);
                    };

                    this._onKeyPress = function (resp) {
                        return collection.processKeyPress(resp);
                    };
                    window.addEventListener('keydown', this._onKeyDown, false);
                    window.addEventListener("keyup", this._onKeyUp, false);
                    window.addEventListener('keypress', this._onKeyPress, false);
                }
            },

            "stop": function () {
                window.removeEventListener("keydown", this._onKeyDown);
                window.removeEventListener('keyup', this._onKeyUp);
                window.removeEventListener('keypress', this._onKeyPress);

                this._onKeyDown = null;

                this._onKeyUp = null;

                this._onKeyPress = null;
            },

            "destroy": function () {
                this.stop();
                this.clearCaptures();

                this._keys.length = 0;

                this._i = 0;
            },

            "addKeyCapture": function (map) {
                if ("object" == typeof map) {
                    var letter;
                    for (letter in map) {

                        this._capture[map[letter]] = true;
                    }
                } else {

                    this._capture[map] = true;
                }
            },

            "removeKeyCapture": function (keycode) {
                delete this._capture[keycode];
            },

            "clearCaptures": function () {
                this._capture = {};
            },

            "update": function () {
                this._i = this._keys.length;
                for (; this._i--;) {
                    if (this._keys[this._i]) {
                        this._keys[this._i].update();
                    }
                }
            },

            "processKeyDown": function (owner) {
                if (this.event = owner, this.game.input.enabled && this.enabled) {
                    var unlock = owner.keyCode;
                    if (this._capture[unlock]) {
                        owner.preventDefault();
                    }
                    if (!this._keys[unlock]) {
                        this._keys[unlock] = new $.Key(this.game, unlock);
                    }
                    this._keys[unlock].processKeyDown(owner);
                    this._k = unlock;
                    if (this.onDownCallback) {
                        this.onDownCallback.call(this.callbackContext, owner);
                    }
                }
            },

            "processKeyPress": function (deepDataAndEvents) {
                this.pressEvent = deepDataAndEvents;
                if (this.game.input.enabled) {
                    if (this.enabled) {
                        if (this.onPressCallback) {
                            this.onPressCallback.call(this.callbackContext, String.fromCharCode(deepDataAndEvents.charCode), deepDataAndEvents);
                        }
                    }
                }
            },

            "processKeyUp": function (owner) {
                if (this.event = owner, this.game.input.enabled && this.enabled) {
                    var unlock = owner.keyCode;
                    if (this._capture[unlock]) {
                        owner.preventDefault();
                    }
                    if (!this._keys[unlock]) {
                        this._keys[unlock] = new $.Key(this.game, unlock);
                    }
                    this._keys[unlock].processKeyUp(owner);
                    if (this.onUpCallback) {
                        this.onUpCallback.call(this.callbackContext, owner);
                    }
                }
            },

            "reset": function (models) {
                if (void 0 === models) {

                    models = true;
                }

                this.event = null;
                var jj = this._keys.length;
                for (; jj--;) {
                    if (this._keys[jj]) {
                        this._keys[jj].reset(models);
                    }
                }
            },

            "downDuration": function (pointer, deepDataAndEvents) {
                return this._keys[pointer] ? this._keys[pointer].downDuration(deepDataAndEvents) : null;
            },

            "upDuration": function (timeoutKey, deepDataAndEvents) {
                return this._keys[timeoutKey] ? this._keys[timeoutKey].upDuration(deepDataAndEvents) : null;
            },

            "justPressed": function (keycode) {
                return this._keys[keycode] ? this._keys[keycode].justPressed() : null;
            },

            "justReleased": function (keycode) {
                return this._keys[keycode] ? this._keys[keycode].justReleased() : null;
            },

            "isDown": function (keycode) {
                return this._keys[keycode] ? this._keys[keycode].isDown : null;
            }
        };
        Object.defineProperty($.Keyboard.prototype, 'lastChar', {

            "get": function () {
                return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null;
            }
        });
        Object.defineProperty($.Keyboard.prototype, 'lastKey', {

            "get": function () {
                return this._keys[this._k];
            }
        });
        $.Keyboard.prototype.constructor = $.Keyboard;
        $.KeyCode = {
            "A": "A" ["charCodeAt"](0),
            "B": "B" ['charCodeAt'](0),
            "C": "C" ['charCodeAt'](0),
            "D": "D" ['charCodeAt'](0),
            "E": "E" ['charCodeAt'](0),
            "F": "F" ['charCodeAt'](0),
            "G": "G" ['charCodeAt'](0),
            "H": "H" ["charCodeAt"](0),
            "I": "I" ["charCodeAt"](0),
            "J": "J" ['charCodeAt'](0),
            "K": "K" ['charCodeAt'](0),
            "L": "L" ["charCodeAt"](0),
            "M": "M" ['charCodeAt'](0),
            "N": "N" ["charCodeAt"](0),
            "O": "O" ['charCodeAt'](0),
            "P": "P" ['charCodeAt'](0),
            "Q": "Q" ['charCodeAt'](0),
            "R": "R" ['charCodeAt'](0),
            "S": "S" ['charCodeAt'](0),
            "T": "T" ['charCodeAt'](0),
            "U": "U" ['charCodeAt'](0),
            "V": "V" ["charCodeAt"](0),
            "W": "W" ["charCodeAt"](0),
            "X": "X" ["charCodeAt"](0),
            "Y": "Y" ['charCodeAt'](0),
            "Z": "Z" ['charCodeAt'](0),
            "ZERO": "0" ['charCodeAt'](0),
            "ONE": "1" ['charCodeAt'](0),
            "TWO": "2" ['charCodeAt'](0),
            "THREE": "3" ['charCodeAt'](0),
            "FOUR": "4" ['charCodeAt'](0),
            "FIVE": "5" ['charCodeAt'](0),
            "SIX": "6" ['charCodeAt'](0),
            "SEVEN": "7" ['charCodeAt'](0),
            "EIGHT": "8" ["charCodeAt"](0),
            "NINE": "9" ['charCodeAt'](0),
            "NUMPAD_0": 96,
            "NUMPAD_1": 97,
            "NUMPAD_2": 98,
            "NUMPAD_3": 99,
            "NUMPAD_4": 100,
            "NUMPAD_5": 101,
            "NUMPAD_6": 102,
            "NUMPAD_7": 103,
            "NUMPAD_8": 104,
            "NUMPAD_9": 105,
            "NUMPAD_MULTIPLY": 106,
            "NUMPAD_ADD": 107,
            "NUMPAD_ENTER": 108,
            "NUMPAD_SUBTRACT": 109,
            "NUMPAD_DECIMAL": 110,
            "NUMPAD_DIVIDE": 111,
            "F1": 112,
            "F2": 113,
            "F3": 114,
            "F4": 115,
            "F5": 116,
            "F6": 117,
            "F7": 118,
            "F8": 119,
            "F9": 120,
            "F10": 121,
            "F11": 122,
            "F12": 123,
            "F13": 124,
            "F14": 125,
            "F15": 126,
            "COLON": 186,
            "EQUALS": 187,
            "COMMA": 188,
            "UNDERSCORE": 189,
            "PERIOD": 190,
            "QUESTION_MARK": 191,
            "TILDE": 192,
            "OPEN_BRACKET": 219,
            "BACKWARD_SLASH": 220,
            "CLOSED_BRACKET": 221,
            "QUOTES": 222,
            "BACKSPACE": 8,
            "TAB": 9,
            "CLEAR": 12,
            "ENTER": 13,
            "SHIFT": 16,
            "CONTROL": 17,
            "ALT": 18,
            "CAPS_LOCK": 20,
            "ESC": 27,
            "SPACEBAR": 32,
            "PAGE_UP": 33,
            "PAGE_DOWN": 34,
            "END": 35,
            "HOME": 36,
            "LEFT": 37,
            "UP": 38,
            "RIGHT": 39,
            "DOWN": 40,
            "PLUS": 43,
            "MINUS": 44,
            "INSERT": 45,
            "DELETE": 46,
            "HELP": 47,
            "NUM_LOCK": 144
        };
        var plugin;
        for (plugin in $.KeyCode) {
            if ($.KeyCode.hasOwnProperty(plugin)) {
                if (!plugin.match(/[a-z]/)) {
                    $.Keyboard[plugin] = $.KeyCode[plugin];
                }
            }
        }

        $.Component = function () {};

        $.Component.Angle = function () {};
        $.Component.Angle.prototype = {
            "angle": {

                "get": function () {
                    return $.Math.wrapAngle($.Math.radToDeg(this.rotation));
                },

                "set": function (opt_path) {
                    this.rotation = $.Math.degToRad($.Math.wrapAngle(opt_path));
                }
            }
        };

        $.Component.Animation = function () {};
        $.Component.Animation.prototype = {

            "play": function (action, options, delay, opt_restart) {
                if (this.animations) {
                    return this.animations.play(action, options, delay, opt_restart);
                }
            }
        };

        $.Component.AutoCull = function () {};
        $.Component.AutoCull.prototype = {
            "autoCull": false,
            "inCamera": {

                "get": function () {
                    return this.autoCull || (this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y)), this.game.world.camera.view.intersects(this._bounds);
                }
            }
        };

        $.Component.Bounds = function () {};
        $.Component.Bounds.prototype = {
            "offsetX": {

                "get": function () {
                    return this.anchor.x * this.width;
                }
            },
            "offsetY": {

                "get": function () {
                    return this.anchor.y * this.height;
                }
            },
            "centerX": {

                "get": function () {
                    return this.x - this.offsetX + 0.5 * this.width;
                },

                "set": function (mL) {

                    this.x = mL + this.offsetX - 0.5 * this.width;
                }
            },
            "centerY": {

                "get": function () {
                    return this.y - this.offsetY + 0.5 * this.height;
                },

                "set": function (mL) {

                    this.y = mL + this.offsetY - 0.5 * this.height;
                }
            },
            "left": {

                "get": function () {
                    return this.x - this.offsetX;
                },

                "set": function (_) {
                    this.x = _ + this.offsetX;
                }
            },
            "right": {

                "get": function () {
                    return this.x + this.width - this.offsetX;
                },

                "set": function (mL) {
                    this.x = mL - this.width + this.offsetX;
                }
            },
            "top": {

                "get": function () {
                    return this.y - this.offsetY;
                },

                "set": function (mL) {
                    this.y = mL + this.offsetY;
                }
            },
            "bottom": {

                "get": function () {
                    return this.y + this.height - this.offsetY;
                },

                "set": function (mL) {
                    this.y = mL - this.height + this.offsetY;
                }
            },

            "alignIn": function (bounds, dataAndEvents, left, top) {
                switch (void 0 === left && (left = 0), void 0 === top && (top = 0), dataAndEvents) {
                default:
                    ;
                case $.TOP_LEFT:

                    this.left = bounds.left - left;

                    this.top = bounds.top - top;
                    break;
                case $.TOP_CENTER:
                    this.centerX = bounds.centerX + left;

                    this.top = bounds.top - top;
                    break;
                case $.TOP_RIGHT:
                    this.right = bounds.right + left;

                    this.top = bounds.top - top;
                    break;
                case $.LEFT_CENTER:

                    this.left = bounds.left - left;
                    this.centerY = bounds.centerY + top;
                    break;
                case $.CENTER:
                    this.centerX = bounds.centerX + left;
                    this.centerY = bounds.centerY + top;
                    break;
                case $.RIGHT_CENTER:
                    this.right = bounds.right + left;
                    this.centerY = bounds.centerY + top;
                    break;
                case $.BOTTOM_LEFT:

                    this.left = bounds.left - left;
                    this.bottom = bounds.bottom + top;
                    break;
                case $.BOTTOM_CENTER:
                    this.centerX = bounds.centerX + left;
                    this.bottom = bounds.bottom + top;
                    break;
                case $.BOTTOM_RIGHT:
                    this.right = bounds.right + left;
                    this.bottom = bounds.bottom + top;
                }
                return this;
            },

            "alignTo": function (bounds, animate, left, top) {
                switch (void 0 === left && (left = 0), void 0 === top && (top = 0), animate) {
                default:
                    ;
                case $.TOP_LEFT:

                    this.left = bounds.left - left;

                    this.bottom = bounds.top - top;
                    break;
                case $.TOP_CENTER:
                    this.centerX = bounds.centerX + left;

                    this.bottom = bounds.top - top;
                    break;
                case $.TOP_RIGHT:
                    this.right = bounds.right + left;

                    this.bottom = bounds.top - top;
                    break;
                case $.LEFT_TOP:

                    this.right = bounds.left - left;

                    this.top = bounds.top - top;
                    break;
                case $.LEFT_CENTER:

                    this.right = bounds.left - left;
                    this.centerY = bounds.centerY + top;
                    break;
                case $.LEFT_BOTTOM:

                    this.right = bounds.left - left;
                    this.bottom = bounds.bottom + top;
                    break;
                case $.RIGHT_TOP:
                    this.left = bounds.right + left;

                    this.top = bounds.top - top;
                    break;
                case $.RIGHT_CENTER:
                    this.left = bounds.right + left;
                    this.centerY = bounds.centerY + top;
                    break;
                case $.RIGHT_BOTTOM:
                    this.left = bounds.right + left;
                    this.bottom = bounds.bottom + top;
                    break;
                case $.BOTTOM_LEFT:

                    this.left = bounds.left - left;
                    this.top = bounds.bottom + top;
                    break;
                case $.BOTTOM_CENTER:
                    this.centerX = bounds.centerX + left;
                    this.top = bounds.bottom + top;
                    break;
                case $.BOTTOM_RIGHT:
                    this.right = bounds.right + left;
                    this.top = bounds.bottom + top;
                }
                return this;
            }
        };
        $.Group.prototype.alignIn = $.Component.Bounds.prototype.alignIn;
        $.Group.prototype.alignTo = $.Component.Bounds.prototype.alignTo;

        $.Component.BringToTop = function () {};

        $.Component.BringToTop.prototype.bringToTop = function () {
            return this.parent && this.parent.bringToTop(this), this;
        };

        $.Component.BringToTop.prototype.sendToBack = function () {
            return this.parent && this.parent.sendToBack(this), this;
        };

        $.Component.BringToTop.prototype.moveUp = function () {
            return this.parent && this.parent.moveUp(this), this;
        };

        $.Component.BringToTop.prototype.moveDown = function () {
            return this.parent && this.parent.moveDown(this), this;
        };

        $.Component.Core = function () {};

        $.Component.Core.skipTypeChecks = false;

        $.Component.Core.install = function (stack) {
            $.Utils.mixinPrototype(this, $.Component.Core.prototype);
            this.components = {};

            var i = 0;
            for (; i < stack.length; i++) {
                var plugin = stack[i];

                var r20 = false;
                if ('Destroy' === plugin) {

                    r20 = true;
                }
                $.Utils.mixinPrototype(this, $.Component[plugin].prototype, r20);

                this.components[plugin] = true;
            }
        };

        $.Component.Core.init = function (dataAndEvents, ext, parserState, deepDataAndEvents, opt_obj2) {
            if (!$.Component.Core.skipTypeChecks) {
                if (!(dataAndEvents instanceof $.Game)) {
                    throw new Error("The value passed as the `game` argument (" + dataAndEvents + ") is not an instance of Phaser.Game.");
                }
                if ('number' != typeof ext) {
                    console.warn('The `x` argument value (%s) should be a number.', ext);

                    ext = 0;
                }
                if ('number' != typeof parserState) {
                    console.warn('The `y` argument value (%s) should be a number.', parserState);

                    parserState = 0;
                }
            }

            this.game = dataAndEvents;

            this.key = deepDataAndEvents;
            this.data = {};
            this.position.set(ext, parserState);
            this.world = new($.Point)(ext, parserState);
            this.previousPosition = new($.Point)(ext, parserState);
            this.events = new($.Events)(this);
            this._bounds = new $.Rectangle;
            if (this.components.PhysicsBody) {
                this.body = this.body;
            }
            if (this.components.Animation) {
                this.animations = new($.AnimationManager)(this);
            }
            if (this.components.LoadTexture) {
                if (null !== deepDataAndEvents) {
                    this.loadTexture(deepDataAndEvents, opt_obj2);
                }
            }
            if (this.components.FixedToCamera) {
                this.cameraOffset = new $.Point(ext, parserState);
            }
        };

        $.Component.Core.preUpdate = function () {
            return this.pendingDestroy ? (this.destroy(), false) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID =
                this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), true) : (this.renderOrderID = -1, false));
        };
        $.Component.Core.prototype = {
            "game": null,
            "name": "",
            "data": {},
            "components": {},
            "z": 0,
            "events": void 0,
            "animations": void 0,
            "key": "",
            "world": null,
            "debug": false,
            "previousPosition": null,
            "previousRotation": 0,
            "renderOrderID": 0,
            "fresh": true,
            "pendingDestroy": false,
            "_bounds": null,
            "_exists": true,
            "exists": {

                "get": function () {
                    return this._exists;
                },

                "set": function (mL) {
                    if (mL) {

                        this._exists = true;
                        if (this.body) {
                            if (this.body.type === $.Physics.P2JS) {
                                this.body.addToWorld();
                            }
                        }

                        this.visible = true;
                    } else {

                        this._exists = false;
                        if (this.body) {
                            if (this.body.type === $.Physics.P2JS) {
                                this.body.removeFromWorld();
                            }
                        }

                        this.visible = false;
                    }
                }
            },

            "preUpdateChildren": function () {

                var unlock = 0;
                for (; unlock < this.children.length;) {
                    var cache = this.children[unlock];
                    cache.preUpdate();
                    if (this === cache.parent) {
                        unlock++;
                    }
                }
            },

            "update": function () {},

            "postUpdate": function () {
                if (this.customRender) {
                    this.key.render();
                }
                if (this.components.PhysicsBody) {
                    $.Component.PhysicsBody.postUpdate.call(this);
                }
                if (this.components.FixedToCamera) {
                    $.Component.FixedToCamera.postUpdate.call(this);
                }

                var unlock = 0;
                for (; unlock < this.children.length; unlock++) {
                    this.children[unlock].postUpdate();
                }
            }
        };

        $.Component.Crop = function () {};
        $.Component.Crop.prototype = {
            "cropRect": null,
            "_crop": null,

            "crop": function (options, append) {
                if (void 0 === append) {

                    append = false;
                }
                if (options) {
                    if (append && null !== this.cropRect) {
                        this.cropRect.setTo(options.x, options.y, options.width, options.height);
                    } else {
                        if (append && null === this.cropRect) {
                            this.cropRect = new $.Rectangle(options.x, options.y, options.width, options.height);
                        } else {

                            this.cropRect = options;
                        }
                    }
                    this.updateCrop();
                } else {

                    this._crop = null;

                    this.cropRect = null;
                    this.resetFrame();
                }
            },

            "updateCrop": function () {
                if (this.cropRect) {
                    var type = this.texture.crop.x;
                    var item = this.texture.crop.y;
                    var value = this.texture.crop.width;
                    var attr = this.texture.crop.height;
                    this._crop = $.Rectangle.clone(this.cropRect, this._crop);
                    this._crop.x += this._frame.x;
                    this._crop.y += this._frame.y;
                    var hash = Math.max(this._frame.x, this._crop.x);
                    var clientY = Math.max(this._frame.y, this._crop.y);

                    var currentValue = Math.min(this._frame.right, this._crop.right) - hash;

                    var y = Math.min(this._frame.bottom, this._crop.bottom) - clientY;
                    this.texture.crop.x = hash;
                    this.texture.crop.y = clientY;

                    this.texture.crop.width = currentValue;

                    this.texture.crop.height = y;
                    this.texture.frame.width = Math.min(currentValue, this.cropRect.width);
                    this.texture.frame.height = Math.min(y, this.cropRect.height);
                    this.texture.width = this.texture.frame.width;
                    this.texture.height = this.texture.frame.height;
                    this.texture._updateUvs();
                    if (!(16777215 === this.tint)) {
                        if (!(type === hash && (item === clientY && (value === currentValue && attr === y)))) {

                            this.texture.requiresReTint = true;
                        }
                    }
                }
            }
        };

        $.Component.Delta = function () {};
        $.Component.Delta.prototype = {
            "deltaX": {

                "get": function () {
                    return this.world.x - this.previousPosition.x;
                }
            },
            "deltaY": {

                "get": function () {
                    return this.world.y - this.previousPosition.y;
                }
            },
            "deltaZ": {

                "get": function () {
                    return this.rotation - this.previousRotation;
                }
            }
        };

        $.Component.Destroy = function () {};
        $.Component.Destroy.prototype = {
            "destroyPhase": false,

            "destroy": function (clientExpiration, removeResizeFix) {
                if (null !== this.game && !this.destroyPhase) {
                    if (void 0 === clientExpiration) {

                        clientExpiration = true;
                    }
                    if (void 0 === removeResizeFix) {

                        removeResizeFix = false;
                    }

                    this.destroyPhase = true;
                    if (this.events) {
                        this.events.onDestroy$dispatch(this);
                    }
                    if (this.parent) {
                        if (this.parent instanceof $.Group) {
                            this.parent.remove(this);
                        } else {
                            this.parent.removeChild(this);
                        }
                    }
                    if (this.input) {
                        this.input.destroy();
                    }
                    if (this.animations) {
                        this.animations.destroy();
                    }
                    if (this.body) {
                        this.body.destroy();
                    }
                    if (this.events) {
                        this.events.destroy();
                    }
                    this.game.tweens.removeFrom(this);
                    var unlock = this.children.length;
                    if (clientExpiration) {
                        for (; unlock--;) {
                            this.children[unlock].destroy(clientExpiration);
                        }
                    } else {
                        for (; unlock--;) {
                            this.removeChild(this.children[unlock]);
                        }
                    }
                    if (this._crop) {

                        this._crop = null;

                        this.cropRect = null;
                    }
                    if (this._frame) {

                        this._frame = null;
                    }
                    if ($.Video) {
                        if (this.key instanceof $.Video) {
                            this.key.onChangeSource.remove(this.resizeFrame, this);
                        }
                    }
                    if ($.BitmapText) {
                        if (this._glyphs) {

                            this._glyphs = [];
                        }
                    }

                    this.alive = false;

                    this.exists = false;

                    this.visible = false;

                    this.filters = null;

                    this.mask = null;

                    this.game = null;
                    this.data = {};

                    this.renderable = false;
                    if (this.transformCallback) {

                        this.transformCallback = null;

                        this.transformCallbackContext = null;
                    }

                    this.hitArea = null;

                    this.parent = null;

                    this.stage = null;

                    this.worldTransform = null;

                    this.filterArea = null;

                    this._bounds = null;

                    this._currentBounds = null;

                    this._mask = null;
                    this._destroyCachedSprite();
                    if (removeResizeFix) {
                        this.texture.destroy(true);
                    }

                    this.destroyPhase = false;

                    this.pendingDestroy = false;
                }
            }
        };

        $.Events = function (parentid) {
            this.parent = parentid;
        };
        $.Events.prototype = {

            "destroy": function () {

                this._parent = null;
                if (this._onDestroy) {
                    this._onDestroy.dispose();
                }
                if (this._onAddedToGroup) {
                    this._onAddedToGroup.dispose();
                }
                if (this._onRemovedFromGroup) {
                    this._onRemovedFromGroup.dispose();
                }
                if (this._onKilled) {
                    this._onKilled.dispose();
                }
                if (this._onRevived) {
                    this._onRevived.dispose();
                }
                if (this._onEnterBounds) {
                    this._onEnterBounds.dispose();
                }
                if (this._onOutOfBounds) {
                    this._onOutOfBounds.dispose();
                }
                if (this._onInputOver) {
                    this._onInputOver.dispose();
                }
                if (this._onInputOut) {
                    this._onInputOut.dispose();
                }
                if (this._onInputDown) {
                    this._onInputDown.dispose();
                }
                if (this._onInputUp) {
                    this._onInputUp.dispose();
                }
                if (this._onDragStart) {
                    this._onDragStart.dispose();
                }
                if (this._onDragUpdate) {
                    this._onDragUpdate.dispose();
                }
                if (this._onDragStop) {
                    this._onDragStop.dispose();
                }
                if (this._onAnimationStart) {
                    this._onAnimationStart.dispose();
                }
                if (this._onAnimationComplete) {
                    this._onAnimationComplete.dispose();
                }
                if (this._onAnimationLoop) {
                    this._onAnimationLoop.dispose();
                }
            },
            "onAddedToGroup": null,
            "onRemovedFromGroup": null,
            "onDestroy": null,
            "onKilled": null,
            "onRevived": null,
            "onOutOfBounds": null,
            "onEnterBounds": null,
            "onInputOver": null,
            "onInputOut": null,
            "onInputDown": null,
            "onInputUp": null,
            "onDragStart": null,
            "onDragUpdate": null,
            "onDragStop": null,
            "onAnimationStart": null,
            "onAnimationComplete": null,
            "onAnimationLoop": null
        };
        $.Events.prototype.constructor = $.Events;
        var prefix;
        for (prefix in $.Events.prototype) {
            if ($.Events.prototype.hasOwnProperty(prefix)) {
                if (0 === prefix.indexOf("on")) {
                    if (null === $.Events.prototype[prefix]) {
                        (function (opt_prefix, method) {
                            Object.defineProperty($.Events.prototype, opt_prefix, {

                                "get": function () {
                                    return this[method] || (this[method] = new($.Signal));
                                }
                            });

                            $.Events.prototype[opt_prefix + '$dispatch'] = function () {
                                return this[method] ? this[method].dispatch.apply(this[method], arguments) : null;
                            };
                        })(prefix, "_" + prefix);
                    }
                }
            }
        }
        return $.Component.FixedToCamera = function () {}, $.Component.FixedToCamera.postUpdate = function () {
                if (this.fixedToCamera) {

                    this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;

                    this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;
                }
            }, $.Component.FixedToCamera.prototype = {
                "_fixedToCamera": false,
                "fixedToCamera": {

                    "get": function () {
                        return this._fixedToCamera;
                    },

                    "set": function (mL) {
                        if (mL) {

                            this._fixedToCamera = true;
                            this.cameraOffset.set(this.x, this.y);
                        } else {

                            this._fixedToCamera = false;
                        }
                    }
                },
                "cameraOffset": new($.Point)
            }, $.Component.Health = function () {}, $.Component.Health.prototype = {
                "health": 1,
                "maxHealth": 100,

                "damage": function (amount) {
                    return this.alive && (this.health -= amount, this.health <= 0 && this.kill()), this;
                },

                "setHealth": function (value) {
                    return this.health = value, this.health > this.maxHealth && (this.health = this.maxHealth), this;
                },

                "heal": function (healing) {
                    return this.alive && (this.health += healing, this.health > this.maxHealth && (this.health = this.maxHealth)), this;
                }
            }, $.Component.InCamera = function () {}, $.Component.InCamera.prototype = {
                "inCamera": {

                    "get": function () {
                        return this.game.world.camera.view.intersects(this._bounds);
                    }
                }
            }, $.Component.InputEnabled = function () {}, $.Component.InputEnabled.prototype = {
                "input": null,
                "inputEnabled": {

                    "get": function () {
                        return this.input && this.input.enabled;
                    },

                    "set": function (mL) {
                        if (mL) {
                            if (null === this.input) {
                                this.input = new $.InputHandler(this);
                                this.input.start();
                            } else {
                                if (this.input) {
                                    if (!this.input.enabled) {
                                        this.input.start();
                                    }
                                }
                            }
                        } else {
                            if (this.input) {
                                if (this.input.enabled) {
                                    this.input.stop();
                                }
                            }
                        }
                    }
                }
            }, $.Component.InWorld = function () {}, $.Component.InWorld.preUpdate = function () {
                if (this.pendingDestroy) {
                    return this.destroy(), false;
                }
                if (this.autoCull || this.checkWorldBounds) {
                    if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull) {
                        if (this.game.world.camera.view.intersects(this._bounds)) {

                            this.renderable = true;
                            this.game.world.camera.totalInView++;
                        } else {
                            if (this.renderable = false, this.outOfCameraBoundsKill) {
                                return this.kill(), false;
                            }
                        }
                    }
                    if (this.checkWorldBounds) {
                        if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) {

                            this._outOfBoundsFired = false;
                            this.events.onEnterBounds$dispatch(this);
                        } else {
                            if (!this._outOfBoundsFired && (!this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = true, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill))) {
                                return this.kill(), false;
                            }
                        }
                    }
                }
                return true;
            }, $.Component.InWorld.prototype = {
                "checkWorldBounds": false,
                "outOfBoundsKill": false,
                "outOfCameraBoundsKill": false,
                "_outOfBoundsFired": false,
                "inWorld": {

                    "get": function () {
                        return this.game.world.bounds.intersects(this.getBounds());
                    }
                }
            }, $.Component.LifeSpan = function () {}, $.Component.LifeSpan.preUpdate = function () {
                return this.pendingDestroy ? (this.destroy(), false) : !(this.lifespan > 0 && ((this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0) && (this.kill(), 1)));
            }, $.Component.LifeSpan.prototype = {
                "alive": true,
                "lifespan": 0,

                "revive": function (next) {
                    return void 0 === next && (next = 100), this.alive = true, this.exists = true, this.visible = true, 'function' == typeof this.setHealth && this.setHealth(next), this.events && this.events.onRevived$dispatch(this), this;
                },

                "kill": function () {
                    return this.alive = false, this.exists = false, this.visible = false, this.events && this.events.onKilled$dispatch(this), this;
                }
            }, $.Component.LoadTexture = function () {}, $.Component.LoadTexture.prototype = {
                "customRender": false,
                "_frame": null,

                "loadTexture": function (identifier, id, imageUrl) {
                    if (identifier === $.PENDING_ATLAS) {

                        identifier = id;

                        id = 0;
                    } else {
                        id = id || 0;
                    }
                    if (imageUrl || void 0 === imageUrl) {
                        if (this.animations) {
                            this.animations.stop();
                        }
                    }

                    this.key = identifier;

                    this.customRender = false;
                    var cache = this.game.cache;

                    var _0x56d152 = true;

                    var _0x27e245 = !this.texture.baseTexture.scaleMode;
                    if ($.RenderTexture && identifier instanceof $.RenderTexture) {
                        this.key = identifier.key;
                        this.setTexture(identifier);
                    } else {
                        if ($.BitmapData && identifier instanceof $.BitmapData) {

                            this.customRender = true;
                            this.setTexture(identifier.texture);

                            _0x56d152 = cache.hasFrameData(identifier.key, $.Cache.BITMAPDATA) ? !this.animations.loadFrameData(cache.getFrameData(identifier.key, $.Cache.BITMAPDATA), id) : !this.animations.loadFrameData(identifier.frameData, 0);
                        } else {
                            if ($.Video && identifier instanceof $.Video) {

                                this.customRender = true;
                                var _0x377998 = identifier.texture.valid;
                                this.setTexture(identifier.texture);
                                this.setFrame(identifier.texture.frame.clone());
                                identifier.onChangeSource.add(this.resizeFrame, this);
                                this.texture.valid = _0x377998;
                            } else {
                                if ($.Tilemap && identifier instanceof $.TilemapLayer) {
                                    this.setTexture(PIXI.Texture.fromCanvas(identifier.canvas));
                                } else {
                                    if (identifier instanceof PIXI.Texture) {
                                        this.setTexture(identifier);
                                    } else {
                                        var knownHard = cache.getImage(identifier, true);
                                        this.key = knownHard.key;
                                        this.setTexture(new(PIXI.Texture)(knownHard.base));

                                        this.texture.baseTexture.skipRender = '__default' === identifier;

                                        _0x56d152 = !this.animations.loadFrameData(knownHard.frameData, id);
                                    }
                                }
                            }
                        }
                    }
                    if (_0x56d152) {
                        this._frame = $.Rectangle.clone(this.texture.frame);
                    }
                    if (!_0x27e245) {

                        this.texture.baseTexture.scaleMode = 1;
                    }
                },

                "setFrame": function (data) {

                    this._frame = data;
                    this.texture.frame.x = data.x;
                    this.texture.frame.y = data.y;
                    this.texture.frame.width = data.width;
                    this.texture.frame.height = data.height;
                    this.texture.crop.x = data.x;
                    this.texture.crop.y = data.y;
                    this.texture.crop.width = data.width;
                    this.texture.crop.height = data.height;
                    if (data.trimmed) {
                        if (this.texture.trim) {
                            this.texture.trim.x = data.spriteSourceSizeX;
                            this.texture.trim.y = data.spriteSourceSizeY;
                            this.texture.trim.width = data.sourceSizeW;
                            this.texture.trim.height = data.sourceSizeH;
                        } else {
                            this.texture.trim = {
                                "x": data.spriteSourceSizeX,
                                "y": data.spriteSourceSizeY,
                                "width": data.sourceSizeW,
                                "height": data.sourceSizeH
                            };
                        }
                        this.texture.width = data.sourceSizeW;
                        this.texture.height = data.sourceSizeH;
                        this.texture.frame.width = data.sourceSizeW;
                        this.texture.frame.height = data.sourceSizeH;
                    } else {
                        if (!data.trimmed) {
                            if (this.texture.trim) {

                                this.texture.trim = null;
                            }
                        }
                    }
                    if (data.rotated) {

                        this.texture.rotated = true;
                    }
                    if (this.cropRect) {
                        this.updateCrop();
                    }

                    this.texture.requiresReTint = true;
                    this.texture._updateUvs();
                    if (this.tilingTexture) {

                        this.refreshTexture = true;
                    }
                },

                "resizeFrame": function (updateHeight, deepDataAndEvents, opt_obj2) {
                    this.texture.frame.resize(deepDataAndEvents, opt_obj2);
                    this.texture.setFrame(this.texture.frame);
                },

                "resetFrame": function () {
                    if (this._frame) {
                        this.setFrame(this._frame);
                    }
                },
                "frame": {

                    "get": function () {
                        return this.animations.frame;
                    },

                    "set": function (value) {
                        this.animations.frame = value;
                    }
                },
                "frameName": {

                    "get": function () {
                        return this.animations.frameName;
                    },

                    "set": function (mL) {
                        this.animations.frameName = mL;
                    }
                }
            }, $.Component.Overlap = function () {}, $.Component.Overlap.prototype = {

                "overlap": function (event) {
                    return $.Rectangle.intersects(this.getBounds(), event.getBounds());
                }
            }, $.Component.PhysicsBody = function () {}, $.Component.PhysicsBody.preUpdate = function () {
                return this.pendingDestroy ? (this.destroy(), false) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation =
                    this.rotation, this.body && this.body.preUpdate(), this.fresh = false, this.preUpdateChildren(), false) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, false));
            }, $.Component.PhysicsBody.postUpdate = function () {
                if (this.exists) {
                    if (this.body) {
                        this.body.postUpdate();
                    }
                }
            }, $.Component.PhysicsBody.prototype = {
                "body": null,
                "x": {

                    "get": function () {
                        return this.position.x;
                    },

                    "set": function (v) {
                        this.position.x = v;
                        if (this.body) {
                            if (!this.body.dirty) {

                                this.body._reset = true;
                            }
                        }
                    }
                },
                "y": {

                    "get": function () {
                        return this.position.y;
                    },

                    "set": function (value) {
                        this.position.y = value;
                        if (this.body) {
                            if (!this.body.dirty) {

                                this.body._reset = true;
                            }
                        }
                    }
                }
            }, $.Component.Reset = function () {}, $.Component.Reset.prototype.reset = function (deepDataAndEvents, opt_obj2, dataAndEvents) {
                return void 0 === dataAndEvents && (dataAndEvents = 1), this.world.set(deepDataAndEvents, opt_obj2), this.position.set(deepDataAndEvents, opt_obj2), this.fresh = true, this.exists = true, this.visible = true, this.renderable = true, this.components.InWorld && (this._outOfBoundsFired = false), this.components.LifeSpan && (this.alive = true, this.health = dataAndEvents), this.components.PhysicsBody &&
                    (this.body && this.body.reset(deepDataAndEvents, opt_obj2, false, false)), this;
            }, $.Component.ScaleMinMax = function () {}, $.Component.ScaleMinMax.prototype = {
                "transformCallback": null,
                "transformCallbackContext": this,
                "scaleMin": null,
                "scaleMax": null,

                "checkTransform": function (nextState) {
                    if (this.scaleMin) {
                        if (nextState.a < this.scaleMin.x) {
                            nextState.a = this.scaleMin.x;
                        }
                        if (nextState.d < this.scaleMin.y) {
                            nextState.d = this.scaleMin.y;
                        }
                    }
                    if (this.scaleMax) {
                        if (nextState.a > this.scaleMax.x) {
                            nextState.a = this.scaleMax.x;
                        }
                        if (nextState.d > this.scaleMax.y) {
                            nextState.d = this.scaleMax.y;
                        }
                    }
                },

                "setScaleMinMax": function (context, c, w, result) {
                    if (void 0 === c) {
                        c = w = result = context;
                    } else {
                        if (void 0 === w) {
                            w = result = c;

                            c = context;
                        }
                    }
                    if (null === context) {

                        this.scaleMin = null;
                    } else {
                        if (this.scaleMin) {
                            this.scaleMin.set(context, c);
                        } else {
                            this.scaleMin = new($.Point)(context, c);
                        }
                    }
                    if (null === w) {

                        this.scaleMax = null;
                    } else {
                        if (this.scaleMax) {
                            this.scaleMax.set(w, result);
                        } else {
                            this.scaleMax = new($.Point)(w, result);
                        }
                    }
                    if (null === this.scaleMin) {

                        this.transformCallback = null;
                    } else {
                        this.transformCallback = this.checkTransform;
                        this.transformCallbackContext = this;
                    }
                }
            }, $.Component.Smoothed = function () {}, $.Component.Smoothed.prototype = {
                "smoothed": {

                    "get": function () {
                        return !this.texture.baseTexture.scaleMode;
                    },

                    "set": function (mL) {
                        if (mL) {
                            if (this.texture) {

                                this.texture.baseTexture.scaleMode = 0;
                                this.texture.baseTexture.dirty();
                            }
                        } else {
                            if (this.texture) {

                                this.texture.baseTexture.scaleMode = 1;
                                this.texture.baseTexture.dirty();
                            }
                        }
                    }
                }
            }, $.GameObjectFactory = function (dataAndEvents) {
                this.game = dataAndEvents;
                this.world = this.game.world;
            }, $.GameObjectFactory.prototype = {

                "existing": function (assert) {
                    return this.world.add(assert);
                },

                "weapon": function (resp, options, owner, angle, x) {
                    var collection = this.game.plugins.add($.Weapon);
                    return x && (collection.bulletClass = x), collection.createBullets(resp, options, owner, angle), collection;
                },

                "image": function (x, node, settings, width, text) {
                    return void 0 === text && (text = this.world), text.add(new($.Image)(this.game, x, node, settings, width));
                },

                "sprite": function (x, tx, tile, tileh, sprite) {
                    return void 0 === sprite && (sprite = this.world), sprite.add(new $.Sprite(this.game, x, tx, tile, tileh));
                },

                "creature": function (rSite, c0x, data, p1x, dataAndEvents) {
                    if (void 0 === dataAndEvents) {
                        dataAndEvents = this.world;
                    }
                    var edge = new($.Creature)(this.game, rSite, c0x, data, p1x);
                    return dataAndEvents.add(edge), edge;
                },

                "tween": function (property) {
                    return this.game.tweens.create(property);
                },

                "group": function (behavior, context, ignoreCase, nonCapture, command) {
                    return new($.Group)(this.game, behavior, context, ignoreCase, nonCapture, command);
                },

                "physicsGroup": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
                    return new $.Group(this.game, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, true, dataAndEvents);
                },

                "spriteBatch": function (dataAndEvents, closest, deepDataAndEvents) {
                    return void 0 === dataAndEvents && (dataAndEvents = null), void 0 === closest && (closest = "group"), void 0 === deepDataAndEvents && (deepDataAndEvents = false), new $.SpriteBatch(this.game, dataAndEvents, closest, deepDataAndEvents);
                },

                "audio": function (urls, overwrite, device, sampleURLs) {
                    return this.game.sound.add(urls, overwrite, device, sampleURLs);
                },

                "sound": function (vol, pitch, s, volume) {
                    return this.game.sound.add(vol, pitch, s, volume);
                },

                "audioSprite": function (deepDataAndEvents) {
                    return this.game.sound.addSprite(deepDataAndEvents);
                },

                "tileSprite": function (x, y, dataAndEvents, frame, height, width, exports) {
                    return void 0 === exports && (exports = this.world), exports.add(new($.TileSprite)(this.game, x, y, dataAndEvents, frame, height, width));
                },

                "rope": function (deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes, dataAndEvents) {
                    return void 0 === dataAndEvents && (dataAndEvents = this.world), dataAndEvents.add(new($.Rope)(this.game, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes));
                },

                "text": function (item, elem, a, x, id) {
                    return void 0 === id && (id = this.world), id.add(new($.Text)(this.game, item, elem, a, x));
                },

                "button": function (htmlList, a, val, settings, node, idx, condition, hoverState, att_value, isDisabled) {
                    return void 0 === isDisabled && (isDisabled = this.world), isDisabled.add(new $.Button(this.game, htmlList, a, val, settings, node, idx, condition, hoverState, att_value));
                },

                "graphics": function (dataAndEvents, x, dt) {
                    return void 0 === dt && (dt = this.world), dt.add(new($.Graphics)(this.game, dataAndEvents, x));
                },

                "emitter": function (new_emitter, x, value) {
                    return this.game.particles.add(new($.Particles.Arcade.Emitter)(this.game, new_emitter, x, value));
                },

                "retroFont": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes, matcherFunction, execResult, opt_keys) {
                    return new($.RetroFont)(this.game, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes, matcherFunction, execResult, opt_keys);
                },

                "bitmapText": function (style, y, dataAndEvents, text, deepDataAndEvents, x) {
                    return void 0 === x && (x = this.world), x.add(new($.BitmapText)(this.game, style, y, dataAndEvents, text, deepDataAndEvents));
                },

                "tilemap": function (overwrite, constrain, propreties, dataAndEvents, format) {
                    return new $.Tilemap(this.game, overwrite, constrain, propreties, dataAndEvents, format);
                },

                "renderTexture": function (timeout, fade, ch, sol) {
                    if (!(void 0 !== ch && "" !== ch)) {
                        ch = this.game.rnd.uuid();
                    }
                    if (void 0 === sol) {

                        sol = false;
                    }
                    var waitsFunc = new($.RenderTexture)(this.game, timeout, fade, ch);
                    return sol && this.game.cache.addRenderTexture(ch, waitsFunc), waitsFunc;
                },

                "video": function (dataAndEvents, url) {
                    return new($.Video)(this.game, dataAndEvents, url);
                },

                "bitmapData": function (dataAndEvents, deepDataAndEvents, ch, keepData) {
                    if (void 0 === keepData) {

                        keepData = false;
                    }
                    if (!(void 0 !== ch && "" !== ch)) {
                        ch = this.game.rnd.uuid();
                    }
                    var elem = new($.BitmapData)(this.game, ch, dataAndEvents, deepDataAndEvents);
                    return keepData && this.game.cache.addBitmapData(ch, elem), elem;
                },

                "filter": function (name) {
                    var expectedArgs = Array.prototype.slice.call(arguments, 1);
                    return (name = new($.Filter[name])(this.game)).init.apply(name, expectedArgs), name;
                },

                "plugin": function (opt) {
                    return this.game.plugins.add(opt);
                }
            }, $.GameObjectFactory.prototype.constructor = $.GameObjectFactory, $.GameObjectCreator = function (dataAndEvents) {
                this.game = dataAndEvents;
                this.world = this.game.world;
            }, $.GameObjectCreator.prototype = {

                "image": function (text, x, node, settings) {
                    return new($.Image)(this.game, text, x, node, settings);
                },

                "sprite": function (sprite, x, tx, tile) {
                    return new($.Sprite)(this.game, sprite, x, tx, tile);
                },

                "tween": function (endValues) {
                    return new($.Tween)(endValues, this.game, this.game.tweens);
                },

                "group": function (behavior, context, ignoreCase, nonCapture, command) {
                    return new($.Group)(this.game, behavior, context, ignoreCase, nonCapture, command);
                },

                "spriteBatch": function (deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist) {
                    return void 0 === dataAndEvents && (dataAndEvents = 'group'), void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = false), new($.SpriteBatch)(this.game, deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist);
                },

                "audio": function (urls, overwrite, device, sampleURLs) {
                    return this.game.sound.add(urls, overwrite, device, sampleURLs);
                },

                "audioSprite": function (deepDataAndEvents) {
                    return this.game.sound.addSprite(deepDataAndEvents);
                },

                "sound": function (vol, pitch, s, volume) {
                    return this.game.sound.add(vol, pitch, s, volume);
                },

                "tileSprite": function (x, y, dataAndEvents, frame, height, width) {
                    return new $.TileSprite(this.game, x, y, dataAndEvents, frame, height, width);
                },

                "rope": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
                    return new $.Rope(this.game, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData);
                },

                "text": function (id, item, elem, a) {
                    return new($.Text)(this.game, id, item, elem, a);
                },

                "button": function (htmlList, isDisabled, a, val, settings, node, idx, condition, hoverState) {
                    return new($.Button)(this.game, htmlList, isDisabled, a, val, settings, node, idx, condition, hoverState);
                },

                "graphics": function (dt, dataAndEvents) {
                    return new $.Graphics(this.game, dt, dataAndEvents);
                },

                "emitter": function (new_emitter, x, value) {
                    return new($.Particles.Arcade.Emitter)(this.game, new_emitter, x, value);
                },

                "retroFont": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes, matcherFunction, execResult, opt_keys) {
                    return new($.RetroFont)(this.game, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes, matcherFunction, execResult, opt_keys);
                },

                "bitmapText": function (x, style, y, dataAndEvents, text, deepDataAndEvents) {
                    return new $.BitmapText(this.game, x, style, y, dataAndEvents, text, deepDataAndEvents);
                },

                "tilemap": function (overwrite, constrain, propreties, dataAndEvents, format) {
                    return new($.Tilemap)(this.game, overwrite, constrain, propreties, dataAndEvents, format);
                },

                "renderTexture": function (timeout, fade, ch, sol) {
                    if (!(void 0 !== ch && "" !== ch)) {
                        ch = this.game.rnd.uuid();
                    }
                    if (void 0 === sol) {

                        sol = false;
                    }
                    var waitsFunc = new($.RenderTexture)(this.game, timeout, fade, ch);
                    return sol && this.game.cache.addRenderTexture(ch, waitsFunc), waitsFunc;
                },

                "bitmapData": function (dataAndEvents, deepDataAndEvents, ch, keepData) {
                    if (void 0 === keepData) {

                        keepData = false;
                    }
                    if (!(void 0 !== ch && "" !== ch)) {
                        ch = this.game.rnd.uuid();
                    }
                    var elem = new($.BitmapData)(this.game, ch, dataAndEvents, deepDataAndEvents);
                    return keepData && this.game.cache.addBitmapData(ch, elem), elem;
                },

                "filter": function (name) {
                    var expectedArgs = Array.prototype.slice.call(arguments, 1);
                    return (name = new($.Filter[name])(this.game)).init.apply(name, expectedArgs), name;
                }
            }, $.GameObjectCreator.prototype.constructor = $.GameObjectCreator, $.Sprite = function (deepDataAndEvents, made, contexts, toClass, opt_message) {
                made = made || 0;
                contexts = contexts || 0;
                toClass = toClass || null;
                opt_message = opt_message || null;
                this.type = $.SPRITE;
                this.physicsType = $.SPRITE;
                PIXI.Sprite.call(this, $.Cache.DEFAULT);
                $.Component.Core.init.call(this, deepDataAndEvents, made, contexts, toClass, opt_message);
            }, $.Sprite.prototype = Object.create(PIXI.Sprite.prototype), $.Sprite.prototype.constructor = $.Sprite, $.Component.Core.install.call($.Sprite.prototype, ['Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', "Crop", 'Delta', 'Destroy', 'FixedToCamera', 'Health', "InCamera", 'InputEnabled', 'InWorld', "LifeSpan", 'LoadTexture',
                "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"
            ]), $.Sprite.prototype.preUpdatePhysics = $.Component.PhysicsBody.preUpdate, $.Sprite.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.Sprite.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.Sprite.prototype.preUpdateCore = $.Component.Core.preUpdate, $.Sprite.prototype.preUpdate =
            function () {
                return !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.Image = function (deepDataAndEvents, made, contexts, toClass, opt_message) {
                made = made || 0;
                contexts = contexts || 0;
                toClass = toClass || null;
                opt_message = opt_message || null;
                this.type = $.IMAGE;
                PIXI.Sprite.call(this, $.Cache.DEFAULT);
                $.Component.Core.init.call(this, deepDataAndEvents, made, contexts, toClass, opt_message);
            }, $.Image.prototype = Object.create(PIXI.Sprite.prototype), $.Image.prototype.constructor = $.Image, $.Component.Core.install.call($.Image.prototype, ['Angle', 'Animation', 'AutoCull', 'Bounds', "BringToTop", "Crop", "Destroy", "FixedToCamera", 'InputEnabled', 'LifeSpan', 'LoadTexture', 'Overlap', 'Reset', 'ScaleMinMax',
                "Smoothed"
            ]), $.Image.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.Image.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.Image.prototype.preUpdateCore = $.Component.Core.preUpdate, $.Image.prototype.preUpdate = function () {
                return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore();
            }, $.Button = function (deepDataAndEvents, made, contexts, toClass, opt_message, details, opt_obj2, walkers, isXML, next_scope) {
                made = made || 0;
                contexts = contexts || 0;
                toClass = toClass || null;
                opt_message = opt_message || null;
                details = details || this;
                $.Image.call(this, deepDataAndEvents, made, contexts, toClass, walkers);
                this.type = $.BUTTON;
                this.physicsType = $.SPRITE;

                this._onOverFrame = null;

                this._onOutFrame = null;

                this._onDownFrame = null;

                this._onUpFrame = null;

                this.onOverSound = null;

                this.onOutSound = null;

                this.onDownSound = null;

                this.onUpSound = null;

                this.onOverSoundMarker = "";

                this.onOutSoundMarker = "";

                this.onDownSoundMarker = "";

                this.onUpSoundMarker = "";
                this.onInputOver = new($.Signal);
                this.onInputOut = new($.Signal);
                this.onInputDown = new($.Signal);
                this.onInputUp = new $.Signal;

                this.onOverMouseOnly = true;
                this.justReleasedPreventsOver = $.PointerMode.CONTACT;

                this.freezeFrames = false;

                this.forceOut = false;

                this.inputEnabled = true;
                this.input.start(0, true);

                this.input.useHandCursor = true;
                this.setFrames(opt_obj2, walkers, isXML, next_scope);
                if (null !== opt_message) {
                    this.onInputUp.add(opt_message, details);
                }
                this.events.onInputOver.add(this.onInputOverHandler, this);
                this.events.onInputOut.add(this.onInputOutHandler, this);
                this.events.onInputDown.add(this.onInputDownHandler, this);
                this.events.onInputUp.add(this.onInputUpHandler, this);
            }, $.Button.prototype = Object.create($.Image.prototype), $.Button.prototype.constructor = $.Button, $.Button.prototype.clearFrames = function () {
                this.setFrames(null, null, null, null);
            }, $.Button.prototype.setStateFrame = function (deepDataAndEvents, data, dataAndEvents) {
                var unlock = '_on' + deepDataAndEvents + 'Frame';
                if (null !== data) {

                    this[unlock] = data;
                    if (dataAndEvents) {
                        this.changeStateFrame(deepDataAndEvents);
                    }
                } else {

                    this[unlock] = null;
                }
            }, $.Button.prototype.changeStateFrame = function (custom) {
                if (this.freezeFrames) {
                    return false;
                }
                var realFrame = this["_on" + custom + 'Frame'];
                return 'string' == typeof realFrame ? (this.frameName = realFrame, true) : 'number' == typeof realFrame && (this.frame = realFrame, true);
            }, $.Button.prototype.setFrames = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
                this.setStateFrame("Over", deepDataAndEvents, this.input.pointerOver());
                this.setStateFrame("Out", opt_obj2, !this.input.pointerOver());
                this.setStateFrame('Down', walkers, this.input.pointerDown());
                this.setStateFrame("Up", isXML, this.input.pointerUp());
            }, $.Button.prototype.setStateSound = function (evtName, data, value) {

                var unlock = "on" + evtName + 'Sound';

                var i = "on" + evtName + 'SoundMarker';
                if (data instanceof $.Sound || data instanceof $.AudioSprite) {
                    this[unlock] = data;
                    this[i] = 'string' == typeof value ? value : "";
                } else {

                    this[unlock] = null;

                    this[i] = "";
                }
            }, $.Button.prototype.playStateSound = function (evtName) {
                var media = this["on" + evtName + "Sound"];
                if (media) {
                    var r20 = this["on" + evtName + 'SoundMarker'];
                    return media.play(r20), true;
                }
                return false;
            }, $.Button.prototype.setSounds = function (walkers, isXML, next_scope, shallow, deepDataAndEvents, opt_obj2, funcToCall, _super) {
                this.setStateSound('Over', walkers, isXML);
                this.setStateSound('Out', deepDataAndEvents, opt_obj2);
                this.setStateSound('Down', next_scope, shallow);
                this.setStateSound("Up", funcToCall, _super);
            }, $.Button.prototype.setOverSound = function (deepDataAndEvents, opt_obj2) {
                this.setStateSound('Over', deepDataAndEvents, opt_obj2);
            }, $.Button.prototype.setOutSound = function (deepDataAndEvents, opt_obj2) {
                this.setStateSound('Out', deepDataAndEvents, opt_obj2);
            }, $.Button.prototype.setDownSound = function (deepDataAndEvents, opt_obj2) {
                this.setStateSound("Down", deepDataAndEvents, opt_obj2);
            }, $.Button.prototype.setUpSound = function (deepDataAndEvents, opt_obj2) {
                this.setStateSound("Up", deepDataAndEvents, opt_obj2);
            }, $.Button.prototype.onInputOverHandler = function (dataAndEvents, deepDataAndEvents) {
                if (!(deepDataAndEvents.justReleased() && (this.justReleasedPreventsOver & deepDataAndEvents.pointerMode) === deepDataAndEvents.pointerMode)) {
                    this.changeStateFrame('Over');
                    if (!(this.onOverMouseOnly && !deepDataAndEvents.isMouse)) {
                        this.playStateSound("Over");
                        if (this.onInputOver) {
                            this.onInputOver.dispatch(this, deepDataAndEvents);
                        }
                    }
                }
            }, $.Button.prototype.onInputOutHandler = function (dataAndEvents, deepDataAndEvents) {
                this.changeStateFrame('Out');
                this.playStateSound("Out");
                if (this.onInputOut) {
                    this.onInputOut.dispatch(this, deepDataAndEvents);
                }
            }, $.Button.prototype.onInputDownHandler = function (dataAndEvents, deepDataAndEvents) {
                this.changeStateFrame('Down');
                this.playStateSound("Down");
                if (this.onInputDown) {
                    this.onInputDown.dispatch(this, deepDataAndEvents);
                }
            }, $.Button.prototype.onInputUpHandler = function (dataAndEvents, deepDataAndEvents, opt_obj2) {
                this.playStateSound("Up");
                if (this.onInputUp) {
                    this.onInputUp.dispatch(this, deepDataAndEvents, opt_obj2);
                }
                if (!this.freezeFrames) {
                    if (true === this.forceOut || (this.forceOut & deepDataAndEvents.pointerMode) === deepDataAndEvents.pointerMode) {
                        this.changeStateFrame('Out');
                    } else {
                        if (!this.changeStateFrame("Up")) {
                            if (opt_obj2) {
                                this.changeStateFrame('Over');
                            } else {
                                this.changeStateFrame('Out');
                            }
                        }
                    }
                }
            }, $.SpriteBatch = function (opt_nodes, node, deepDataAndEvents, opt_obj2) {
                if (!(void 0 !== node && null !== node)) {
                    node = opt_nodes.world;
                }
                $.Group.call(this, opt_nodes, node, deepDataAndEvents, opt_obj2);
                this.type = $.SPRITEBATCH;

                this.fastSpriteBatch = null;

                this.ready = false;
            }, $.SpriteBatch.prototype = Object.create($.Group.prototype), $.SpriteBatch.prototype.constructor = $.SpriteBatch, $.SpriteBatch.prototype._renderWebGL = function (deepDataAndEvents) {
                if (!!this.visible) {
                    if (!(this.alpha <= 0)) {
                        if (!!this.children.length) {
                            if (!this.ready) {
                                this.fastSpriteBatch = new(PIXI.WebGLFastSpriteBatch)(deepDataAndEvents.gl);

                                this.ready = true;
                            }
                            if (this.fastSpriteBatch.gl !== deepDataAndEvents.gl) {
                                this.fastSpriteBatch.setContext(deepDataAndEvents.gl);
                            }
                            deepDataAndEvents.spriteBatch.stop();
                            deepDataAndEvents.shaderManager.setShader(deepDataAndEvents.shaderManager.fastShader);
                            this.fastSpriteBatch.begin(this, deepDataAndEvents);
                            this.fastSpriteBatch.render(this);
                            deepDataAndEvents.spriteBatch.start();
                        }
                    }
                }
            }, $.SpriteBatch.prototype._renderCanvas = function (fn) {
                if (this.visible && (!(this.alpha <= 0) && this.children.length)) {
                    var obj = fn.context;
                    obj.globalAlpha = this.worldAlpha;
                    this.displayObjectUpdateTransform();
                    var array = this.worldTransform;

                    var _0x594520 = true;

                    var paramIndex = 0;
                    for (; paramIndex < this.children.length; paramIndex++) {
                        var params = this.children[paramIndex];
                        if (params.visible) {
                            var param = params.texture;
                            var args = param.frame;
                            if (obj.globalAlpha = this.worldAlpha * params.alpha, params.rotation % (2 * Math.PI) == 0) {
                                if (_0x594520) {
                                    obj.setTransform(array.a, array.b, array.c, array.d, array.tx, array.ty);

                                    _0x594520 = false;
                                }
                                obj.drawImage(param.baseTexture.source, args.x, args.y, args.width, args.height, params.anchor.x * (-args.width * params.scale.x) + params.position.x + 0.5 + fn.shakeX | 0, params.anchor.y * (-args.height * params.scale.y) + params.position.y + 0.5 + fn.shakeY | 0, args.width * params.scale.x, args.height * params.scale.y);
                            } else {
                                if (!_0x594520) {

                                    _0x594520 = true;
                                }
                                params.displayObjectUpdateTransform();
                                var data = params.worldTransform;
                                var r20 = data.tx * fn.resolution + fn.shakeX;
                                var restoreScript = data.ty * fn.resolution + fn.shakeY;
                                if (fn.roundPixels) {
                                    obj.setTransform(data.a, data.b, data.c, data.d, 0 | r20, 0 | restoreScript);
                                } else {
                                    obj.setTransform(data.a, data.b, data.c, data.d, r20, restoreScript);
                                }
                                obj.drawImage(param.baseTexture.source, args.x, args.y, args.width, args.height, params.anchor.x * -args.width + 0.5 | 0, params.anchor.y * -args.height + 0.5 | 0, args.width, args.height);
                            }
                        }
                    }
                }
            }, $.BitmapData = function (dataAndEvents, ignoreMethodDoesntExist, following, newval, deepDataAndEvents) {
                if (!(void 0 !== following && 0 !== following)) {

                    following = 256;
                }
                if (!(void 0 !== newval && 0 !== newval)) {

                    newval = 256;
                }
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = false;
                }
                this.game = dataAndEvents;
                this.key = ignoreMethodDoesntExist;

                this.width = following;

                this.height = newval;
                this.canvas = $.Canvas.create(this, following, newval, null, deepDataAndEvents);
                this.context = this.canvas.getContext("2d", {
                    "alpha": true
                });
                this.ctx = this.context;
                this.smoothProperty = dataAndEvents.renderType === $.CANVAS ? dataAndEvents.renderer.renderSession.smoothProperty : $.Canvas.getSmoothingPrefix(this.context);
                this.imageData = this.context.getImageData(0, 0, following, newval);

                this.data = null;
                if (this.imageData) {
                    this.data = this.imageData.data;
                }

                this.pixels = null;
                if (this.data) {
                    if (this.imageData.data.buffer) {
                        this.buffer = this.imageData.data.buffer;

                        this.pixels = new Uint32Array(this.buffer);
                    } else {
                        if (window.ArrayBuffer) {

                            this.buffer = new ArrayBuffer(this.imageData.data.length);

                            this.pixels = new Uint32Array(this.buffer);
                        } else {
                            this.pixels = this.imageData.data;
                        }
                    }
                }
                this.baseTexture = new(PIXI.BaseTexture)(this.canvas, null, this.game.resolution);
                this.texture = new(PIXI.Texture)(this.baseTexture);
                this.frameData = new($.FrameData);
                this.textureFrame = this.frameData.addFrame(new($.Frame)(0, 0, 0, following, newval, 'bitmapData'));
                this.texture.frame = this.textureFrame;
                this.type = $.BITMAPDATA;

                this.disableTextureUpload = false;

                this.dirty = false;
                this.cls = this.clear;

                this._image = null;
                this._pos = new($.Point);
                this._size = new($.Point);
                this._scale = new($.Point);

                this._rotate = 0;
                this._alpha = {
                    "prev": 1,
                    "current": 1
                };
                this._anchor = new $.Point;

                this._tempR = 0;

                this._tempG = 0;

                this._tempB = 0;
                this._circle = new($.Circle);
                this._swapCanvas = void 0;
            }, $.BitmapData.prototype = {

                "move": function (element, e, animationCompleted) {
                    return 0 !== element && this.moveH(element, animationCompleted), 0 !== e && this.moveV(e, animationCompleted), this;
                },

                "moveH": function (t, dataAndEvents) {
                    if (void 0 === dataAndEvents) {

                        dataAndEvents = true;
                    }
                    if (void 0 === this._swapCanvas) {
                        this._swapCanvas = $.CanvasPool.create(this, this.width, this.height);
                    }
                    var modifierFunctions = this._swapCanvas.getContext("2d");
                    var dh = this.height;
                    var newDoc = this.canvas;
                    if (modifierFunctions.clearRect(0, 0, this.width, this.height), t < 0) {
                        t = Math.abs(t);

                        k = this.width - t;
                        if (dataAndEvents) {
                            modifierFunctions.drawImage(newDoc, 0, 0, t, dh, k, 0, t, dh);
                        }
                        modifierFunctions.drawImage(newDoc, t, 0, k, dh, 0, 0, k, dh);
                    } else {

                        var k = this.width - t;
                        if (dataAndEvents) {
                            modifierFunctions.drawImage(newDoc, k, 0, t, dh, 0, 0, t, dh);
                        }
                        modifierFunctions.drawImage(newDoc, 0, 0, k, dh, t, 0, k, dh);
                    }
                    return this.clear(), this.copy(this._swapCanvas);
                },

                "moveV": function (i, dataAndEvents) {
                    if (void 0 === dataAndEvents) {

                        dataAndEvents = true;
                    }
                    if (void 0 === this._swapCanvas) {
                        this._swapCanvas = $.CanvasPool.create(this, this.width, this.height);
                    }
                    var doc = this._swapCanvas.getContext("2d");
                    var r20 = this.width;
                    var domContentLoaded = this.canvas;
                    if (doc.clearRect(0, 0, this.width, this.height), i < 0) {
                        i = Math.abs(i);

                        f = this.height - i;
                        if (dataAndEvents) {
                            doc.drawImage(domContentLoaded, 0, 0, r20, i, 0, f, r20, i);
                        }
                        doc.drawImage(domContentLoaded, 0, i, r20, f, 0, 0, r20, f);
                    } else {

                        var f = this.height - i;
                        if (dataAndEvents) {
                            doc.drawImage(domContentLoaded, 0, f, r20, i, 0, 0, r20, i);
                        }
                        doc.drawImage(domContentLoaded, 0, 0, r20, f, 0, i, r20, f);
                    }
                    return this.clear(), this.copy(this._swapCanvas);
                },

                "add": function (h) {
                    if (Array.isArray(h)) {

                        var k = 0;
                        for (; k < h.length; k++) {
                            if (h[k].loadTexture) {
                                h[k].loadTexture(this);
                            }
                        }
                    } else {
                        h.loadTexture(this);
                    }
                    return this;
                },

                "load": function (params) {
                    if ('string' == typeof params && (params = this.game.cache.getImage(params)), params) {
                        return this.resize(params.width, params.height), this.cls(), this.draw(params), this.update(), this;
                    }
                },

                "clear": function (initial, arr, timerId, reporter) {
                    return void 0 === initial && (initial = 0), void 0 === arr && (arr = 0), void 0 === timerId && (timerId = this.width), void 0 === reporter && (reporter = this.height), this.context.clearRect(initial, arr, timerId, reporter), this.dirty = true, this;
                },

                "fill": function (inContext, fill, soft, pool) {
                    return void 0 === pool && (pool = 1), this.context.fillStyle = "rgba(" + inContext + "," + fill + "," + soft + "," + pool + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = true, this;
                },

                "generateTexture": function (data, defn, height) {
                    var listeners = this.game.cache;

                    var image = new Image;
                    if (defn && (image.onload = function () {
                            var doc2 = listeners.addImage(data, "", image);
                            var r20 = new PIXI.Texture(doc2.base);
                            defn.call(height || null, r20);

                            image.onload = null;
                        }), image.src = this.canvas.toDataURL("image/png"), !defn) {
                        var doc2 = listeners.addImage(data, "", image);
                        return new PIXI.Texture(doc2.base);
                    }
                    return null;
                },

                "resize": function (x, y) {
                    return x === this.width && y === this.height || (this.width = x, this.height = y, this.canvas.width = x, this.canvas.height = y, void 0 !== this._swapCanvas && (this._swapCanvas.width = x, this._swapCanvas.height = y), this.baseTexture.width = x, this.baseTexture.height = y, this.textureFrame.width = x, this.textureFrame.height = y, this.texture.width =
                        x, this.texture.height = y, this.texture.crop.width = x, this.texture.crop.height = y, this.update(), this.dirty = true), this;
                },

                "update": function (bytes, atts, viewModel, opt_length) {
                    return void 0 === bytes && (bytes = 0), void 0 === atts && (atts = 0), void 0 === viewModel && (viewModel = Math.max(1, this.width)), void 0 === opt_length && (opt_length = Math.max(1, this.height)), this.imageData = this.context.getImageData(bytes, atts, viewModel, opt_length), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer,
                        this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this;
                },

                "processPixelRGB": function (el, k, element, far, suffix, near) {
                    if (void 0 === element) {

                        element = 0;
                    }
                    if (void 0 === far) {

                        far = 0;
                    }
                    if (void 0 === suffix) {
                        suffix = this.width;
                    }
                    if (void 0 === near) {
                        near = this.height;
                    }
                    var elementFuncName = element + suffix;
                    var blockCount = far + near;
                    var oldc = $.Color.createColor();
                    var c = {
                        "r": 0,
                        "g": 0,
                        "b": 0,
                        "a": 0
                    };

                    var _0x1efbfa = false;

                    var b = far;
                    for (; b < blockCount; b++) {

                        var hr = element;
                        for (; hr < elementFuncName; hr++) {
                            $.Color.unpackPixel(this.getPixel32(hr, b), oldc);
                            if (false !== (c = el.call(k, oldc, hr, b))) {
                                if (null !== c) {
                                    if (void 0 !== c) {
                                        this.setPixel32(hr, b, c.r, c.g, c.b, c.a, false);

                                        _0x1efbfa = true;
                                    }
                                }
                            }
                        }
                    }
                    return _0x1efbfa && (this.context.putImageData(this.imageData, 0, 0), this.dirty = true), this;
                },

                "processPixel": function (collection, resp, event, y1, type, height) {
                    if (void 0 === event) {

                        event = 0;
                    }
                    if (void 0 === y1) {

                        y1 = 0;
                    }
                    if (void 0 === type) {
                        type = this.width;
                    }
                    if (void 0 === height) {
                        height = this.height;
                    }
                    var msg = event + type;
                    var y2 = y1 + height;

                    var pdataCur = 0;

                    var respOutput = 0;

                    var _0x2d0a3e = false;

                    var pdataOld = y1;
                    for (; pdataOld < y2; pdataOld++) {

                        var originalEvent = event;
                        for (; originalEvent < msg; originalEvent++) {
                            pdataCur = this.getPixel32(originalEvent, pdataOld);
                            if ((respOutput = collection.call(resp, pdataCur, originalEvent, pdataOld)) !== pdataCur) {
                                this.pixels[pdataOld * this.width + originalEvent] = respOutput;

                                _0x2d0a3e = true;
                            }
                        }
                    }
                    return _0x2d0a3e && (this.context.putImageData(this.imageData, 0, 0), this.dirty = true), this;
                },

                "replaceRGB": function (elem, fn, until, next_scope, deepDataAndEvents, opt_obj2, walkers, isXML, row) {

                    var token = 0;

                    var child = 0;
                    var level = this.width;
                    var cell = this.height;
                    var matched = $.Color.packPixel(elem, fn, until, next_scope);
                    if (void 0 !== row) {
                        if (row instanceof $.Rectangle) {
                            token = row.x;
                            child = row.y;
                            level = row.width;
                            cell = row.height;
                        }
                    }

                    var i = 0;
                    for (; i < cell; i++) {

                        var index = 0;
                        for (; index < level; index++) {
                            if (this.getPixel32(token + index, child + i) === matched) {
                                this.setPixel32(token + index, child + i, deepDataAndEvents, opt_obj2, walkers, isXML, false);
                            }
                        }
                    }
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = true, this;
                },

                "setHSL": function (value, g, l, s) {
                    var class2remove = value || 0 === value;
                    var program = g || 0 === g;
                    var inverse = l || 0 === l;
                    if (class2remove || (program || inverse)) {
                        if (void 0 === s) {
                            s = new($.Rectangle)(0, 0, this.width, this.height);
                        }
                        var data = $.Color.createColor();
                        var v = s.y;
                        for (; v < s.bottom; v++) {
                            var tmp = s.x;
                            for (; tmp < s.right; tmp++) {
                                $.Color.unpackPixel(this.getPixel32(tmp, v), data, true);
                                if (class2remove) {
                                    data.h = value;
                                }
                                if (program) {
                                    data.s = g;
                                }
                                if (inverse) {
                                    data.l = l;
                                }
                                $.Color.HSLtoRGB(data.h, data.s, data.l, data);
                                this.setPixel32(tmp, v, data.r, data.g, data.b, data.a, false);
                            }
                        }
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = true, this;
                    }
                },

                "shiftHSL": function (blue, method, value, target) {
                    if (void 0 !== blue && null !== blue || (blue = false), void 0 !== method && null !== method || (method = false), void 0 !== value && null !== value || (value = false), blue || (method || value)) {
                        if (void 0 === target) {
                            target = new($.Rectangle)(0, 0, this.width, this.height);
                        }
                        var data = $.Color.createColor();
                        var t = target.y;
                        for (; t < target.bottom; t++) {
                            var command = target.x;
                            for (; command < target.right; command++) {
                                $.Color.unpackPixel(this.getPixel32(command, t), data, true);
                                if (blue) {
                                    data.h = this.game.math.wrap(data.h + blue, 0, 1);
                                }
                                if (method) {
                                    data.s = this.game.math.clamp(data.s + method, 0, 1);
                                }
                                if (value) {
                                    data.l = this.game.math.clamp(data.l + value, 0, 1);
                                }
                                $.Color.HSLtoRGB(data.h, data.s, data.l, data);
                                this.setPixel32(command, t, data.r, data.g, data.b, data.a, false);
                            }
                        }
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = true, this;
                    }
                },

                "setPixel32": function (b, c, dataAndEvents, deepDataAndEvents, o2, o1, ignoreMethodDoesntExist) {
                    return void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = true), b >= 0 && (b <= this.width && (c >= 0 && (c <= this.height && ($.Device.LITTLE_ENDIAN ? this.pixels[c * this.width + b] = o1 << 24 | o2 << 16 | deepDataAndEvents << 8 | dataAndEvents : this.pixels[c * this.width + b] = dataAndEvents << 24 | deepDataAndEvents << 16 | o2 << 8 | o1, ignoreMethodDoesntExist && (this.context.putImageData(this.imageData,
                        0, 0), this.dirty = true))))), this;
                },

                "setPixel": function (g, r, a, b, imageData, deepDataAndEvents) {
                    return this.setPixel32(g, r, a, b, imageData, 255, deepDataAndEvents);
                },

                "getPixel": function (a, x, o) {
                    if (!o) {
                        o = $.Color.createColor();
                    }

                    var i = ~~(a + x * this.width);
                    return i *= 4, o.r = this.data[i], o.g = this.data[++i], o.b = this.data[++i], o.a = this.data[++i], o;
                },

                "getPixel32": function (b, c) {
                    if (b >= 0 && (b <= this.width && (c >= 0 && c <= this.height))) {
                        return this.pixels[c * this.width + b];
                    }
                },

                "getPixelRGB": function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
                    return $.Color.unpackPixel(this.getPixel32(deepDataAndEvents, opt_obj2), walkers, isXML, next_scope);
                },

                "getPixels": function (data) {
                    return this.context.getImageData(data.x, data.y, data.width, data.height);
                },

                "getFirstPixel": function (code) {
                    if (void 0 === code) {

                        code = 0;
                    }
                    var keys = $.Color.createColor();

                    var key = 0;

                    var value = 0;

                    var c = 1;

                    var _0x34bc6c = false;
                    if (1 === code) {

                        c = -1;
                        value = this.height;
                    } else {
                        if (3 === code) {

                            c = -1;
                            key = this.width;
                        }
                    }
                    do {
                        $.Color.unpackPixel(this.getPixel32(key, value), keys);
                        if (0 === code || 1 === code) {
                            if (++key === this.width) {

                                key = 0;
                                if ((value += c) >= this.height || value <= 0) {

                                    _0x34bc6c = true;
                                }
                            }
                        } else {
                            if (!(2 !== code && 3 !== code)) {
                                if (++value === this.height) {

                                    value = 0;
                                    if ((key += c) >= this.width || key <= 0) {

                                        _0x34bc6c = true;
                                    }
                                }
                            }
                        }
                    } while (0 === keys.a && !_0x34bc6c);
                    return keys.x = key, keys.y = value, keys;
                },

                "getBounds": function (prevState) {
                    return void 0 === prevState && (prevState = new($.Rectangle)), prevState.x = this.getFirstPixel(2).x, prevState.x === this.width ? prevState.setTo(0, 0, 0, 0) : (prevState.y = this.getFirstPixel(0).y, prevState.width = this.getFirstPixel(3).x - prevState.x + 1, prevState.height = this.getFirstPixel(1).y - prevState.y + 1, prevState);
                },

                "addToWorld": function ($rootScope, protoProps, deepDataAndEvents, opt_obj2, options, made) {
                    options = options || 1;
                    made = made || 1;
                    var child = this.game.add.image($rootScope, protoProps, this);
                    return child.anchor.set(deepDataAndEvents, opt_obj2), child.scale.set(options, made), child;
                },

                "copy": function (data, obj, node, x, array, target, value, out, tree, index, v, len, test, res, from_instance, name, dstUri) {
                    if (void 0 !== data && null !== data || (data = this), data instanceof $.RenderTexture && (data = data.getCanvas()), this._image = data, data instanceof $.Sprite || (data instanceof $.Image || (data instanceof $.Text || data instanceof PIXI.Sprite))) {
                        this._pos.set(data.texture.crop.x, data.texture.crop.y);
                        this._size.set(data.texture.crop.width, data.texture.crop.height);
                        this._scale.set(data.scale.x, data.scale.y);
                        this._anchor.set(data.anchor.x, data.anchor.y);
                        this._rotate = data.rotation;
                        this._alpha.current = data.alpha;
                        if (data.texture instanceof $.RenderTexture) {
                            this._image = data.texture.getCanvas();
                        } else {
                            this._image = data.texture.baseTexture.source;
                        }
                        if (!(void 0 !== target && null !== target)) {
                            target = data.x;
                        }
                        if (!(void 0 !== value && null !== value)) {
                            value = data.y;
                        }
                        if (data.texture.trim) {
                            target += data.texture.trim.x - data.anchor.x * data.texture.trim.width;
                            value += data.texture.trim.y - data.anchor.y * data.texture.trim.height;
                        }
                        if (16777215 !== data.tint) {
                            if (data.cachedTint !== data.tint) {
                                data.cachedTint = data.tint;
                                data.tintedTexture = PIXI.CanvasTinter.getTintedTexture(data, data.tint);
                            }
                            this._image = data.tintedTexture;
                            this._pos.set(0);
                        }
                    } else {
                        if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, data instanceof $.BitmapData) {
                            this._image = data.canvas;
                        } else {
                            if ('string' == typeof data) {
                                if (null === (data = this.game.cache.getImage(data))) {
                                    return;
                                }
                                this._image = data;
                            }
                        }
                        this._size.set(this._image.width, this._image.height);
                    }
                    if (void 0 !== obj && null !== obj || (obj = 0), void 0 !== node && null !== node || (node = 0), x && (this._size.x = x), array && (this._size.y = array), void 0 !== target && null !== target || (target = obj), void 0 !== value && null !== value || (value = node), void 0 !== out && null !== out || (out = this._size.x), void 0 !== tree && null !== tree || (tree = this._size.y), "number" == typeof index && (this._rotate = index), 'number' ==
                        typeof v && (this._anchor.x = v), "number" == typeof len && (this._anchor.y = len), 'number' == typeof test && (this._scale.x = test), 'number' == typeof res && (this._scale.y = res), 'number' == typeof from_instance && (this._alpha.current = from_instance), void 0 === name && (name = null), void 0 === dstUri && (dstUri = false), !(this._alpha.current <= 0 || (0 === this._scale.x ||
                            (0 === this._scale.y || (0 === this._size.x || 0 === this._size.y))))) {
                        var doc = this.context;
                        return this._alpha.prev = doc.globalAlpha, doc.save(), doc.globalAlpha = this._alpha.current, name && (this.op = name), dstUri && (target |= 0, value |= 0), doc.translate(target, value), doc.scale(this._scale.x, this._scale.y), doc.rotate(this._rotate), doc.drawImage(this._image, this._pos.x + obj, this._pos.y + node, this._size.x,
                            this._size.y, -out * this._anchor.x, -tree * this._anchor.y, out, tree), doc.restore(), doc.globalAlpha = this._alpha.prev, this.dirty = true, this;
                    }
                },

                "copyTransform": function (data, i, dataAndEvents) {
                    if (void 0 === i && (i = null), void 0 === dataAndEvents && (dataAndEvents = false), !data.hasOwnProperty('worldTransform') || (!data.worldVisible || 0 === data.worldAlpha)) {
                        return this;
                    }
                    var g = data.worldTransform;
                    if (this._pos.set(data.texture.crop.x, data.texture.crop.y), this._size.set(data.texture.crop.width, data.texture.crop.height), 0 === g.a || (0 === g.d || (0 === this._size.x || 0 === this._size.y))) {
                        return this;
                    }
                    if (data.texture instanceof $.RenderTexture) {
                        this._image = data.texture.getCanvas();
                    } else {
                        this._image = data.texture.baseTexture.source;
                    }
                    var r20 = g.tx;
                    var restoreScript = g.ty;
                    if (data.texture.trim) {
                        r20 += data.texture.trim.x - data.anchor.x * data.texture.trim.width;
                        restoreScript += data.texture.trim.y - data.anchor.y * data.texture.trim.height;
                    }
                    if (16777215 !== data.tint) {
                        if (data.cachedTint !== data.tint) {
                            data.cachedTint = data.tint;
                            data.tintedTexture = PIXI.CanvasTinter.getTintedTexture(data, data.tint);
                        }
                        this._image = data.tintedTexture;
                        this._pos.set(0);
                    }
                    if (dataAndEvents) {
                        r20 |= 0;
                        restoreScript |= 0;
                    }
                    var node = this.context;
                    return this._alpha.prev = node.globalAlpha, node.save(), node.globalAlpha = this._alpha.current, i && (this.op = i), node[this.smoothProperty] = data.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, node.setTransform(g.a, g.b, g.c, g.d, r20, restoreScript), node.drawImage(this._image, this._pos.x, this._pos.y, this._size.x,
                        this._size.y, -this._size.x * data.anchor.x, -this._size.y * data.anchor.y, this._size.x, this._size.y), node.restore(), node.globalAlpha = this._alpha.prev, this.dirty = true, this;
                },

                "copyRect": function (deepDataAndEvents, hash, opt_obj2, walkers, isXML, next_scope, shallow) {
                    return this.copy(deepDataAndEvents, hash.x, hash.y, hash.width, hash.height, opt_obj2, walkers, hash.width, hash.height, 0, 0, 0, 1, 1, isXML, next_scope, shallow);
                },

                "draw": function (px, surface, ctx, opt_options, deltaT, dataTable, time) {
                    return this.copy(px, null, null, null, null, surface, ctx, opt_options, deltaT, null, null, null, null, null, null, dataTable, time);
                },

                "drawGroup": function (dataAndEvents, deepDataAndEvents, opt_obj2) {
                    return dataAndEvents.total > 0 && dataAndEvents.forEachExists(this.drawGroupProxy, this, deepDataAndEvents, opt_obj2), this;
                },

                "drawGroupProxy": function (data, deepDataAndEvents, opt_obj2) {
                    if (data.hasOwnProperty("texture") && this.copyTransform(data, deepDataAndEvents, opt_obj2), data.type === $.GROUP && data.exists) {
                        this.drawGroup(data, deepDataAndEvents, opt_obj2);
                    } else {
                        if (data.hasOwnProperty('children') && data.children.length > 0) {

                            var value_idx = 0;
                            for (; value_idx < data.children.length; value_idx++) {
                                if (data.children[value_idx].exists) {
                                    this.copyTransform(data.children[value_idx], deepDataAndEvents, opt_obj2);
                                }
                            }
                        }
                    }
                },

                "drawFull": function (data, deepDataAndEvents, opt_obj2) {
                    if (false === data.worldVisible || (0 === data.worldAlpha || data.hasOwnProperty('exists') && false === data.exists)) {
                        return this;
                    }
                    if (data.type !== $.GROUP && (data.type !== $.EMITTER && data.type !== $.BITMAPTEXT)) {
                        if (data.type === $.GRAPHICS) {
                            var urls = data.getBounds();
                            this.ctx.save();
                            this.ctx.translate(urls.x, urls.y);
                            PIXI.CanvasGraphics.renderGraphics(data, this.ctx);
                            this.ctx.restore();
                        } else {
                            this.copy(data, null, null, null, null, data.worldPosition.x, data.worldPosition.y, null, null, data.worldRotation, null, null, data.worldScale.x, data.worldScale.y, data.worldAlpha, deepDataAndEvents, opt_obj2);
                        }
                    }
                    if (data.children) {

                        var value_idx = 0;
                        for (; value_idx < data.children.length; value_idx++) {
                            this.drawFull(data.children[value_idx], deepDataAndEvents, opt_obj2);
                        }
                    }
                    return this;
                },

                "shadow": function (value, cutOff, b, elementName) {
                    var flags = this.context;
                    return void 0 === value || null === value ? flags.shadowColor = 'rgba(0,0,0,0)' : (flags.shadowColor = value, flags.shadowBlur = cutOff || 5, flags.shadowOffsetX = b || 10, flags.shadowOffsetY = elementName || 10), this;
                },

                "alphaMask": function (opt_obj2, deepDataAndEvents, hash, right) {
                    return void 0 === right || null === right ? this.draw(deepDataAndEvents).blendSourceAtop() : this.draw(deepDataAndEvents, right.x, right.y, right.width, right.height).blendSourceAtop(), void 0 === hash || null === hash ? this.draw(opt_obj2).blendReset() : this.draw(opt_obj2, hash.x, hash.y, hash.width, hash.height).blendReset(), this;
                },

                "extract": function (obj, textAlt, param, a, fieldName, store, text, ref, cb) {
                    return void 0 === fieldName && (fieldName = 255), void 0 === store && (store = false), void 0 === text && (text = textAlt), void 0 === ref && (ref = param), void 0 === cb && (cb = a), store && obj.resize(this.width, this.height), this.processPixelRGB(function (c, req, callback) {
                        return c.r === textAlt && (c.g === param && (c.b === a && obj.setPixel32(req, callback, text, ref, cb, fieldName, false))), false;
                    }, this), obj.context.putImageData(obj.imageData, 0, 0), obj.dirty = true, obj;
                },

                "rect": function (rx, surface, x, h, a) {
                    return void 0 !== a && (this.context.fillStyle = a), this.context.fillRect(rx, surface, x, h), this;
                },

                "text": function (el, text, cb, id, item, elem) {
                    if (void 0 === text) {

                        text = 0;
                    }
                    if (void 0 === cb) {

                        cb = 0;
                    }
                    if (void 0 === id) {
                        id = '14px Courier';
                    }
                    if (void 0 === item) {
                        item = 'rgb(255,255,255)';
                    }
                    if (void 0 === elem) {

                        elem = true;
                    }
                    var self = this.context;
                    var value = self.font;
                    return self.font = id, elem && (self.fillStyle = 'rgb(0,0,0)', self.fillText(el, text + 1, cb + 1)), self.fillStyle = item, self.fillText(el, text, cb), self.font = value, this;
                },

                "circle": function (resp, options, x, a) {
                    var collection = this.context;
                    return void 0 !== a && (collection.fillStyle = a), collection.beginPath(), collection.arc(resp, options, x, 0, 2 * Math.PI, false), collection.closePath(), collection.fill(), this;
                },

                "line": function (nodes, argv, value, surface, node, l) {
                    if (void 0 === node) {
                        node = '#fff';
                    }
                    if (void 0 === l) {

                        l = 1;
                    }
                    var list = this.context;
                    return list.beginPath(), list.moveTo(nodes, argv), list.lineTo(value, surface), list.lineWidth = l, list.strokeStyle = node, list.stroke(), list.closePath(), this;
                },

                "polygon": function (data, val, y, err) {
                    if (void 0 === err) {
                        err = '#fff';
                    }
                    if (void 0 === y) {

                        y = 0;
                    }
                    var m = this.context;
                    if (val) {

                        m.fillStyle = val;
                    }
                    if (y) {

                        m.lineWidth = y;

                        m.strokeStyle = err;
                    }
                    m.beginPath();
                    m.moveTo(data[0].x, data[0].y);

                    var i = 1;
                    var length = data.length;
                    for (; i < length; i++) {
                        var o = data[i];
                        m.lineTo(o.x, o.y);
                    }
                    return m.closePath(), val && m.fill(), y && m.stroke(), this;
                },

                "textureLine": function (grid, data, doc) {
                    if (void 0 === doc && (doc = "repeat-x"), "string" != typeof data || (data = this.game.cache.getImage(data))) {
                        var g = grid.length;
                        if ('no-repeat' === doc) {
                            if (g > data.width) {
                                g = data.width;
                            }
                        }
                        var cache = this.context;
                        return cache.fillStyle = cache.createPattern(data, doc), this._circle = new($.Circle)(grid.start.x, grid.start.y, data.height), this._circle.circumferencePoint(grid.angle - 1.5707963267948966, false, this._pos), cache.save(), cache.translate(this._pos.x, this._pos.y), cache.rotate(grid.angle), cache.fillRect(0, 0, g, data.height), cache.restore(),
                            this.dirty = true, this;
                    }
                },

                "render": function () {
                    return !this.disableTextureUpload && (this.dirty && (this.baseTexture.dirty(), this.dirty = false)), this;
                },

                "destroy": function () {
                    this.frameData.destroy();
                    this.texture.destroy(true);
                    $.CanvasPool.remove(this);
                },

                "blendReset": function () {
                    return this.op = 'source-over', this;
                },

                "blendSourceOver": function () {
                    return this.op = 'source-over', this;
                },

                "blendSourceIn": function () {
                    return this.op = 'source-in', this;
                },

                "blendSourceOut": function () {
                    return this.op = 'source-out', this;
                },

                "blendSourceAtop": function () {
                    return this.op = 'source-atop', this;
                },

                "blendDestinationOver": function () {
                    return this.op = 'destination-over', this;
                },

                "blendDestinationIn": function () {
                    return this.op = "destination-in", this;
                },

                "blendDestinationOut": function () {
                    return this.op = "destination-out", this;
                },

                "blendDestinationAtop": function () {
                    return this.op = "destination-atop", this;
                },

                "blendXor": function () {
                    return this.op = "xor", this;
                },

                "blendAdd": function () {
                    return this.op = 'lighter', this;
                },

                "blendMultiply": function () {
                    return this.op = 'multiply', this;
                },

                "blendScreen": function () {
                    return this.op = 'screen', this;
                },

                "blendOverlay": function () {
                    return this.op = 'overlay', this;
                },

                "blendDarken": function () {
                    return this.op = "darken", this;
                },

                "blendLighten": function () {
                    return this.op = "lighten", this;
                },

                "blendColorDodge": function () {
                    return this.op = 'color-dodge', this;
                },

                "blendColorBurn": function () {
                    return this.op = 'color-burn', this;
                },

                "blendHardLight": function () {
                    return this.op = 'hard-light', this;
                },

                "blendSoftLight": function () {
                    return this.op = 'soft-light', this;
                },

                "blendDifference": function () {
                    return this.op = "difference", this;
                },

                "blendExclusion": function () {
                    return this.op = 'exclusion', this;
                },

                "blendHue": function () {
                    return this.op = 'hue', this;
                },

                "blendSaturation": function () {
                    return this.op = "saturation", this;
                },

                "blendColor": function () {
                    return this.op = 'color', this;
                },

                "blendLuminosity": function () {
                    return this.op = 'luminosity', this;
                },

                "copyBitmapData": function (o, last, h) {
                    o.update();
                    var str;

                    var m = 0;
                    for (; m < o.height; m++) {
                        str = (h + m) * this.width + last;

                        var k = 0;
                        for (; k < o.width; k++) {
                            this.pixels[str + k] = o.pixels[m * o.width + k];
                        }
                    }
                    return this;
                }
            }, Object.defineProperty($.BitmapData.prototype, 'smoothed', {

                "get": function () {
                    $.Canvas.getSmoothingEnabled(this.context);
                },

                "set": function (opt_path) {
                    $.Canvas.setSmoothingEnabled(this.context, opt_path);
                }
            }), Object.defineProperty($.BitmapData.prototype, "op", {

                "get": function () {
                    return this.context.globalCompositeOperation;
                },

                "set": function (mL) {
                    this.context.globalCompositeOperation = mL;
                }
            }), $.BitmapData.getTransform = function (x, y, sx, scaleY, skewX, skewY) {
                return 'number' != typeof x && (x = 0), 'number' != typeof y && (y = 0), "number" != typeof sx && (sx = 1), 'number' != typeof scaleY && (scaleY = 1), 'number' != typeof skewX && (skewX = 0), 'number' != typeof skewY && (skewY = 0), {
                    "sx": sx,
                    "sy": scaleY,
                    "scaleX": sx,
                    "scaleY": scaleY,
                    "skewX": skewX,
                    "skewY": skewY,
                    "translateX": x,
                    "translateY": y,
                    "tx": x,
                    "ty": y
                };
            }, $.BitmapData.prototype.constructor = $.BitmapData, $.EarCut = {}, $.EarCut.Triangulate = function (args, deps, step) {
                step = step || 2;
                var r = deps && deps.length;
                var l = r ? deps[0] * step : args.length;
                var result = $.EarCut.linkedList(args, 0, l, step, true);

                var r20 = [];
                if (!result) {
                    return r20;
                }
                var start;
                var min;
                var last;
                var max;
                var next;
                var value;
                var restoreScript;
                if (r && (result = $.EarCut.eliminateHoles(args, deps, result, step)), args.length > 80 * step) {
                    start = last = args[0];
                    min = max = args[1];

                    var i = step;
                    for (; i < l; i += step) {
                        next = args[i];
                        value = args[i + 1];
                        if (next < start) {
                            start = next;
                        }
                        if (value < min) {
                            min = value;
                        }
                        if (next > last) {
                            last = next;
                        }
                        if (value > max) {
                            max = value;
                        }
                    }
                    restoreScript = Math.max(last - start, max - min);
                }
                return $.EarCut.earcutLinked(result, r20, step, start, min, restoreScript), r20;
            }, $.EarCut.linkedList = function (a, stop, size, end, dataAndEvents) {
                var start;
                var i;
                var index;

                var _0x11dae8 = 0;

                start = stop;

                i = size - end;
                for (; start < size; start += end) {
                    _0x11dae8 += (a[i] - a[start]) * (a[start + 1] + a[i + 1]);
                    i = start;
                }
                if (dataAndEvents === _0x11dae8 > 0) {

                    start = stop;
                    for (; start < size; start += end) {
                        index = $.EarCut.insertNode(start, a[start], a[start + 1], index);
                    }
                } else {

                    start = size - end;
                    for (; start >= stop; start -= end) {
                        index = $.EarCut.insertNode(start, a[start], a[start + 1], index);
                    }
                }
                return index;
            }, $.EarCut.filterPoints = function ($p2, b) {
                if (!$p2) {
                    return $p2;
                }
                if (!b) {

                    b = $p2;
                }
                var useActivate;

                var a = $p2;
                do {
                    if (useActivate = false, a.steiner || !$.EarCut.equals(a, a.next) && 0 !== $.EarCut.area(a.prev, a, a.next)) {
                        a = a.next;
                    } else {
                        if ($.EarCut.removeNode(a), (a = b = a.prev) === a.next) {
                            return null;
                        }

                        useActivate = true;
                    }
                } while (useActivate || a !== b);
                return b;
            }, $.EarCut.earcutLinked = function (s, at, b, deepDataAndEvents, opt_obj2, forward, dataAndEvents) {
                if (s) {
                    if (!dataAndEvents) {
                        if (forward) {
                            $.EarCut.indexCurve(s, deepDataAndEvents, opt_obj2, forward);
                        }
                    }
                    var a;
                    var c;

                    var i = s;
                    for (; s.prev !== s.next;) {
                        if (a = s.prev, c = s.next, forward ? $.EarCut.isEarHashed(s, deepDataAndEvents, opt_obj2, forward) : $.EarCut.isEar(s)) {
                            at.push(a.i / b);
                            at.push(s.i / b);
                            at.push(c.i / b);
                            $.EarCut.removeNode(s);
                            s = c.next;
                            i = c.next;
                        } else {
                            if ((s = c) === i) {
                                if (dataAndEvents) {
                                    if (1 === dataAndEvents) {
                                        s = $.EarCut.cureLocalIntersections(s, at, b);
                                        $.EarCut.earcutLinked(s, at, b, deepDataAndEvents, opt_obj2, forward, 2);
                                    } else {
                                        if (2 === dataAndEvents) {
                                            $.EarCut.splitEarcut(s, at, b, deepDataAndEvents, opt_obj2, forward);
                                        }
                                    }
                                } else {
                                    $.EarCut.earcutLinked($.EarCut.filterPoints(s), at, b, deepDataAndEvents, opt_obj2, forward, 1);
                                }
                                break;
                            }
                        }
                    }
                }
            }, $.EarCut.isEar = function (node) {
                var current = node.prev;

                var prev = node;
                var keys = node.next;
                if ($.EarCut.area(current, prev, keys) >= 0) {
                    return false;
                }
                var el = node.next.next;
                for (; el !== node.prev;) {
                    if ($.EarCut.pointInTriangle(current.x, current.y, prev.x, prev.y, keys.x, keys.y, el.x, el.y) && $.EarCut.area(el.prev, el, el.next) >= 0) {
                        return false;
                    }
                    el = el.next;
                }
                return true;
            }, $.EarCut.isEarHashed = function (sizes, opt_this, opt_capt, opt_handler) {
                var mid = sizes.prev;

                var left = sizes;
                var right = sizes.next;
                if ($.EarCut.area(mid, left, right) >= 0) {
                    return false;
                }
                var stringifier = mid.x < left.x ? mid.x < right.x ? mid.x : right.x : left.x < right.x ? left.x : right.x;
                var camelKey = mid.y < left.y ? mid.y < right.y ? mid.y : right.y : left.y < right.y ? left.y : right.y;
                var functionUid = mid.x > left.x ? mid.x > right.x ? mid.x : right.x : left.x > right.x ? left.x : right.x;
                var eqPos = mid.y > left.y ? mid.y > right.y ? mid.y : right.y : left.y > right.y ? left.y : right.y;
                var data = $.EarCut.zOrder(stringifier, camelKey, opt_this, opt_capt, opt_handler);
                var key = $.EarCut.zOrder(functionUid, eqPos, opt_this, opt_capt, opt_handler);
                var size = sizes.nextZ;
                for (; size && size.z <= key;) {
                    if (size !== sizes.prev && (size !== sizes.next && ($.EarCut.pointInTriangle(mid.x, mid.y, left.x, left.y, right.x, right.y, size.x, size.y) && $.EarCut.area(size.prev, size, size.next) >= 0))) {
                        return false;
                    }
                    size = size.nextZ;
                }
                size = sizes.prevZ;
                for (; size && size.z >= data;) {
                    if (size !== sizes.prev && (size !== sizes.next && ($.EarCut.pointInTriangle(mid.x, mid.y, left.x, left.y, right.x, right.y, size.x, size.y) && $.EarCut.area(size.prev, size, size.next) >= 0))) {
                        return false;
                    }
                    size = size.prevZ;
                }
                return true;
            }, $.EarCut.cureLocalIntersections = function (elem, dataAndEvents, iTotal) {
                var node = elem;
                do {
                    var bodies = node.prev;
                    var newTarget = node.next.next;
                    if ($.EarCut.intersects(bodies, node, node.next, newTarget)) {
                        if ($.EarCut.locallyInside(bodies, newTarget)) {
                            if ($.EarCut.locallyInside(newTarget, bodies)) {
                                dataAndEvents.push(bodies.i / iTotal);
                                dataAndEvents.push(node.i / iTotal);
                                dataAndEvents.push(newTarget.i / iTotal);
                                $.EarCut.removeNode(node);
                                $.EarCut.removeNode(node.next);
                                node = elem = newTarget;
                            }
                        }
                    }
                    node = node.next;
                } while (node !== elem);
                return node;
            }, $.EarCut.splitEarcut = function (inNode, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {

                var node = inNode;
                do {
                    var c = node.next.next;
                    for (; c !== node.prev;) {
                        if (node.i !== c.i && $.EarCut.isValidDiagonal(node, c)) {
                            var nc = $.EarCut.splitPolygon(node, c);
                            return node = $.EarCut.filterPoints(node, node.next), nc = $.EarCut.filterPoints(nc, nc.next), $.EarCut.earcutLinked(node, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope), void $.EarCut.earcutLinked(nc, deepDataAndEvents, opt_obj2, walkers, isXML, next_scope);
                        }
                        c = c.next;
                    }
                    node = node.next;
                } while (node !== inNode);
            }, $.EarCut.eliminateHoles = function (dest, stack, basis, fact) {
                var i;
                var len;
                var pdataOld;
                var r20;
                var pdataCur;

                var routes = [];

                i = 0;
                len = stack.length;
                for (; i < len; i++) {

                    pdataOld = stack[i] * fact;
                    r20 = i < len - 1 ? stack[i + 1] * fact : dest.length;
                    if ((pdataCur = $.EarCut.linkedList(dest, pdataOld, r20, fact, false)) === pdataCur.next) {

                        pdataCur.steiner = true;
                    }
                    routes.push($.EarCut.getLeftmost(pdataCur));
                }
                routes.sort(compareX);

                i = 0;
                for (; i < routes.length; i++) {
                    $.EarCut.eliminateHole(routes[i], basis);
                    basis = $.EarCut.filterPoints(basis, basis.next);
                }
                return basis;
            }, $.EarCut.compareX = function (p2, p1) {
                return p2.x - p1.x;
            }, $.EarCut.eliminateHole = function (model, resp) {
                if (resp = $.EarCut.findHoleBridge(model, resp)) {
                    var serverAttrs = $.EarCut.splitPolygon(resp, model);
                    $.EarCut.filterPoints(serverAttrs, serverAttrs.next);
                }
            }, $.EarCut.findHoleBridge = function (coords, i) {
                var node;

                var p = i;
                var x = coords.x;
                var y = coords.y;

                var right = -1 / 0;
                do {
                    if (y <= p.y && y >= p.next.y) {
                        var left = p.x + (y - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (left <= x) {
                            if (left > right) {
                                right = left;
                                node = p.x < p.next.x ? p : p.next;
                            }
                        }
                    }
                    p = p.next;
                } while (p !== i);
                if (!node) {
                    return null;
                }
                if (coords.x === node.x) {
                    return node.prev;
                }
                var element;
                var prototype = node;

                var openElement = 1 / 0;
                p = node.next;
                for (; p !== prototype;) {
                    if (x >= p.x) {
                        if (p.x >= node.x) {
                            if ($.EarCut.pointInTriangle(y < node.y ? x : right, y, node.x, node.y, y < node.y ? right : x, y, p.x, p.y)) {
                                if ((element = Math.abs(y - p.y) / (x - p.x)) < openElement || element === openElement && p.x > node.x) {
                                    if ($.EarCut.locallyInside(p, coords)) {
                                        node = p;

                                        openElement = element;
                                    }
                                }
                            }
                        }
                    }
                    p = p.next;
                }
                return node;
            }, $.EarCut.indexCurve = function (obj, deepDataAndEvents, opt_obj2, walkers) {

                var ref = obj;
                do {
                    if (null === ref.z) {
                        ref.z = $.EarCut.zOrder(ref.x, ref.y, deepDataAndEvents, opt_obj2, walkers);
                    }
                    ref.prevZ = ref.prev;
                    ref.nextZ = ref.next;
                    ref = ref.next;
                } while (ref !== obj);

                ref.prevZ.nextZ = null;

                ref.prevZ = null;
                $.EarCut.sortLinked(ref);
            }, $.EarCut.sortLinked = function (r) {
                var i;
                var root;
                var c;
                var tmp;
                var data;
                var _0x973b47;
                var hr;
                var declarationError;

                var e = 1;
                do {

                    root = r;

                    r = null;

                    data = null;

                    _0x973b47 = 0;
                    for (; root;) {
                        _0x973b47++;
                        c = root;

                        hr = 0;

                        i = 0;
                        for (; i < e && (hr++, c = c.nextZ); i++) {}

                        declarationError = e;
                        for (; hr > 0 || declarationError > 0 && c;) {
                            if (0 === hr) {
                                tmp = c;
                                c = c.nextZ;
                                declarationError--;
                            } else {
                                if (0 !== declarationError && c) {
                                    if (root.z <= c.z) {
                                        tmp = root;
                                        root = root.nextZ;
                                        hr--;
                                    } else {
                                        tmp = c;
                                        c = c.nextZ;
                                        declarationError--;
                                    }
                                } else {
                                    tmp = root;
                                    root = root.nextZ;
                                    hr--;
                                }
                            }
                            if (data) {
                                data.nextZ = tmp;
                            } else {
                                r = tmp;
                            }

                            tmp.prevZ = data;
                            data = tmp;
                        }
                        root = c;
                    }

                    data.nextZ = null;
                    e *= 2;
                } while (_0x973b47 > 1);
                return r;
            }, $.EarCut.zOrder = function (far, a, near, b, dataAndEvents) {
                return far = 32767 * (far - near) / dataAndEvents, a = 32767 * (a - b) / dataAndEvents, far = 16711935 & (far | far << 8), far = 252645135 & (far | far << 4), far = 858993459 & (far | far << 2), far = 1431655765 & (far | far << 1), a = 16711935 & (a | a << 8), a = 252645135 & (a | a << 4), a = 858993459 & (a | a << 2), a = 1431655765 & (a | a << 1), far | a << 1;
            }, $.EarCut.getLeftmost = function (context) {

                var cur = context;

                var tmp = context;
                do {
                    if (cur.x < tmp.x) {
                        tmp = cur;
                    }
                    cur = cur.next;
                } while (cur !== context);
                return tmp;
            }, $.EarCut.pointInTriangle = function (g, closest, a, h, v, far, b, near) {
                return (v - b) * (closest - near) - (g - b) * (far - near) >= 0 && ((g - b) * (h - near) - (a - b) * (closest - near) >= 0 && (a - b) * (far - near) - (v - b) * (h - near) >= 0);
            }, $.EarCut.isValidDiagonal = function (subset, obj) {
                return $.EarCut.equals(subset, obj) || subset.next.i !== obj.i && (subset.prev.i !== obj.i && (!$.EarCut.intersectsPolygon(subset, obj) && ($.EarCut.locallyInside(subset, obj) && ($.EarCut.locallyInside(obj, subset) && $.EarCut.middleInside(subset, obj)))));
            }, $.EarCut.area = function (ad, p1, p2) {
                return (p1.y - ad.y) * (p2.x - p1.x) - (p1.x - ad.x) * (p2.y - p1.y);
            }, $.EarCut.equals = function (b, a) {
                return b.x === a.x && b.y === a.y;
            }, $.EarCut.intersects = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
                return $.EarCut.area(deepDataAndEvents, opt_obj2, walkers) > 0 != $.EarCut.area(deepDataAndEvents, opt_obj2, isXML) > 0 && $.EarCut.area(walkers, isXML, deepDataAndEvents) > 0 != $.EarCut.area(walkers, isXML, opt_obj2) > 0;
            }, $.EarCut.intersectsPolygon = function (y, contexts) {

                var x = y;
                do {
                    if (x.i !== y.i && (x.next.i !== y.i && (x.i !== contexts.i && (x.next.i !== contexts.i && $.EarCut.intersects(x, x.next, y, contexts))))) {
                        return true;
                    }
                    x = x.next;
                } while (x !== y);
                return false;
            }, $.EarCut.locallyInside = function (commands, deepDataAndEvents) {
                return $.EarCut.area(commands.prev, commands, commands.next) < 0 ? $.EarCut.area(commands, deepDataAndEvents, commands.next) >= 0 && $.EarCut.area(commands, commands.prev, deepDataAndEvents) >= 0 : $.EarCut.area(commands, deepDataAndEvents, commands.prev) < 0 || $.EarCut.area(commands, commands.next, deepDataAndEvents) < 0;
            }, $.EarCut.middleInside = function (offset, size) {

                var pos = offset;

                var perm = false;

                var _0x178e54 = (offset.x + size.x) / 2;

                var y = (offset.y + size.y) / 2;
                do {
                    if (pos.y > y != pos.next.y > y) {
                        if (_0x178e54 < (pos.next.x - pos.x) * (y - pos.y) / (pos.next.y - pos.y) + pos.x) {

                            perm = !perm;
                        }
                    }
                    pos = pos.next;
                } while (pos !== offset);
                return perm;
            }, $.EarCut.splitPolygon = function (data, row) {
                var prev = new($.EarCut.Node)(data.i, data.x, data.y);
                var node = new $.EarCut.Node(row.i, row.x, row.y);
                var next = data.next;
                var value = row.prev;
                return data.next = row, row.prev = data, prev.next = next, next.prev = prev, node.next = prev, prev.prev = node, value.next = node, node.prev = value, node;
            }, $.EarCut.insertNode = function (att, doc, dataAndEvents, node) {
                var newNode = new($.EarCut.Node)(att, doc, dataAndEvents);
                return node ? (newNode.next = node.next, newNode.prev = node, node.next.prev = newNode, node.next = newNode) : (newNode.prev = newNode, newNode.next = newNode), newNode;
            }, $.EarCut.removeNode = function (newValue) {
                newValue.next.prev = newValue.prev;
                newValue.prev.next = newValue.next;
                if (newValue.prevZ) {
                    newValue.prevZ.nextZ = newValue.nextZ;
                }
                if (newValue.nextZ) {
                    newValue.nextZ.prevZ = newValue.prevZ;
                }
            }, $.EarCut.Node = function (offsetPosition, v, sum) {
                this.i = offsetPosition;
                this.x = v;
                this.y = sum;

                this.prev = null;

                this.next = null;

                this.z = null;

                this.prevZ = null;

                this.nextZ = null;

                this.steiner = false;
            }, PIXI.WebGLGraphics = function () {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function (pcity, ranges) {
                var entry;
                var gl = ranges.gl;
                var right = ranges.projection;
                var left = ranges.offset;
                var r20 = ranges.shaderManager.primitiveShader;
                if (pcity.dirty) {
                    PIXI.WebGLGraphics.updateGraphics(pcity, gl);
                }
                var cache = pcity._webGL[gl.id];
                if (cache) {

                    var i = 0;
                    for (; i < cache.data.length; i++) {
                        if (1 === cache.data[i].mode) {
                            entry = cache.data[i];
                            ranges.stencilManager.pushStencil(pcity, entry, ranges);
                            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, 2 * (entry.indices.length - 4));
                            ranges.stencilManager.popStencil(pcity, entry, ranges);
                        } else {
                            entry = cache.data[i];
                            ranges.shaderManager.setShader(r20);
                            r20 = ranges.shaderManager.primitiveShader;
                            gl.uniformMatrix3fv(r20.translationMatrix, false, pcity.worldTransform.toArray(true));
                            gl.uniform1f(r20.flipY, 1);
                            gl.uniform2f(r20.projectionVector, right.x, -right.y);
                            gl.uniform2f(r20.offsetVector, -left.x, -left.y);
                            gl.uniform3fv(r20.tintColor, $.Color.hexToRGBArray(pcity.tint));
                            gl.uniform1f(r20.alpha, pcity.worldAlpha);
                            gl.bindBuffer(gl.ARRAY_BUFFER, entry.buffer);
                            gl.vertexAttribPointer(r20.aVertexPosition, 2, gl.FLOAT, false, 24, 0);
                            gl.vertexAttribPointer(r20.colorAttribute, 4, gl.FLOAT, false, 24, 8);
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, entry.indexBuffer);
                            gl.drawElements(gl.TRIANGLE_STRIP, entry.indices.length, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                }
            }, PIXI.WebGLGraphics.updateGraphics = function (pcity, punittype) {
                var args = pcity._webGL[punittype.id];
                if (!args) {
                    args = pcity._webGL[punittype.id] = {
                        "lastIndex": 0,
                        "data": [],
                        "gl": punittype
                    };
                }

                pcity.dirty = false;
                var i;
                if (pcity.clearDirty) {

                    pcity.clearDirty = false;

                    i = 0;
                    for (; i < args.data.length; i++) {
                        var seg = args.data[i];
                        seg.reset();
                        PIXI.WebGLGraphics.graphicsDataPool.push(seg);
                    }

                    args.data = [];

                    args.lastIndex = 0;
                }
                var fragment;
                i = args.lastIndex;
                for (; i < pcity.graphicsData.length; i++) {
                    var row = pcity.graphicsData[i];
                    if (row.type === $.POLYGON) {
                        row.points = row.shape.points.slice();
                        if (row.shape.closed) {
                            if (!(row.points[0] === row.points[row.points.length - 2] && row.points[1] === row.points[row.points.length - 1])) {
                                row.points.push(row.points[0], row.points[1]);
                            }
                        }
                        if (row.fill) {
                            if (row.points.length >= PIXI.WebGLGraphics.stencilBufferLimit) {
                                if (row.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                                    fragment = PIXI.WebGLGraphics.switchMode(args, 0);
                                    if (!PIXI.WebGLGraphics.buildPoly(row, fragment)) {
                                        fragment = PIXI.WebGLGraphics.switchMode(args, 1);
                                        PIXI.WebGLGraphics.buildComplexPoly(row, fragment);
                                    }
                                } else {
                                    fragment = PIXI.WebGLGraphics.switchMode(args, 1);
                                    PIXI.WebGLGraphics.buildComplexPoly(row, fragment);
                                }
                            }
                        }
                        if (row.lineWidth > 0) {
                            fragment = PIXI.WebGLGraphics.switchMode(args, 0);
                            PIXI.WebGLGraphics.buildLine(row, fragment);
                        }
                    } else {
                        fragment = PIXI.WebGLGraphics.switchMode(args, 0);
                        if (row.type === $.RECTANGLE) {
                            PIXI.WebGLGraphics.buildRectangle(row, fragment);
                        } else {
                            if (row.type === $.CIRCLE || row.type === $.ELLIPSE) {
                                PIXI.WebGLGraphics.buildCircle(row, fragment);
                            } else {
                                if (row.type === $.ROUNDEDRECTANGLE) {
                                    PIXI.WebGLGraphics.buildRoundedRectangle(row, fragment);
                                }
                            }
                        }
                    }
                    args.lastIndex++;
                }

                i = 0;
                for (; i < args.data.length; i++) {
                    if ((fragment = args.data[i]).dirty) {
                        fragment.upload();
                    }
                }
            }, PIXI.WebGLGraphics.switchMode = function (cache, logic) {
                var dep;
                return cache.data.length ? (dep = cache.data[cache.data.length - 1]).mode === logic && 1 !== logic || ((dep = PIXI.WebGLGraphics.graphicsDataPool.pop() || new(PIXI.WebGLGraphicsData)(cache.gl)).mode = logic, cache.data.push(dep)) : ((dep = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(cache.gl)).mode = logic, cache.data.push(dep)), dep.dirty =
                    true, dep;
            }, PIXI.WebGLGraphics.buildRectangle = function (params, deepDataAndEvents) {
                var urls = params.shape;
                var testUrl = urls.x;
                var v = urls.y;
                var match = urls.width;
                var u = urls.height;
                if (params.fill) {
                    var mat = $.Color.hexToRGBArray(params.fillColor);
                    var z = params.fillAlpha;

                    var dep = mat[0] * z;

                    var zz = mat[1] * z;

                    var temp3 = mat[2] * z;
                    var missing = deepDataAndEvents.points;
                    var eventHandlers = deepDataAndEvents.indices;

                    var event = missing.length / 6;
                    missing.push(testUrl, v);
                    missing.push(dep, zz, temp3, z);
                    missing.push(testUrl + match, v);
                    missing.push(dep, zz, temp3, z);
                    missing.push(testUrl, v + u);
                    missing.push(dep, zz, temp3, z);
                    missing.push(testUrl + match, v + u);
                    missing.push(dep, zz, temp3, z);
                    eventHandlers.push(event, event, event + 1, event + 2, event + 3, event + 3);
                }
                if (params.lineWidth) {
                    var param = params.points;

                    params.points = [testUrl, v, testUrl + match, v, testUrl + match, v + u, testUrl, v + u, testUrl, v];
                    PIXI.WebGLGraphics.buildLine(params, deepDataAndEvents);
                    params.points = param;
                }
            }, PIXI.WebGLGraphics.buildRoundedRectangle = function (attributes, json) {
                var args = attributes.shape;
                var r = args.x;
                var x = args.y;
                var next = args.width;
                var width = args.height;
                var height = args.radius;

                var res = [];
                if (res.push(r, x + height), res = res.concat(PIXI.WebGLGraphics.quadraticBezierCurve(r, x + width - height, r, x + width, r + height, x + width)), res = res.concat(PIXI.WebGLGraphics.quadraticBezierCurve(r + next - height, x + width, r + next, x + width, r + next, x + width - height)), res = res.concat(PIXI.WebGLGraphics.quadraticBezierCurve(r + next, x + height, r + next, x, r + next - height, x)), res = res.concat(PIXI.WebGLGraphics.quadraticBezierCurve(r +
                        height, x, r, x, r, x + height)), attributes.fill) {
                    var e = $.Color.hexToRGBArray(attributes.fillColor);
                    var a = attributes.fillAlpha;

                    var capture = e[0] * a;

                    var r20 = e[1] * a;

                    var restoreScript = e[2] * a;
                    var object = json.points;
                    var tag = json.indices;

                    var push = object.length / 6;
                    var obj = $.EarCut.Triangulate(res, null, 2);

                    var i = 0;

                    i = 0;
                    for (; i < obj.length; i += 3) {
                        tag.push(obj[i] + push);
                        tag.push(obj[i] + push);
                        tag.push(obj[i + 1] + push);
                        tag.push(obj[i + 2] + push);
                        tag.push(obj[i + 2] + push);
                    }

                    i = 0;
                    for (; i < res.length; i++) {
                        object.push(res[i], res[++i], capture, r20, restoreScript, a);
                    }
                }
                if (attributes.lineWidth) {
                    var value = attributes.points;
                    attributes.points = res;
                    PIXI.WebGLGraphics.buildLine(attributes, json);
                    attributes.points = value;
                }
            }, PIXI.WebGLGraphics.quadraticBezierCurve = function (regex, touch, deepDataAndEvents, dataAndEvents, cx, type) {

                function clone(deepDataAndEvents, regex, dataAndEvents) {
                    return deepDataAndEvents + (regex - deepDataAndEvents) * dataAndEvents;
                }
                var pos1;
                var pos2;
                var r20;
                var rreturn;
                var pos;
                var pos3;

                var begin = [];

                var node = 0;

                var _0x3cf049 = 0;
                for (; _0x3cf049 <= 20; _0x3cf049++) {
                    pos1 = clone(regex, deepDataAndEvents, node = _0x3cf049 / 20);
                    pos2 = clone(touch, dataAndEvents, node);
                    r20 = clone(deepDataAndEvents, cx, node);
                    rreturn = clone(dataAndEvents, type, node);
                    pos = clone(pos1, r20, node);
                    pos3 = clone(pos2, rreturn, node);
                    begin.push(pos, pos3);
                }
                return begin;
            }, PIXI.WebGLGraphics.buildCircle = function (a, segs) {
                var p;
                var observer;
                var o = a.shape;
                var current = o.x;
                var v = o.y;
                if (a.type === $.CIRCLE) {
                    p = o.radius;
                    observer = o.radius;
                } else {
                    p = o.width;
                    observer = o.height;
                }

                var a1 = 2 * Math.PI / 40;

                var b4 = 0;
                if (a.fill) {
                    var mat = $.Color.hexToRGBArray(a.fillColor);
                    var z = a.fillAlpha;

                    var zz = mat[0] * z;

                    var temp3 = mat[1] * z;

                    var r20 = mat[2] * z;
                    var seg = segs.points;
                    var missing = segs.indices;

                    var dep = seg.length / 6;
                    missing.push(dep);

                    b4 = 0;
                    for (; b4 < 41; b4++) {
                        seg.push(current, v, zz, temp3, r20, z);
                        seg.push(current + Math.sin(a1 * b4) * p, v + Math.cos(a1 * b4) * observer, zz, temp3, r20, z);
                        missing.push(dep++, dep++);
                    }
                    missing.push(dep - 1);
                }
                if (a.lineWidth) {
                    var a12 = a.points;

                    a.points = [];

                    b4 = 0;
                    for (; b4 < 41; b4++) {
                        a.points.push(current + Math.sin(a1 * b4) * p, v + Math.cos(a1 * b4) * observer);
                    }
                    PIXI.WebGLGraphics.buildLine(a, segs);
                    a.points = a12;
                }
            }, PIXI.WebGLGraphics.buildLine = function (data, $cookies) {

                var i = 0;
                var a = data.points;
                if (0 !== a.length) {
                    if (data.lineWidth % 2) {

                        i = 0;
                        for (; i < a.length; i++) {
                            a[i] += 0.5;
                        }
                    }
                    var pointA = new(PIXI.Point)(a[0], a[1]);
                    var pointB = new PIXI.Point(a[a.length - 2], a[a.length - 1]);
                    if (pointA.x === pointB.x && pointA.y === pointB.y) {
                        (a = a.slice()).pop();
                        a.pop();
                        var r20 = (pointB = new(PIXI.Point)(a[a.length - 2], a[a.length - 1])).x + 0.5 * (pointA.x - pointB.x);
                        var restoreScript = pointB.y + 0.5 * (pointA.y - pointB.y);
                        a.unshift(r20, restoreScript);
                        a.push(r20, restoreScript);
                    }
                    var imageWidth;
                    var h;
                    var y;
                    var y2;
                    var x;
                    var r;
                    var dw;
                    var g;
                    var x2;
                    var y1;
                    var x0;
                    var x1;
                    var z0;
                    var z1;
                    var m11;
                    var a0;
                    var b4;
                    var m01;
                    var a1;
                    var b5;
                    var ratio;
                    var logpad;
                    var missing = $cookies.points;
                    var value = $cookies.indices;

                    var length = a.length / 2;
                    var ii = a.length;

                    var pdataOld = missing.length / 6;

                    var len = data.lineWidth / 2;
                    var m = $.Color.hexToRGBArray(data.lineColor);
                    var b0 = data.lineAlpha;

                    var dep = m[0] * b0;

                    var rreturn = m[1] * b0;

                    var udataCur = m[2] * b0;
                    y = a[0];
                    y2 = a[1];
                    x = a[2];

                    x2 = -(y2 - (r = a[3]));

                    y1 = y - x;
                    x2 /= logpad = Math.sqrt(x2 * x2 + y1 * y1);
                    y1 /= logpad;
                    x2 *= len;
                    y1 *= len;
                    missing.push(y - x2, y2 - y1, dep, rreturn, udataCur, b0);
                    missing.push(y + x2, y2 + y1, dep, rreturn, udataCur, b0);

                    i = 1;
                    for (; i < length - 1; i++) {
                        y = a[2 * (i - 1)];
                        y2 = a[2 * (i - 1) + 1];
                        x = a[2 * i];
                        r = a[2 * i + 1];
                        dw = a[2 * (i + 1)];
                        g = a[2 * (i + 1) + 1];

                        x2 = -(y2 - r);

                        y1 = y - x;
                        x2 /= logpad = Math.sqrt(x2 * x2 + y1 * y1);
                        y1 /= logpad;
                        x2 *= len;
                        y1 *= len;

                        x0 = -(r - g);

                        x1 = x - dw;
                        x0 /= logpad = Math.sqrt(x0 * x0 + x1 * x1);
                        x1 /= logpad;

                        b4 = (-x2 + y) * (-y1 + r) - (-x2 + x) * (-y1 + y2);

                        b5 = (-(x0 *= len) + dw) * (-(x1 *= len) + r) - (-x0 + x) * (-x1 + g);

                        ratio = (m11 = -y1 + y2 - (-y1 + r)) * (a1 = -x0 + x - (-x0 + dw)) - (m01 = -x1 + g - (-x1 + r)) * (a0 = -x2 + x - (-x2 + y));
                        if (Math.abs(ratio) < 0.1) {
                            ratio += 10.1;
                            missing.push(x - x2, r - y1, dep, rreturn, udataCur, b0);
                            missing.push(x + x2, r + y1, dep, rreturn, udataCur, b0);
                        } else {
                            if (((imageWidth = (a0 * b5 - a1 * b4) / ratio) - x) * (imageWidth - x) + ((h = (m01 * b4 - m11 * b5) / ratio) - r) + (h - r) > 19600) {

                                z0 = x2 - x0;

                                z1 = y1 - x1;
                                z0 /= logpad = Math.sqrt(z0 * z0 + z1 * z1);
                                z1 /= logpad;
                                z0 *= len;
                                z1 *= len;
                                missing.push(x - z0, r - z1);
                                missing.push(dep, rreturn, udataCur, b0);
                                missing.push(x + z0, r + z1);
                                missing.push(dep, rreturn, udataCur, b0);
                                missing.push(x - z0, r - z1);
                                missing.push(dep, rreturn, udataCur, b0);
                                ii++;
                            } else {
                                missing.push(imageWidth, h);
                                missing.push(dep, rreturn, udataCur, b0);
                                missing.push(x - (imageWidth - x), r - (h - r));
                                missing.push(dep, rreturn, udataCur, b0);
                            }
                        }
                    }
                    y = a[2 * (length - 2)];
                    y2 = a[2 * (length - 2) + 1];
                    x = a[2 * (length - 1)];

                    x2 = -(y2 - (r = a[2 * (length - 1) + 1]));

                    y1 = y - x;
                    x2 /= logpad = Math.sqrt(x2 * x2 + y1 * y1);
                    y1 /= logpad;
                    x2 *= len;
                    y1 *= len;
                    missing.push(x - x2, r - y1);
                    missing.push(dep, rreturn, udataCur, b0);
                    missing.push(x + x2, r + y1);
                    missing.push(dep, rreturn, udataCur, b0);
                    value.push(pdataOld);

                    i = 0;
                    for (; i < ii; i++) {
                        value.push(pdataOld++);
                    }
                    value.push(pdataOld - 1);
                }
            }, PIXI.WebGLGraphics.buildComplexPoly = function (defaults, options) {
                var src = defaults.points.slice();
                if (!(src.length < 6)) {
                    var value = options.indices;
                    options.points = src;
                    options.alpha = defaults.fillAlpha;
                    options.color = $.Color.hexToRGBArray(defaults.fillColor);
                    var line;
                    var h;

                    var lowest_line = 1 / 0;

                    var highest_line = -1 / 0;

                    var w = 1 / 0;

                    var maxh = -1 / 0;

                    var i = 0;
                    for (; i < src.length; i += 2) {
                        line = src[i];
                        h = src[i + 1];
                        lowest_line = line < lowest_line ? line : lowest_line;
                        highest_line = line > highest_line ? line : highest_line;
                        w = h < w ? h : w;
                        maxh = h > maxh ? h : maxh;
                    }
                    src.push(lowest_line, w, highest_line, w, highest_line, maxh, lowest_line, maxh);

                    var padLength = src.length / 2;

                    i = 0;
                    for (; i < padLength; i++) {
                        value.push(i);
                    }
                }
            }, PIXI.WebGLGraphics.buildPoly = function (array, args) {
                var tag = array.points;
                if (!(tag.length < 6)) {
                    var pageY = args.points;
                    var count = args.indices;

                    var padLength = tag.length / 2;
                    var mat = $.Color.hexToRGBArray(array.fillColor);
                    var z = array.fillAlpha;

                    var zz = mat[0] * z;

                    var temp3 = mat[1] * z;

                    var r20 = mat[2] * z;
                    var spec = $.EarCut.Triangulate(tag, null, 2);
                    if (!spec) {
                        return false;
                    }

                    var push = pageY.length / 6;

                    var i = 0;

                    i = 0;
                    for (; i < spec.length; i += 3) {
                        count.push(spec[i] + push);
                        count.push(spec[i] + push);
                        count.push(spec[i + 1] + push);
                        count.push(spec[i + 2] + push);
                        count.push(spec[i + 2] + push);
                    }

                    i = 0;
                    for (; i < padLength; i++) {
                        pageY.push(tag[2 * i], tag[2 * i + 1], zz, temp3, r20, z);
                    }
                    return true;
                }
            }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function (dataAndEvents) {
                this.gl = dataAndEvents;

                this.color = [0, 0, 0];

                this.points = [];

                this.indices = [];
                this.buffer = dataAndEvents.createBuffer();
                this.indexBuffer = dataAndEvents.createBuffer();

                this.mode = 1;

                this.alpha = 1;

                this.dirty = true;
            }, PIXI.WebGLGraphicsData.prototype.reset = function () {

                this.points = [];

                this.indices = [];
            }, PIXI.WebGLGraphicsData.prototype.upload = function () {
                var action = this.gl;

                this.glPoints = new Float32Array(this.points);
                action.bindBuffer(action.ARRAY_BUFFER, this.buffer);
                action.bufferData(action.ARRAY_BUFFER, this.glPoints, action.STATIC_DRAW);

                this.glIndicies = new Uint16Array(this.indices);
                action.bindBuffer(action.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                action.bufferData(action.ELEMENT_ARRAY_BUFFER, this.glIndicies, action.STATIC_DRAW);

                this.dirty = false;
            }, PIXI.CanvasGraphics = function () {}, PIXI.CanvasGraphics.renderGraphics = function (dirs, el) {
                var dir = dirs.worldAlpha;
                if (dirs.dirty) {
                    this.updateGraphicsTint(dirs);

                    dirs.dirty = false;
                }

                var STYLE = 0;
                for (; STYLE < dirs.graphicsData.length; STYLE++) {
                    var style = dirs.graphicsData[STYLE];
                    var o = style.shape;
                    var old = style._fillTint;
                    var styleValue = style._lineTint;
                    if (el.lineWidth = style.lineWidth, style.type === $.POLYGON) {
                        el.beginPath();
                        var data = o.points;
                        el.moveTo(data[0], data[1]);

                        var key = 1;
                        for (; key < data.length / 2; key++) {
                            el.lineTo(data[2 * key], data[2 * key + 1]);
                        }
                        if (o.closed) {
                            el.lineTo(data[0], data[1]);
                        }
                        if (data[0] === data[data.length - 2]) {
                            if (data[1] === data[data.length - 1]) {
                                el.closePath();
                            }
                        }
                        if (style.fill) {

                            el.globalAlpha = style.fillAlpha * dir;
                            el.fillStyle = "#" + ("00000" + (0 | old).toString(16)).substr(-6);
                            el.fill();
                        }
                        if (style.lineWidth) {

                            el.globalAlpha = style.lineAlpha * dir;
                            el.strokeStyle = "#" + ("00000" + (0 | styleValue).toString(16)).substr(-6);
                            el.stroke();
                        }
                    } else {
                        if (style.type === $.RECTANGLE) {
                            if (style.fillColor || 0 === style.fillColor) {

                                el.globalAlpha = style.fillAlpha * dir;
                                el.fillStyle = "#" + ('00000' + (0 | old).toString(16)).substr(-6);
                                el.fillRect(o.x, o.y, o.width, o.height);
                            }
                            if (style.lineWidth) {

                                el.globalAlpha = style.lineAlpha * dir;
                                el.strokeStyle = "#" + ("00000" + (0 | styleValue).toString(16)).substr(-6);
                                el.strokeRect(o.x, o.y, o.width, o.height);
                            }
                        } else {
                            if (style.type === $.CIRCLE) {
                                el.beginPath();
                                el.arc(o.x, o.y, o.radius, 0, 2 * Math.PI);
                                el.closePath();
                                if (style.fill) {

                                    el.globalAlpha = style.fillAlpha * dir;
                                    el.fillStyle = "#" + ('00000' + (0 | old).toString(16)).substr(-6);
                                    el.fill();
                                }
                                if (style.lineWidth) {

                                    el.globalAlpha = style.lineAlpha * dir;
                                    el.strokeStyle = "#" + ('00000' + (0 | styleValue).toString(16)).substr(-6);
                                    el.stroke();
                                }
                            } else {
                                if (style.type === $.ELLIPSE) {

                                    var millis = 2 * o.width;

                                    var y = 2 * o.height;

                                    var oldMillis = o.x - millis / 2;

                                    var x = o.y - y / 2;
                                    el.beginPath();

                                    var near = millis / 2 * 0.5522848;

                                    var left = y / 2 * 0.5522848;

                                    var newMillis = oldMillis + millis;

                                    var dist = x + y;

                                    var far = oldMillis + millis / 2;

                                    var right = x + y / 2;
                                    el.moveTo(oldMillis, right);
                                    el.bezierCurveTo(oldMillis, right - left, far - near, x, far, x);
                                    el.bezierCurveTo(far + near, x, newMillis, right - left, newMillis, right);
                                    el.bezierCurveTo(newMillis, right + left, far + near, dist, far, dist);
                                    el.bezierCurveTo(far - near, dist, oldMillis, right + left, oldMillis, right);
                                    el.closePath();
                                    if (style.fill) {

                                        el.globalAlpha = style.fillAlpha * dir;
                                        el.fillStyle = "#" + ("00000" + (0 | old).toString(16)).substr(-6);
                                        el.fill();
                                    }
                                    if (style.lineWidth) {

                                        el.globalAlpha = style.lineAlpha * dir;
                                        el.strokeStyle = "#" + ('00000' + (0 | styleValue).toString(16)).substr(-6);
                                        el.stroke();
                                    }
                                } else {
                                    if (style.type === $.ROUNDEDRECTANGLE) {
                                        var prefix = o.x;
                                        var v = o.y;
                                        var t = o.width;
                                        var r = o.height;
                                        var n = o.radius;

                                        var pageCount = Math.min(t, r) / 2 | 0;
                                        n = n > pageCount ? pageCount : n;
                                        el.beginPath();
                                        el.moveTo(prefix, v + n);
                                        el.lineTo(prefix, v + r - n);
                                        el.quadraticCurveTo(prefix, v + r, prefix + n, v + r);
                                        el.lineTo(prefix + t - n, v + r);
                                        el.quadraticCurveTo(prefix + t, v + r, prefix + t, v + r - n);
                                        el.lineTo(prefix + t, v + n);
                                        el.quadraticCurveTo(prefix + t, v, prefix + t - n, v);
                                        el.lineTo(prefix + n, v);
                                        el.quadraticCurveTo(prefix, v, prefix, v + n);
                                        el.closePath();
                                        if (style.fillColor || 0 === style.fillColor) {

                                            el.globalAlpha = style.fillAlpha * dir;
                                            el.fillStyle = "#" + ('00000' + (0 | old).toString(16)).substr(-6);
                                            el.fill();
                                        }
                                        if (style.lineWidth) {

                                            el.globalAlpha = style.lineAlpha * dir;
                                            el.strokeStyle = "#" + ('00000' + (0 | styleValue).toString(16)).substr(-6);
                                            el.stroke();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }, PIXI.CanvasGraphics.renderGraphicsMask = function (res, app) {
                var jj = res.graphicsData.length;
                if (0 !== jj) {
                    app.beginPath();

                    var j = 0;
                    for (; j < jj; j++) {
                        var special = res.graphicsData[j];
                        var a = special.shape;
                        if (special.type === $.POLYGON) {
                            var data = a.points;
                            app.moveTo(data[0], data[1]);

                            var key = 1;
                            for (; key < data.length / 2; key++) {
                                app.lineTo(data[2 * key], data[2 * key + 1]);
                            }
                            if (data[0] === data[data.length - 2]) {
                                if (data[1] === data[data.length - 1]) {
                                    app.closePath();
                                }
                            }
                        } else {
                            if (special.type === $.RECTANGLE) {
                                app.rect(a.x, a.y, a.width, a.height);
                                app.closePath();
                            } else {
                                if (special.type === $.CIRCLE) {
                                    app.arc(a.x, a.y, a.radius, 0, 2 * Math.PI);
                                    app.closePath();
                                } else {
                                    if (special.type === $.ELLIPSE) {

                                        var width = 2 * a.width;

                                        var height = 2 * a.height;

                                        var x = a.x - width / 2;

                                        var y = a.y - height / 2;

                                        var left = width / 2 * 0.5522848;

                                        var near = height / 2 * 0.5522848;

                                        var cp_x = x + width;

                                        var y2 = y + height;

                                        var right = x + width / 2;

                                        var far = y + height / 2;
                                        app.moveTo(x, far);
                                        app.bezierCurveTo(x, far - near, right - left, y, right, y);
                                        app.bezierCurveTo(right + left, y, cp_x, far - near, cp_x, far);
                                        app.bezierCurveTo(cp_x, far + near, right + left, y2, right, y2);
                                        app.bezierCurveTo(right - left, y2, x, far + near, x, far);
                                        app.closePath();
                                    } else {
                                        if (special.type === $.ROUNDEDRECTANGLE) {
                                            var r = a.x;
                                            var t = a.y;
                                            var next = a.width;
                                            var b = a.height;
                                            var n = a.radius;

                                            var pageCount = Math.min(next, b) / 2 | 0;
                                            n = n > pageCount ? pageCount : n;
                                            app.moveTo(r, t + n);
                                            app.lineTo(r, t + b - n);
                                            app.quadraticCurveTo(r, t + b, r + n, t + b);
                                            app.lineTo(r + next - n, t + b);
                                            app.quadraticCurveTo(r + next, t + b, r + next, t + b - n);
                                            app.lineTo(r + next, t + n);
                                            app.quadraticCurveTo(r + next, t, r + next - n, t);
                                            app.lineTo(r + n, t);
                                            app.quadraticCurveTo(r, t, r, t + n);
                                            app.closePath();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }, PIXI.CanvasGraphics.updateGraphicsTint = function (arrs) {
                if (16777215 !== arrs.tint) {

                    var _0x4754a4 = (arrs.tint >> 16 & 255) / 255;

                    var _0x3245c2 = (arrs.tint >> 8 & 255) / 255;

                    var _0x2640b0 = (255 & arrs.tint) / 255;

                    var i = 0;
                    for (; i < arrs.graphicsData.length; i++) {
                        var style = arrs.graphicsData[i];

                        var _0x4c90f4 = 0 | style.fillColor;

                        var _0x3409db = 0 | style.lineColor;

                        style._fillTint = ((_0x4c90f4 >> 16 & 255) / 255 * _0x4754a4 * 255 << 16) + ((_0x4c90f4 >> 8 & 255) / 255 * _0x3245c2 * 255 << 8) + (255 & _0x4c90f4) / 255 * _0x2640b0 * 255;

                        style._lineTint = ((_0x3409db >> 16 & 255) / 255 * _0x4754a4 * 255 << 16) + ((_0x3409db >> 8 & 255) / 255 * _0x3245c2 * 255 << 8) + (255 & _0x3409db) / 255 * _0x2640b0 * 255;
                    }
                }
            }, $.GraphicsData = function (deepDataAndEvents, ignoreMethodDoesntExist, textAlt, dataAndEvents, keepData, opt_attributes, exts) {
                this.lineWidth = deepDataAndEvents;
                this.lineColor = ignoreMethodDoesntExist;
                this.lineAlpha = textAlt;
                this._lineTint = ignoreMethodDoesntExist;
                this.fillColor = dataAndEvents;
                this.fillAlpha = keepData;
                this._fillTint = dataAndEvents;
                this.fill = opt_attributes;
                this.shape = exts;
                this.type = exts.type;
            }, $.GraphicsData.prototype.constructor = $.GraphicsData, $.GraphicsData.prototype.clone = function () {
                return new($.GraphicsData)(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
            }, $.Graphics = function (deepDataAndEvents, opt_obj2, walkers) {
                if (void 0 === opt_obj2) {

                    opt_obj2 = 0;
                }
                if (void 0 === walkers) {

                    walkers = 0;
                }
                this.type = $.GRAPHICS;
                this.physicsType = $.SPRITE;
                this.anchor = new $.Point;
                PIXI.DisplayObjectContainer.call(this);

                this.renderable = true;

                this.fillAlpha = 1;

                this.lineWidth = 0;

                this.lineColor = 0;

                this.graphicsData = [];

                this.tint = 16777215;
                this.blendMode = PIXI.blendModes.NORMAL;

                this.currentPath = null;

                this._webGL = [];

                this.isMask = false;

                this.boundsPadding = 0;
                this._localBounds = new($.Rectangle)(0, 0, 1, 1);

                this.dirty = true;

                this._boundsDirty = false;

                this.webGLDirty = false;

                this.cachedSpriteDirty = false;
                $.Component.Core.init.call(this, deepDataAndEvents, opt_obj2, walkers, "", null);
            }, $.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), $.Graphics.prototype.constructor = $.Graphics, $.Component.Core.install.call($.Graphics.prototype, ['Angle', 'AutoCull', 'Bounds', 'Destroy', 'FixedToCamera', 'InputEnabled', 'InWorld', 'LifeSpan', 'PhysicsBody', 'Reset']), $.Graphics.prototype.preUpdatePhysics =
            $.Component.PhysicsBody.preUpdate, $.Graphics.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.Graphics.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.Graphics.prototype.preUpdateCore = $.Component.Core.preUpdate, $.Graphics.prototype.preUpdate = function () {
                return !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.Graphics.prototype.postUpdate = function () {
                $.Component.PhysicsBody.postUpdate.call(this);
                $.Component.FixedToCamera.postUpdate.call(this);
                if (this._boundsDirty) {
                    this.updateLocalBounds();

                    this._boundsDirty = false;
                }

                var unlock = 0;
                for (; unlock < this.children.length; unlock++) {
                    this.children[unlock].postUpdate();
                }
            }, $.Graphics.prototype.destroy = function (deepDataAndEvents) {
                this.clear();
                $.Component.Destroy.prototype.destroy.call(this, deepDataAndEvents);
            }, $.Graphics.prototype.drawTriangle = function (data, dataAndEvents) {
                if (void 0 === dataAndEvents) {

                    dataAndEvents = false;
                }
                var smc = new($.Polygon)(data);
                if (dataAndEvents) {
                    var _0x54ba49 = new $.Point(this.game.camera.x - data[0].x, this.game.camera.y - data[0].y);
                    var key = new($.Point)(data[1].x - data[0].x, data[1].y - data[0].y);
                    var camelKey = (new($.Point)(data[1].x - data[2].x, data[1].y - data[2].y)).cross(key);
                    if (_0x54ba49.dot(camelKey) > 0) {
                        this.drawPolygon(smc);
                    }
                } else {
                    this.drawPolygon(smc);
                }
            }, $.Graphics.prototype.drawTriangles = function (props, data, deepDataAndEvents) {
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = false;
                }
                var i;
                var map = new($.Point);
                var keys = new($.Point);
                var current = new($.Point);

                var missing = [];
                if (data) {
                    if (props[0] instanceof $.Point) {

                        i = 0;
                        for (; i < data.length / 3; i++) {
                            missing.push(props[data[3 * i]]);
                            missing.push(props[data[3 * i + 1]]);
                            missing.push(props[data[3 * i + 2]]);
                            if (3 === missing.length) {
                                this.drawTriangle(missing, deepDataAndEvents);

                                missing = [];
                            }
                        }
                    } else {

                        i = 0;
                        for (; i < data.length; i++) {
                            map.x = props[2 * data[i]];
                            map.y = props[2 * data[i] + 1];
                            missing.push(map.copyTo({}));
                            if (3 === missing.length) {
                                this.drawTriangle(missing, deepDataAndEvents);

                                missing = [];
                            }
                        }
                    }
                } else {
                    if (props[0] instanceof $.Point) {

                        i = 0;
                        for (; i < props.length / 3; i++) {
                            this.drawTriangle([props[3 * i], props[3 * i + 1], props[3 * i + 2]], deepDataAndEvents);
                        }
                    } else {

                        i = 0;
                        for (; i < props.length / 6; i++) {
                            map.x = props[6 * i + 0];
                            map.y = props[6 * i + 1];
                            keys.x = props[6 * i + 2];
                            keys.y = props[6 * i + 3];
                            current.x = props[6 * i + 4];
                            current.y = props[6 * i + 5];
                            this.drawTriangle([map, keys, current], deepDataAndEvents);
                        }
                    }
                }
            }, $.Graphics.prototype.lineStyle = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
                return this.lineWidth = dataAndEvents || 0, this.lineColor = deepDataAndEvents || 0, this.lineAlpha = void 0 === ignoreMethodDoesntExist ? 1 : ignoreMethodDoesntExist, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new($.Polygon)(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor =
                    this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this;
            }, $.Graphics.prototype.moveTo = function (dataAndEvents, deepDataAndEvents) {
                return this.drawShape(new($.Polygon)([dataAndEvents, deepDataAndEvents])), this;
            }, $.Graphics.prototype.lineTo = function (deepDataAndEvents, opt_obj2) {
                return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(deepDataAndEvents, opt_obj2), this.dirty = true, this._boundsDirty = true, this;
            }, $.Graphics.prototype.quadraticCurveTo = function (min, source, max, target) {
                if (this.currentPath) {
                    if (0 === this.currentPath.shape.points.length) {

                        this.currentPath.shape.points = [0, 0];
                    }
                } else {
                    this.moveTo(0, 0);
                }
                var from;
                var end;
                var args = this.currentPath.shape.points;
                if (0 === args.length) {
                    this.moveTo(0, 0);
                }
                var position = args[args.length - 2];
                var start = args[args.length - 1];

                var pos = 0;

                var current = 1;
                for (; current <= 20; ++current) {
                    from = position + (min - position) * (pos = current / 20);
                    end = start + (source - start) * pos;
                    args.push(from + (min + (max - min) * pos - from) * pos, end + (source + (target - source) * pos - end) * pos);
                }
                return this.dirty = true, this._boundsDirty = true, this;
            }, $.Graphics.prototype.bezierCurveTo = function (ratio, g, _c, d, m21, m31) {
                if (this.currentPath) {
                    if (0 === this.currentPath.shape.points.length) {

                        this.currentPath.shape.points = [0, 0];
                    }
                } else {
                    this.moveTo(0, 0);
                }
                var t;
                var point;
                var gr;
                var y;
                var m10;
                var params = this.currentPath.shape.points;
                var param = params[params.length - 2];
                var r = params[params.length - 1];

                var radius = 0;

                var min_dimension = 1;
                for (; min_dimension <= 20; ++min_dimension) {

                    gr = (point = (t = 1 - (radius = min_dimension / 20)) * t) * t;

                    m10 = (y = radius * radius) * radius;
                    params.push(gr * param + 3 * point * radius * ratio + 3 * t * y * _c + m10 * m21, gr * r + 3 * point * radius * g + 3 * t * y * d + m10 * m31);
                }
                return this.dirty = true, this._boundsDirty = true, this;
            }, $.Graphics.prototype.arcTo = function (b, a, g, x, elapsed) {
                if (this.currentPath) {
                    if (0 === this.currentPath.shape.points.length) {
                        this.currentPath.shape.points.push(b, a);
                    }
                } else {
                    this.moveTo(b, a);
                }
                var result = this.currentPath.shape.points;
                var r = result[result.length - 2];

                var z0 = result[result.length - 1] - a;

                var z1 = r - b;

                var x0 = x - a;

                var x1 = g - b;
                var n = Math.abs(z0 * x1 - z1 * x0);
                if (n < 1E-8 || 0 === elapsed) {
                    if (!(result[result.length - 2] === b && result[result.length - 1] === a)) {
                        result.push(b, a);
                    }
                } else {

                    var det = z0 * z0 + z1 * z1;

                    var denom = x0 * x0 + x1 * x1;

                    var eyez = z0 * x0 + z1 * x1;

                    var z2 = elapsed * Math.sqrt(det) / n;

                    var y2 = elapsed * Math.sqrt(denom) / n;

                    var idet = z2 * eyez / det;

                    var ub = y2 * eyez / denom;

                    var i = z2 * x1 + y2 * z1;

                    var start = z2 * x0 + y2 * z0;

                    var olen = z1 * (y2 + idet);

                    var end = z0 * (y2 + idet);

                    var startOffset = x1 * (z2 + ub);

                    var start1 = x0 * (z2 + ub);
                    var r20 = Math.atan2(end - start, olen - i);
                    var restoreScript = Math.atan2(start1 - start, startOffset - i);
                    this.arc(i + b, start + a, elapsed, r20, restoreScript, z1 * x0 > x1 * z0);
                }
                return this.dirty = true, this._boundsDirty = true, this;
            }, $.Graphics.prototype.arc = function (oldMillis, from, delta, a, b, forward, d) {
                if (a === b) {
                    return this;
                }
                if (void 0 === forward) {

                    forward = false;
                }
                if (void 0 === d) {

                    d = 40;
                }
                if (!forward && b <= a) {
                    b += 2 * Math.PI;
                } else {
                    if (forward) {
                        if (a <= b) {
                            a += 2 * Math.PI;
                        }
                    }
                }

                var j = forward ? -1 * (a - b) : b - a;

                var x2 = Math.ceil(Math.abs(j) / (2 * Math.PI)) * d;
                if (0 === j) {
                    return this;
                }
                var newMillis = oldMillis + Math.cos(a) * delta;
                var leftInterval = from + Math.sin(a) * delta;
                if (forward && this.filling) {
                    this.moveTo(oldMillis, from);
                } else {
                    this.moveTo(newMillis, leftInterval);
                }
                var _0x4068ed = this.currentPath.shape.points;

                var t = j / (2 * x2);

                var b3 = 2 * t;
                var m10 = Math.cos(t);
                var m11 = Math.sin(t);

                var dx = x2 - 1;

                var ratio = dx % 1 / dx;

                var h = 0;
                for (; h <= dx; h++) {
                    var n = t + a + b3 * (h + ratio * h);
                    var c = Math.cos(n);

                    var s = -Math.sin(n);
                    _0x4068ed.push((m10 * c + m11 * s) * delta + oldMillis, (m10 * -s + m11 * c) * delta + from);
                }
                return this.dirty = true, this._boundsDirty = true, this;
            }, $.Graphics.prototype.beginFill = function (deepDataAndEvents, dataAndEvents) {
                return this.filling = true, this.fillColor = deepDataAndEvents || 0, this.fillAlpha = void 0 === dataAndEvents ? 1 : dataAndEvents, this.currentPath && (this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha)), this;
            }, $.Graphics.prototype.endFill = function () {
                return this.filling = false, this.fillColor = null, this.fillAlpha = 1, this;
            }, $.Graphics.prototype.drawRect = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
                return this.drawShape(new($.Rectangle)(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt)), this;
            }, $.Graphics.prototype.drawRoundedRect = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
                return this.drawShape(new($.RoundedRectangle)(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData)), this;
            }, $.Graphics.prototype.drawCircle = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
                return this.drawShape(new $.Circle(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist)), this;
            }, $.Graphics.prototype.drawEllipse = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
                return this.drawShape(new $.Ellipse(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt)), this;
            }, $.Graphics.prototype.drawPolygon = function (response) {
                if (response instanceof $.Polygon) {
                    response = response.points;
                }

                var data = response;
                if (!Array.isArray(data)) {

                    data = new Array(arguments.length);

                    var i = 0;
                    for (; i < data.length; ++i) {
                        data[i] = arguments[i];
                    }
                }
                return this.drawShape(new($.Polygon)(data)), this;
            }, $.Graphics.prototype.clear = function () {
                return this.lineWidth = 0, this.filling = false, this.dirty = true, this._boundsDirty = true, this.clearDirty = true, this.graphicsData = [], this.updateLocalBounds(), this;
            }, $.Graphics.prototype.generateTexture = function (deepDataAndEvents, protoProps, dataAndEvents) {
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = 1;
                }
                if (void 0 === protoProps) {
                    protoProps = PIXI.scaleModes.DEFAULT;
                }
                if (void 0 === dataAndEvents) {

                    dataAndEvents = 0;
                }
                var urls = this.getBounds();
                urls.width += dataAndEvents;
                urls.height += dataAndEvents;
                var fn = new(PIXI.CanvasBuffer)(urls.width * deepDataAndEvents, urls.height * deepDataAndEvents);
                var child = PIXI.Texture.fromCanvas(fn.canvas, protoProps);
                return child.baseTexture.resolution = deepDataAndEvents, fn.context.scale(deepDataAndEvents, deepDataAndEvents), fn.context.translate(-urls.x, -urls.y), PIXI.CanvasGraphics.renderGraphics(this, fn.context), child;
            }, $.Graphics.prototype._renderWebGL = function (relation) {
                if (false !== this.visible && (0 !== this.alpha && true !== this.isMask)) {
                    if (this._cacheAsBitmap) {
                        return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = false, this.dirty = false), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, relation);
                    }
                    if (relation.spriteBatch.stop(), relation.blendModeManager.setBlendMode(this.blendMode), this._mask && relation.maskManager.pushMask(this._mask, relation), this._filters && relation.filterManager.pushFilter(this._filterBlock), this.blendMode !== relation.spriteBatch.currentBlendMode) {
                        relation.spriteBatch.currentBlendMode = this.blendMode;
                        var _0x516041 = PIXI.blendModesWebGL[relation.spriteBatch.currentBlendMode];
                        relation.spriteBatch.gl.blendFunc(_0x516041[0], _0x516041[1]);
                    }
                    if (this.webGLDirty && (this.dirty = true, this.webGLDirty = false), PIXI.WebGLGraphics.renderGraphics(this, relation), this.children.length) {
                        relation.spriteBatch.start();

                        var unlock = 0;
                        for (; unlock < this.children.length; unlock++) {
                            this.children[unlock]._renderWebGL(relation);
                        }
                        relation.spriteBatch.stop();
                    }
                    if (this._filters) {
                        relation.filterManager.popFilter();
                    }
                    if (this._mask) {
                        relation.maskManager.popMask(this.mask, relation);
                    }
                    relation.drawCount++;
                    relation.spriteBatch.start();
                }
            }, $.Graphics.prototype._renderCanvas = function (ca) {
                if (false !== this.visible && (0 !== this.alpha && true !== this.isMask)) {
                    if (this._prevTint !== this.tint && (this.dirty = true, this._prevTint = this.tint), this._cacheAsBitmap) {
                        return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = false, this.dirty = false), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, ca);
                    }
                    var r20 = ca.context;
                    var m = this.worldTransform;
                    if (this.blendMode !== ca.currentBlendMode) {
                        ca.currentBlendMode = this.blendMode;
                        r20.globalCompositeOperation = PIXI.blendModesCanvas[ca.currentBlendMode];
                    }
                    if (this._mask) {
                        ca.maskManager.pushMask(this._mask, ca);
                    }
                    var c = ca.resolution;
                    var restoreScript = m.tx * ca.resolution + ca.shakeX;
                    var rreturn = m.ty * ca.resolution + ca.shakeY;
                    r20.setTransform(m.a * c, m.b * c, m.c * c, m.d * c, restoreScript, rreturn);
                    PIXI.CanvasGraphics.renderGraphics(this, r20);

                    var unlock = 0;
                    for (; unlock < this.children.length; unlock++) {
                        this.children[unlock]._renderCanvas(ca);
                    }
                    if (this._mask) {
                        ca.maskManager.popMask(ca);
                    }
                }
            }, $.Graphics.prototype.getBounds = function (dataAndEvents) {
                if (this._currentBounds) {
                    return this._currentBounds;
                }
                if (!this.renderable) {
                    return $.EmptyRectangle;
                }
                if (this.dirty) {
                    this.updateLocalBounds();

                    this.webGLDirty = true;

                    this.cachedSpriteDirty = true;

                    this.dirty = false;
                }
                var s = this._localBounds;
                var x = s.x;
                var z = s.width + s.x;
                var t = s.y;
                var y = s.height + s.y;
                var data = dataAndEvents || this.worldTransform;
                var v = data.a;
                var qz = data.b;
                var u = data.c;
                var qw = data.d;
                var col = data.tx;
                var value = data.ty;
                var ret = v * z + u * y + col;
                var tval = qw * y + qz * z + value;
                var h = v * x + u * y + col;
                var number = qw * y + qz * x + value;
                var offset = v * x + u * t + col;
                var num = qw * t + qz * x + value;
                var ii = v * z + u * t + col;
                var n = qw * t + qz * z + value;
                var maxh = ret;
                var max = tval;
                var firstIdx = ret;
                var min = tval;
                return firstIdx = h < firstIdx ? h : firstIdx, firstIdx = offset < firstIdx ? offset : firstIdx, firstIdx = ii < firstIdx ? ii : firstIdx, min = number < min ? number : min, min = num < min ? num : min, min = n < min ? n : min, maxh = h > maxh ? h : maxh, maxh = offset > maxh ? offset : maxh, maxh = ii > maxh ? ii : maxh, max = number > max ? number : max, max = num > max ? num : max, max = n > max ? n : max, this._bounds.x = firstIdx, this._bounds.width = maxh - firstIdx,
                    this._bounds.y = min, this._bounds.height = max - min, this._currentBounds = this._bounds, this._currentBounds;
            }, $.Graphics.prototype.getLocalBounds = function () {
                var _0x4dbbe6 = this.worldTransform;
                this.worldTransform = $.identityMatrix;

                var i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i].updateTransform();
                }
                var _0x102998 = this.getBounds();
                this.worldTransform = _0x4dbbe6;

                i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i].updateTransform();
                }
                return _0x102998;
            }, $.Graphics.prototype.containsPoint = function (deepDataAndEvents, urls) {
                if (void 0 === urls) {
                    urls = new($.Point);
                }
                this.worldTransform.applyInverse(deepDataAndEvents, urls);
                var data = this.graphicsData;

                var i = 0;
                for (; i < data.length; i++) {
                    var style = data[i];
                    if (style.fill && (style.shape && style.shape.contains(urls.x, urls.y))) {
                        return true;
                    }
                }
                return false;
            }, $.Graphics.prototype.updateLocalBounds = function () {

                var y = 1 / 0;

                var y2 = -1 / 0;

                var min = 1 / 0;

                var max = -1 / 0;
                if (this.graphicsData.length) {
                    var o;
                    var data;
                    var x;
                    var value;
                    var w;
                    var offset;

                    var unlock = 0;
                    for (; unlock < this.graphicsData.length; unlock++) {
                        var cache = this.graphicsData[unlock];
                        var c = cache.type;
                        var delta = cache.lineWidth;
                        if (o = cache.shape, c === $.RECTANGLE || c === $.ROUNDEDRECTANGLE) {

                            x = o.x - delta / 2;

                            value = o.y - delta / 2;
                            w = o.width + delta;
                            offset = o.height + delta;

                            y = x < y ? x : y;
                            y2 = x + w > y2 ? x + w : y2;

                            min = value < min ? value : min;
                            max = value + offset > max ? value + offset : max;
                        } else {
                            if (c === $.CIRCLE) {
                                x = o.x;
                                value = o.y;
                                w = o.radius + delta / 2;
                                offset = o.radius + delta / 2;

                                y = x - w < y ? x - w : y;
                                y2 = x + w > y2 ? x + w : y2;

                                min = value - offset < min ? value - offset : min;
                                max = value + offset > max ? value + offset : max;
                            } else {
                                if (c === $.ELLIPSE) {
                                    x = o.x;
                                    value = o.y;
                                    w = o.width + delta / 2;
                                    offset = o.height + delta / 2;

                                    y = x - w < y ? x - w : y;
                                    y2 = x + w > y2 ? x + w : y2;

                                    min = value - offset < min ? value - offset : min;
                                    max = value + offset > max ? value + offset : max;
                                } else {
                                    data = o.points;

                                    var i = 0;
                                    for (; i < data.length; i++) {
                                        if (data[i] instanceof $.Point) {
                                            x = data[i].x;
                                            value = data[i].y;
                                        } else {
                                            x = data[i];
                                            value = data[i + 1];
                                            if (i < data.length - 1) {
                                                i++;
                                            }
                                        }

                                        y = x - delta < y ? x - delta : y;
                                        y2 = x + delta > y2 ? x + delta : y2;

                                        min = value - delta < min ? value - delta : min;
                                        max = value + delta > max ? value + delta : max;
                                    }
                                }
                            }
                        }
                    }
                } else {

                    y = 0;

                    y2 = 0;

                    min = 0;

                    max = 0;
                }
                var half = this.boundsPadding;

                this._localBounds.x = y - half;

                this._localBounds.width = y2 - y + 2 * half;

                this._localBounds.y = min - half;

                this._localBounds.height = max - min + 2 * half;
            }, $.Graphics.prototype._generateCachedSprite = function () {
                var hash = this.getLocalBounds();
                if (this._cachedSprite) {
                    this._cachedSprite.buffer.resize(hash.width, hash.height);
                } else {
                    var _0x1b3749 = new(PIXI.CanvasBuffer)(hash.width, hash.height);
                    var Sprite = PIXI.Texture.fromCanvas(_0x1b3749.canvas);
                    this._cachedSprite = new PIXI.Sprite(Sprite);
                    this._cachedSprite.buffer = _0x1b3749;
                    this._cachedSprite.worldTransform = this.worldTransform;
                }

                this._cachedSprite.anchor.x = -hash.x / hash.width;

                this._cachedSprite.anchor.y = -hash.y / hash.height;
                this._cachedSprite.buffer.context.translate(-hash.x, -hash.y);

                this.worldAlpha = 1;
                PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);
                this._cachedSprite.alpha = this.alpha;
            }, $.Graphics.prototype.updateCachedSpriteTexture = function () {
                var output = this._cachedSprite;
                var style = output.texture;
                var map = output.buffer.canvas;
                style.baseTexture.width = map.width;
                style.baseTexture.height = map.height;
                style.crop.width = style.frame.width = map.width;
                style.crop.height = style.frame.height = map.height;
                output._width = map.width;
                output._height = map.height;
                style.baseTexture.dirty();
            }, $.Graphics.prototype.destroyCachedSprite = function () {
                this._cachedSprite.texture.destroy(true);

                this._cachedSprite = null;
            }, $.Graphics.prototype.drawShape = function (dataAndEvents) {
                if (this.currentPath) {
                    if (this.currentPath.shape.points.length <= 2) {
                        this.graphicsData.pop();
                    }
                }

                this.currentPath = null;
                if (dataAndEvents instanceof $.Polygon) {
                    (dataAndEvents = dataAndEvents.clone()).flatten();
                }
                var r20 = new($.GraphicsData)(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, dataAndEvents);
                return this.graphicsData.push(r20), r20.type === $.POLYGON && (r20.shape.closed = this.filling, this.currentPath = r20), this.dirty = true, this._boundsDirty = true, r20;
            }, Object.defineProperty($.Graphics.prototype, "cacheAsBitmap", {

                "get": function () {
                    return this._cacheAsBitmap;
                },

                "set": function (mL) {
                    this._cacheAsBitmap = mL;
                    if (this._cacheAsBitmap) {
                        this._generateCachedSprite();
                    } else {
                        this.destroyCachedSprite();
                    }

                    this.dirty = true;

                    this.webGLDirty = true;
                }
            }), $.RenderTexture = function (ignoreMethodDoesntExist, textAlt, keepData, expires, opt_attributes, dataAndEvents, deepDataAndEvents, mesh) {
                if (void 0 === textAlt && (textAlt = 100), void 0 === keepData && (keepData = 100), void 0 === expires && (expires = ""), void 0 === opt_attributes && (opt_attributes = $.scaleModes.DEFAULT), void 0 === dataAndEvents && (dataAndEvents = 1), void 0 === deepDataAndEvents && (deepDataAndEvents = PIXI.defaultRenderer), void 0 === mesh && (mesh = 0), this.game = ignoreMethodDoesntExist, this.key = expires, this.type = $.RENDERTEXTURE, this._tempMatrix =
                    new($.Matrix), this.width = textAlt, this.height = keepData, this.resolution = dataAndEvents, this.frame = new $.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new(PIXI.BaseTexture), this.baseTexture.width = this.width * this.resolution, this.baseTexture.height =
                    this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = opt_attributes, this.baseTexture.hasLoaded = true, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = deepDataAndEvents, this.renderer.type === $.WEBGL) {
                    var done = this.renderer.gl;

                    this.baseTexture.textureIndex = mesh;

                    this.baseTexture._dirty[done.id] = false;
                    this.textureBuffer = new(PIXI.FilterTexture)(done, this.width, this.height, this.baseTexture.scaleMode, mesh);
                    this.baseTexture._glTextures[done.id] = this.textureBuffer.texture;
                    this.projection = new $.Point(0.5 * this.width, 0.5 * -this.height);
                } else {
                    this.textureBuffer = new(PIXI.CanvasBuffer)(this.width * this.resolution, this.height * this.resolution);
                    this.baseTexture.source = this.textureBuffer.canvas;
                }

                this.valid = true;
                this.tempMatrix = new $.Matrix;
                this._updateUvs();
            }, $.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), $.RenderTexture.prototype.constructor = $.RenderTexture, $.RenderTexture.prototype.renderXY = function (deepDataAndEvents, dataAndEvents, new_name, opt_obj2) {
                deepDataAndEvents.updateTransform();
                this._tempMatrix.copyFrom(deepDataAndEvents.worldTransform);
                this._tempMatrix.tx = dataAndEvents;
                this._tempMatrix.ty = new_name;
                if (this.renderer.type === $.WEBGL) {
                    this._renderWebGL(deepDataAndEvents, this._tempMatrix, opt_obj2);
                } else {
                    this._renderCanvas(deepDataAndEvents, this._tempMatrix, opt_obj2);
                }
            }, $.RenderTexture.prototype.renderRawXY = function (walkers, deepDataAndEvents, opt_obj2, isXML) {
                this._tempMatrix.identity().translate(deepDataAndEvents, opt_obj2);
                if (this.renderer.type === $.WEBGL) {
                    this._renderWebGL(walkers, this._tempMatrix, isXML);
                } else {
                    this._renderCanvas(walkers, this._tempMatrix, isXML);
                }
            }, $.RenderTexture.prototype.render = function (deepDataAndEvents, opt_obj2, walkers) {
                if (void 0 === opt_obj2 || null === opt_obj2) {
                    this._tempMatrix.copyFrom(deepDataAndEvents.worldTransform);
                } else {
                    this._tempMatrix.copyFrom(opt_obj2);
                }
                if (this.renderer.type === $.WEBGL) {
                    this._renderWebGL(deepDataAndEvents, this._tempMatrix, walkers);
                } else {
                    this._renderCanvas(deepDataAndEvents, this._tempMatrix, walkers);
                }
            }, $.RenderTexture.prototype.resize = function (a, b, dataAndEvents) {
                if (!(a === this.width && b === this.height)) {

                    this.valid = a > 0 && b > 0;

                    this.width = a;

                    this.height = b;

                    this.frame.width = this.crop.width = a * this.resolution;

                    this.frame.height = this.crop.height = b * this.resolution;
                    if (dataAndEvents) {

                        this.baseTexture.width = this.width * this.resolution;

                        this.baseTexture.height = this.height * this.resolution;
                    }
                    if (this.renderer.type === $.WEBGL) {

                        this.projection.x = this.width / 2;

                        this.projection.y = -this.height / 2;
                    }
                    if (this.valid) {
                        this.textureBuffer.resize(this.width, this.height);
                    }
                }
            }, $.RenderTexture.prototype.clear = function () {
                if (this.valid) {
                    if (this.renderer.type === $.WEBGL) {
                        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);
                    }
                    this.textureBuffer.clear();
                }
            }, $.RenderTexture.prototype._renderWebGL = function (data, deepDataAndEvents, dataAndEvents) {
                if (this.valid && 0 !== data.alpha) {
                    var displayAxes = data.worldTransform;
                    displayAxes.identity();
                    displayAxes.translate(0, 2 * this.projection.y);
                    if (deepDataAndEvents) {
                        displayAxes.append(deepDataAndEvents);
                    }
                    displayAxes.scale(1, -1);

                    var value_idx = 0;
                    for (; value_idx < data.children.length; value_idx++) {
                        data.children[value_idx].updateTransform();
                    }
                    var results = this.renderer.gl;
                    results.viewport(0, 0, this.width * this.resolution, this.height * this.resolution);
                    results.bindFramebuffer(results.FRAMEBUFFER, this.textureBuffer.frameBuffer);
                    if (dataAndEvents) {
                        this.textureBuffer.clear();
                    }

                    this.renderer.spriteBatch.dirty = true;
                    this.renderer.renderDisplayObject(data, this.projection, this.textureBuffer.frameBuffer, deepDataAndEvents);

                    this.renderer.spriteBatch.dirty = true;
                    results.bindFramebuffer(results.FRAMEBUFFER, null);
                }
            }, $.RenderTexture.prototype._renderCanvas = function (data, obj, dataAndEvents) {
                if (this.valid && 0 !== data.alpha) {
                    var _ = data.worldTransform;
                    _.identity();
                    if (obj) {
                        _.append(obj);
                    }

                    var value_idx = 0;
                    for (; value_idx < data.children.length; value_idx++) {
                        data.children[value_idx].updateTransform();
                    }
                    if (dataAndEvents) {
                        this.textureBuffer.clear();
                    }
                    var fileTypeObj = this.renderer.resolution;
                    this.renderer.resolution = this.resolution;
                    this.renderer.renderDisplayObject(data, this.textureBuffer.context, obj);
                    this.renderer.resolution = fileTypeObj;
                }
            }, $.RenderTexture.prototype.getImage = function () {

                var im = new Image;
                return im.src = this.getBase64(), im;
            }, $.RenderTexture.prototype.getBase64 = function () {
                return this.getCanvas().toDataURL();
            }, $.RenderTexture.prototype.getCanvas = function () {
                if (this.renderer.type === $.WEBGL) {
                    var results = this.renderer.gl;
                    var width = this.textureBuffer.width;
                    var height = this.textureBuffer.height;

                    var writeArrayBuffer = new Uint8Array(4 * width * height);
                    results.bindFramebuffer(results.FRAMEBUFFER, this.textureBuffer.frameBuffer);
                    results.readPixels(0, 0, width, height, results.RGBA, results.UNSIGNED_BYTE, writeArrayBuffer);
                    results.bindFramebuffer(results.FRAMEBUFFER, null);
                    var np = new(PIXI.CanvasBuffer)(width, height);
                    var boundary = np.context.getImageData(0, 0, width, height);
                    return boundary.data.set(writeArrayBuffer), np.context.putImageData(boundary, 0, 0), np.canvas;
                }
                return this.textureBuffer.canvas;
            }, $.Text = function (deepDataAndEvents, made, contexts, g, dataAndEvents) {
                made = made || 0;
                contexts = contexts || 0;
                g = void 0 === g || null === g ? "" : g.toString();
                this.type = $.TEXT;
                this.physicsType = $.SPRITE;
                this.padding = new($.Point);

                this.textBounds = null;
                this.canvas = $.CanvasPool.create(this);
                this.context = this.canvas.getContext("2d");

                this.colors = [];

                this.strokeColors = [];

                this.fontStyles = [];

                this.fontWeights = [];

                this.autoRound = false;

                this.useAdvancedWrap = false;

                this.splitRegExp = /(?:\r\n|\r|\n)/;

                this.characterLimitSize = -1;

                this.characterLimitSuffix = "";
                this._res = deepDataAndEvents.renderer.resolution;

                this._text = g;

                this._fontComponents = null;

                this._lineSpacing = 0;

                this._charCount = 0;

                this._width = 0;

                this._height = 0;
                $.Sprite.call(this, deepDataAndEvents, made, contexts, PIXI.Texture.fromCanvas(this.canvas));
                this.style = {};
                this.setStyle(dataAndEvents || {});
                if ("" !== g) {
                    this.updateText();
                }
            }, $.Text.prototype = Object.create($.Sprite.prototype), $.Text.prototype.constructor = $.Text, $.Text.prototype.preUpdate = function () {
                return !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.Text.prototype.update = function () {}, $.Text.prototype.destroy = function (deepDataAndEvents) {
                this.texture.destroy(true);
                $.Component.Destroy.prototype.destroy.call(this, deepDataAndEvents);
            }, $.Text.prototype.setShadow = function (deepDataAndEvents, ignoreMethodDoesntExist, dataAndEvents, value, textAlt, keepData) {
                return void 0 === deepDataAndEvents && (deepDataAndEvents = 0), void 0 === ignoreMethodDoesntExist && (ignoreMethodDoesntExist = 0), void 0 === dataAndEvents && (dataAndEvents = 'rgba(0, 0, 0, 1)'), void 0 === value && (value = 0), void 0 === textAlt && (textAlt = true), void 0 === keepData && (keepData = true), this.style.shadowOffsetX = deepDataAndEvents, this.style.shadowOffsetY = ignoreMethodDoesntExist, this.style.shadowColor = dataAndEvents, this.style.shadowBlur =
                    value, this.style.shadowStroke = textAlt, this.style.shadowFill = keepData, this.dirty = true, this;
            }, $.Text.prototype.setStyle = function (options, dataAndEvents) {
                if (void 0 === dataAndEvents) {

                    dataAndEvents = false;
                }
                var o = Object.assign({}, options);
                o.font = options.font || 'bold 20pt Arial';
                o.backgroundColor = options.backgroundColor || null;
                o.fill = options.fill || 'black';
                o.align = (options.align || 'left').toLowerCase();
                o.boundsAlignH = (options.boundsAlignH || 'left').toLowerCase();
                o.boundsAlignV = (options.boundsAlignV || 'top').toLowerCase();
                o.stroke = options.stroke || 'black';

                o.strokeThickness = Number(options.strokeThickness) || 0;
                o.wordWrap = options.wordWrap || false;
                o.wordWrapWidth = options.wordWrapWidth || 100;
                o.maxLines = options.maxLines || 0;
                o.shadowOffsetX = options.shadowOffsetX || 0;
                o.shadowOffsetY = options.shadowOffsetY || 0;
                o.shadowColor = options.shadowColor || 'rgba(0,0,0,0)';
                o.shadowBlur = options.shadowBlur || 0;
                o.tabs = options.tabs || 0;
                var o2 = this.fontToComponents(o.font);
                return o.fontStyle && (o2.fontStyle = o.fontStyle), o.fontVariant && (o2.fontVariant = o.fontVariant), o.fontWeight && (o2.fontWeight = o.fontWeight), o.fontSize && ('number' == typeof o.fontSize && (o.fontSize = o.fontSize + "px"), o2.fontSize = o.fontSize), this._fontComponents = o2, o.font = this.componentsToFont(this._fontComponents), this.style = o, this.dirty =
                    true, dataAndEvents && this.updateText(), this;
            }, $.Text.prototype.updateText = function () {
                this.texture.baseTexture.resolution = this._res;
                this.context.font = this.style.font;
                var result = this.text;
                if (this.characterLimitSize > -1) {
                    if (this.characterLimitSize < result.length) {
                        result = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix;
                    }
                }
                if (this.style.wordWrap) {
                    result = this.runWordWrap(this.text);
                }
                var mat = result.split(this.splitRegExp);
                var r20 = this.style.tabs;

                var attribs = [];

                var t = 0;
                var subTests = this.determineFontProperties(this.style.font);
                var mag = mat.length;
                if (this.style.maxLines > 0) {
                    if (this.style.maxLines < mat.length) {
                        mag = this.style.maxLines;
                    }
                }

                this._charCount = 0;

                var i = 0;
                for (; i < mag; i++) {
                    if (0 === r20) {
                        x = this.style.strokeThickness + this.padding.x;
                        if (this.colors.length > 0 || (this.strokeColors.length > 0 || (this.fontWeights.length > 0 || this.fontStyles.length > 0))) {
                            x += this.measureLine(mat[i]);
                        } else {
                            x += this.context.measureText(mat[i]).width;
                        }
                        if (this.style.wordWrap) {
                            x -= this.context.measureText(" ").width;
                        }
                    } else {
                        var map = mat[i].split(/(?:\t)/);
                        var x = this.padding.x + this.style.strokeThickness;
                        if (Array.isArray(r20)) {

                            var x1 = 0;

                            var objUid = 0;
                            for (; objUid < map.length; objUid++) {

                                var dx = 0;
                                dx = this.colors.length > 0 || (this.strokeColors.length > 0 || (this.fontWeights.length > 0 || this.fontStyles.length > 0)) ? this.measureLine(map[objUid]) : Math.ceil(this.context.measureText(map[objUid]).width);
                                if (objUid > 0) {
                                    x1 += r20[objUid - 1];
                                }
                                x = x1 + dx;
                            }
                        } else {

                            objUid = 0;
                            for (; objUid < map.length; objUid++) {
                                if (this.colors.length > 0 || (this.strokeColors.length > 0 || (this.fontWeights.length > 0 || this.fontStyles.length > 0))) {
                                    x += this.measureLine(map[objUid]);
                                } else {
                                    x += Math.ceil(this.context.measureText(map[objUid]).width);
                                }
                                x += this.game.math.snapToCeil(x, r20) - x;
                            }
                        }
                    }
                    attribs[i] = Math.ceil(x);
                    t = Math.max(t, attribs[i]);
                }

                this.canvas.width = t * this._res;
                var dy = subTests.fontSize + this.style.strokeThickness + this.padding.y;

                var delta_vy = dy * mag;
                var y = this._lineSpacing;
                if (y < 0) {
                    if (Math.abs(y) > dy) {

                        y = -dy;
                    }
                }
                if (0 !== y) {
                    delta_vy += y > 0 ? y * mat.length : y * (mat.length - 1);
                }

                this.canvas.height = delta_vy * this._res;
                this.context.scale(this._res, this._res);
                if (navigator.isCocoonJS) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                if (this.style.backgroundColor) {
                    this.context.fillStyle = this.style.backgroundColor;
                    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                this.context.fillStyle = this.style.fill;
                this.context.font = this.style.font;
                this.context.strokeStyle = this.style.stroke;
                this.context.textBaseline = 'alphabetic';
                this.context.lineWidth = this.style.strokeThickness;

                this.context.lineCap = "round";

                this.context.lineJoin = "round";
                var from;
                var currentValue;

                this._charCount = 0;

                i = 0;
                for (; i < mag; i++) {

                    from = this.style.strokeThickness / 2;
                    currentValue = this.style.strokeThickness / 2 + i * dy + subTests.ascent;
                    if (i > 0) {
                        currentValue += y * i;
                    }
                    if ("right" === this.style.align) {
                        from += t - attribs[i];
                    } else {
                        if ('center' === this.style.align) {
                            from += (t - attribs[i]) / 2;
                        }
                    }
                    if (this.autoRound) {
                        from = Math.round(from);
                        currentValue = Math.round(currentValue);
                    }
                    if (this.colors.length > 0 || (this.strokeColors.length > 0 || (this.fontWeights.length > 0 || this.fontStyles.length > 0))) {
                        this.updateLine(mat[i], from, currentValue);
                    } else {
                        if (this.style.stroke) {
                            if (this.style.strokeThickness) {
                                this.updateShadow(this.style.shadowStroke);
                                if (0 === r20) {
                                    this.context.strokeText(mat[i], from, currentValue);
                                } else {
                                    this.renderTabLine(mat[i], from, currentValue, false);
                                }
                            }
                        }
                        if (this.style.fill) {
                            this.updateShadow(this.style.shadowFill);
                            if (0 === r20) {
                                this.context.fillText(mat[i], from, currentValue);
                            } else {
                                this.renderTabLine(mat[i], from, currentValue, true);
                            }
                        }
                    }
                }
                this.updateTexture();

                this.dirty = false;
            }, $.Text.prototype.renderTabLine = function (dataAndEvents, startAngle, deepDataAndEvents, ignoreMethodDoesntExist) {
                var stack = dataAndEvents.split(/(?:\t)/);
                var pdataOld = this.style.tabs;

                var pdataCur = 0;
                if (Array.isArray(pdataOld)) {

                    var endAngle = 0;

                    var i = 0;
                    for (; i < stack.length; i++) {
                        if (i > 0) {
                            endAngle += pdataOld[i - 1];
                        }
                        pdataCur = startAngle + endAngle;
                        if (ignoreMethodDoesntExist) {
                            this.context.fillText(stack[i], pdataCur, deepDataAndEvents);
                        } else {
                            this.context.strokeText(stack[i], pdataCur, deepDataAndEvents);
                        }
                    }
                } else {

                    i = 0;
                    for (; i < stack.length; i++) {
                        var millis = Math.ceil(this.context.measureText(stack[i]).width);
                        pdataCur = this.game.math.snapToCeil(startAngle, pdataOld);
                        if (ignoreMethodDoesntExist) {
                            this.context.fillText(stack[i], pdataCur, deepDataAndEvents);
                        } else {
                            this.context.strokeText(stack[i], pdataCur, deepDataAndEvents);
                        }
                        startAngle = pdataCur + millis;
                    }
                }
            }, $.Text.prototype.updateShadow = function (dataAndEvents) {
                if (dataAndEvents) {
                    this.context.shadowOffsetX = this.style.shadowOffsetX;
                    this.context.shadowOffsetY = this.style.shadowOffsetY;
                    this.context.shadowColor = this.style.shadowColor;
                    this.context.shadowBlur = this.style.shadowBlur;
                } else {

                    this.context.shadowOffsetX = 0;

                    this.context.shadowOffsetY = 0;

                    this.context.shadowColor = 0;

                    this.context.shadowBlur = 0;
                }
            }, $.Text.prototype.measureLine = function ($cookies) {

                var currentValue = 0;

                var key = 0;
                for (; key < $cookies.length; key++) {
                    var value = $cookies[key];
                    if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                        var r20 = this.fontToComponents(this.context.font);
                        if (this.fontStyles[this._charCount]) {
                            r20.fontStyle = this.fontStyles[this._charCount];
                        }
                        if (this.fontWeights[this._charCount]) {
                            r20.fontWeight = this.fontWeights[this._charCount];
                        }
                        this.context.font = this.componentsToFont(r20);
                    }
                    if (this.style.stroke) {
                        if (this.style.strokeThickness) {
                            if (this.strokeColors[this._charCount]) {
                                this.context.strokeStyle = this.strokeColors[this._charCount];
                            }
                            this.updateShadow(this.style.shadowStroke);
                        }
                    }
                    if (this.style.fill) {
                        if (this.colors[this._charCount]) {
                            this.context.fillStyle = this.colors[this._charCount];
                        }
                        this.updateShadow(this.style.shadowFill);
                    }
                    currentValue += this.context.measureText(value).width;
                    this._charCount++;
                }
                return Math.ceil(currentValue);
            }, $.Text.prototype.updateLine = function (stack, deepDataAndEvents, opt_obj2) {

                var i = 0;
                for (; i < stack.length; i++) {
                    var currentStackItem = stack[i];
                    if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                        var r20 = this.fontToComponents(this.context.font);
                        if (this.fontStyles[this._charCount]) {
                            r20.fontStyle = this.fontStyles[this._charCount];
                        }
                        if (this.fontWeights[this._charCount]) {
                            r20.fontWeight = this.fontWeights[this._charCount];
                        }
                        this.context.font = this.componentsToFont(r20);
                    }
                    if (this.style.stroke) {
                        if (this.style.strokeThickness) {
                            if (this.strokeColors[this._charCount]) {
                                this.context.strokeStyle = this.strokeColors[this._charCount];
                            }
                            this.updateShadow(this.style.shadowStroke);
                            this.context.strokeText(currentStackItem, deepDataAndEvents, opt_obj2);
                        }
                    }
                    if (this.style.fill) {
                        if (this.colors[this._charCount]) {
                            this.context.fillStyle = this.colors[this._charCount];
                        }
                        this.updateShadow(this.style.shadowFill);
                        this.context.fillText(currentStackItem, deepDataAndEvents, opt_obj2);
                    }
                    deepDataAndEvents += this.context.measureText(currentStackItem).width;
                    this._charCount++;
                }
            }, $.Text.prototype.clearColors = function () {
                return this.colors = [], this.strokeColors = [], this.dirty = true, this;
            }, $.Text.prototype.clearFontValues = function () {
                return this.fontStyles = [], this.fontWeights = [], this.dirty = true, this;
            }, $.Text.prototype.addColor = function (offsetPosition, i) {
                return this.colors[i] = offsetPosition, this.dirty = true, this;
            }, $.Text.prototype.addStrokeColor = function (offsetPosition, i) {
                return this.strokeColors[i] = offsetPosition, this.dirty = true, this;
            }, $.Text.prototype.addFontStyle = function (offsetPosition, i) {
                return this.fontStyles[i] = offsetPosition, this.dirty = true, this;
            }, $.Text.prototype.addFontWeight = function (offsetPosition, i) {
                return this.fontWeights[i] = offsetPosition, this.dirty = true, this;
            }, $.Text.prototype.precalculateWordWrap = function (deepDataAndEvents) {
                return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(deepDataAndEvents).split(/(?:\r\n|\r|\n)/);
            }, $.Text.prototype.runWordWrap = function (deepDataAndEvents) {
                return this.useAdvancedWrap ? this.advancedWordWrap(deepDataAndEvents) : this.basicWordWrap(deepDataAndEvents);
            }, $.Text.prototype.advancedWordWrap = function (dataAndEvents) {
                var cmp = this.context;
                var high = this.style.wordWrapWidth;

                var path = "";
                var parts = dataAndEvents.replace(/ +/gi, " ").split(/\r?\n/gi);
                var last = parts.length;

                var i = 0;
                for (; i < last; i++) {
                    var location = parts[i];

                    var optsData = "";
                    if (location = location.replace(/^ *|\s*$/gi, ""), cmp.measureText(location).width < high) {
                        path += location + "\n";
                    } else {
                        var best = high;
                        var doc = location.split(" ");

                        var unlock = 0;
                        for (; unlock < doc.length; unlock++) {
                            var cache = doc[unlock];

                            var buf = cache + " ";
                            var score = cmp.measureText(buf).width;
                            if (score > best) {
                                if (0 === unlock) {

                                    var b = buf;
                                    for (; b.length && (b = b.slice(0, -1), !((score = cmp.measureText(b).width) <= best));) {}
                                    if (!b.length) {
                                        throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                    }
                                    var data = cache.substr(b.length);
                                    doc[unlock] = data;
                                    optsData += b;
                                }

                                var domContentLoaded = doc[unlock].length ? unlock : unlock + 1;
                                var name = doc.slice(domContentLoaded).join(" ").replace(/[ \n]*$/gi, "");
                                parts[i + 1] = name + " " + (parts[i + 1] || "");
                                last = parts.length;
                                break;
                            }
                            optsData += buf;
                            best -= score;
                        }
                        path += optsData.replace(/[ \n]*$/gi, "") + "\n";
                    }
                }
                return path = path.replace(/[\s|\n]*$/gi, "");
            }, $.Text.prototype.basicWordWrap = function (dataAndEvents) {

                var optsData = "";
                var stack = dataAndEvents.split("\n");

                var i = 0;
                for (; i < stack.length; i++) {
                    var b = this.style.wordWrapWidth;
                    var map = stack[i].split(" ");

                    var objUid = 0;
                    for (; objUid < map.length; objUid++) {
                        var rot = this.context.measureText(map[objUid]).width;
                        var a = rot + this.context.measureText(" ").width;
                        if (a > b) {
                            if (objUid > 0) {
                                optsData += "\n";
                            }
                            optsData += map[objUid] + " ";

                            b = this.style.wordWrapWidth - rot;
                        } else {
                            b -= a;
                            optsData += map[objUid] + " ";
                        }
                    }
                    if (i < stack.length - 1) {
                        optsData += "\n";
                    }
                }
                return optsData;
            }, $.Text.prototype.updateFont = function (opt_context) {
                var result = this.componentsToFont(opt_context);
                if (this.style.font !== result) {
                    this.style.font = result;

                    this.dirty = true;
                    if (this.parent) {
                        this.updateTransform();
                    }
                }
            }, $.Text.prototype.fontToComponents = function (font) {
                var parts = font.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
                if (parts) {
                    var fontFamily = parts[5].trim();
                    return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/ ['exec'](fontFamily) || (/['",]/ ['exec'](fontFamily) || (fontFamily = "'" + fontFamily + "'")), {
                        "font": font,
                        "fontStyle": parts[1] || 'normal',
                        "fontVariant": parts[2] || 'normal',
                        "fontWeight": parts[3] || "normal",
                        "fontSize": parts[4] || 'medium',
                        "fontFamily": fontFamily
                    };
                }
                return console.warn('Phaser.Text - unparsable CSS font: ' + font), {
                    "font": font
                };
            }, $.Text.prototype.componentsToFont = function (elements) {
                var element;

                var Effect = [];
                return (element = elements.fontStyle) && ('normal' !== element && Effect.push(element)), (element = elements.fontVariant) && ("normal" !== element && Effect.push(element)), (element = elements.fontWeight) && ('normal' !== element && Effect.push(element)), (element = elements.fontSize) && ('medium' !== element && Effect.push(element)), (element = elements.fontFamily) && Effect.push(element),
                    Effect.length || Effect.push(elements.font), Effect.join(" ");
            }, $.Text.prototype.setText = function (res, dataAndEvents) {
                return void 0 === dataAndEvents && (dataAndEvents = false), this.text = res.toString() || "", dataAndEvents ? this.updateText() : this.dirty = true, this;
            }, $.Text.prototype.parseList = function (data) {
                if (!Array.isArray(data)) {
                    return this;
                }

                var c = "";

                var i = 0;
                for (; i < data.length; i++) {
                    if (Array.isArray(data[i])) {
                        c += data[i].join("\t");
                        if (i < data.length - 1) {
                            c += "\n";
                        }
                    } else {
                        c += data[i];
                        if (i < data.length - 1) {
                            c += "\t";
                        }
                    }
                }
                return this.text = c, this.dirty = true, this;
            }, $.Text.prototype.setTextBounds = function (deepDataAndEvents, opt_obj2, walkers, isXML) {
                return void 0 === deepDataAndEvents ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(deepDataAndEvents, opt_obj2, walkers, isXML) : this.textBounds = new $.Rectangle(deepDataAndEvents, opt_obj2, walkers, isXML), this.style.wordWrapWidth > walkers && (this.style.wordWrapWidth = walkers)), this.updateTexture(), this;
            }, $.Text.prototype.updateTexture = function () {
                var ret = this.texture.baseTexture;
                var options = this.texture.crop;
                var viewportSet = this.texture.frame;
                var width = this.canvas.width;
                var height = this.canvas.height;
                if (ret.width = width, ret.height = height, options.width = width, options.height = height, viewportSet.width = width, viewportSet.height = height, this.texture.width = width, this.texture.height = height, this._width = width, this._height = height, this.textBounds) {
                    var x = this.textBounds.x;
                    var y = this.textBounds.y;
                    if ('right' === this.style.boundsAlignH) {
                        x += this.textBounds.width - this.canvas.width / this.resolution;
                    } else {
                        if ('center' === this.style.boundsAlignH) {
                            x += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2;
                        }
                    }
                    if ('bottom' === this.style.boundsAlignV) {
                        y += this.textBounds.height - this.canvas.height / this.resolution;
                    } else {
                        if ("middle" === this.style.boundsAlignV) {
                            y += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2;
                        }
                    }

                    this.pivot.x = -x;

                    this.pivot.y = -y;
                }

                this.renderable = 0 !== width && 0 !== height;

                this.texture.requiresReTint = true;
                this.texture.baseTexture.dirty();
            }, $.Text.prototype._renderWebGL = function (deepDataAndEvents) {
                if (this.dirty) {
                    this.updateText();

                    this.dirty = false;
                }
                PIXI.Sprite.prototype._renderWebGL.call(this, deepDataAndEvents);
            }, $.Text.prototype._renderCanvas = function (deepDataAndEvents) {
                if (this.dirty) {
                    this.updateText();

                    this.dirty = false;
                }
                PIXI.Sprite.prototype._renderCanvas.call(this, deepDataAndEvents);
            }, $.Text.prototype.determineFontProperties = function (name) {
                var region = $.Text.fontPropertiesCache[name];
                if (!region) {
                    region = {};
                    var mat = $.Text.fontPropertiesCanvas;
                    var webshims = $.Text.fontPropertiesContext;
                    webshims.font = name;
                    var v3 = Math.ceil(webshims.measureText('|MÃ‰q').width);
                    var b = Math.ceil(webshims.measureText('|MÃ‰q').width);

                    var c = 2 * b;
                    if (b = 1.4 * b | 0, mat.width = v3, mat.height = c, webshims.fillStyle = '#f00', webshims.fillRect(0, 0, v3, c), webshims.font = name, webshims.textBaseline = 'alphabetic', webshims.fillStyle = "#000", webshims.fillText("|MÃ‰q", 0, b), !webshims.getImageData(0, 0, v3, c)) {
                        return region.ascent = b, region.descent = b + 6, region.fontSize = region.ascent + region.descent, $.Text.fontPropertiesCache[name] = region, region;
                    }
                    var a;
                    var minWidth;
                    var result = webshims.getImageData(0, 0, v3, c).data;
                    var wrapper_width = result.length;

                    var width = 4 * v3;

                    var left = 0;

                    var _0xb3e949 = false;

                    a = 0;
                    for (; a < b; a++) {

                        minWidth = 0;
                        for (; minWidth < width; minWidth += 4) {
                            if (255 !== result[left + minWidth]) {

                                _0xb3e949 = true;
                                break;
                            }
                        }
                        if (_0xb3e949) {
                            break;
                        }
                        left += width;
                    }

                    region.ascent = b - a;

                    left = wrapper_width - width;

                    _0xb3e949 = false;

                    a = c;
                    for (; a > b; a--) {

                        minWidth = 0;
                        for (; minWidth < width; minWidth += 4) {
                            if (255 !== result[left + minWidth]) {

                                _0xb3e949 = true;
                                break;
                            }
                        }
                        if (_0xb3e949) {
                            break;
                        }
                        left -= width;
                    }

                    region.descent = a - b;
                    region.descent += 6;
                    region.fontSize = region.ascent + region.descent;
                    $.Text.fontPropertiesCache[name] = region;
                }
                return region;
            }, $.Text.prototype.getBounds = function (deepDataAndEvents) {
                return this.dirty && (this.updateText(), this.dirty = false), PIXI.Sprite.prototype.getBounds.call(this, deepDataAndEvents);
            }, $.Text.prototype.setCharacterLimit = function (dataAndEvents, value) {
                this.characterLimitSuffix = void 0 === value ? "" : value;
                this.characterLimitSize = dataAndEvents;
                this.updateText();
            }, Object.defineProperty($.Text.prototype, 'text', {

                "get": function () {
                    return this._text;
                },

                "set": function (mL) {
                    if (mL !== this._text) {
                        this._text = mL.toString() || "";

                        this.dirty = true;
                        if (this.parent) {
                            this.updateTransform();
                        }
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'cssFont', {

                "get": function () {
                    return this.componentsToFont(this._fontComponents);
                },

                "set": function (capturePhase) {
                    capturePhase = capturePhase || 'bold 20pt Arial';
                    this._fontComponents = this.fontToComponents(capturePhase);
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, 'font', {

                "get": function () {
                    return this._fontComponents.fontFamily;
                },

                "set": function (format) {
                    format = (format = format || 'Arial').trim();
                    if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/ ['exec'](format)) {
                        if (!/['",]/ ["exec"](format)) {

                            format = "'" + format + "'";
                        }
                    }

                    this._fontComponents.fontFamily = format;
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, 'fontSize', {

                "get": function () {
                    var line = this._fontComponents.fontSize;
                    return line && /(?:^0$|px$)/ ['exec'](line) ? parseInt(line, 10) : line;
                },

                "set": function (size) {
                    if ("number" == typeof (size = size || "0")) {
                        size += "px";
                    }

                    this._fontComponents.fontSize = size;
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, 'fontWeight', {

                "get": function () {
                    return this._fontComponents.fontWeight || 'normal';
                },

                "set": function (z) {
                    z = z || 'normal';
                    this._fontComponents.fontWeight = z;
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, "fontStyle", {

                "get": function () {
                    return this._fontComponents.fontStyle || "normal";
                },

                "set": function (z) {
                    z = z || 'normal';
                    this._fontComponents.fontStyle = z;
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, "fontVariant", {

                "get": function () {
                    return this._fontComponents.fontVariant || 'normal';
                },

                "set": function (z) {
                    z = z || 'normal';
                    this._fontComponents.fontVariant = z;
                    this.updateFont(this._fontComponents);
                }
            }), Object.defineProperty($.Text.prototype, "fill", {

                "get": function () {
                    return this.style.fill;
                },

                "set": function (mL) {
                    if (mL !== this.style.fill) {
                        this.style.fill = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'align', {

                "get": function () {
                    return this.style.align;
                },

                "set": function (mL) {
                    if ((mL = mL.toLowerCase()) !== this.style.align) {

                        this.style.align = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'resolution', {

                "get": function () {
                    return this._res;
                },

                "set": function (mL) {
                    if (mL !== this._res) {
                        this._res = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'tabs', {

                "get": function () {
                    return this.style.tabs;
                },

                "set": function (mL) {
                    if (mL !== this.style.tabs) {
                        this.style.tabs = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'boundsAlignH', {

                "get": function () {
                    return this.style.boundsAlignH;
                },

                "set": function (mL) {
                    if ((mL = mL.toLowerCase()) !== this.style.boundsAlignH) {

                        this.style.boundsAlignH = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, "boundsAlignV", {

                "get": function () {
                    return this.style.boundsAlignV;
                },

                "set": function (mL) {
                    if ((mL = mL.toLowerCase()) !== this.style.boundsAlignV) {

                        this.style.boundsAlignV = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'stroke', {

                "get": function () {
                    return this.style.stroke;
                },

                "set": function (mL) {
                    if (mL !== this.style.stroke) {
                        this.style.stroke = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, "strokeThickness", {

                "get": function () {
                    return this.style.strokeThickness;
                },

                "set": function (ms) {
                    if (ms !== this.style.strokeThickness) {

                        this.style.strokeThickness = Number(ms);

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'wordWrap', {

                "get": function () {
                    return this.style.wordWrap;
                },

                "set": function (mL) {
                    if (mL !== this.style.wordWrap) {
                        this.style.wordWrap = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'wordWrapWidth', {

                "get": function () {
                    return this.style.wordWrapWidth;
                },

                "set": function (mL) {
                    if (mL !== this.style.wordWrapWidth) {
                        this.style.wordWrapWidth = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'lineSpacing', {

                "get": function () {
                    return this._lineSpacing;
                },

                "set": function (ms) {
                    if (ms !== this._lineSpacing) {

                        this._lineSpacing = parseFloat(ms);

                        this.dirty = true;
                        if (this.parent) {
                            this.updateTransform();
                        }
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'shadowOffsetX', {

                "get": function () {
                    return this.style.shadowOffsetX;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowOffsetX) {
                        this.style.shadowOffsetX = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'shadowOffsetY', {

                "get": function () {
                    return this.style.shadowOffsetY;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowOffsetY) {
                        this.style.shadowOffsetY = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'shadowColor', {

                "get": function () {
                    return this.style.shadowColor;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowColor) {
                        this.style.shadowColor = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, "shadowBlur", {

                "get": function () {
                    return this.style.shadowBlur;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowBlur) {
                        this.style.shadowBlur = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'shadowStroke', {

                "get": function () {
                    return this.style.shadowStroke;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowStroke) {
                        this.style.shadowStroke = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, 'shadowFill', {

                "get": function () {
                    return this.style.shadowFill;
                },

                "set": function (mL) {
                    if (mL !== this.style.shadowFill) {
                        this.style.shadowFill = mL;

                        this.dirty = true;
                    }
                }
            }), Object.defineProperty($.Text.prototype, "width", {

                "get": function () {
                    return this.dirty && (this.updateText(), this.dirty = false), this.scale.x * (this.texture.frame.width / this.resolution);
                },

                "set": function (x) {

                    this.scale.x = x / this.texture.frame.width;
                    this._width = x;
                }
            }), Object.defineProperty($.Text.prototype, 'height', {

                "get": function () {
                    return this.dirty && (this.updateText(), this.dirty = false), this.scale.y * (this.texture.frame.height / this.resolution);
                },

                "set": function (y) {

                    this.scale.y = y / this.texture.frame.height;
                    this._height = y;
                }
            }), $.Text.fontPropertiesCache = {}, $.Text.fontPropertiesCanvas = document.createElement('canvas'), $.Text.fontPropertiesContext = $.Text.fontPropertiesCanvas.getContext("2d"), $.BitmapText = function (priv, made, contexts, classNames, opt_prefix, details, dataAndEvents) {
                made = made || 0;
                contexts = contexts || 0;
                classNames = classNames || "";
                opt_prefix = opt_prefix || "";
                details = details || 32;
                dataAndEvents = dataAndEvents || 'left';
                PIXI.DisplayObjectContainer.call(this);
                this.type = $.BITMAPTEXT;
                this.physicsType = $.SPRITE;

                this.textWidth = 0;

                this.textHeight = 0;
                this.anchor = new($.Point);
                this._prevAnchor = new($.Point);

                this._glyphs = [];

                this._maxWidth = 0;
                this._text = opt_prefix.toString() || "";
                this._data = priv.cache.getBitmapFont(classNames);

                this._font = classNames;

                this._fontSize = details;
                this._align = dataAndEvents;

                this._tint = 16777215;
                this.updateText();

                this.dirty = false;
                $.Component.Core.init.call(this, priv, made, contexts, "", null);
            }, $.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), $.BitmapText.prototype.constructor = $.BitmapText, $.Component.Core.install.call($.BitmapText.prototype, ["Angle", 'AutoCull', "Bounds", 'Destroy', "FixedToCamera", 'InputEnabled', 'InWorld', 'LifeSpan', 'PhysicsBody', "Reset"]), $.BitmapText.prototype.preUpdatePhysics = $.Component.PhysicsBody.preUpdate,
            $.BitmapText.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.BitmapText.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.BitmapText.prototype.preUpdateCore = $.Component.Core.preUpdate, $.BitmapText.prototype.preUpdate = function () {
                return !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.BitmapText.prototype.postUpdate = function () {
                $.Component.PhysicsBody.postUpdate.call(this);
                $.Component.FixedToCamera.postUpdate.call(this);
                if (this.body) {
                    if (this.body.type === $.Physics.ARCADE) {
                        if (!(this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight)) {
                            this.body.setSize(this.textWidth, this.textHeight);
                        }
                    }
                }
            }, $.BitmapText.prototype.setText = function (el) {
                this.text = el;
            }, $.BitmapText.prototype.scanLine = function (matches, index, params) {

                var start = 0;

                var fx = 0;

                var startIdx = -1;

                var type = 0;

                var k = null;
                var maxPg = this._maxWidth > 0 ? this._maxWidth : null;

                var chars = [];

                var i = 0;
                for (; i < params.length; i++) {

                    var transitionEnd = i === params.length - 1;
                    if (/(?:\r\n|\r|\n)/ ['test'](params.charAt(i))) {
                        return {
                            "width": fx,
                            "text": params.substr(0, i),
                            "end": transitionEnd,
                            "chars": chars
                        };
                    }
                    var j = params.charCodeAt(i);
                    var arr = matches.chars[j];

                    var offset = 0;
                    if (void 0 === arr) {

                        j = 32;
                        arr = matches.chars[j];
                    }
                    var cnt = k && arr.kerning[k] ? arr.kerning[k] : 0;
                    if (/(\s)/ ["test"](params.charAt(i)) && (startIdx = i, type = fx), offset = (cnt + arr.texture.width + arr.xOffset) * index, maxPg && (fx + offset >= maxPg && startIdx > -1)) {
                        return {
                            "width": type || fx,
                            "text": params.substr(0, i - (i - startIdx)),
                            "end": false,
                            "chars": chars
                        };
                    }
                    fx += (arr.xAdvance + cnt) * index;
                    chars.push(start + (arr.xOffset + cnt) * index);
                    start += (arr.xAdvance + cnt) * index;
                    k = j;
                }
                return {
                    "width": fx,
                    "text": params,
                    "end": transitionEnd,
                    "chars": chars
                };
            }, $.BitmapText.prototype.cleanText = function (dataAndEvents, expires) {
                if (void 0 === expires) {

                    expires = "";
                }
                var FONT = this._data.font;
                if (!FONT) {
                    return "";
                }

                var r20 = /\r\n|\n\r|\n|\r/g;
                var res = dataAndEvents.replace(r20, "\n").split("\n");

                var i = 0;
                for (; i < res.length; i++) {

                    var val = "";
                    var o = res[i];

                    var eventName = 0;
                    for (; eventName < o.length; eventName++) {
                        val = FONT.chars[o.charCodeAt(eventName)] ? val.concat(o[eventName]) : val.concat(expires);
                    }
                    res[i] = val;
                }
                return res.join("\n");
            }, $.BitmapText.prototype.updateText = function () {
                var FONT = this._data.font;
                if (FONT) {
                    var r20 = this.text;

                    var base = this._fontSize / FONT.size;

                    var buf = [];

                    var value = 0;

                    this.textWidth = 0;
                    do {

                        (pp = this.scanLine(FONT, base, r20)).y = value;
                        buf.push(pp);
                        if (pp.width > this.textWidth) {
                            this.textWidth = pp.width;
                        }
                        value += FONT.lineHeight * base;
                        r20 = r20.substr(pp.text.length + 1);
                    } while (false === pp.end);

                    this.textHeight = value;

                    var i$ = 0;

                    var capitalized = 0;

                    var x = this.textWidth * this.anchor.x;

                    var y = this.textHeight * this.anchor.y;

                    var i = 0;
                    for (; i < buf.length; i++) {
                        var pp = buf[i];
                        if ("right" === this._align) {

                            capitalized = this.textWidth - pp.width;
                        } else {
                            if ('center' === this._align) {

                                capitalized = (this.textWidth - pp.width) / 2;
                            }
                        }

                        var length = 0;
                        for (; length < pp.text.length; length++) {
                            var idx = pp.text.charCodeAt(length);
                            var next = FONT.chars[idx];
                            if (void 0 === next) {

                                idx = 32;
                                next = FONT.chars[idx];
                            }
                            var tiles = this._glyphs[i$];
                            if (tiles) {
                                tiles.texture = next.texture;
                            } else {
                                (tiles = new(PIXI.Sprite)(next.texture)).name = pp.text[length];
                                this._glyphs.push(tiles);
                            }

                            tiles.position.x = pp.chars[length] + capitalized - x;

                            tiles.position.y = pp.y + next.yOffset * base - y;
                            tiles.scale.set(base);
                            tiles.tint = this.tint;

                            tiles.texture.requiresReTint = true;

                            tiles.cachedTint = 16777215;
                            if (!tiles.parent) {
                                this.addChild(tiles);
                            }
                            i$++;
                        }
                    }

                    i = i$;
                    for (; i < this._glyphs.length; i++) {
                        this.removeChild(this._glyphs[i]);
                    }
                }
            }, $.BitmapText.prototype.purgeGlyphs = function () {
                var value = this._glyphs.length;

                var range = [];

                var rangeEl = 0;
                for (; rangeEl < this._glyphs.length; rangeEl++) {
                    if (this._glyphs[rangeEl].parent !== this) {
                        this._glyphs[rangeEl].destroy();
                    } else {
                        range.push(this._glyphs[rangeEl]);
                    }
                }
                return this._glyphs = [], this._glyphs = range, this.updateText(), value - range.length;
            }, $.BitmapText.prototype.updateTransform = function () {
                if (!(!this.dirty && this.anchor.equals(this._prevAnchor))) {
                    this.updateText();

                    this.dirty = false;
                    this._prevAnchor.copyFrom(this.anchor);
                }
                PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
            }, Object.defineProperty($.BitmapText.prototype, 'align', {

                "get": function () {
                    return this._align;
                },

                "set": function (right) {
                    if (!(right === this._align)) {
                        if (!('left' !== right && ('center' !== right && "right" !== right))) {
                            this._align = right;
                            this.updateText();
                        }
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, 'tint', {

                "get": function () {
                    return this._tint;
                },

                "set": function (mL) {
                    if (mL !== this._tint) {
                        this._tint = mL;
                        this.updateText();
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, 'font', {

                "get": function () {
                    return this._font;
                },

                "set": function (mL) {
                    if (mL !== this._font) {
                        this._font = mL.trim();
                        this._data = this.game.cache.getBitmapFont(this._font);
                        this.updateText();
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, "fontSize", {

                "get": function () {
                    return this._fontSize;
                },

                "set": function (mode) {
                    if ((mode = parseInt(mode, 10)) !== this._fontSize) {
                        if (mode > 0) {

                            this._fontSize = mode;
                            this.updateText();
                        }
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, 'text', {

                "get": function () {
                    return this._text;
                },

                "set": function (mL) {
                    if (mL !== this._text) {
                        this._text = mL.toString() || "";
                        this.updateText();
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, 'maxWidth', {

                "get": function () {
                    return this._maxWidth;
                },

                "set": function (mL) {
                    if (mL !== this._maxWidth) {
                        this._maxWidth = mL;
                        this.updateText();
                    }
                }
            }), Object.defineProperty($.BitmapText.prototype, 'smoothed', {

                "get": function () {
                    return !this._data.base.scaleMode;
                },

                "set": function (mL) {

                    this._data.base.scaleMode = mL ? 0 : 1;
                    this._data.base.dirty();
                }
            }), $.RetroFont = function (priv, slotIndex, maxr, deepDataAndEvents, dataAndEvents, val, ignoreMethodDoesntExist, textAlt, opt_attributes, keepData) {
                if (!priv.cache.checkImageKey(slotIndex)) {
                    return false;
                }
                if (!(void 0 !== val && null !== val)) {

                    val = priv.cache.getImage(slotIndex).width / maxr;
                }
                this.characterWidth = maxr;
                this.characterHeight = deepDataAndEvents;
                this.characterSpacingX = ignoreMethodDoesntExist || 0;
                this.characterSpacingY = textAlt || 0;

                this.characterPerRow = val;
                this.offsetX = opt_attributes || 0;
                this.offsetY = keepData || 0;
                this.align = 'left';

                this.multiLine = false;

                this.autoUpperCase = true;

                this.customSpacingX = 0;

                this.customSpacingY = 0;

                this.fixedWidth = 0;
                this.fontSet = priv.cache.getImage(slotIndex);

                this._text = "";

                this.grabData = [];
                this.frameData = new $.FrameData;
                var offsetX = this.offsetX;
                var offsetY = this.offsetY;

                var _0x4714be = 0;

                var r20 = 0;
                for (; r20 < dataAndEvents.length; r20++) {
                    var _0x31bc4c = this.frameData.addFrame(new($.Frame)(r20, offsetX, offsetY, this.characterWidth, this.characterHeight));
                    this.grabData[dataAndEvents.charCodeAt(r20)] = _0x31bc4c.index;
                    if (++_0x4714be === this.characterPerRow) {

                        _0x4714be = 0;
                        offsetX = this.offsetX;
                        offsetY += this.characterHeight + this.characterSpacingY;
                    } else {
                        offsetX += this.characterWidth + this.characterSpacingX;
                    }
                }
                priv.cache.updateFrameData(slotIndex, this.frameData);
                this.stamp = new($.Image)(priv, 0, 0, slotIndex, 0);
                $.RenderTexture.call(this, priv, 100, 100, "", $.scaleModes.NEAREST);
                this.type = $.RETROFONT;
            }, $.RetroFont.prototype = Object.create($.RenderTexture.prototype), $.RetroFont.prototype.constructor = $.RetroFont, $.RetroFont.ALIGN_LEFT = 'left', $.RetroFont.ALIGN_RIGHT = "right", $.RetroFont.ALIGN_CENTER = 'center', $.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", $.RetroFont.TEXT_SET2 =
            " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", $.RetroFont.TEXT_SET3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', $.RetroFont.TEXT_SET4 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', $.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", $.RetroFont.TEXT_SET6 = `ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.' `, $.RetroFont.TEXT_SET7 = `AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39`, $.RetroFont.TEXT_SET8 = '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', $.RetroFont.TEXT_SET9 = `ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!`, $.RetroFont.TEXT_SET10 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            $.RetroFont.TEXT_SET11 = `ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789`, $.RetroFont.prototype.setFixedWidth = function (dataAndEvents, align) {
                if (void 0 === align) {
                    align = 'left';
                }
                this.fixedWidth = dataAndEvents;

                this.align = align;
            }, $.RetroFont.prototype.setText = function (result, dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents, align, textAlt) {
                this.multiLine = dataAndEvents || false;
                this.customSpacingX = ignoreMethodDoesntExist || 0;
                this.customSpacingY = deepDataAndEvents || 0;
                this.align = align || "left";

                this.autoUpperCase = !textAlt;
                if (result.length > 0) {

                    this.text = result;
                }
            }, $.RetroFont.prototype.buildRetroFontText = function () {

                var r20 = 0;

                var restoreScript = 0;
                if (this.clear(), this.multiLine) {
                    var res = this._text.split("\n");
                    if (this.fixedWidth > 0) {
                        this.resize(this.fixedWidth, res.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
                    } else {
                        this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), res.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, true);
                    }

                    var i = 0;
                    for (; i < res.length; i++) {

                        r20 = 0;
                        if (this.align === $.RetroFont.ALIGN_RIGHT) {

                            r20 = this.width - res[i].length * (this.characterWidth + this.customSpacingX);
                        } else {
                            if (this.align === $.RetroFont.ALIGN_CENTER) {

                                r20 = this.width / 2 - res[i].length * (this.characterWidth + this.customSpacingX) / 2;
                                r20 += this.customSpacingX / 2;
                            }
                        }
                        if (r20 < 0) {

                            r20 = 0;
                        }
                        this.pasteLine(res[i], r20, restoreScript, this.customSpacingX);
                        restoreScript += this.characterHeight + this.customSpacingY;
                    }
                } else {
                    if (this.fixedWidth > 0) {
                        this.resize(this.fixedWidth, this.characterHeight, true);
                    } else {
                        this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true);
                    }

                    r20 = 0;
                    if (this.align === $.RetroFont.ALIGN_RIGHT) {

                        r20 = this.width - this._text.length * (this.characterWidth + this.customSpacingX);
                    } else {
                        if (this.align === $.RetroFont.ALIGN_CENTER) {

                            r20 = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2;
                            r20 += this.customSpacingX / 2;
                        }
                    }
                    if (r20 < 0) {

                        r20 = 0;
                    }
                    this.pasteLine(this._text, r20, 0, this.customSpacingX);
                }

                this.requiresReTint = true;
            }, $.RetroFont.prototype.pasteLine = function (collection, deepDataAndEvents, opt_obj2, dataAndEvents) {

                var resp = 0;
                for (; resp < collection.length; resp++) {
                    if (" " === collection.charAt(resp)) {
                        deepDataAndEvents += this.characterWidth + dataAndEvents;
                    } else {
                        if (this.grabData[collection.charCodeAt(resp)] >= 0 && (this.stamp.frame = this.grabData[collection.charCodeAt(resp)], this.renderXY(this.stamp, deepDataAndEvents, opt_obj2, false), (deepDataAndEvents += this.characterWidth + dataAndEvents) > this.width)) {
                            break;
                        }
                    }
                }
            }, $.RetroFont.prototype.getLongestLine = function () {

                var _0x2a977a = 0;
                if (this._text.length > 0) {
                    var h = this._text.split("\n");

                    var k = 0;
                    for (; k < h.length; k++) {
                        if (h[k].length > _0x2a977a) {
                            _0x2a977a = h[k].length;
                        }
                    }
                }
                return _0x2a977a;
            }, $.RetroFont.prototype.removeUnsupportedCharacters = function (dataAndEvents) {

                var events = "";

                var unlock = 0;
                for (; unlock < this._text.length; unlock++) {
                    var event = this._text[unlock];
                    var frontName = event.charCodeAt(0);
                    if (this.grabData[frontName] >= 0 || !dataAndEvents && "\n" === event) {
                        events = events.concat(event);
                    }
                }
                return events;
            }, $.RetroFont.prototype.updateOffset = function (dataAndEvents, numPoints) {
                if (this.offsetX !== dataAndEvents || this.offsetY !== numPoints) {

                    var suf = dataAndEvents - this.offsetX;

                    var j = numPoints - this.offsetY;
                    var data = this.game.cache.getFrameData(this.stamp.key).getFrames();
                    var i = data.length;
                    for (; i--;) {
                        data[i].x += suf;
                        data[i].y += j;
                    }
                    this.buildRetroFontText();
                }
            }, Object.defineProperty($.RetroFont.prototype, 'text', {

                "get": function () {
                    return this._text;
                },

                "set": function (func) {
                    var wrapper;
                    if ((wrapper = this.autoUpperCase ? func.toUpperCase() : func) !== this._text) {
                        this._text = wrapper;
                        this.removeUnsupportedCharacters(this.multiLine);
                        this.buildRetroFontText();
                    }
                }
            }), Object.defineProperty($.RetroFont.prototype, "smoothed", {

                "get": function () {
                    return this.stamp.smoothed;
                },

                "set": function (mL) {
                    this.stamp.smoothed = mL;
                    this.buildRetroFontText();
                }
            }), $.Rope = function (deepDataAndEvents, made, contexts, toClass, opt_message, dataAndEvents) {
                this.points = dataAndEvents || [];

                this._hasUpdateAnimation = false;

                this._updateAnimationCallback = null;
                made = made || 0;
                contexts = contexts || 0;
                toClass = toClass || null;
                opt_message = opt_message || null;
                this.type = $.ROPE;
                PIXI.DisplayObjectContainer.call(this);
                this.texture = $.Cache.DEFAULT;

                this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]);

                this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);

                this.colors = new Float32Array([1, 1, 1, 1]);

                this.indices = new Uint16Array([0, 1, 2, 3]);
                if (dataAndEvents) {

                    this.vertices = new Float32Array(4 * dataAndEvents.length);

                    this.uvs = new Float32Array(4 * dataAndEvents.length);

                    this.colors = new Float32Array(2 * dataAndEvents.length);

                    this.indices = new Uint16Array(2 * dataAndEvents.length);
                }

                this.dirty = true;

                this.canvasPadding = 0;
                this.drawMode = $.Rope.TRIANGLE_STRIP;
                $.Component.Core.init.call(this, deepDataAndEvents, made, contexts, toClass, opt_message);
                this.refresh();
            }, $.Rope.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), $.Rope.prototype.constructor = $.Rope, $.Component.Core.install.call($.Rope.prototype, ['Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', "Crop", 'Delta', 'Destroy', 'FixedToCamera', 'InWorld', 'LifeSpan', 'LoadTexture', 'Overlap', "PhysicsBody",
                'Reset', 'ScaleMinMax', 'Smoothed'
            ]), $.Rope.prototype.preUpdatePhysics = $.Component.PhysicsBody.preUpdate, $.Rope.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.Rope.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.Rope.prototype.preUpdateCore = $.Component.Core.preUpdate, $.Rope.TRIANGLE_STRIP = 0, $.Rope.TRIANGLES =
            1, $.Rope.prototype.preUpdate = function () {
                return !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.Rope.prototype.update = function () {
                if (this._hasUpdateAnimation) {
                    this.updateAnimation.call(this);
                }
            }, $.Rope.prototype.reset = function (deepDataAndEvents, opt_obj2) {
                return $.Component.Reset.prototype.reset.call(this, deepDataAndEvents, opt_obj2), this;
            }, $.Rope.prototype.refresh = function () {
                var components = this.points;
                if (!(components.length < 1)) {
                    var mat = this.uvs;
                    var a = this.indices;
                    var args = this.colors;
                    this.count -= 0.2;

                    mat[0] = 0;

                    mat[1] = 0;

                    mat[2] = 0;

                    mat[3] = 1;

                    args[0] = 1;

                    args[1] = 1;

                    a[0] = 0;

                    a[1] = 1;
                    var i;
                    var c;
                    var length = components.length;

                    var index = 1;
                    for (; index < length; index++) {

                        c = index / (length - 1);

                        mat[i = 4 * index] = c;

                        mat[i + 1] = 0;

                        mat[i + 2] = c;

                        mat[i + 3] = 1;

                        args[i = 2 * index] = 1;

                        args[i + 1] = 1;

                        a[i = 2 * index] = i;

                        a[i + 1] = i + 1;
                    }
                }
            }, $.Rope.prototype.updateTransform = function () {
                var points = this.points;
                if (!(points.length < 1)) {
                    var p2;
                    var p1 = points[0];
                    var neXY = {
                        "x": 0,
                        "y": 0
                    };
                    this.count -= 0.2;
                    var swXY;
                    var row;
                    var _0x2fb4ce;
                    var x;
                    var mat = this.vertices;
                    var end = points.length;

                    var i = 0;
                    for (; i < end; i++) {
                        swXY = points[i];

                        row = 4 * i;
                        p2 = i < points.length - 1 ? points[i + 1] : swXY;

                        neXY.y = -(p2.x - p1.x);

                        neXY.x = p2.y - p1.y;
                        _0x2fb4ce = Math.sqrt(neXY.x * neXY.x + neXY.y * neXY.y);

                        x = this.texture.height / 2;
                        neXY.x /= _0x2fb4ce;
                        neXY.y /= _0x2fb4ce;
                        neXY.x *= x;
                        neXY.y *= x;
                        mat[row] = swXY.x + neXY.x;
                        mat[row + 1] = swXY.y + neXY.y;

                        mat[row + 2] = swXY.x - neXY.x;

                        mat[row + 3] = swXY.y - neXY.y;
                        p1 = swXY;
                    }
                    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);
                }
            }, $.Rope.prototype.setTexture = function (dataAndEvents) {
                this.texture = dataAndEvents;
            }, $.Rope.prototype._renderWebGL = function (deepDataAndEvents) {
                if (!!this.visible) {
                    if (!(this.alpha <= 0)) {
                        deepDataAndEvents.spriteBatch.stop();
                        if (!this._vertexBuffer) {
                            this._initWebGL(deepDataAndEvents);
                        }
                        deepDataAndEvents.shaderManager.setShader(deepDataAndEvents.shaderManager.stripShader);
                        this._renderStrip(deepDataAndEvents);
                        deepDataAndEvents.spriteBatch.start();
                    }
                }
            }, $.Rope.prototype._initWebGL = function (tuple) {
                var action = tuple.gl;
                this._vertexBuffer = action.createBuffer();
                this._indexBuffer = action.createBuffer();
                this._uvBuffer = action.createBuffer();
                this._colorBuffer = action.createBuffer();
                action.bindBuffer(action.ARRAY_BUFFER, this._vertexBuffer);
                action.bufferData(action.ARRAY_BUFFER, this.vertices, action.DYNAMIC_DRAW);
                action.bindBuffer(action.ARRAY_BUFFER, this._uvBuffer);
                action.bufferData(action.ARRAY_BUFFER, this.uvs, action.STATIC_DRAW);
                action.bindBuffer(action.ARRAY_BUFFER, this._colorBuffer);
                action.bufferData(action.ARRAY_BUFFER, this.colors, action.STATIC_DRAW);
                action.bindBuffer(action.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                action.bufferData(action.ELEMENT_ARRAY_BUFFER, this.indices, action.STATIC_DRAW);
            }, $.Rope.prototype._renderStrip = function (data) {
                var index = data.gl;
                var urls = data.projection;
                var text = data.offset;
                var translationMatrix = data.shaderManager.stripShader;
                var r20 = this.drawMode === $.Rope.TRIANGLE_STRIP ? index.TRIANGLE_STRIP : index.TRIANGLES;
                data.blendModeManager.setBlendMode(this.blendMode);
                index.uniformMatrix3fv(translationMatrix.translationMatrix, false, this.worldTransform.toArray(true));
                index.uniform2f(translationMatrix.projectionVector, urls.x, -urls.y);
                index.uniform2f(translationMatrix.offsetVector, -text.x, -text.y);
                index.uniform1f(translationMatrix.alpha, this.worldAlpha);
                if (this.dirty) {

                    this.dirty = false;
                    index.bindBuffer(index.ARRAY_BUFFER, this._vertexBuffer);
                    index.bufferData(index.ARRAY_BUFFER, this.vertices, index.STATIC_DRAW);
                    index.vertexAttribPointer(translationMatrix.aVertexPosition, 2, index.FLOAT, false, 0, 0);
                    index.bindBuffer(index.ARRAY_BUFFER, this._uvBuffer);
                    index.bufferData(index.ARRAY_BUFFER, this.uvs, index.STATIC_DRAW);
                    index.vertexAttribPointer(translationMatrix.aTextureCoord, 2, index.FLOAT, false, 0, 0);
                    index.activeTexture(index.TEXTURE0);
                    if (this.texture.baseTexture._dirty[index.id]) {
                        data.renderer.updateTexture(this.texture.baseTexture);
                    } else {
                        index.bindTexture(index.TEXTURE_2D, this.texture.baseTexture._glTextures[index.id]);
                    }
                    index.bindBuffer(index.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                    index.bufferData(index.ELEMENT_ARRAY_BUFFER, this.indices, index.STATIC_DRAW);
                } else {
                    index.bindBuffer(index.ARRAY_BUFFER, this._vertexBuffer);
                    index.bufferSubData(index.ARRAY_BUFFER, 0, this.vertices);
                    index.vertexAttribPointer(translationMatrix.aVertexPosition, 2, index.FLOAT, false, 0, 0);
                    index.bindBuffer(index.ARRAY_BUFFER, this._uvBuffer);
                    index.vertexAttribPointer(translationMatrix.aTextureCoord, 2, index.FLOAT, false, 0, 0);
                    index.activeTexture(index.TEXTURE0);
                    if (this.texture.baseTexture._dirty[index.id]) {
                        data.renderer.updateTexture(this.texture.baseTexture);
                    } else {
                        index.bindTexture(index.TEXTURE_2D, this.texture.baseTexture._glTextures[index.id]);
                    }
                    index.bindBuffer(index.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
                }
                index.drawElements(r20, this.indices.length, index.UNSIGNED_SHORT, 0);
            }, $.Rope.prototype._renderCanvas = function (fdtbl) {
                var formatters = fdtbl.context;
                var data = this.worldTransform;
                var r20 = data.tx * fdtbl.resolution + fdtbl.shakeX;
                var restoreScript = data.ty * fdtbl.resolution + fdtbl.shakeY;
                if (fdtbl.roundPixels) {
                    formatters.setTransform(data.a, data.b, data.c, data.d, 0 | r20, 0 | restoreScript);
                } else {
                    formatters.setTransform(data.a, data.b, data.c, data.d, r20, restoreScript);
                }
                if (this.drawMode === $.Rope.TRIANGLE_STRIP) {
                    this._renderCanvasTriangleStrip(formatters);
                } else {
                    this._renderCanvasTriangles(formatters);
                }
            }, $.Rope.prototype._renderCanvasTriangleStrip = function (deepDataAndEvents) {
                var vertices = this.vertices;
                var r20 = this.uvs;

                var length = vertices.length / 2;
                this.count++;

                var index = 0;
                for (; index < length - 2; index++) {

                    var theta = 2 * index;
                    this._renderCanvasDrawTriangle(deepDataAndEvents, vertices, r20, theta, theta + 2, theta + 4);
                }
            }, $.Rope.prototype._renderCanvasTriangles = function (deepDataAndEvents) {
                var r20 = this.vertices;
                var restoreScript = this.uvs;
                var spec = this.indices;
                var padLength = spec.length;
                this.count++;

                var i = 0;
                for (; i < padLength; i += 3) {

                    var rreturn = 2 * spec[i];

                    var udataCur = 2 * spec[i + 1];

                    var pdataOld = 2 * spec[i + 2];
                    this._renderCanvasDrawTriangle(deepDataAndEvents, r20, restoreScript, rreturn, udataCur, pdataOld);
                }
            }, $.Rope.prototype._renderCanvasDrawTriangle = function (dataAndEvents, mat, data, offset, i, row) {
                var r20 = this.texture.baseTexture.source;
                var mul = this.texture.width;
                var tmpsin = this.texture.height;
                var m20 = mat[offset];
                var b5 = mat[i];
                var r11 = mat[row];
                var m10 = mat[offset + 1];
                var m21 = mat[i + 1];
                var r10 = mat[row + 1];

                var m00 = data[offset] * mul;

                var m01 = data[i] * mul;

                var r12 = data[row] * mul;

                var m11 = data[offset + 1] * tmpsin;

                var m31 = data[i + 1] * tmpsin;

                var c = data[row + 1] * tmpsin;
                if (this.canvasPadding > 0) {

                    var Dimension = this.canvasPadding / this.worldTransform.a;

                    var arr = this.canvasPadding / this.worldTransform.d;

                    var centerx = (m20 + b5 + r11) / 3;

                    var centery = (m10 + m21 + r10) / 3;

                    var z0 = m20 - centerx;

                    var z1 = m10 - centery;
                    var inner = Math.sqrt(z0 * z0 + z1 * z1);

                    m20 = centerx + z0 / inner * (inner + Dimension);

                    m10 = centery + z1 / inner * (inner + arr);

                    z1 = m21 - centery;

                    b5 = centerx + (z0 = b5 - centerx) / (inner = Math.sqrt(z0 * z0 + z1 * z1)) * (inner + Dimension);

                    m21 = centery + z1 / inner * (inner + arr);

                    z1 = r10 - centery;

                    r11 = centerx + (z0 = r11 - centerx) / (inner = Math.sqrt(z0 * z0 + z1 * z1)) * (inner + Dimension);

                    r10 = centery + z1 / inner * (inner + arr);
                }
                dataAndEvents.save();
                dataAndEvents.beginPath();
                dataAndEvents.moveTo(m20, m10);
                dataAndEvents.lineTo(b5, m21);
                dataAndEvents.lineTo(r11, r10);
                dataAndEvents.closePath();
                dataAndEvents.clip();

                var d = m00 * m31 + m11 * r12 + m01 * c - m31 * r12 - m11 * m01 - m00 * c;

                var z = m20 * m31 + m11 * r11 + b5 * c - m31 * r11 - m11 * b5 - m20 * c;

                var ms = m00 * b5 + m20 * r12 + m01 * r11 - b5 * r12 - m20 * m01 - m00 * r11;

                var t = m00 * m31 * r11 + m11 * b5 * r12 + m20 * m01 * c - m20 * m31 * r12 - m11 * m01 * r11 - m00 * b5 * c;

                var n2 = m10 * m31 + m11 * r10 + m21 * c - m31 * r10 - m11 * m21 - m10 * c;

                var n1 = m00 * m21 + m10 * r12 + m01 * r10 - m21 * r12 - m10 * m01 - m00 * r10;

                var value = m00 * m31 * r10 + m11 * m21 * r12 + m10 * m01 * c - m10 * m31 * r12 - m11 * m01 * r10 - m00 * m21 * c;
                dataAndEvents.transform(z / d, n2 / d, ms / d, n1 / d, t / d, value / d);
                dataAndEvents.drawImage(r20, 0, 0);
                dataAndEvents.restore();
            }, $.Rope.prototype.renderStripFlat = function (listener) {
                var collection = this.context;
                var args = listener.vertices;

                var length = args.length / 2;
                this.count++;
                collection.beginPath();

                var i = 1;
                for (; i < length - 2; i++) {

                    var idx = 2 * i;
                    var next = args[idx];
                    var resp = args[idx + 2];
                    var pageX = args[idx + 4];
                    var _buttonLabels = args[idx + 1];
                    var options = args[idx + 3];
                    var pageY = args[idx + 5];
                    collection.moveTo(next, _buttonLabels);
                    collection.lineTo(resp, options);
                    collection.lineTo(pageX, pageY);
                }
                collection.fillStyle = '#FF0000';
                collection.fill();
                collection.closePath();
            }, $.Rope.prototype.getBounds = function (dataAndEvents) {
                var data = dataAndEvents || this.worldTransform;
                var qw = data.a;
                var c = data.b;
                var qz = data.c;
                var r = data.d;
                var _ = data.tx;
                var opcode = data.ty;

                var paramMax = -1 / 0;

                var maxw = -1 / 0;

                var v = 1 / 0;

                var h = 1 / 0;
                var symbol = this.vertices;

                var i = 0;
                for (; i < symbol.length; i += 2) {
                    var y = symbol[i];
                    var x = symbol[i + 1];
                    var p = qw * y + qz * x + _;
                    var w = r * x + c * y + opcode;
                    v = p < v ? p : v;
                    h = w < h ? w : h;
                    paramMax = p > paramMax ? p : paramMax;
                    maxw = w > maxw ? w : maxw;
                }
                if (v === -1 / 0 || maxw === 1 / 0) {
                    return PIXI.EmptyRectangle;
                }
                var verts = this._bounds;
                return verts.x = v, verts.width = paramMax - v, verts.y = h, verts.height = maxw - h, this._currentBounds = verts, verts;
            }, Object.defineProperty($.Rope.prototype, 'updateAnimation', {

                "get": function () {
                    return this._updateAnimation;
                },

                "set": function (mL) {
                    if (mL && 'function' == typeof mL) {

                        this._hasUpdateAnimation = true;

                        this._updateAnimation = mL;
                    } else {

                        this._hasUpdateAnimation = false;

                        this._updateAnimation = null;
                    }
                }
            }), Object.defineProperty($.Rope.prototype, 'segments', {

                "get": function () {
                    var x;
                    var context;
                    var dest;
                    var camelKey;
                    var pdataOld;
                    var data;
                    var pdataCur;
                    var resp;

                    var collection = [];

                    var length = 0;
                    for (; length < this.points.length; length++) {

                        x = 4 * length;

                        context = this.vertices[x] * this.scale.x;

                        dest = this.vertices[x + 1] * this.scale.y;

                        camelKey = this.vertices[x + 4] * this.scale.x;

                        pdataOld = this.vertices[x + 3] * this.scale.y;
                        data = $.Math.difference(context, camelKey);
                        pdataCur = $.Math.difference(dest, pdataOld);
                        context += this.world.x;
                        dest += this.world.y;
                        resp = new $.Rectangle(context, dest, data, pdataCur);
                        collection.push(resp);
                    }
                    return collection;
                }
            }), $.TileSprite = function (deepDataAndEvents, made, contexts, toClass, opt_message, details, thisp) {
                made = made || 0;
                contexts = contexts || 0;
                toClass = toClass || 256;
                opt_message = opt_message || 256;
                details = details || null;
                thisp = thisp || null;
                PIXI.Sprite.call(this, new(PIXI.Texture)($.Cache.DEFAULT.baseTexture), toClass, opt_message);
                this.type = $.TILESPRITE;
                this.physicsType = $.SPRITE;
                this._scroll = new $.Point;
                this.tileScale = new($.Point)(1, 1);
                this.tileScaleOffset = new($.Point)(1, 1);
                this.tilePosition = new($.Point);

                this.textureDebug = false;

                this.canvasBuffer = null;

                this.tilingTexture = null;

                this.tilePattern = null;

                this.refreshTexture = true;

                this.frameWidth = 0;

                this.frameHeight = 0;

                this._width = toClass;

                this._height = opt_message;
                $.Component.Core.init.call(this, deepDataAndEvents, made, contexts, details, thisp);
            }, $.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), $.TileSprite.prototype.constructor = $.TileSprite, $.Component.Core.install.call($.TileSprite.prototype, ['Angle', "Animation", "AutoCull", 'Bounds', 'BringToTop', "Destroy", "FixedToCamera", 'Health', 'InCamera', 'InputEnabled', "InWorld", 'LifeSpan', 'LoadTexture', 'Overlap',
                "PhysicsBody", 'Reset', 'Smoothed'
            ]), $.TileSprite.prototype.preUpdatePhysics = $.Component.PhysicsBody.preUpdate, $.TileSprite.prototype.preUpdateLifeSpan = $.Component.LifeSpan.preUpdate, $.TileSprite.prototype.preUpdateInWorld = $.Component.InWorld.preUpdate, $.TileSprite.prototype.preUpdateCore = $.Component.Core.preUpdate, $.TileSprite.prototype.preUpdate =
            function () {
                return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore();
            }, $.TileSprite.prototype.autoScroll = function (deepDataAndEvents, opt_obj2) {
                return this._scroll.set(deepDataAndEvents, opt_obj2), this;
            }, $.TileSprite.prototype.stopScroll = function () {
                return this._scroll.set(0, 0), this;
            }, $.TileSprite.prototype.destroy = function (deepDataAndEvents) {
                $.Component.Destroy.prototype.destroy.call(this, deepDataAndEvents);
                PIXI.Sprite.prototype.destroy.call(this);
                if (this.canvasBuffer) {
                    this.canvasBuffer.destroy();

                    this.canvasBuffer = null;
                }

                this.tileScale = null;

                this.tileScaleOffset = null;

                this.tilePosition = null;
                if (this.tilingTexture) {
                    this.tilingTexture.destroy(true);

                    this.tilingTexture = null;
                }
            }, $.TileSprite.prototype.reset = function (deepDataAndEvents, opt_obj2) {
                return $.Component.Reset.prototype.reset.call(this, deepDataAndEvents, opt_obj2), this.tilePosition.x = 0, this.tilePosition.y = 0, this;
            }, $.TileSprite.prototype.setTexture = function (dataAndEvents) {
                return this.texture !== dataAndEvents && (this.texture = dataAndEvents, this.refreshTexture = true, this.cachedTint = 16777215), this;
            }, $.TileSprite.prototype._renderWebGL = function (controller) {
                if (this.visible && (this.renderable && 0 !== this.alpha)) {
                    if (this._mask && (controller.spriteBatch.stop(), controller.maskManager.pushMask(this.mask, controller), controller.spriteBatch.start()), this._filters && (controller.spriteBatch.flush(), controller.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                        if (this.generateTilingTexture(true, controller), !this.tilingTexture) {
                            return;
                        }
                        if (this.tilingTexture.needsUpdate) {
                            this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex;
                            controller.renderer.updateTexture(this.tilingTexture.baseTexture);

                            this.tilingTexture.needsUpdate = false;
                        }
                    }
                    controller.spriteBatch.renderTilingSprite(this);

                    var unlock = 0;
                    for (; unlock < this.children.length; unlock++) {
                        this.children[unlock]._renderWebGL(controller);
                    }

                    var _0x3a467c = false;
                    if (this._filters) {

                        _0x3a467c = true;
                        controller.spriteBatch.stop();
                        controller.filterManager.popFilter();
                    }
                    if (this._mask) {
                        if (!_0x3a467c) {
                            controller.spriteBatch.stop();
                        }
                        controller.maskManager.popMask(this._mask, controller);
                    }
                    if (_0x3a467c) {
                        controller.spriteBatch.start();
                    }
                }
            }, $.TileSprite.prototype._renderCanvas = function (data) {
                if (this.visible && (this.renderable && 0 !== this.alpha)) {
                    var col = data.context;
                    if (this._mask) {
                        data.maskManager.pushMask(this._mask, data);
                    }
                    col.globalAlpha = this.worldAlpha;
                    var m = this.worldTransform;
                    var c = data.resolution;
                    var r20 = m.tx * c + data.shakeX;
                    var restoreScript = m.ty * c + data.shakeY;
                    if (col.setTransform(m.a * c, m.b * c, m.c * c, m.d * c, r20, restoreScript), 16777215 === this.tint || (!this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = false, this.refreshTexture = true)), this.refreshTexture) {
                        if (this.generateTilingTexture(false, data), !this.tilingTexture) {
                            return;
                        }
                        this.tilePattern = col.createPattern(this.tilingTexture.baseTexture.source, 'repeat');
                    }
                    var element = data.currentBlendMode;
                    if (this.blendMode !== data.currentBlendMode) {
                        data.currentBlendMode = this.blendMode;
                        col.globalCompositeOperation = PIXI.blendModesCanvas[data.currentBlendMode];
                    }
                    var urls = this.tilePosition;
                    var row = this.tileScale;
                    urls.x %= this.tilingTexture.baseTexture.width;
                    urls.y %= this.tilingTexture.baseTexture.height;
                    col.scale(row.x, row.y);
                    col.translate(urls.x + this.anchor.x * -this._width, urls.y + this.anchor.y * -this._height);
                    col.fillStyle = this.tilePattern;

                    r20 = -urls.x;

                    restoreScript = -urls.y;

                    var rreturn = this._width / row.x;

                    var udataCur = this._height / row.y;
                    if (data.roundPixels) {
                        r20 |= 0;
                        restoreScript |= 0;
                        rreturn |= 0;
                        udataCur |= 0;
                    }
                    col.fillRect(r20, restoreScript, rreturn, udataCur);
                    col.scale(1 / row.x, 1 / row.y);
                    col.translate(-urls.x + this.anchor.x * this._width, -urls.y + this.anchor.y * this._height);
                    if (this._mask) {
                        data.maskManager.popMask(data);
                    }

                    var i = 0;
                    for (; i < this.children.length; i++) {
                        this.children[i]._renderCanvas(data);
                    }
                    if (element !== this.blendMode) {
                        data.currentBlendMode = element;
                        col.globalCompositeOperation = PIXI.blendModesCanvas[element];
                    }
                }
            }, $.TileSprite.prototype.onTextureUpdate = function () {}, $.TileSprite.prototype.generateTilingTexture = function (dataAndEvents) {
                if (this.texture.baseTexture.hasLoaded) {
                    var params = this.texture;
                    var param = params.frame;
                    var element = this._frame.sourceSizeW || this._frame.width;
                    var fx = this._frame.sourceSizeH || this._frame.height;

                    var r20 = 0;

                    var restoreScript = 0;
                    if (this._frame.trimmed) {
                        r20 = this._frame.spriteSourceSizeX;
                        restoreScript = this._frame.spriteSourceSizeY;
                    }
                    if (dataAndEvents) {
                        element = $.Math.getNextPowerOfTwo(element);
                        fx = $.Math.getNextPowerOfTwo(fx);
                    }
                    if (this.canvasBuffer) {
                        this.canvasBuffer.resize(element, fx);
                        this.tilingTexture.baseTexture.width = element;
                        this.tilingTexture.baseTexture.height = fx;

                        this.tilingTexture.needsUpdate = true;
                    } else {
                        this.canvasBuffer = new PIXI.CanvasBuffer(element, fx);
                        this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas);

                        this.tilingTexture.isTiling = true;

                        this.tilingTexture.needsUpdate = true;
                    }
                    if (this.textureDebug) {
                        this.canvasBuffer.context.strokeStyle = '#00ff00';
                        this.canvasBuffer.context.strokeRect(0, 0, element, fx);
                    }
                    var openElement = params.crop.width;
                    var type = params.crop.height;
                    if (!(openElement === element && type === fx)) {
                        openElement = element;
                        type = fx;
                    }
                    var rreturn = this.tintedTexture ? this.tintedTexture : params.baseTexture.source;
                    this.canvasBuffer.context.drawImage(rreturn, params.crop.x, params.crop.y, params.crop.width, params.crop.height, r20, restoreScript, openElement, type);

                    this.tileScaleOffset.x = param.width / element;

                    this.tileScaleOffset.y = param.height / fx;

                    this.refreshTexture = false;

                    this.tilingTexture.baseTexture._powerOf2 = true;
                }
            }, $.TileSprite.prototype.getBounds = function () {
                var cosPhi = this._width;
                var d = this._height;

                var s = cosPhi * (1 - this.anchor.x);

                var x = cosPhi * -this.anchor.x;

                var y = d * (1 - this.anchor.y);

                var c = d * -this.anchor.y;
                var a = this.worldTransform;
                var a00 = a.a;
                var b = a.b;
                var a10 = a.c;
                var a13 = a.d;
                var dx = a.tx;
                var z = a.ty;
                var x4 = a00 * x + a10 * c + dx;
                var w = a13 * c + b * x + z;
                var x3 = a00 * s + a10 * c + dx;
                var idx = a13 * c + b * s + z;
                var duration = a00 * s + a10 * y + dx;
                var key = a13 * y + b * s + z;
                var p = a00 * x + a10 * y + dx;
                var height = a13 * y + b * x + z;

                var right = -1 / 0;

                var width = -1 / 0;

                var left = 1 / 0;

                var h = 1 / 0;
                left = p < (left = duration < (left = x3 < (left = x4 < left ? x4 : left) ? x3 : left) ? duration : left) ? p : left;
                h = height < (h = key < (h = idx < (h = w < h ? w : h) ? idx : h) ? key : h) ? height : h;
                right = p > (right = duration > (right = x3 > (right = x4 > right ? x4 : right) ? x3 : right) ? duration : right) ? p : right;
                width = height > (width = key > (width = idx > (width = w > width ? w : width) ? idx : width) ? key : width) ? height : width;
                var el = this._bounds;
                return el.x = left, el.width = right - left, el.y = h, el.height = width - h, this._currentBounds = el, el;
            }, Object.defineProperty($.TileSprite.prototype, 'width', {

                "get": function () {
                    return this._width;
                },

                "set": function (mL) {
                    this._width = mL;
                }
            }), Object.defineProperty($.TileSprite.prototype, "height", {

                "get": function () {
                    return this._height;
                },

                "set": function (mL) {
                    this._height = mL;
                }
            }), $.CanvasPool = {

                "create": function (widget, key, value) {
                    var res;
                    var unlock = $.CanvasPool.getFirst();
                    if (-1 === unlock) {
                        var dep = {
                            "parent": widget,
                            "canvas": document.createElement('canvas')
                        };
                        $.CanvasPool.pool.push(dep);
                        res = dep.canvas;
                    } else {

                        $.CanvasPool.pool[unlock].parent = widget;
                        res = $.CanvasPool.pool[unlock].canvas;
                    }
                    return void 0 !== key && (res.width = key, res.height = value), res;
                },

                "getFirst": function () {
                    var sorted = $.CanvasPool.pool;

                    var key = 0;
                    for (; key < sorted.length; key++) {
                        if (!sorted[key].parent) {
                            return key;
                        }
                    }
                    return -1;
                },

                "remove": function (keepData) {
                    var h = $.CanvasPool.pool;

                    var k = 0;
                    for (; k < h.length; k++) {
                        if (h[k].parent === keepData) {

                            h[k].parent = null;

                            h[k].canvas.width = 1;

                            h[k].canvas.height = 1;
                        }
                    }
                },

                "removeByCanvas": function (dataAndEvents) {
                    var stack = $.CanvasPool.pool;

                    var i = 0;
                    for (; i < stack.length; i++) {
                        if (stack[i].canvas === dataAndEvents) {

                            stack[i].parent = null;

                            stack[i].canvas.width = 1;

                            stack[i].canvas.height = 1;
                        }
                    }
                },

                "getTotal": function () {
                    var sorted = $.CanvasPool.pool;

                    var total = 0;

                    var key = 0;
                    for (; key < sorted.length; key++) {
                        if (sorted[key].parent) {
                            total++;
                        }
                    }
                    return total;
                },

                "getFree": function () {
                    var h = $.CanvasPool.pool;

                    var getFree = 0;

                    var k = 0;
                    for (; k < h.length; k++) {
                        if (!h[k].parent) {
                            getFree++;
                        }
                    }
                    return getFree;
                },

                "log": function () {
                    console.log('CanvasPool: %s used, %s free, %s total', this.getTotal(), this.getFree(), this.pool.length);
                }
            }, $.CanvasPool.pool = [], Object.defineProperty($.CanvasPool, "length", {

                "get": function () {
                    return this.pool.length;
                }
            }), $.Device = function () {

                this.deviceReadyAt = 0;

                this.initialized = false;

                this.desktop = false;

                this.iOS = false;

                this.iOSVersion = 0;

                this.cocoonJS = false;

                this.cocoonJSApp = false;

                this.cordova = false;

                this.node = false;

                this.nodeWebkit = false;

                this.electron = false;

                this.ejecta = false;

                this.crosswalk = false;

                this.android = false;

                this.chromeOS = false;

                this.linux = false;

                this.macOS = false;

                this.windows = false;

                this.windowsPhone = false;

                this.canvas = false;

                this.canvasBitBltShift = null;

                this.canHandleAlpha = false;

                this.canUseMultiply = false;

                this.webGL = false;

                this.file = false;

                this.fileSystem = false;

                this.localStorage = false;

                this.worker = false;

                this.css3D = false;

                this.pointerLock = false;

                this.typedArray = false;

                this.vibration = false;

                this.getUserMedia = true;

                this.quirksMode = false;

                this.touch = false;

                this.mspointer = false;

                this.wheelEvent = null;

                this.arora = false;

                this.chrome = false;

                this.chromeVersion = 0;

                this.epiphany = false;

                this.firefox = false;

                this.firefoxVersion = 0;

                this.ie = false;

                this.ieVersion = 0;

                this.trident = false;

                this.tridentVersion = 0;

                this.edge = false;

                this.mobileSafari = false;

                this.midori = false;

                this.opera = false;

                this.safari = false;

                this.safariVersion = 0;

                this.webApp = false;

                this.silk = false;

                this.audioData = false;

                this.webAudio = false;

                this.ogg = false;

                this.opus = false;

                this.mp3 = false;

                this.wav = false;

                this.m4a = false;

                this.webm = false;

                this.dolby = false;

                this.oggVideo = false;

                this.h264Video = false;

                this.mp4Video = false;

                this.webmVideo = false;

                this.vp9Video = false;

                this.hlsVideo = false;

                this.iPhone = false;

                this.iPhone4 = false;

                this.iPad = false;

                this.pixelRatio = 0;

                this.littleEndian = false;

                this.LITTLE_ENDIAN = false;

                this.support32bit = false;

                this.fullscreen = false;

                this.requestFullscreen = "";

                this.cancelFullscreen = "";

                this.fullscreenKeyboard = false;
            }, $.Device = new($.Device), $.Device.onInitialized = new $.Signal, $.Device.whenReady = function (collection, resp, str) {
                var obj = this._readyCheck;
                if (this.deviceReadyAt || !obj) {
                    collection.call(resp, this);
                } else {
                    if (obj._monitor || str) {
                        obj._queue = obj._queue || [];
                        obj._queue.push([collection, resp]);
                    } else {
                        obj._monitor = obj.bind(this);
                        obj._queue = obj._queue || [];
                        obj._queue.push([collection, resp]);

                        var _tryInitOnFocus = void 0 !== window.cordova;
                        var _isFocused = navigator.isCocoonJS;
                        if ('complete' === document.readyState || 'interactive' === document.readyState) {
                            window.setTimeout(obj._monitor, 0);
                        } else {
                            if (_tryInitOnFocus && !_isFocused) {
                                document.addEventListener("deviceready", obj._monitor, false);
                            } else {
                                document.addEventListener('DOMContentLoaded', obj._monitor, false);
                                window.addEventListener('load', obj._monitor, false);
                            }
                        }
                    }
                }
            }, $.Device._readyCheck = function () {
                var keycode2keysym = this._readyCheck;
                if (document.body) {
                    if (!this.deviceReadyAt) {
                        this.deviceReadyAt = Date.now();
                        document.removeEventListener("deviceready", keycode2keysym._monitor);
                        document.removeEventListener('DOMContentLoaded', keycode2keysym._monitor);
                        window.removeEventListener('load', keycode2keysym._monitor);
                        this._initialize();

                        this.initialized = true;
                        this.onInitialized.dispatch(this);
                        var args;
                        for (; args = keycode2keysym._queue.shift();) {
                            var next = args[0];
                            var msg = args[1];
                            next.call(msg, this);
                        }

                        this._readyCheck = null;

                        this._initialize = null;

                        this.onInitialized = null;
                    }
                } else {
                    window.setTimeout(keycode2keysym._monitor, 20);
                }
            }, $.Device._initialize = function () {
                var result = this;
                ! function () {
                    var elem = navigator.userAgent;
                    if (/Playstation Vita/ ['test'](elem)) {

                        result.vita = true;
                    } else {
                        if (/Kindle/ ["test"](elem) || (/\bKF[A-Z][A-Z]+/ ["test"](elem) || /Silk.*Mobile Safari/ ['test'](elem))) {

                            result.kindle = true;
                        } else {
                            if (/Android/ ['test'](elem)) {

                                result.android = true;
                            } else {
                                if (/CrOS/ ['test'](elem)) {

                                    result.chromeOS = true;
                                } else {
                                    if (/iP[ao]d|iPhone/i ['test'](elem)) {

                                        result.iOS = true;
                                        navigator.appVersion.match(/OS (\d+)/);

                                        result.iOSVersion = parseInt(RegExp.$1, 10);
                                    } else {
                                        if (/Linux/ ['test'](elem)) {

                                            result.linux = true;
                                        } else {
                                            if (/Mac OS/ ['test'](elem)) {

                                                result.macOS = true;
                                            } else {
                                                if (/Windows/ ['test'](elem)) {

                                                    result.windows = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (/Windows Phone/i ['test'](elem) || /IEMobile/i ['test'](elem)) {

                        result.android = false;

                        result.iOS = false;

                        result.macOS = false;

                        result.windows = true;

                        result.windowsPhone = true;
                    }
                    var hasBody = /Silk/ ['test'](elem);
                    if (result.windows || (result.macOS || (result.linux && !hasBody || result.chromeOS))) {

                        result.desktop = true;
                    }
                    if (result.windowsPhone || /Windows NT/i ["test"](elem) && /Touch/i ['test'](elem)) {

                        result.desktop = false;
                    }
                }();
                (function () {
                    var r20 = navigator.userAgent;
                    if (/Arora/ ['test'](r20) ? result.arora = true : /Edge\/\d+/ ['test'](r20) ? result.edge = true : /Chrome\/(\d+)/ ['test'](r20) && !result.windowsPhone ? (result.chrome = true, result.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/ ['test'](r20) ? result.epiphany = true : /Firefox\D+(\d+)/ ['test'](r20) ? (result.firefox = true, result.firefoxVersion = parseInt(RegExp.$1, 10)) :
                        /AppleWebKit/ ["test"](r20) && result.iOS ? result.mobileSafari = true : /MSIE (\d+\.\d+);/ ["test"](r20) ? (result.ie = true, result.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/ ['test'](r20) ? result.midori = true : /Opera/ ['test'](r20) ? result.opera = true : /Safari\/(\d+)/ ["test"](r20) && !result.windowsPhone ? (result.safari = true, /Version\/(\d+)\./ ['test'](r20) && (result.safariVersion = parseInt(RegExp.$1,
                            10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/ ["test"](r20) && (result.ie = true, result.trident = true, result.tridentVersion = parseInt(RegExp.$1, 10), result.ieVersion = parseInt(RegExp.$3, 10)), /Silk/ ['test'](r20) && (result.silk = true), navigator.standalone && (result.webApp = true), void 0 !== window.cordova && (result.cordova = true), 'undefined' != typeof process && ("undefined" != typeof require &&
                            (result.node = true)), result.node && ('object' == typeof process.versions && (result.nodeWebkit = !!process.versions["node-webkit"], result.electron = !!process.versions.electron)), navigator.isCocoonJS && (result.cocoonJS = true), result.cocoonJS) {
                        try {

                            result.cocoonJSApp = 'undefined' != typeof CocoonJS;
                        } catch (_0x49c1b0) {

                            result.cocoonJSApp = false;
                        }
                    }
                    if (void 0 !== window.ejecta) {

                        result.ejecta = true;
                    }
                    if (/Crosswalk/ ["test"](r20)) {

                        result.crosswalk = true;
                    }
                })();
                (function () {

                    result.audioData = !!window.Audio;

                    result.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                    var audio = document.createElement("audio");
                    try {
                        if (audio.canPlayType && (audio.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (result.ogg = true), (audio.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || audio.canPlayType('audio/opus;').replace(/^no$/, "")) && (result.opus = true), audio.canPlayType('audio/mpeg;').replace(/^no$/, "") && (result.mp3 = true), audio.canPlayType('audio/wav; codecs="1"').replace(/^no$/,
                                "") && (result.wav = true), (audio.canPlayType('audio/x-m4a;') || audio.canPlayType("audio/aac;").replace(/^no$/, "")) && (result.m4a = true), audio.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (result.webm = true), "" !== audio.canPlayType('audio/mp4;codecs="ec-3"'))) {
                            if (result.edge) {

                                result.dolby = true;
                            } else {
                                if (result.safari && (result.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/ ['test'](navigator.userAgent))) {

                                    var d = parseInt(RegExp.$1, 10);

                                    var step = parseInt(RegExp.$2, 10);
                                    if (10 === d && step >= 11 || d > 10) {

                                        result.dolby = true;
                                    }
                                }
                            }
                        }
                    } catch (_0x1b6991) {}
                })();
                (function () {
                    var audio = document.createElement('video');
                    try {
                        if (!!audio.canPlayType) {
                            if (audio.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "")) {

                                result.oggVideo = true;
                            }
                            if (audio.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "")) {

                                result.h264Video = true;

                                result.mp4Video = true;
                            }
                            if (audio.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")) {

                                result.webmVideo = true;
                            }
                            if (audio.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "")) {

                                result.vp9Video = true;
                            }
                            if (audio.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "")) {

                                result.hlsVideo = true;
                            }
                        }
                    } catch (_0x2b130a) {}
                })();
                (function () {
                    var _0x1a5e97;
                    var task = document.createElement("p");
                    var map = {
                        "webkitTransform": '-webkit-transform',
                        "OTransform": "-o-transform",
                        "msTransform": "-ms-transform",
                        "MozTransform": '-moz-transform',
                        "transform": 'transform'
                    };
                    document.body.insertBefore(task, null);
                    var letter;
                    for (letter in map) {
                        if (void 0 !== task.style[letter]) {
                            task.style[letter] = 'translate3d(1px,1px,1px)';
                            _0x1a5e97 = window.getComputedStyle(task).getPropertyValue(map[letter]);
                        }
                    }
                    document.body.removeChild(task);

                    result.css3D = void 0 !== _0x1a5e97 && (_0x1a5e97.length > 0 && 'none' !== _0x1a5e97);
                })();
                result.pixelRatio = window.devicePixelRatio || 1;

                result.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf('iphone');
                result.iPhone4 = 2 === result.pixelRatio && result.iPhone;

                result.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad");
                if ("undefined" != typeof Int8Array) {

                    result.typedArray = true;
                } else {

                    result.typedArray = false;
                }
                if ("undefined" != typeof ArrayBuffer) {
                    if ('undefined' != typeof Uint8Array) {
                        if ('undefined' != typeof Uint32Array) {
                            result.littleEndian = function () {

                                var packIntToFloatArrayBuffer = new ArrayBuffer(4);

                                var packIntToFloatUint8Buffer = new Uint8Array(packIntToFloatArrayBuffer);

                                var packIntToFloatInt32Buffer = new Uint32Array(packIntToFloatArrayBuffer);
                                return packIntToFloatUint8Buffer[0] = 161, packIntToFloatUint8Buffer[1] = 178, packIntToFloatUint8Buffer[2] = 195, packIntToFloatUint8Buffer[3] = 212, 3569595041 === packIntToFloatInt32Buffer[0] || 2712847316 !== packIntToFloatInt32Buffer[0] && null;
                            }();
                            result.LITTLE_ENDIAN = result.littleEndian;
                        }
                    }
                }
                result.support32bit = 'undefined' != typeof ArrayBuffer && ('undefined' != typeof Uint8ClampedArray && ('undefined' != typeof Int32Array && (null !== result.littleEndian && function () {
                    if (void 0 === Uint8ClampedArray) {
                        return false;
                    }
                    var _0x35b826 = $.CanvasPool.create(this, 1, 1).getContext("2d");
                    if (!_0x35b826) {
                        return false;
                    }
                    var _0x2bb7b7 = _0x35b826.createImageData(1, 1);
                    return $.CanvasPool.remove(this), _0x2bb7b7.data instanceof Uint8ClampedArray;
                }())));
                navigator.vibrate = navigator.vibrate || (navigator.webkitVibrate || (navigator.mozVibrate || navigator.msVibrate));
                if (navigator.vibrate) {

                    result.vibration = true;
                }
                (function () {
                    result.canvas = !!window.CanvasRenderingContext2D || result.cocoonJS;
                    try {

                        result.localStorage = !!localStorage.getItem;
                    } catch (_0x398ba8) {

                        result.localStorage = false;
                    }

                    result.file = !!(window.File && (window.FileReader && (window.FileList && window.Blob)));

                    result.fileSystem = !!window.requestFileSystem;

                    result.webGL = !!window.WebGLRenderingContext;

                    result.worker = !!window.Worker;

                    result.pointerLock = 'pointerLockElement' in document || ('mozPointerLockElement' in document || 'webkitPointerLockElement' in document);

                    result.quirksMode = 'CSS1Compat' !== document.compatMode;
                    navigator.getUserMedia = navigator.getUserMedia || (navigator.webkitGetUserMedia || (navigator.mozGetUserMedia || (navigator.msGetUserMedia || navigator.oGetUserMedia)));
                    window.URL = window.URL || (window.webkitURL || (window.mozURL || window.msURL));
                    result.getUserMedia = result.getUserMedia && (!!navigator.getUserMedia && !!window.URL);
                    if (result.firefox) {
                        if (result.firefoxVersion < 21) {

                            result.getUserMedia = false;
                        }
                    }
                    if (!result.iOS) {
                        if (result.ie || (result.firefox || result.chrome)) {

                            result.canvasBitBltShift = true;
                        }
                    }
                    if (result.safari || result.mobileSafari) {

                        result.canvasBitBltShift = false;
                    }
                })();
                (function () {
                    var r20 = $.CanvasPool.create(this, 6, 1);
                    var console = r20.getContext("2d");
                    console.fillStyle = 'rgba(10, 20, 30, 0.5)';
                    console.fillRect(0, 0, 1, 1);
                    var x = console.getImageData(0, 0, 1, 1);
                    if (x) {
                        console.putImageData(x, 1, 0);
                        var cache = console.getImageData(1, 0, 1, 1);

                        result.canHandleAlpha = cache.data[0] === x.data[0] && (cache.data[1] === x.data[1] && (cache.data[2] === x.data[2] && cache.data[3] === x.data[3]));
                    }
                    console.globalCompositeOperation = 'multiply';

                    result.canUseMultiply = 'multiply' === console.globalCompositeOperation;
                    $.CanvasPool.removeByCanvas(r20);
                    PIXI.CanvasTinter.tintMethod = result.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel;
                })();
                (function () {

                    var keys = ['requestFullscreen', 'requestFullScreen', 'webkitRequestFullscreen', "webkitRequestFullScreen", 'msRequestFullscreen', "msRequestFullScreen", 'mozRequestFullScreen', 'mozRequestFullscreen'];
                    var origin = document.createElement('div');

                    var i = 0;
                    for (; i < keys.length; i++) {
                        if (origin[keys[i]]) {

                            result.fullscreen = true;
                            result.requestFullscreen = keys[i];
                            break;
                        }
                    }

                    var obj = ['cancelFullScreen', 'exitFullscreen', "webkitCancelFullScreen", "webkitExitFullscreen", 'msCancelFullScreen', 'msExitFullscreen', 'mozCancelFullScreen', "mozExitFullscreen"];
                    if (result.fullscreen) {

                        i = 0;
                        for (; i < obj.length; i++) {
                            if (document[obj[i]]) {
                                result.cancelFullscreen = obj[i];
                                break;
                            }
                        }
                    }
                    if (window.Element) {
                        if (Element.ALLOW_KEYBOARD_INPUT) {

                            result.fullscreenKeyboard = true;
                        }
                    }
                })();
                if ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) {

                    result.touch = true;
                }
                if (window.PointerEvent || (window.MSPointerEvent || (window.navigator.msPointerEnabled || window.navigator.pointerEnabled))) {

                    result.mspointer = true;
                }
                if (!result.cocoonJS) {
                    if ('onwheel' in window || result.ie && 'WheelEvent' in window) {
                        result.wheelEvent = 'wheel';
                    } else {
                        if ('onmousewheel' in window) {

                            result.wheelEvent = "mousewheel";
                        } else {
                            if (result.firefox) {
                                if ('MouseScrollEvent' in window) {
                                    result.wheelEvent = 'DOMMouseScroll';
                                }
                            }
                        }
                    }
                }
            }, $.Device.canPlayAudio = function (wav) {
                return !!("mp3" === wav && this.mp3 || ('ogg' === wav && (this.ogg || this.opus) || ('m4a' === wav && this.m4a || ('opus' === wav && this.opus || ('wav' === wav && this.wav || ("webm" === wav && this.webm || 'mp4' === wav && this.dolby))))));
            }, $.Device.canPlayVideo = function (dataAndEvents) {
                return !!("webm" === dataAndEvents && (this.webmVideo || this.vp9Video) || ('mp4' === dataAndEvents && (this.mp4Video || this.h264Video) || (('ogg' === dataAndEvents || 'ogv' === dataAndEvents) && this.oggVideo || 'mpeg' === dataAndEvents && this.hlsVideo)));
            }, $.Device.needsTouchUnlock = function () {
                return !!(!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock);
            }, $.Device.isAndroidStockBrowser = function () {
                var _0x200f2b = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                return _0x200f2b && _0x200f2b[1] < 537;
            }, $.Canvas = {

                "create": function (action, version, options, val, fn) {
                    version = version || 256;
                    options = options || 256;
                    var object = fn ? document.createElement('canvas') : $.CanvasPool.create(action, version, options);
                    return 'string' == typeof val && ("" !== val && (object.id = val)), object.width = version, object.height = options, object.style.display = 'block', object;
                },

                "setBackgroundColor": function (options, color) {
                    return color = color || 'rgb(0,0,0)', options.style.backgroundColor = color, options;
                },

                "setTouchAction": function (value, align) {
                    return align = align || "none", value.style.msTouchAction = align, value.style['ms-touch-action'] = align, value.style['touch-action'] = align, value;
                },

                "setUserSelect": function (value, align) {
                    return align = align || "none", value.style['-webkit-touch-callout'] = align, value.style['-webkit-user-select'] = align, value.style['-khtml-user-select'] = align, value.style['-moz-user-select'] = align, value.style['-ms-user-select'] = align, value.style['user-select'] = align, value.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', value;
                },

                "addToDOM": function (type, el, overflowHidden) {
                    var element;
                    return void 0 === overflowHidden && (overflowHidden = true), el && ("string" == typeof el ? element = document.getElementById(el) : 'object' == typeof el && (1 === el.nodeType && (element = el))), element || (element = document.body), overflowHidden && (element.style && (element.style.overflow = 'hidden')), element.appendChild(type), type;
                },

                "removeFromDOM": function (range) {
                    if (range.parentNode) {
                        range.parentNode.removeChild(range);
                    }
                },

                "setTransform": function (obj, dy, z, transform, m12, callback, capture) {
                    return obj.setTransform(transform, callback, capture, m12, dy, z), obj;
                },

                "setSmoothingEnabled": function (value, rhs) {
                    var name = $.Canvas.getSmoothingPrefix(value);
                    return name && (value[name] = rhs), value;
                },

                "getSmoothingPrefix": function (arr2) {

                    var map = ["i", 'webkitI', 'msI', 'mozI', "oI"];
                    var letter;
                    for (letter in map) {
                        var i = map[letter] + "mageSmoothingEnabled";
                        if (i in arr2) {
                            return i;
                        }
                    }
                    return null;
                },

                "getSmoothingEnabled": function (selector) {
                    var insert = $.Canvas.getSmoothingPrefix(selector);
                    if (insert) {
                        return selector[insert];
                    }
                },

                "setImageRenderingCrisp": function (dataAndEvents) {

                    var stack = ['-webkit-optimize-contrast', '-moz-crisp-edges', 'crisp-edges', "pixelated"];

                    var i = 0;
                    for (; i < stack.length; i++) {
                        dataAndEvents.style["image-rendering"] = stack[i];
                    }
                    return dataAndEvents.style.msInterpolationMode = 'nearest-neighbor', dataAndEvents;
                },

                "setImageRenderingBicubic": function (dataAndEvents) {
                    return dataAndEvents.style['image-rendering'] = "auto", dataAndEvents.style.msInterpolationMode = 'bicubic', dataAndEvents;
                }
            }, $.RequestAnimationFrame = function (dataAndEvents, deepDataAndEvents) {
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = false;
                }
                this.game = dataAndEvents;

                this.isRunning = false;

                this.forceSetTimeOut = deepDataAndEvents;

                var vendors = ["ms", 'moz', 'webkit', "o"];

                var x = 0;
                for (; x < vendors.length && !window.requestAnimationFrame; x++) {
                    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
                    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
                }

                this._isSetTimeOut = false;

                this._onLoop = null;

                this._timeOutID = null;
            }, $.RequestAnimationFrame.prototype = {

                "start": function () {

                    this.isRunning = true;
                    var collection = this;
                    if (!window.requestAnimationFrame || this.forceSetTimeOut) {

                        this._isSetTimeOut = true;

                        this._onLoop = function () {
                            return collection.updateSetTimeout();
                        };
                        this._timeOutID = window.setTimeout(this._onLoop, 0);
                    } else {

                        this._isSetTimeOut = false;

                        this._onLoop = function (resp) {
                            return collection.updateRAF(resp);
                        };
                        this._timeOutID = window.requestAnimationFrame(this._onLoop);
                    }
                },

                "updateRAF": function (currentValue) {
                    if (this.isRunning) {
                        this.game.update(Math.floor(currentValue));
                        this._timeOutID = window.requestAnimationFrame(this._onLoop);
                    }
                },

                "updateSetTimeout": function () {
                    if (this.isRunning) {
                        this.game.update(Date.now());
                        this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);
                    }
                },

                "stop": function () {
                    if (this._isSetTimeOut) {
                        clearTimeout(this._timeOutID);
                    } else {
                        window.cancelAnimationFrame(this._timeOutID);
                    }

                    this.isRunning = false;
                },

                "isSetTimeOut": function () {
                    return this._isSetTimeOut;
                },

                "isRAF": function () {
                    return false === this._isSetTimeOut;
                }
            }, $.RequestAnimationFrame.prototype.constructor = $.RequestAnimationFrame, $.Math = {
                "PI2": 2 * Math.PI,
                "HALF_PI": 0.5 * Math.PI,
                "DEG_TO_RAD": Math.PI / 180,
                "RAD_TO_DEG": 180 / Math.PI,

                "degToRad": function (degrees) {
                    return degrees * $.Math.DEG_TO_RAD;
                },

                "radToDeg": function (radians) {
                    return radians * $.Math.RAD_TO_DEG;
                },

                "getNextPowerOfTwo": function (n) {
                    if (n > 0 && 0 == (n & n - 1)) {
                        return n;
                    }

                    var i = 1;
                    for (; i < n;) {
                        i <<= 1;
                    }
                    return i;
                },

                "isPowerOfTwo": function (x, value) {
                    return x > 0 && (0 == (x & x - 1) && (value > 0 && 0 == (value & value - 1)));
                },

                "random": function (min, max) {
                    if (void 0 === min && (min = 0), void 0 === max && (max = 1), min === max) {
                        return min;
                    }
                    if (min > max) {

                        var temp = min;

                        min = max;
                        max = temp;
                    }
                    return Math.random() * (max - min) + min;
                },

                "between": function (from, to) {
                    if (void 0 === from && (from = 0), void 0 === to && (to = 1), from === to) {
                        return from;
                    }
                    if (from > to) {

                        var tmp = from;

                        from = to;
                        to = tmp;
                    }
                    return from = Math.ceil(from), to = Math.floor(to), Math.floor(Math.random() * (to - from + 1)) + from;
                },

                "fuzzyEqual": function (far, near, dataAndEvents) {
                    return void 0 === dataAndEvents && (dataAndEvents = 1E-4), Math.abs(far - near) < dataAndEvents;
                },

                "fuzzyLessThan": function (dataAndEvents, far, near) {
                    return void 0 === near && (near = 1E-4), dataAndEvents < far + near;
                },

                "fuzzyGreaterThan": function (dataAndEvents, far, near) {
                    return void 0 === near && (near = 1E-4), dataAndEvents > far - near;
                },

                "fuzzyCeil": function (far, near) {
                    return void 0 === near && (near = 1E-4), Math.ceil(far - near);
                },

                "fuzzyFloor": function (far, near) {
                    return void 0 === near && (near = 1E-4), Math.floor(far + near);
                },

                "average": function () {

                    var a = 0;
                    var b = arguments.length;

                    var g = 0;
                    for (; g < b; g++) {
                        a += +arguments[g];
                    }
                    return a / b;
                },

                "shear": function (kx) {
                    return kx % 1;
                },

                "snapTo": function (a, b, dir) {
                    return void 0 === dir && (dir = 0), 0 === b ? a : (a -= dir, a = b * Math.round(a / b), dir + a);
                },

                "snapToFloor": function (b, l, a) {
                    return void 0 === a && (a = 0), 0 === l ? b : (b -= a, b = l * Math.floor(b / l), a + b);
                },

                "snapToCeil": function (b, l, a) {
                    return void 0 === a && (a = 0), 0 === l ? b : (b -= a, b = l * Math.ceil(b / l), a + b);
                },

                "roundTo": function (number, decimals, value) {
                    if (void 0 === decimals) {

                        decimals = 0;
                    }
                    if (void 0 === value) {

                        value = 10;
                    }
                    var isFunction = Math.pow(value, -decimals);
                    return Math.round(number * isFunction) / isFunction;
                },

                "floorTo": function (a4, dataAndEvents, currentValue) {
                    if (void 0 === dataAndEvents) {

                        dataAndEvents = 0;
                    }
                    if (void 0 === currentValue) {

                        currentValue = 10;
                    }
                    var b1 = Math.pow(currentValue, -dataAndEvents);
                    return Math.floor(a4 * b1) / b1;
                },

                "ceilTo": function (dataAndEvents, num, value) {
                    if (void 0 === num) {

                        num = 0;
                    }
                    if (void 0 === value) {

                        value = 10;
                    }
                    var isFunction = Math.pow(value, -num);
                    return Math.ceil(dataAndEvents * isFunction) / isFunction;
                },

                "rotateToAngle": function (b, a, range) {
                    return void 0 === range && (range = 0.05), b === a ? b : (Math.abs(a - b) <= range || Math.abs(a - b) >= $.Math.PI2 - range ? b = a : (Math.abs(a - b) > Math.PI && (a < b ? a += $.Math.PI2 : a -= $.Math.PI2), a > b ? b += range : a < b && (b -= range)), b);
                },

                "getShortestAngle": function (near, far) {

                    var fn = far - near;
                    return 0 === fn ? 0 : fn - 360 * Math.floor((fn - -180) / 360);
                },

                "angleBetween": function (b, min, a, max) {
                    return Math.atan2(max - min, a - b);
                },

                "angleBetweenY": function (b, near, a, far) {
                    return Math.atan2(a - b, far - near);
                },

                "angleBetweenPoints": function (p1, p2) {
                    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
                },

                "angleBetweenPointsY": function (p1, p2) {
                    return Math.atan2(p2.x - p1.x, p2.y - p1.y);
                },

                "reverseAngle": function (dataAndEvents) {
                    return this.normalizeAngle(dataAndEvents + Math.PI, true);
                },

                "normalizeAngle": function (angle) {
                    return (angle %= 2 * Math.PI) >= 0 ? angle : angle + 2 * Math.PI;
                },

                "maxAdd": function (far, near, bot) {
                    return Math.min(far + near, bot);
                },

                "minSub": function (far, near, bot) {
                    return Math.max(far - near, bot);
                },

                "wrap": function (value, min, max) {

                    var step = max - min;
                    if (step <= 0) {
                        return 0;
                    }

                    var i = (value - min) % step;
                    return i < 0 && (i += step), i + min;
                },

                "wrapValue": function (value, number, basis) {
                    return value = Math.abs(value), number = Math.abs(number), basis = Math.abs(basis), (value + number) % basis;
                },

                "isOdd": function (elem) {
                    return !!(1 & elem);
                },

                "isEven": function (x) {
                    return !(1 & x);
                },

                "min": function () {
                    if (1 === arguments.length && 'object' == typeof arguments[0]) {
                        a = arguments[0];
                    } else {

                        var a = arguments
                    }

                    var i = 1;

                    var j = 0;
                    var ii = a.length;
                    for (; i < ii; i++) {
                        if (a[i] < a[j]) {

                            j = i;
                        }
                    }
                    return a[j];
                },

                "max": function () {
                    if (1 === arguments.length && 'object' == typeof arguments[0]) {
                        values = arguments[0];
                    } else {

                        var values = arguments
                    }

                    var i = 1;

                    var last = 0;
                    var ii = values.length;
                    for (; i < ii; i++) {
                        if (values[i] > values[last]) {

                            last = i;
                        }
                    }
                    return values[last];
                },

                "minProperty": function (field) {
                    if (2 === arguments.length && 'object' == typeof arguments[1]) {
                        results = arguments[1];
                    } else {
                        var results = arguments.slice(1)
                    }

                    var i = 1;

                    var idx = 0;
                    var r1 = results.length;
                    for (; i < r1; i++) {
                        if (results[i][field] < results[idx][field]) {

                            idx = i;
                        }
                    }
                    return results[idx][field];
                },

                "maxProperty": function (col) {
                    if (2 === arguments.length && "object" == typeof arguments[1]) {
                        result = arguments[1];
                    } else {
                        var result = arguments.slice(1)
                    }

                    var j = 1;

                    var row = 0;
                    var jj = result.length;
                    for (; j < jj; j++) {
                        if (result[j][col] > result[row][col]) {

                            row = j;
                        }
                    }
                    return result[row][col];
                },

                "wrapAngle": function (iterator, initial) {
                    return initial ? this.wrap(iterator, -Math.PI, Math.PI) : this.wrap(iterator, -180, 180);
                },

                "linearInterpolation": function (colors, chunkSize) {

                    var i = colors.length - 1;

                    var n = i * chunkSize;
                    var c = Math.floor(n);
                    return chunkSize < 0 ? this.linear(colors[0], colors[1], n) : chunkSize > 1 ? this.linear(colors[i], colors[i - 1], i - n) : this.linear(colors[c], colors[c + 1 > i ? i : c + 1], n - c);
                },

                "bezierInterpolation": function (rec, currentValue) {

                    var bezierInterpolation = 0;

                    var x2 = rec.length - 1;

                    var r = 0;
                    for (; r <= x2; r++) {
                        bezierInterpolation += Math.pow(1 - currentValue, x2 - r) * Math.pow(currentValue, r) * rec[r] * this.bernstein(x2, r);
                    }
                    return bezierInterpolation;
                },

                "catmullRomInterpolation": function (data, s) {

                    var l = data.length - 1;

                    var b = l * s;
                    var x = Math.floor(b);
                    return data[0] === data[l] ? (s < 0 && (x = Math.floor(b = l * (1 + s))), this.catmullRom(data[(x - 1 + l) % l], data[x], data[(x + 1) % l], data[(x + 2) % l], b - x)) : s < 0 ? data[0] - (this.catmullRom(data[0], data[0], data[1], data[1], -b) - data[0]) : s > 1 ? data[l] - (this.catmullRom(data[l], data[l], data[l - 1], data[l - 1], b - l) - data[l]) : this.catmullRom(data[x ? x - 1 : 0], data[x], data[l < x + 1 ? l : x + 1], data[l < x + 2 ? l : x + 2], b -
                        x);
                },

                "linear": function (x, p, f) {
                    return (p - x) * f + x;
                },

                "bernstein": function (a, b) {
                    return this.factorial(a) / this.factorial(b) / this.factorial(a - b);
                },

                "factorial": function (value) {
                    if (0 === value) {
                        return 1;
                    }

                    var res = value;
                    for (; --value;) {
                        res *= value;
                    }
                    return res;
                },

                "catmullRom": function (a2, a3, a1, dataAndEvents, x) {

                    var g = 0.5 * (a1 - a2);

                    var b = 0.5 * (dataAndEvents - a3);

                    var xx = x * x;
                    return (2 * a3 - 2 * a1 + g + b) * (x * xx) + (-3 * a3 + 3 * a1 - 2 * g - b) * xx + g * x + a3;
                },

                "difference": function (a, b) {
                    return Math.abs(a - b);
                },

                "roundAwayFromZero": function (x) {
                    return x > 0 ? Math.ceil(x) : Math.floor(x);
                },

                "sinCosGenerator": function (len, dataAndEvents, obj, factor) {
                    if (void 0 === dataAndEvents) {

                        dataAndEvents = 1;
                    }
                    if (void 0 === obj) {

                        obj = 1;
                    }
                    if (void 0 === factor) {

                        factor = 1;
                    }

                    var v0 = dataAndEvents;

                    var o = obj;

                    var t = factor * Math.PI / len;

                    var passedValues = [];

                    var mat = [];

                    var i = 0;
                    for (; i < len; i++) {
                        v0 += (o -= v0 * t) * t;
                        passedValues[i] = o;
                        mat[i] = v0;
                    }
                    return {
                        "sin": mat,
                        "cos": passedValues,
                        "length": len
                    };
                },

                "hypot": function (z0, z1) {
                    return Math.sqrt(z0 * z0 + z1 * z1);
                },

                "distance": function (to, a, from, b) {

                    var z0 = to - from;

                    var z1 = a - b;
                    return Math.sqrt(z0 * z0 + z1 * z1);
                },

                "distanceSq": function (eyex, eyey, centerx, centery) {

                    var z0 = eyex - centerx;

                    var z1 = eyey - centery;
                    return z0 * z0 + z1 * z1;
                },

                "distancePow": function (near, b, far, a, x) {
                    return void 0 === x && (x = 2), Math.sqrt(Math.pow(far - near, x) + Math.pow(a - b, x));
                },

                "clamp": function (n, min, max) {
                    return n < min ? min : max < n ? max : n;
                },

                "clampBottom": function (max, value) {
                    return max < value ? value : max;
                },

                "within": function (a, b, distance) {
                    return Math.abs(a - b) <= distance;
                },

                "mapLinear": function (closest, near, far, b, a) {
                    return b + (closest - near) * (a - b) / (far - near);
                },

                "smoothstep": function (value, min, max) {
                    return (value = Math.max(0, Math.min(1, (value - min) / (max - min)))) * value * (3 - 2 * value);
                },

                "smootherstep": function (value, min, max) {
                    return (value = Math.max(0, Math.min(1, (value - min) / (max - min)))) * value * value * (value * (6 * value - 15) + 10);
                },

                "sign": function (x) {
                    return x < 0 ? -1 : x > 0 ? 1 : 0;
                },

                "percent": function (end, max, start) {
                    return void 0 === start && (start = 0), end > max || start > max ? 1 : end < start || start > end ? 0 : (end - start) / max;
                }
            }, $.RandomDataGenerator = function (err) {
                if (void 0 === err) {

                    err = [];
                }

                this.c = 1;

                this.s0 = 0;

                this.s1 = 0;

                this.s2 = 0;
                if ("string" == typeof err) {
                    this.state(err);
                } else {
                    this.sow(err);
                }
            }, $.RandomDataGenerator.prototype = {

                "rnd": function () {

                    var c = 2091639 * this.s0 + 2.3283064365386963E-10 * this.c;
                    return this.c = 0 | c, this.s0 = this.s1, this.s1 = this.s2, this.s2 = c - this.c, this.s2;
                },

                "sow": function (stack) {
                    if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, stack) {

                        var i = 0;
                        for (; i < stack.length && null != stack[i]; i++) {
                            var currentStackItem = stack[i];
                            this.s0 -= this.hash(currentStackItem);
                            this.s0 += ~~(this.s0 < 0);
                            this.s1 -= this.hash(currentStackItem);
                            this.s1 += ~~(this.s1 < 0);
                            this.s2 -= this.hash(currentStackItem);
                            this.s2 += ~~(this.s2 < 0);
                        }
                    }
                },

                "hash": function (doc) {
                    var h;
                    var domContentLoaded;
                    var n;

                    n = 4022871197;
                    doc = doc.toString();

                    domContentLoaded = 0;
                    for (; domContentLoaded < doc.length; domContentLoaded++) {

                        h = 0.02519603282416938 * (n += doc.charCodeAt(domContentLoaded));
                        h -= n = h >>> 0;

                        n = (h *= n) >>> 0;
                        n += 4294967296 * (h -= n);
                    }
                    return 2.3283064365386963E-10 * (n >>> 0);
                },

                "integer": function () {
                    return 4294967296 * this.rnd.apply(this);
                },

                "frac": function () {
                    return this.rnd.apply(this) + 1.1102230246251565E-16 * (2097152 * this.rnd.apply(this) | 0);
                },

                "real": function () {
                    return this.integer() + this.frac();
                },

                "integerInRange": function (near, far) {
                    return Math.floor(this.realInRange(0, far - near + 1) + near);
                },

                "between": function (endTime, suffix) {
                    return this.integerInRange(endTime, suffix);
                },

                "realInRange": function (near, far) {
                    return this.frac() * (far - near) + near;
                },

                "normal": function () {
                    return 1 - 2 * this.frac();
                },

                "uuid": function () {

                    var expires = "";

                    var b = "";

                    b = expires = "";
                    for (; expires++ < 36; b += ~expires % 5 | 3 * expires & 4 ? (15 ^ expires ? 8 ^ this.frac() * (20 ^ expires ? 16 : 4) : 4).toString(16) : "-") {}
                    return b;
                },

                "pick": function (var_keys) {
                    return var_keys[this.integerInRange(0, var_keys.length - 1)];
                },

                "sign": function () {
                    return this.pick([-1, 1]);
                },

                "weightedPick": function (dataAndEvents) {
                    return dataAndEvents[~~(Math.pow(this.frac(), 2) * (dataAndEvents.length - 1) + 0.5)];
                },

                "timestamp": function (timestamp, date) {
                    return this.realInRange(timestamp || 9466848E5, date || 1577862E6);
                },

                "angle": function () {
                    return this.integerInRange(-180, 180);
                },

                "state": function (s) {
                    return 'string' == typeof s && (s.match(/^!rnd/) && (s = s.split(","), this.c = parseFloat(s[1]), this.s0 = parseFloat(s[2]), this.s1 = parseFloat(s[3]), this.s2 = parseFloat(s[4]))), ['!rnd', this.c, this.s0, this.s1, this.s2].join(",");
                }
            }, $.RandomDataGenerator.prototype.constructor = $.RandomDataGenerator, $.QuadTree = function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope, shallow, funcToCall) {

                this.maxObjects = 10;

                this.maxLevels = 4;

                this.level = 0;
                this.bounds = {};

                this.objects = [];

                this.nodes = [];

                this._empty = [];
                this.reset(deepDataAndEvents, opt_obj2, walkers, isXML, next_scope, shallow, funcToCall);
            }, $.QuadTree.prototype = {

                "reset": function (x, y, w, delta, models, evt, abandon) {
                    this.maxObjects = models || 10;
                    this.maxLevels = evt || 4;
                    this.level = abandon || 0;
                    this.bounds = {
                        "x": Math.round(x),
                        "y": Math.round(y),
                        "width": w,
                        "height": delta,
                        "subWidth": Math.floor(w / 2),
                        "subHeight": Math.floor(delta / 2),
                        "right": Math.round(x) + Math.floor(w / 2),
                        "bottom": Math.round(y) + Math.floor(delta / 2)
                    };

                    this.objects.length = 0;

                    this.nodes.length = 0;
                },

                "populate": function (template) {
                    template.forEach(this.populateHandler, this, true);
                },

                "populateHandler": function (dataAndEvents) {
                    if (dataAndEvents.body) {
                        if (dataAndEvents.exists) {
                            this.insert(dataAndEvents.body);
                        }
                    }
                },

                "split": function () {
                    this.nodes[0] = new $.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
                    this.nodes[1] = new($.QuadTree)(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
                    this.nodes[2] = new($.QuadTree)(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
                    this.nodes[3] = new $.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1);
                },

                "insert": function (arr) {
                    var i;

                    var sel = 0;
                    if (null == this.nodes[0] || -1 === (i = this.getIndex(arr))) {
                        if (this.objects.push(arr), this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                            if (null == this.nodes[0]) {
                                this.split();
                            }
                            for (; sel < this.objects.length;) {
                                if (-1 !== (i = this.getIndex(this.objects[sel]))) {
                                    this.nodes[i].insert(this.objects.splice(sel, 1)[0]);
                                } else {
                                    sel++;
                                }
                            }
                        }
                    } else {
                        this.nodes[i].insert(arr);
                    }
                },

                "getIndex": function (s) {

                    var _0x47ac31 = -1;
                    return s.x < this.bounds.right && s.right < this.bounds.right ? s.y < this.bounds.bottom && s.bottom < this.bounds.bottom ? _0x47ac31 = 1 : s.y > this.bounds.bottom && (_0x47ac31 = 2) : s.x > this.bounds.right && (s.y < this.bounds.bottom && s.bottom < this.bounds.bottom ? _0x47ac31 = 0 : s.y > this.bounds.bottom &&
                        (_0x47ac31 = 3)), _0x47ac31;
                },

                "retrieve": function (key) {
                    if (key instanceof $.Rectangle) {
                        var combList = this.objects;
                        var camelKey = this.getIndex(key);
                    } else {
                        if (!key.body) {
                            return this._empty;
                        }
                        combList = this.objects;
                        camelKey = this.getIndex(key.body);
                    }
                    return this.nodes[0] && (combList = -1 !== camelKey ? combList.concat(this.nodes[camelKey].retrieve(key)) : (combList = (combList = (combList = combList.concat(this.nodes[0].retrieve(key))).concat(this.nodes[1].retrieve(key))).concat(this.nodes[2].retrieve(key))).concat(this.nodes[3].retrieve(key))), combList;
                },

                "clear": function () {

                    this.objects.length = 0;
                    var ii = this.nodes.length;
                    for (; ii--;) {
                        this.nodes[ii].clear();
                        this.nodes.splice(ii, 1);
                    }

                    this.nodes.length = 0;
                }
            }, $.QuadTree.prototype.constructor = $.QuadTree, $.Net = function (dataAndEvents) {
                this.game = dataAndEvents;
            }, $.Net.prototype = {

                "getHostName": function () {
                    return window.location && window.location.hostname ? window.location.hostname : null;
                },

                "checkDomainName": function (oldItem) {
                    return -1 !== window.location.hostname.indexOf(oldItem);
                },

                "updateQueryString": function (key, method, redirect, url) {
                    if (void 0 === redirect) {

                        redirect = false;
                    }
                    if (!(void 0 !== url && "" !== url)) {
                        url = window.location.href;
                    }

                    var output = "";

                    var classSelector = new RegExp('([?|&])' + key + '=.*?(&|#|$)(.*)', "gi");
                    if (classSelector.test(url)) {
                        output = void 0 !== method && null !== method ? url.replace(classSelector, "$1" + key + "=" + method + '$2$3') : url.replace(classSelector, '$1$3').replace(/(&|\?)$/, "");
                    } else {
                        if (void 0 !== method && null !== method) {

                            var _ = -1 !== url.indexOf("?") ? "&" : "?";
                            var parts = url.split("#");

                            url = parts[0] + _ + key + "=" + method;
                            if (parts[1]) {
                                url += "#" + parts[1];
                            }

                            output = url;
                        } else {

                            output = url;
                        }
                    }
                    if (!redirect) {
                        return output;
                    }
                    window.location.href = output;
                },

                "getQueryString": function (name) {
                    if (void 0 === name) {

                        name = "";
                    }
                    var queryString = {};
                    var map = location.search.substring(1).split("&");
                    var letter;
                    for (letter in map) {
                        var _0x3c4377 = map[letter].split("=");
                        if (_0x3c4377.length > 1) {
                            if (name && name === this.decodeURI(_0x3c4377[0])) {
                                return this.decodeURI(_0x3c4377[1]);
                            }
                            queryString[this.decodeURI(_0x3c4377[0])] = this.decodeURI(_0x3c4377[1]);
                        }
                    }
                    return queryString;
                },

                "decodeURI": function (value) {
                    return decodeURIComponent(value.replace(/\+/g, " "));
                }
            }, $.Net.prototype.constructor = $.Net, $.TweenManager = function (dataAndEvents) {
                this.game = dataAndEvents;

                this.frameBased = false;

                this._tweens = [];

                this._add = [];
                this.easeMap = {
                    "Power0": $.Easing.Power0,
                    "Power1": $.Easing.Power1,
                    "Power2": $.Easing.Power2,
                    "Power3": $.Easing.Power3,
                    "Power4": $.Easing.Power4,
                    "Linear": $.Easing.Linear.None,
                    "Quad": $.Easing.Quadratic.Out,
                    "Cubic": $.Easing.Cubic.Out,
                    "Quart": $.Easing.Quartic.Out,
                    "Quint": $.Easing.Quintic.Out,
                    "Sine": $.Easing.Sinusoidal.Out,
                    "Expo": $.Easing.Exponential.Out,
                    "Circ": $.Easing.Circular.Out,
                    "Elastic": $.Easing.Elastic.Out,
                    "Back": $.Easing.Back.Out,
                    "Bounce": $.Easing.Bounce.Out,
                    "Quad.easeIn": $.Easing.Quadratic.In,
                    "Cubic.easeIn": $.Easing.Cubic.In,
                    "Quart.easeIn": $.Easing.Quartic.In,
                    "Quint.easeIn": $.Easing.Quintic.In,
                    "Sine.easeIn": $.Easing.Sinusoidal.In,
                    "Expo.easeIn": $.Easing.Exponential.In,
                    "Circ.easeIn": $.Easing.Circular.In,
                    "Elastic.easeIn": $.Easing.Elastic.In,
                    "Back.easeIn": $.Easing.Back.In,
                    "Bounce.easeIn": $.Easing.Bounce.In,
                    "Quad.easeOut": $.Easing.Quadratic.Out,
                    "Cubic.easeOut": $.Easing.Cubic.Out,
                    "Quart.easeOut": $.Easing.Quartic.Out,
                    "Quint.easeOut": $.Easing.Quintic.Out,
                    "Sine.easeOut": $.Easing.Sinusoidal.Out,
                    "Expo.easeOut": $.Easing.Exponential.Out,
                    "Circ.easeOut": $.Easing.Circular.Out,
                    "Elastic.easeOut": $.Easing.Elastic.Out,
                    "Back.easeOut": $.Easing.Back.Out,
                    "Bounce.easeOut": $.Easing.Bounce.Out,
                    "Quad.easeInOut": $.Easing.Quadratic.InOut,
                    "Cubic.easeInOut": $.Easing.Cubic.InOut,
                    "Quart.easeInOut": $.Easing.Quartic.InOut,
                    "Quint.easeInOut": $.Easing.Quintic.InOut,
                    "Sine.easeInOut": $.Easing.Sinusoidal.InOut,
                    "Expo.easeInOut": $.Easing.Exponential.InOut,
                    "Circ.easeInOut": $.Easing.Circular.InOut,
                    "Elastic.easeInOut": $.Easing.Elastic.InOut,
                    "Back.easeInOut": $.Easing.Back.InOut,
                    "Bounce.easeInOut": $.Easing.Bounce.InOut
                };
                this.game.onPause.add(this._pauseAll, this);
                this.game.onResume.add(this._resumeAll, this);
            }, $.TweenManager.prototype = {

                "getAll": function () {
                    return this._tweens;
                },

                "removeAll": function () {

                    var unlock = 0;
                    for (; unlock < this._tweens.length; unlock++) {

                        this._tweens[unlock].pendingDelete = true;
                    }

                    this._add = [];
                },

                "removeFrom": function (target, array) {
                    if (void 0 === array && (array = true), Array.isArray(target)) {

                        property = 0;
                        method = target.length;
                        for (; property < method; property++) {
                            this.removeFrom(target[property]);
                        }
                    } else {
                        if (target.type === $.GROUP && array) {

                            var property = 0;
                            var method = target.children.length;
                            for (; property < method; property++) {
                                this.removeFrom(target.children[property]);
                            }
                        } else {

                            property = 0;
                            method = this._tweens.length;
                            for (; property < method; property++) {
                                if (target === this._tweens[property].target) {
                                    this.remove(this._tweens[property]);
                                }
                            }

                            property = 0;
                            method = this._add.length;
                            for (; property < method; property++) {
                                if (target === this._add[property].target) {
                                    this.remove(this._add[property]);
                                }
                            }
                        }
                    }
                },

                "add": function (vec0) {
                    vec0._manager = this;
                    this._add.push(vec0);
                },

                "create": function (context) {
                    return new($.Tween)(context, this.game, this);
                },

                "remove": function (value) {
                    var strValue = this._tweens.indexOf(value);
                    if (-1 !== strValue) {

                        this._tweens[strValue].pendingDelete = true;
                    } else {
                        if (-1 !== (strValue = this._add.indexOf(value))) {

                            this._add[strValue].pendingDelete = true;
                        }
                    }
                },

                "update": function () {
                    var _0x525c87 = this._add.length;
                    var jj = this._tweens.length;
                    if (0 === jj && 0 === _0x525c87) {
                        return false;
                    }

                    var j = 0;
                    for (; j < jj;) {
                        if (this._tweens[j].update(this.game.time.time)) {
                            j++;
                        } else {
                            this._tweens.splice(j, 1);
                            jj--;
                        }
                    }
                    return _0x525c87 > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), true;
                },

                "isTweening": function (needle, dataAndEvents) {
                    return dataAndEvents || (dataAndEvents = false), this._tweens.some(function (list) {
                        return list.target === needle && (!dataAndEvents || list.isRunning && !list.pendingDelete);
                    });
                },

                "_pauseAll": function () {

                    var unlock = this._tweens.length - 1;
                    for (; unlock >= 0; unlock--) {
                        this._tweens[unlock]._pause();
                    }
                },

                "_resumeAll": function () {

                    var unlock = this._tweens.length - 1;
                    for (; unlock >= 0; unlock--) {
                        this._tweens[unlock]._resume();
                    }
                },

                "pauseAll": function () {

                    var unlock = this._tweens.length - 1;
                    for (; unlock >= 0; unlock--) {
                        this._tweens[unlock].pause();
                    }
                },

                "resumeAll": function () {

                    var unlock = this._tweens.length - 1;
                    for (; unlock >= 0; unlock--) {
                        this._tweens[unlock].resume(true);
                    }
                }
            }, $.TweenManager.prototype.constructor = $.TweenManager, $.Tween = function (deepDataAndEvents, ignoreMethodDoesntExist, dataAndEvents) {
                this.game = ignoreMethodDoesntExist;
                this.target = deepDataAndEvents;

                this.manager = dataAndEvents;

                this.timeline = [];

                this.reverse = false;

                this.timeScale = 1;

                this.repeatCounter = 0;

                this.pendingDelete = false;
                this.onStart = new($.Signal);
                this.onLoop = new($.Signal);
                this.onRepeat = new($.Signal);
                this.onChildComplete = new($.Signal);
                this.onComplete = new($.Signal);

                this.isRunning = false;

                this.current = 0;
                this.properties = {};

                this.chainedTween = null;

                this.isPaused = false;
                this.frameBased = dataAndEvents.frameBased;

                this._onUpdateCallback = null;

                this._onUpdateCallbackContext = null;

                this._pausedTime = 0;

                this._codePaused = false;

                this._hasStarted = false;
            }, $.Tween.updateColor = function (context) {
                $.Color.updateColor(context.target);
            }, $.Tween.prototype = {

                "to": function (value, attr, handler, rgba, to, immediate, recordType) {
                    return (void 0 === attr || attr <= 0) && (attr = 1E3), void 0 !== handler && null !== handler || (handler = $.Easing.Default), void 0 === rgba && (rgba = false), void 0 === to && (to = 0), void 0 === immediate && (immediate = 0), void 0 === recordType && (recordType = false), 'string' == typeof handler && (this.manager.easeMap[handler] && (handler = this.manager.easeMap[handler])), this.isRunning ? (console.warn('Phaser.Tween.to cannot be called after Tween.start'), this) :
                        (this.timeline.push((new($.TweenData)(this)).to(value, attr, handler, to, immediate, recordType)), rgba && this.start(), this);
                },

                "from": function (defaultValue, dataSource, type, withoutSuffix, attr, vars, serialized) {
                    return void 0 === dataSource && (dataSource = 1E3), void 0 !== type && null !== type || (type = $.Easing.Default), void 0 === withoutSuffix && (withoutSuffix = false), void 0 === attr && (attr = 0), void 0 === vars && (vars = 0), void 0 === serialized && (serialized = false), 'string' == typeof type && (this.manager.easeMap[type] && (type = this.manager.easeMap[type])), this.isRunning ? (console.warn('Phaser.Tween.from cannot be called after Tween.start'), this) :
                        (this.timeline.push((new($.TweenData)(this)).from(defaultValue, dataSource, type, attr, vars, serialized)), withoutSuffix && this.start(), this);
                },

                "start": function (index) {
                    if (void 0 === index && (index = 0), this.pendingDelete) {
                        return console.warn('Phaser.Tween.start cannot be called after Tween.stop'), this;
                    }
                    if (null === this.game || (null === this.target || (0 === this.timeline.length || this.isRunning))) {
                        return this;
                    }

                    i = 0;
                    for (; i < this.timeline.length; i++) {
                        var unlock;
                        for (unlock in this.timeline[i].vEnd) {
                            this.properties[unlock] = this.target[unlock] || 0;
                            if (!Array.isArray(this.properties[unlock])) {
                                this.properties[unlock] *= 1;
                            }
                        }
                    }

                    var i = 0;
                    for (; i < this.timeline.length; i++) {
                        this.timeline[i].loadValues();
                    }
                    return this.manager.add(this), this.isRunning = true, (index < 0 || index > this.timeline.length - 1) && (index = 0), this.current = index, this.timeline[this.current].start(), this;
                },

                "stop": function (gotoEnd) {
                    return void 0 === gotoEnd && (gotoEnd = false), this.isRunning = false, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, gotoEnd && (this.onComplete.dispatch(this.target, this), this._hasStarted = false, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this;
                },

                "updateTweenData": function (path, root, ident) {
                    if (0 === this.timeline.length) {
                        return this;
                    }
                    if (void 0 === ident && (ident = 0), -1 === ident) {

                        var i = 0;
                        for (; i < this.timeline.length; i++) {
                            this.timeline[i][path] = root;
                        }
                    } else {
                        this.timeline[ident][path] = root;
                    }
                    return this;
                },

                "delay": function (wait, type) {
                    return this.updateTweenData('delay', wait, type);
                },

                "repeat": function (string, times, sep) {
                    return void 0 === times && (times = 0), this.updateTweenData("repeatCounter", string, sep), this.updateTweenData('repeatTotal', string, sep), this.updateTweenData("repeatDelay", times, sep);
                },

                "repeatDelay": function (value, deepDataAndEvents) {
                    return this.updateTweenData('repeatDelay', value, deepDataAndEvents);
                },

                "yoyo": function (value, opt_obj2, deepDataAndEvents) {
                    return void 0 === opt_obj2 && (opt_obj2 = 0), this.updateTweenData("yoyo", value, deepDataAndEvents), this.updateTweenData("yoyoDelay", opt_obj2, deepDataAndEvents);
                },

                "yoyoDelay": function (deepDataAndEvents, opt_obj2) {
                    return this.updateTweenData("yoyoDelay", deepDataAndEvents, opt_obj2);
                },

                "easing": function (time, easing) {
                    return 'string' == typeof time && (this.manager.easeMap[time] && (time = this.manager.easeMap[time])), this.updateTweenData('easingFunction', time, easing);
                },

                "interpolation": function (text, interpolation, deepDataAndEvents) {
                    return void 0 === interpolation && (interpolation = $.Math), this.updateTweenData('interpolationFunction', text, deepDataAndEvents), this.updateTweenData('interpolationContext', interpolation, deepDataAndEvents);
                },

                "repeatAll": function (dataAndEvents) {
                    return void 0 === dataAndEvents && (dataAndEvents = 0), this.repeatCounter = dataAndEvents, this;
                },

                "chain": function () {
                    var n = arguments.length;
                    for (; n--;) {
                        if (n > 0) {
                            arguments[n - 1].chainedTween = arguments[n];
                        } else {
                            this.chainedTween = arguments[n];
                        }
                    }
                    return this;
                },

                "loop": function (domEl) {
                    return void 0 === domEl && (domEl = true), this.repeatCounter = domEl ? -1 : 0, this;
                },

                "onUpdateCallback": function (dataAndEvents, callback) {
                    return this._onUpdateCallback = dataAndEvents, this._onUpdateCallbackContext = callback, this;
                },

                "pause": function () {

                    this.isPaused = true;

                    this._codePaused = true;
                    this._pausedTime = this.game.time.time;
                },

                "_pause": function () {
                    if (!this._codePaused) {

                        this.isPaused = true;
                        this._pausedTime = this.game.time.time;
                    }
                },

                "resume": function () {
                    if (this.isPaused) {

                        this.isPaused = false;

                        this._codePaused = false;

                        var unlock = 0;
                        for (; unlock < this.timeline.length; unlock++) {
                            if (!this.timeline[unlock].isRunning) {
                                this.timeline[unlock].startTime += this.game.time.time - this._pausedTime;
                            }
                        }
                    }
                },

                "_resume": function () {
                    if (!this._codePaused) {
                        this.resume();
                    }
                },

                "update": function (element) {
                    if (this.pendingDelete || !this.target) {
                        return false;
                    }
                    if (this.isPaused) {
                        return true;
                    }
                    var elementRect = this.timeline[this.current].update(element);
                    if (elementRect === $.TweenData.PENDING) {
                        return true;
                    }
                    if (elementRect === $.TweenData.RUNNING) {
                        return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = true), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                    }
                    if (elementRect === $.TweenData.LOOPED) {
                        return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), true;
                    }
                    if (elementRect === $.TweenData.COMPLETE) {

                        var _0x20f17c = false;
                        return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, _0x20f17c = true) : ++this.current === this.timeline.length && (this.current = 0, _0x20f17c = true), _0x20f17c ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), true) : this.repeatCounter > 0 ? (this.repeatCounter--,
                            this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), true) : (this.isRunning = false, this.onComplete.dispatch(this.target, this), this._hasStarted = false, this.chainedTween && this.chainedTween.start(), false) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), true);
                    }
                },

                "generateData": function (resp, collection) {
                    if (null === this.game || null === this.target) {
                        return null;
                    }
                    if (void 0 === resp) {

                        resp = 60;
                    }
                    if (void 0 === collection) {

                        collection = [];
                    }

                    i = 0;
                    for (; i < this.timeline.length; i++) {
                        var unlock;
                        for (unlock in this.timeline[i].vEnd) {
                            this.properties[unlock] = this.target[unlock] || 0;
                            if (!Array.isArray(this.properties[unlock])) {
                                this.properties[unlock] *= 1;
                            }
                        }
                    }

                    i = 0;
                    for (; i < this.timeline.length; i++) {
                        this.timeline[i].loadValues();
                    }

                    var i = 0;
                    for (; i < this.timeline.length; i++) {
                        collection = collection.concat(this.timeline[i].generateData(resp));
                    }
                    return collection;
                }
            }, Object.defineProperty($.Tween.prototype, 'totalDuration', {

                "get": function () {

                    var entries = 0;

                    var unlock = 0;
                    for (; unlock < this.timeline.length; unlock++) {
                        entries += this.timeline[unlock].duration;
                    }
                    return entries;
                }
            }), $.Tween.prototype.constructor = $.Tween, $.TweenData = function (dataAndEvents) {
                this.parent = dataAndEvents;
                this.game = dataAndEvents.game;
                this.vStart = {};
                this.vStartCache = {};
                this.vEnd = {};
                this.vEndCache = {};

                this.duration = 1E3;

                this.percent = 0;

                this.value = 0;

                this.repeatCounter = 0;

                this.repeatDelay = 0;

                this.repeatTotal = 0;

                this.interpolate = false;

                this.yoyo = false;

                this.yoyoDelay = 0;

                this.inReverse = false;

                this.delay = 0;

                this.dt = 0;

                this.startTime = null;
                this.easingFunction = $.Easing.Default;
                this.interpolationFunction = $.Math.linearInterpolation;
                this.interpolationContext = $.Math;

                this.isRunning = false;

                this.isFrom = false;
            }, $.TweenData.PENDING = 0, $.TweenData.RUNNING = 1, $.TweenData.LOOPED = 2, $.TweenData.COMPLETE = 3, $.TweenData.prototype = {

                "to": function (x, y, rgba, immediate, parentRecord, attr) {
                    return this.vEnd = x, this.duration = y, this.easingFunction = rgba, this.delay = immediate, this.repeatTotal = parentRecord, this.yoyo = attr, this.isFrom = false, this;
                },

                "from": function (defaultValue, withoutSuffix, newReference, value, excludeScripts, record) {
                    return this.vEnd = defaultValue, this.duration = withoutSuffix, this.easingFunction = newReference, this.delay = value, this.repeatTotal = excludeScripts, this.yoyo = record, this.isFrom = true, this;
                },

                "start": function () {
                    if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = false : this.isRunning = true, this.isFrom) {
                        var currentParam;
                        for (currentParam in this.vStartCache) {
                            this.vStart[currentParam] = this.vEndCache[currentParam];
                            this.vEnd[currentParam] = this.vStartCache[currentParam];
                            this.parent.target[currentParam] = this.vStart[currentParam];
                        }
                    }
                    return this.value = 0, this.repeatCounter = this.repeatTotal, this;
                },

                "loadValues": function () {
                    var i;
                    for (i in this.parent.properties) {
                        if (this.vStart[i] = this.parent.properties[i], Array.isArray(this.vEnd[i])) {
                            if (0 === this.vEnd[i].length) {
                                continue;
                            }
                            if (0 === this.percent) {
                                this.vEnd[i] = [this.vStart[i]].concat(this.vEnd[i]);
                            }
                        }
                        if (void 0 !== this.vEnd[i]) {
                            if ('string' == typeof this.vEnd[i]) {
                                this.vEnd[i] = this.vStart[i] + parseFloat(this.vEnd[i], 10);
                            }
                            this.parent.properties[i] = this.vEnd[i];
                        } else {
                            this.vEnd[i] = this.vStart[i];
                        }
                        this.vStartCache[i] = this.vStart[i];
                        this.vEndCache[i] = this.vEnd[i];
                    }
                    return this;
                },

                "update": function (allBindingsAccessor) {
                    if (this.isRunning) {
                        if (allBindingsAccessor < this.startTime) {
                            return $.TweenData.RUNNING;
                        }
                    } else {
                        if (!(allBindingsAccessor >= this.startTime)) {
                            return $.TweenData.PENDING;
                        }

                        this.isRunning = true;
                    }
                    var timeScale = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                    if (this.parent.reverse) {
                        this.dt -= timeScale * this.parent.timeScale;
                        this.dt = Math.max(this.dt, 0);
                    } else {
                        this.dt += timeScale * this.parent.timeScale;
                        this.dt = Math.min(this.dt, this.duration);
                    }

                    this.percent = this.dt / this.duration;
                    this.value = this.easingFunction(this.percent);
                    var eventName;
                    for (eventName in this.vEnd) {
                        var eventSubscribers = this.vStart[eventName];
                        var callback = this.vEnd[eventName];
                        if (Array.isArray(callback)) {
                            this.parent.target[eventName] = this.interpolationFunction.call(this.interpolationContext, callback, this.value);
                        } else {
                            this.parent.target[eventName] = eventSubscribers + (callback - eventSubscribers) * this.value;
                        }
                    }
                    return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : $.TweenData.RUNNING;
                },

                "generateData": function (dataAndEvents) {
                    if (this.parent.reverse) {
                        this.dt = this.duration;
                    } else {

                        this.dt = 0;
                    }

                    var doc = [];

                    var _0x1ee4f6 = false;

                    var dt = 1 / dataAndEvents * 1E3;
                    do {
                        if (this.parent.reverse) {
                            this.dt -= dt;
                            this.dt = Math.max(this.dt, 0);
                        } else {
                            this.dt += dt;
                            this.dt = Math.min(this.dt, this.duration);
                        }

                        this.percent = this.dt / this.duration;
                        this.value = this.easingFunction(this.percent);
                        var target = {};
                        var name;
                        for (name in this.vEnd) {
                            var cur = this.vStart[name];
                            var clone = this.vEnd[name];
                            if (Array.isArray(clone)) {
                                target[name] = this.interpolationFunction.call(this.interpolationContext, clone, this.value);
                            } else {
                                target[name] = cur + (clone - cur) * this.value;
                            }
                        }
                        doc.push(target);
                        if (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) {

                            _0x1ee4f6 = true;
                        }
                    } while (!_0x1ee4f6);
                    if (this.yoyo) {
                        var text = doc.slice();
                        text.reverse();
                        doc = doc.concat(text);
                    }
                    return doc;
                },

                "repeat": function () {
                    if (this.yoyo) {
                        if (this.inReverse && 0 === this.repeatCounter) {
                            var currentParam;
                            for (currentParam in this.vStartCache) {
                                this.vStart[currentParam] = this.vStartCache[currentParam];
                                this.vEnd[currentParam] = this.vEndCache[currentParam];
                            }
                            return this.inReverse = false, $.TweenData.COMPLETE;
                        }

                        this.inReverse = !this.inReverse;
                    } else {
                        if (0 === this.repeatCounter) {
                            return $.TweenData.COMPLETE;
                        }
                    }
                    if (this.inReverse) {
                        for (currentParam in this.vStartCache) {
                            this.vStart[currentParam] = this.vEndCache[currentParam];
                            this.vEnd[currentParam] = this.vStartCache[currentParam];
                        }
                    } else {
                        for (currentParam in this.vStartCache) {
                            this.vStart[currentParam] = this.vStartCache[currentParam];
                            this.vEnd[currentParam] = this.vEndCache[currentParam];
                        }
                        if (this.repeatCounter > 0) {
                            this.repeatCounter--;
                        }
                    }
                    return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, $.TweenData.LOOPED;
                }
            }, $.TweenData.prototype.constructor = $.TweenData, $.Easing = {
                "Linear": {

                    "None": function (data) {
                        return data;
                    }
                },
                "Quadratic": {

                    "In": function (k) {
                        return k * k;
                    },

                    "Out": function (k) {
                        return k * (2 - k);
                    },

                    "InOut": function (k) {
                        return (k *= 2) < 1 ? 0.5 * k * k : -0.5 * (--k * (k - 2) - 1);
                    }
                },
                "Cubic": {

                    "In": function (k) {
                        return k * k * k;
                    },

                    "Out": function (k) {
                        return --k * k * k + 1;
                    },

                    "InOut": function (k) {
                        return (k *= 2) < 1 ? 0.5 * k * k * k : 0.5 * ((k -= 2) * k * k + 2);
                    }
                },
                "Quartic": {

                    "In": function (k) {
                        return k * k * k * k;
                    },

                    "Out": function (k) {
                        return 1 - --k * k * k * k;
                    },

                    "InOut": function (k) {
                        return (k *= 2) < 1 ? 0.5 * k * k * k * k : -0.5 * ((k -= 2) * k * k * k - 2);
                    }
                },
                "Quintic": {

                    "In": function (k) {
                        return k * k * k * k * k;
                    },

                    "Out": function (k) {
                        return --k * k * k * k * k + 1;
                    },

                    "InOut": function (k) {
                        return (k *= 2) < 1 ? 0.5 * k * k * k * k * k : 0.5 * ((k -= 2) * k * k * k * k + 2);
                    }
                },
                "Sinusoidal": {

                    "In": function (object) {
                        return 0 === object ? 0 : 1 === object ? 1 : 1 - Math.cos(object * Math.PI / 2);
                    },

                    "Out": function (event) {
                        return 0 === event ? 0 : 1 === event ? 1 : Math.sin(event * Math.PI / 2);
                    },

                    "InOut": function (k) {
                        return 0 === k ? 0 : 1 === k ? 1 : 0.5 * (1 - Math.cos(Math.PI * k));
                    }
                },
                "Exponential": {

                    "In": function (object) {
                        return 0 === object ? 0 : Math.pow(1024, object - 1);
                    },

                    "Out": function (event) {
                        return 1 === event ? 1 : 1 - Math.pow(2, -10 * event);
                    },

                    "InOut": function (k) {
                        return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? 0.5 * Math.pow(1024, k - 1) : 0.5 * (2 - Math.pow(2, -10 * (k - 1)));
                    }
                },
                "Circular": {

                    "In": function (k) {
                        return 1 - Math.sqrt(1 - k * k);
                    },

                    "Out": function (k) {
                        return Math.sqrt(1 - --k * k);
                    },

                    "InOut": function (k) {
                        return (k *= 2) < 1 ? -0.5 * (Math.sqrt(1 - k * k) - 1) : 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                    }
                },
                "Elastic": {

                    "In": function (far) {
                        var near;

                        var lowestDeltaXY = 0.1;
                        return 0 === far ? 0 : 1 === far ? 1 : (!lowestDeltaXY || lowestDeltaXY < 1 ? (lowestDeltaXY = 1, near = 0.1) : near = 0.4 * Math.asin(1 / lowestDeltaXY) / (2 * Math.PI), -lowestDeltaXY * Math.pow(2, 10 * (far -= 1)) * Math.sin((far - near) * (2 * Math.PI) / 0.4));
                    },

                    "Out": function (g) {
                        var b;

                        var a = 0.1;
                        return 0 === g ? 0 : 1 === g ? 1 : (!a || a < 1 ? (a = 1, b = 0.1) : b = 0.4 * Math.asin(1 / a) / (2 * Math.PI), a * Math.pow(2, -10 * g) * Math.sin((g - b) * (2 * Math.PI) / 0.4) + 1);
                    },

                    "InOut": function (k) {
                        var x;

                        var j = 0.1;
                        return 0 === k ? 0 : 1 === k ? 1 : (!j || j < 1 ? (j = 1, x = 0.1) : x = 0.4 * Math.asin(1 / j) / (2 * Math.PI), (k *= 2) < 1 ? j * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - x) * (2 * Math.PI) / 0.4) * -0.5 : j * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - x) * (2 * Math.PI) / 0.4) * 0.5 + 1);
                    }
                },
                "Back": {

                    "In": function (k) {

                        var s = 1.70158;
                        return k * k * ((s + 1) * k - s);
                    },

                    "Out": function (k) {

                        var b = 1.70158;
                        return --k * k * ((b + 1) * k + b) + 1;
                    },

                    "InOut": function (k) {

                        var s = 2.5949095;
                        return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * 0.5 : 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                    }
                },
                "Bounce": {

                    "In": function (object) {
                        return 1 - $.Easing.Bounce.Out(1 - object);
                    },

                    "Out": function (k) {
                        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + 0.75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375 : 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
                    },

                    "InOut": function (k) {
                        return k < 0.5 ? 0.5 * $.Easing.Bounce.In(2 * k) : 0.5 * $.Easing.Bounce.Out(2 * k - 1) + 0.5;
                    }
                }
            }, $.Easing.Default = $.Easing.Linear.None, $.Easing.Power0 = $.Easing.Linear.None, $.Easing.Power1 = $.Easing.Quadratic.Out, $.Easing.Power2 = $.Easing.Cubic.Out, $.Easing.Power3 = $.Easing.Quartic.Out, $.Easing.Power4 = $.Easing.Quintic.Out,
            $.Time = function (dataAndEvents) {
                this.game = dataAndEvents;

                this.time = 0;

                this.prevTime = 0;

                this.now = 0;

                this.elapsed = 0;

                this.elapsedMS = 0;

                this.physicsElapsed = 1 / 60;

                this.physicsElapsedMS = 1 / 60 * 1E3;

                this.desiredFpsMult = 1 / 60;

                this._desiredFps = 60;
                this.suggestedFps = this.desiredFps;

                this.slowMotion = 1;

                this.advancedTiming = false;

                this.frames = 0;

                this.updates = 0;

                this.renders = 0;

                this.fps = 0;

                this.ups = 0;

                this.rps = 0;

                this.fpsMin = 1E3;

                this.fpsMax = 0;

                this.msMin = 1E3;

                this.msMax = 0;

                this.pauseDuration = 0;

                this.timeToCall = 0;

                this.timeExpected = 0;
                this.events = new($.Timer)(this.game, false);

                this._frameCount = 0;

                this._elapsedAccumulator = 0;

                this._started = 0;

                this._timeLastSecond = 0;

                this._pauseStarted = 0;

                this._justResumed = false;

                this._timers = [];
            }, $.Time.prototype = {

                "boot": function () {
                    this._started = Date.now();
                    this.time = Date.now();
                    this.events.start();
                    this.timeExpected = this.time;
                },

                "add": function (vec0) {
                    return this._timers.push(vec0), vec0;
                },

                "create": function (timeout) {
                    if (void 0 === timeout) {

                        timeout = true;
                    }
                    var waitsFunc = new $.Timer(this.game, timeout);
                    return this._timers.push(waitsFunc), waitsFunc;
                },

                "removeAll": function () {

                    var unlock = 0;
                    for (; unlock < this._timers.length; unlock++) {
                        this._timers[unlock].destroy();
                    }

                    this._timers = [];
                    this.events.removeAll();
                },

                "refresh": function () {
                    var time = this.time;
                    this.time = Date.now();

                    this.elapsedMS = this.time - time;
                },

                "update": function (allBindingsAccessor) {
                    var _0x2dca91 = this.time;
                    this.time = Date.now();

                    this.elapsedMS = this.time - _0x2dca91;
                    this.prevTime = this.now;
                    this.now = allBindingsAccessor;

                    this.elapsed = this.now - this.prevTime;
                    if (this.game.raf._isSetTimeOut) {
                        this.timeToCall = Math.floor(Math.max(0, 1E3 / this._desiredFps - (this.timeExpected - allBindingsAccessor)));
                        this.timeExpected = allBindingsAccessor + this.timeToCall;
                    }
                    if (this.advancedTiming) {
                        this.updateAdvancedTiming();
                    }
                    if (!this.game.paused) {
                        this.events.update(this.time);
                        if (this._timers.length) {
                            this.updateTimers();
                        }
                    }
                },

                "updateTimers": function () {

                    var j = 0;
                    var jj = this._timers.length;
                    for (; j < jj;) {
                        if (this._timers[j].update(this.time)) {
                            j++;
                        } else {
                            this._timers.splice(j, 1);
                            jj--;
                        }
                    }
                },

                "updateAdvancedTiming": function () {
                    if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond +
                        1E3) {

                        var lowestDeltaXY = this.now - this._timeLastSecond;
                        this.fps = Math.round(1E3 * this.frames / lowestDeltaXY);
                        this.ups = Math.round(1E3 * this.updates / lowestDeltaXY);
                        this.rps = Math.round(1E3 * this.renders / lowestDeltaXY);
                        this.fpsMin = Math.min(this.fpsMin, this.fps);
                        this.fpsMax = Math.max(this.fpsMax, this.fps);
                        this._timeLastSecond = this.now;

                        this.frames = 0;

                        this.updates = 0;

                        this.renders = 0;
                    }
                },

                "countUpdate": function () {
                    if (this.advancedTiming) {
                        this.updates++;
                    }
                },

                "countRender": function () {
                    if (this.advancedTiming) {
                        this.renders++;
                    }
                },

                "gamePaused": function () {
                    this._pauseStarted = Date.now();
                    this.events.pause();
                    var unlock = this._timers.length;
                    for (; unlock--;) {
                        this._timers[unlock]._pause();
                    }
                },

                "gameResumed": function () {
                    this.time = Date.now();

                    this.pauseDuration = this.time - this._pauseStarted;
                    this.events.resume();
                    var unlock = this._timers.length;
                    for (; unlock--;) {
                        this._timers[unlock]._resume();
                    }
                },

                "totalElapsedSeconds": function () {
                    return 0.001 * (this.time - this._started);
                },

                "elapsedSince": function (since) {
                    return this.time - since;
                },

                "elapsedSecondsSince": function (since) {
                    return 0.001 * (this.time - since);
                },

                "reset": function () {
                    this._started = this.time;
                    this.removeAll();
                }
            }, Object.defineProperty($.Time.prototype, 'desiredFps', {

                "get": function () {
                    return this._desiredFps;
                },

                "set": function (mL) {
                    this._desiredFps = mL;

                    this.physicsElapsed = 1 / mL;

                    this.physicsElapsedMS = 1E3 * this.physicsElapsed;

                    this.desiredFpsMult = 1 / mL;
                }
            }), $.Time.prototype.constructor = $.Time, $.Timer = function (dataAndEvents, deepDataAndEvents) {
                if (void 0 === deepDataAndEvents) {

                    deepDataAndEvents = true;
                }
                this.game = dataAndEvents;

                this.running = false;

                this.autoDestroy = deepDataAndEvents;

                this.expired = false;

                this.elapsed = 0;

                this.events = [];
                this.onComplete = new($.Signal);

                this.nextTick = 0;

                this.timeCap = 1E3;

                this.paused = false;

                this._codePaused = false;

                this._started = 0;

                this._pauseStarted = 0;

                this._pauseTotal = 0;
                this._now = Date.now();

                this._len = 0;

                this._marked = 0;

                this._i = 0;

                this._diff = 0;

                this._newTick = 0;
            }, $.Timer.MINUTE = 6E4, $.Timer.SECOND = 1E3, $.Timer.HALF = 500, $.Timer.QUARTER = 250, $.Timer.prototype = {

                "create": function (y, var_args, minutes, moduleNames, title, now) {
                    var latchFunction_ = y = Math.round(y);
                    if (0 === this._now) {
                        latchFunction_ += this.game.time.time;
                    } else {
                        latchFunction_ += this._now;
                    }
                    var waitsForFunc = new($.TimerEvent)(this, y, latchFunction_, minutes, var_args, moduleNames, title, now);
                    return this.events.push(waitsForFunc), this.order(), this.expired = false, waitsForFunc;
                },

                "add": function (vec0, vec1, fake) {
                    return this.create(vec0, false, 0, vec1, fake, Array.prototype.slice.call(arguments, 3));
                },

                "repeat": function (string, times, sep, str) {
                    return this.create(string, false, times, sep, str, Array.prototype.slice.call(arguments, 4));
                },

                "loop": function (ms, director, debug) {
                    return this.create(ms, true, 0, director, debug, Array.prototype.slice.call(arguments, 3));
                },

                "start": function (ui) {
                    if (!this.running) {
                        this._started = this.game.time.time + (ui || 0);

                        this.running = true;

                        var unlock = 0;
                        for (; unlock < this.events.length; unlock++) {
                            this.events[unlock].tick = this.events[unlock].delay + this._started;
                        }
                    }
                },

                "stop": function (gotoEnd) {

                    this.running = false;
                    if (void 0 === gotoEnd) {

                        gotoEnd = true;
                    }
                    if (gotoEnd) {

                        this.events.length = 0;
                    }
                },

                "remove": function (keepData) {

                    var unlock = 0;
                    for (; unlock < this.events.length; unlock++) {
                        if (this.events[unlock] === keepData) {
                            return this.events[unlock].pendingDelete = true, true;
                        }
                    }
                    return false;
                },

                "order": function () {
                    if (this.events.length > 0) {
                        this.events.sort(this.sortHandler);
                        this.nextTick = this.events[0].tick;
                    }
                },

                "sortHandler": function (a, b) {
                    return a.tick < b.tick ? -1 : a.tick > b.tick ? 1 : 0;
                },

                "clearPendingEvents": function () {
                    this._i = this.events.length;
                    for (; this._i--;) {
                        if (this.events[this._i].pendingDelete) {
                            this.events.splice(this._i, 1);
                        }
                    }
                    this._len = this.events.length;

                    this._i = 0;
                },

                "update": function (elapsed) {
                    if (this.paused) {
                        return true;
                    }
                    if (this.elapsed = elapsed - this._now, this._now = elapsed, this.elapsed > this.timeCap && this.adjustEvents(elapsed - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && (this._now >= this.nextTick && this._len > 0)) {
                        for (; this._i < this._len && this.running;) {
                            var buffer = this.events[this._i];
                            if (!(this._now >= buffer.tick) || buffer.pendingDelete) {
                                break;
                            }

                            this._newTick = this._now + buffer.delay - (this._now - buffer.tick);
                            if (this._newTick < 0) {
                                this._newTick = this._now + buffer.delay;
                            }
                            if (true === buffer.loop) {
                                buffer.tick = this._newTick;
                                buffer.callback.apply(buffer.callbackContext, buffer.args);
                            } else {
                                if (buffer.repeatCount > 0) {
                                    buffer.repeatCount--;
                                    buffer.tick = this._newTick;
                                    buffer.callback.apply(buffer.callbackContext, buffer.args);
                                } else {
                                    this._marked++;

                                    buffer.pendingDelete = true;
                                    buffer.callback.apply(buffer.callbackContext, buffer.args);
                                }
                            }
                            this._i++;
                        }
                        if (this.events.length > this._marked) {
                            this.order();
                        } else {

                            this.expired = true;
                            this.onComplete.dispatch(this);
                        }
                    }
                    return !this.expired || !this.autoDestroy;
                },

                "pause": function () {
                    if (this.running) {

                        this._codePaused = true;
                        if (!this.paused) {
                            this._pauseStarted = this.game.time.time;

                            this.paused = true;
                        }
                    }
                },

                "_pause": function () {
                    if (!this.paused) {
                        if (this.running) {
                            this._pauseStarted = this.game.time.time;

                            this.paused = true;
                        }
                    }
                },

                "adjustEvents": function (near) {

                    var unlock = 0;
                    for (; unlock < this.events.length; unlock++) {
                        if (!this.events[unlock].pendingDelete) {

                            var dz = this.events[unlock].tick - near;
                            if (dz < 0) {

                                dz = 0;
                            }
                            this.events[unlock].tick = this._now + dz;
                        }
                    }

                    var fn = this.nextTick - near;
                    this.nextTick = fn < 0 ? this._now : this._now + fn;
                },

                "resume": function () {
                    if (this.paused) {
                        var time = this.game.time.time;
                        this._pauseTotal += time - this._now;
                        this._now = time;
                        this.adjustEvents(this._pauseStarted);

                        this.paused = false;

                        this._codePaused = false;
                    }
                },

                "_resume": function () {
                    if (!this._codePaused) {
                        this.resume();
                    }
                },

                "removeAll": function () {
                    this.onComplete.removeAll();

                    this.events.length = 0;

                    this._len = 0;

                    this._i = 0;
                },

                "destroy": function () {
                    this.onComplete.removeAll();

                    this.running = false;

                    this.expired = true;

                    this.events = [];

                    this._len = 0;

                    this._i = 0;
                }
            }, Object.defineProperty($.Timer.prototype, 'next', {

                "get": function () {
                    return this.nextTick;
                }
            }), Object.defineProperty($.Timer.prototype, "duration", {

                "get": function () {
                    return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0;
                }
            }), Object.defineProperty($.Timer.prototype, 'length', {

                "get": function () {
                    return this.events.length;
                }
            }), Object.defineProperty($.Timer.prototype, "ms", {

                "get": function () {
                    return this.running ? this._now - this._started - this._pauseTotal : 0;
                }
            }), Object.defineProperty($.Timer.prototype, "seconds", {

                "get": function () {
                    return this.running ? 0.001 * this.ms : 0;
                }
            }), $.Timer.prototype.constructor = $.Timer, $.TimerEvent = function (ignoreMethodDoesntExist, textAlt, dataAndEvents, deepDataAndEvents, keepData, opt_attributes, matcherFunction, execResult) {
                this.timer = ignoreMethodDoesntExist;
                this.delay = textAlt;
                this.tick = dataAndEvents;

                this.repeatCount = deepDataAndEvents - 1;
                this.loop = keepData;
                this.callback = opt_attributes;
                this.callbackContext = matcherFunction;
                this.args = execResult;

                this.pendingDelete = false;
            }, $.TimerEvent.prototype.constructor = $.TimerEvent, $.AnimationManager = function (dataAndEvents) {
                this.sprite = dataAndEvents;
                this.game = dataAndEvents.game;

                this.currentFrame = null;

                this.currentAnim = null;

                this.updateIfVisible = true;

                this.isLoaded = false;

                this._frameData = null;
                this._anims = {};

                this._outputFrames = [];
            }, $.AnimationManager.prototype = {

                "loadFrameData": function (frameData, dataAndEvents) {
                    if (void 0 === frameData) {
                        return false;
                    }
                    if (this.isLoaded) {
                        var unlock;
                        for (unlock in this._anims) {
                            this._anims[unlock].updateFrameData(frameData);
                        }
                    }
                    return this._frameData = frameData, void 0 === dataAndEvents || null === dataAndEvents ? this.frame = 0 : 'string' == typeof dataAndEvents ? this.frameName = dataAndEvents : this.frame = dataAndEvents, this.isLoaded = true, true;
                },

                "copyFrameData": function (dataAndEvents, deepDataAndEvents) {
                    if (this._frameData = dataAndEvents.clone(), this.isLoaded) {
                        var unlock;
                        for (unlock in this._anims) {
                            this._anims[unlock].updateFrameData(this._frameData);
                        }
                    }
                    return void 0 === deepDataAndEvents || null === deepDataAndEvents ? this.frame = 0 : 'string' == typeof deepDataAndEvents ? this.frameName = deepDataAndEvents : this.frame = deepDataAndEvents, this.isLoaded = true, true;
                },

                "add": function (key, details, models, vec0, vec1) {
                    return details = details || [], models = models || 60, void 0 === vec0 && (vec0 = false), void 0 === vec1 && (vec1 = !(!details || 'number' != typeof details[0])), this._outputFrames = [], this._frameData.getFrameIndexes(details, vec1, this._outputFrames), this._anims[key] = new($.Animation)(this.game, this.sprite, key, this._frameData, this._outputFrames, models, vec0), this.currentAnim = this._anims[key], this.sprite.tilingTexture &&
                        (this.sprite.refreshTexture = true), this._anims[key];
                },

                "validateFrames": function ($cookies, useNumericIndex) {
                    if (void 0 === useNumericIndex) {

                        useNumericIndex = true;
                    }

                    var key = 0;
                    for (; key < $cookies.length; key++) {
                        if (true === useNumericIndex) {
                            if ($cookies[key] > this._frameData.total) {
                                return false;
                            }
                        } else {
                            if (false === this._frameData.checkFrameName($cookies[key])) {
                                return false;
                            }
                        }
                    }
                    return true;
                },

                "play": function (action, options, delay, opt_restart) {
                    if (this._anims[action]) {
                        return this.currentAnim === this._anims[action] ? false === this.currentAnim.isPlaying ? (this.currentAnim.paused = false, this.currentAnim.play(options, delay, opt_restart)) : this.currentAnim : (this.currentAnim && (this.currentAnim.isPlaying && this.currentAnim.stop()), this.currentAnim = this._anims[action], this.currentAnim.paused = false, this.currentFrame =
                            this.currentAnim.currentFrame, this.currentAnim.play(options, delay, opt_restart));
                    }
                },

                "stop": function (val, gotoEnd) {
                    if (void 0 === gotoEnd) {

                        gotoEnd = false;
                    }
                    if (!!this.currentAnim) {
                        if (!('string' == typeof val && val !== this.currentAnim.name)) {
                            this.currentAnim.stop(gotoEnd);
                        }
                    }
                },

                "update": function () {
                    return !(this.updateIfVisible && !this.sprite.visible || (!this.currentAnim || (!this.currentAnim.update() || (this.currentFrame = this.currentAnim.currentFrame, 0))));
                },

                "next": function (shallow) {
                    if (this.currentAnim) {
                        this.currentAnim.next(shallow);
                        this.currentFrame = this.currentAnim.currentFrame;
                    }
                },

                "previous": function (n) {
                    if (this.currentAnim) {
                        this.currentAnim.previous(n);
                        this.currentFrame = this.currentAnim.currentFrame;
                    }
                },

                "getAnimation": function (index) {
                    return "string" == typeof index && this._anims[index] ? this._anims[index] : null;
                },

                "refreshFrame": function () {},

                "destroy": function () {

                    sel = null;
                    var sel;
                    for (sel in this._anims) {
                        if (this._anims.hasOwnProperty(sel)) {
                            this._anims[sel].destroy();
                        }
                    }
                    this._anims = {};

                    this._outputFrames = [];

                    this._frameData = null;

                    this.currentAnim = null;

                    this.currentFrame = null;

                    this.sprite = null;

                    this.game = null;
                }
            }, $.AnimationManager.prototype.constructor = $.AnimationManager, Object.defineProperty($.AnimationManager.prototype, 'frameData', {

                "get": function () {
                    return this._frameData;
                }
            }), Object.defineProperty($.AnimationManager.prototype, 'frameTotal', {

                "get": function () {
                    return this._frameData.total;
                }
            }), Object.defineProperty($.AnimationManager.prototype, 'paused', {

                "get": function () {
                    return this.currentAnim.isPaused;
                },

                "set": function (mL) {
                    this.currentAnim.paused = mL;
                }
            }), Object.defineProperty($.AnimationManager.prototype, 'name', {

                "get": function () {
                    if (this.currentAnim) {
                        return this.currentAnim.name;
                    }
                }
            }), Object.defineProperty($.AnimationManager.prototype, 'frame', {

                "get": function () {
                    if (this.currentFrame) {
                        return this.currentFrame.index;
                    }
                },

                "set": function (dest) {
                    var pdataCur;
                    if ('number' == typeof dest) {
                        if (this._frameData) {
                            if (pdataCur = this._frameData.getFrame(dest)) {
                                this.currentFrame = pdataCur;
                                this.sprite.setFrame(this.currentFrame);
                            }
                        }
                    }
                }
            }), Object.defineProperty($.AnimationManager.prototype, 'frameName', {

                "get": function () {
                    if (this.currentFrame) {
                        return this.currentFrame.name;
                    }
                },

                "set": function (dest) {
                    var pdataCur;
                    if ('string' == typeof dest && (this._frameData && (pdataCur = this._frameData.getFrameByName(dest)))) {
                        this.currentFrame = pdataCur;
                        this._frameIndex = this.currentFrame.index;
                        this.sprite.setFrame(this.currentFrame);
                    } else {
                        console.warn('Cannot set frameName: ' + dest);
                    }
                }
            }), $.Animation = function (dataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, deepDataAndEvents, opt_attributes, matcherFunction) {
                if (void 0 === matcherFunction) {

                    matcherFunction = false;
                }
                this.game = dataAndEvents;
                this._parent = ignoreMethodDoesntExist;
                this._frameData = keepData;
                this.name = textAlt;

                this._frames = [];
                this._frames = this._frames.concat(deepDataAndEvents);

                this.delay = 1E3 / opt_attributes;

                this.loop = matcherFunction;

                this.loopCount = 0;

                this.killOnComplete = false;

                this.isFinished = false;

                this.isPlaying = false;

                this.isPaused = false;

                this._pauseStartTime = 0;

                this._frameIndex = 0;

                this._frameDiff = 0;

                this._frameSkip = 1;
                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                this.onStart = new($.Signal);

                this.onUpdate = null;
                this.onComplete = new($.Signal);
                this.onLoop = new($.Signal);

                this.isReversed = false;
                this.game.onPause.add(this.onPause, this);
                this.game.onResume.add(this.onResume, this);
            }, $.Animation.prototype = {

                "play": function (options, action, a) {
                    return 'number' == typeof options && (this.delay = 1E3 / options), 'boolean' == typeof action && (this.loop = action), void 0 !== a && (this.killOnComplete = a), this.isPlaying = true, this.isFinished = false, this.paused = false, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex =
                        this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(false, true), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this;
                },

                "restart": function () {

                    this.isPlaying = true;

                    this.isFinished = false;

                    this.paused = false;

                    this.loopCount = 0;
                    this._timeLastFrame = this.game.time.time;
                    this._timeNextFrame = this.game.time.time + this.delay;

                    this._frameIndex = 0;
                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                    this._parent.setFrame(this.currentFrame);
                    this._parent.animations.currentAnim = this;
                    this._parent.animations.currentFrame = this.currentFrame;
                    this.onStart.dispatch(this._parent, this);
                },

                "reverse": function () {
                    return this.reversed = !this.reversed, this;
                },

                "reverseOnce": function () {
                    return this.onComplete.addOnce(this.reverse, this), this.reverse();
                },

                "setFrame": function (val, b) {
                    var to;
                    if (void 0 === b && (b = false), 'string' == typeof val) {

                        i = 0;
                        for (; i < this._frames.length; i++) {
                            if (this._frameData.getFrame(this._frames[i]).name === val) {

                                to = i;
                            }
                        }
                    } else {
                        if ('number' == typeof val) {
                            if (b) {

                                to = val;
                            } else {

                                var i = 0;
                                for (; i < this._frames.length; i++) {
                                    if (this._frames[i] === val) {

                                        to = i;
                                    }
                                }
                            }
                        }
                    }
                    if (to) {

                        var from = this.isReversed ? -1 : 1;

                        this._frameIndex = to - from;
                        this._timeNextFrame = this.game.time.time;
                        this.update();
                    }
                },

                "stop": function (gotoEnd, ui) {
                    if (void 0 === gotoEnd) {

                        gotoEnd = false;
                    }
                    if (void 0 === ui) {

                        ui = false;
                    }

                    this.isPlaying = false;

                    this.isFinished = true;

                    this.paused = false;
                    if (gotoEnd) {
                        this.currentFrame = this._frameData.getFrame(this._frames[0]);
                        this._parent.setFrame(this.currentFrame);
                    }
                    if (ui) {
                        this._parent.events.onAnimationComplete$dispatch(this._parent, this);
                        this.onComplete.dispatch(this._parent, this);
                    }
                },

                "onPause": function () {
                    if (this.isPlaying) {

                        this._frameDiff = this._timeNextFrame - this.game.time.time;
                    }
                },

                "onResume": function () {
                    if (this.isPlaying) {
                        this._timeNextFrame = this.game.time.time + this._frameDiff;
                    }
                },

                "update": function () {
                    return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay ? (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -=
                        this._frameSkip * this.delay) : this._frameDiff = 0, this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex =
                        Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent,
                            this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), false) : this.updateCurrentFrame(true)));
                },

                "updateCurrentFrame": function (dataAndEvents, fail) {
                    if (void 0 === fail && (fail = false), !this._frameData) {
                        return false;
                    }
                    var value = this.currentFrame.index;
                    return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && ((fail || !fail && value !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame)), !this.onUpdate || (!dataAndEvents || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData));
                },

                "next": function (file) {
                    if (void 0 === file) {

                        file = 1;
                    }
                    var path = this._frameIndex + file;
                    if (path >= this._frames.length) {
                        if (this.loop) {
                            path %= this._frames.length;
                        } else {

                            path = this._frames.length - 1;
                        }
                    }
                    if (path !== this._frameIndex) {
                        this._frameIndex = path;
                        this.updateCurrentFrame(true);
                    }
                },

                "previous": function (circular) {
                    if (void 0 === circular) {

                        circular = 1;
                    }

                    var length = this._frameIndex - circular;
                    if (length < 0) {
                        if (this.loop) {
                            length = this._frames.length + length;
                        } else {
                            length++;
                        }
                    }
                    if (length !== this._frameIndex) {

                        this._frameIndex = length;
                        this.updateCurrentFrame(true);
                    }
                },

                "updateFrameData": function (dataAndEvents) {
                    this._frameData = dataAndEvents;
                    this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null;
                },

                "destroy": function () {
                    if (this._frameData) {
                        this.game.onPause.remove(this.onPause, this);
                        this.game.onResume.remove(this.onResume, this);

                        this.game = null;

                        this._parent = null;

                        this._frames = null;

                        this._frameData = null;

                        this.currentFrame = null;

                        this.isPlaying = false;
                        this.onStart.dispose();
                        this.onLoop.dispose();
                        this.onComplete.dispose();
                        if (this.onUpdate) {
                            this.onUpdate.dispose();
                        }
                    }
                },

                "complete": function () {

                    this._frameIndex = this._frames.length - 1;
                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);

                    this.isPlaying = false;

                    this.isFinished = true;

                    this.paused = false;
                    this._parent.events.onAnimationComplete$dispatch(this._parent, this);
                    this.onComplete.dispatch(this._parent, this);
                    if (this.killOnComplete) {
                        this._parent.kill();
                    }
                }
            }, $.Animation.prototype.constructor = $.Animation, Object.defineProperty($.Animation.prototype, 'paused', {

                "get": function () {
                    return this.isPaused;
                },

                "set": function (mL) {
                    this.isPaused = mL;
                    if (mL) {
                        this._pauseStartTime = this.game.time.time;
                    } else {
                        if (this.isPlaying) {
                            this._timeNextFrame = this.game.time.time + this.delay;
                        }
                    }
                }
            }), Object.defineProperty($.Animation.prototype, 'reversed', {

                "get": function () {
                    return this.isReversed;
                },

                "set": function (mL) {
                    this.isReversed = mL;
                }
            }), Object.defineProperty($.Animation.prototype, 'frameTotal', {

                "get": function () {
                    return this._frames.length;
                }
            }), Object.defineProperty($.Animation.prototype, "frame", {

                "get": function () {
                    return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex;
                },

                "set": function (att) {
                    this.currentFrame = this._frameData.getFrame(this._frames[att]);
                    if (null !== this.currentFrame) {
                        this._frameIndex = att;
                        this._parent.setFrame(this.currentFrame);
                        if (this.onUpdate) {
                            this.onUpdate.dispatch(this, this.currentFrame);
                        }
                    }
                }
            }), Object.defineProperty($.Animation.prototype, 'speed', {

                "get": function () {
                    return 1E3 / this.delay;
                },

                "set": function (mL) {
                    if (mL > 0) {

                        this.delay = 1E3 / mL;
                    }
                }
            }), Object.defineProperty($.Animation.prototype, 'enableUpdate', {

                "get": function () {
                    return null !== this.onUpdate;
                },

                "set": function (mL) {
                    if (mL && null === this.onUpdate) {
                        this.onUpdate = new($.Signal);
                    } else {
                        if (!mL) {
                            if (!(null === this.onUpdate)) {
                                this.onUpdate.dispose();

                                this.onUpdate = null;
                            }
                        }
                    }
                }
            }), $.Animation.generateFrameNames = function (front, c, b, tag, ms) {
                if (void 0 === tag) {

                    tag = "";
                }

                var dots = [];

                var dot = "";
                if (c < b) {
                    a = c;
                    for (; a <= b; a++) {
                        dot = front + (dot = 'number' == typeof ms ? $.Utils.pad(a.toString(), ms, "0", 1) : a.toString()) + tag;
                        dots.push(dot);
                    }
                } else {
                    var a = c;
                    for (; a >= b; a--) {
                        dot = front + (dot = "number" == typeof ms ? $.Utils.pad(a.toString(), ms, "0", 1) : a.toString()) + tag;
                        dots.push(dot);
                    }
                }
                return dots;
            }, $.Frame = function (dataAndEvents, v, sum, deltaY, newval, deepDataAndEvents) {
                this.index = dataAndEvents;
                this.x = v;
                this.y = sum;

                this.width = deltaY;

                this.height = newval;
                if (!(0 !== this.width && 0 !== this.height)) {
                    console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero');
                }
                this.name = deepDataAndEvents;
                this.centerX = Math.floor(deltaY / 2);
                this.centerY = Math.floor(newval / 2);
                this.distance = $.Math.distance(0, 0, deltaY, newval);

                this.rotated = false;

                this.trimmed = false;

                this.sourceSizeW = deltaY;

                this.sourceSizeH = newval;

                this.spriteSourceSizeX = 0;

                this.spriteSourceSizeY = 0;

                this.spriteSourceSizeW = 0;

                this.spriteSourceSizeH = 0;
                this.right = this.x + this.width;
                this.bottom = this.y + this.height;
            }, $.Frame.prototype = {

                "resize": function (width, height) {

                    this.width = width;

                    this.height = height;
                    this.centerX = Math.floor(width / 2);
                    this.centerY = Math.floor(height / 2);
                    this.distance = $.Math.distance(0, 0, width, height);

                    this.sourceSizeW = width;

                    this.sourceSizeH = height;
                    this.right = this.x + width;
                    this.bottom = this.y + height;
                },

                "setTrim": function (dataAndEvents, deltaY, deltaX, destHeight, destX, destWidth, destY) {
                    this.trimmed = dataAndEvents;
                    if (dataAndEvents) {

                        this.sourceSizeW = deltaY;

                        this.sourceSizeH = deltaX;
                        this.centerX = Math.floor(deltaY / 2);
                        this.centerY = Math.floor(deltaX / 2);
                        this.spriteSourceSizeX = destHeight;
                        this.spriteSourceSizeY = destX;
                        this.spriteSourceSizeW = destWidth;
                        this.spriteSourceSizeH = destY;
                    }
                },

                "clone": function () {
                    var old = new($.Frame)(this.index, this.x, this.y, this.width, this.height, this.name);
                    var name;
                    for (name in this) {
                        if (this.hasOwnProperty(name)) {
                            old[name] = this[name];
                        }
                    }
                    return old;
                },

                "getRect": function (m) {
                    return void 0 === m ? m = new $.Rectangle(this.x, this.y, this.width, this.height) : m.setTo(this.x, this.y, this.width, this.height), m;
                }
            }, $.Frame.prototype.constructor = $.Frame, $.FrameData = function () {

                this._frames = [];

                this._frameNames = [];
            }, $.FrameData.prototype = {

                "addFrame": function (x) {
                    return x.index = this._frames.length, this._frames.push(x), "" !== x.name && (this._frameNames[x.name] = x.index), x;
                },

                "getFrame": function (index) {
                    return index >= this._frames.length && (index = 0), this._frames[index];
                },

                "getFrameByName": function (key) {
                    return "number" == typeof this._frameNames[key] ? this._frames[this._frameNames[key]] : null;
                },

                "checkFrameName": function (name) {
                    return null != this._frameNames[name];
                },

                "clone": function () {
                    var res = new($.FrameData);

                    var i = 0;
                    for (; i < this._frames.length; i++) {
                        res._frames.push(this._frames[i].clone());
                    }
                    var l;
                    for (l in this._frameNames) {
                        if (this._frameNames.hasOwnProperty(l)) {
                            res._frameNames.push(this._frameNames[l]);
                        }
                    }
                    return res;
                },

                "getFrameRange": function (start, end, output) {
                    if (void 0 === output) {

                        output = [];
                    }
                    var i = start;
                    for (; i <= end; i++) {
                        output.push(this._frames[i]);
                    }
                    return output;
                },

                "getFrames": function (stack, consoleMessage, output) {
                    if (void 0 === consoleMessage && (consoleMessage = true), void 0 === output && (output = []), void 0 === stack || 0 === stack.length) {

                        i = 0;
                        for (; i < this._frames.length; i++) {
                            output.push(this._frames[i]);
                        }
                    } else {

                        var i = 0;
                        for (; i < stack.length; i++) {
                            if (consoleMessage) {
                                output.push(this.getFrame(stack[i]));
                            } else {
                                output.push(this.getFrameByName(stack[i]));
                            }
                        }
                    }
                    return output;
                },

                "getFrameIndexes": function (vis, useNumericIndex, output) {
                    if (void 0 === useNumericIndex && (useNumericIndex = true), void 0 === output && (output = []), void 0 === vis || 0 === vis.length) {

                        i = 0;
                        for (; i < this._frames.length; i++) {
                            output.push(this._frames[i].index);
                        }
                    } else {

                        var i = 0;
                        for (; i < vis.length; i++) {
                            if (useNumericIndex && this._frames[vis[i]]) {
                                output.push(this._frames[vis[i]].index);
                            } else {
                                if (this.getFrameByName(vis[i])) {
                                    output.push(this.getFrameByName(vis[i]).index);
                                }
                            }
                        }
                    }
                    return output;
                },

                "destroy": function () {

                    this._frames = null;

                    this._frameNames = null;
                }
            }, $.FrameData.prototype.constructor = $.FrameData, Object.defineProperty($.FrameData.prototype, 'total', {

                "get": function () {
                    return this._frames.length;
                }
            }), $.AnimationParser = {

                "spriteSheet": function (frameMax, parent, frameWidth, x, howMany, pos, value, start) {
                    if (void 0 === howMany) {

                        howMany = -1;
                    }
                    if (void 0 === pos) {

                        pos = 0;
                    }
                    if (void 0 === value) {

                        value = 0;
                    }
                    if (void 0 === start) {

                        start = 0;
                    }

                    var obj = parent;
                    if ('string' == typeof parent && (obj = frameMax.cache.getImage(parent)), null === obj) {
                        return null;
                    }
                    var width = obj.width;
                    var w = obj.height;
                    if (frameWidth <= 0) {
                        frameWidth = Math.floor(-width / Math.min(-1, frameWidth));
                    }
                    if (x <= 0) {
                        x = Math.floor(-w / Math.min(-1, x));
                    }

                    var end = Math.floor((width - pos) / (frameWidth + value)) * Math.floor((w - pos) / (x + value));
                    if (start > end || start < -end) {
                        return console.warn("Phaser.AnimationParser.spriteSheet: skipFrames = " + start.toString() + ' is larger than total sprite number ' + end.toString()), null;
                    }
                    if (start < 0 && (start = end + start), -1 !== howMany && (end = start + howMany), 0 === width || (0 === w || (width < frameWidth || (w < x || 0 === end)))) {
                        return console.warn("Phaser.AnimationParser.spriteSheet: '" + parent + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                    }
                    var data = new($.FrameData);

                    var savedPos4 = pos;

                    var savedPos0 = pos;

                    var i = 0;
                    for (; i < end; i++) {
                        data.addFrame(new $.Frame(i, savedPos4, savedPos0, frameWidth, x, ""));
                        if ((savedPos4 += frameWidth + value) + frameWidth > width) {

                            savedPos4 = pos;
                            savedPos0 += x + value;
                        }
                    }
                    return data;
                },

                "JSONData": function (dataAndEvents, json) {
                    if (!json.frames) {
                        return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(json);
                    }
                    var frame;
                    var data = new($.FrameData);
                    var tag = json.frames;

                    var i = 0;
                    for (; i < tag.length; i++) {
                        frame = data.addFrame(new $.Frame(i, tag[i].frame.x, tag[i].frame.y, tag[i].frame.w, tag[i].frame.h, tag[i].filename));
                        if (tag[i].trimmed) {
                            frame.setTrim(tag[i].trimmed, tag[i].sourceSize.w, tag[i].sourceSize.h, tag[i].spriteSourceSize.x, tag[i].spriteSourceSize.y, tag[i].spriteSourceSize.w, tag[i].spriteSourceSize.h);
                        }
                        if (tag[i].rotated) {

                            frame.rotated = true;
                        }
                    }
                    return data;
                },

                "JSONDataPyxel": function (dataAndEvents, message) {
                    if (['layers', 'tilewidth', "tileheight", 'tileswide', 'tileshigh'].forEach(function (uuid) {
                            if (!message[uuid]) {
                                return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + uuid + '" key.'), void console.log(message);
                            }
                        }), 1 !== message.layers.length) {
                        return console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.'), void console.log(message);
                    }
                    var JSONDataPyxel = new($.FrameData);
                    var id = message.tileheight;
                    var messageType = message.tilewidth;
                    var data = message.layers[0].tiles;

                    var i = 0;
                    for (; i < data.length; i++) {
                        JSONDataPyxel.addFrame(new($.Frame)(i, data[i].x, data[i].y, messageType, id, "frame_" + i)).setTrim(false);
                    }
                    return JSONDataPyxel;
                },

                "JSONDataHash": function (dataAndEvents, x) {
                    if (!x.frames) {
                        return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(x);
                    }
                    var frame;
                    var data = new($.FrameData);
                    var testSource = x.frames;

                    var context = 0;
                    var name;
                    for (name in testSource) {
                        frame = data.addFrame(new($.Frame)(context, testSource[name].frame.x, testSource[name].frame.y, testSource[name].frame.w, testSource[name].frame.h, name));
                        if (testSource[name].trimmed) {
                            frame.setTrim(testSource[name].trimmed, testSource[name].sourceSize.w, testSource[name].sourceSize.h, testSource[name].spriteSourceSize.x, testSource[name].spriteSourceSize.y, testSource[name].spriteSourceSize.w, testSource[name].spriteSourceSize.h);
                        }
                        if (testSource[name].rotated) {

                            frame.rotated = true;
                        }
                        context++;
                    }
                    return data;
                },

                "XMLData": function (cacheKey, dataAndEvents) {
                    if (dataAndEvents.getElementsByTagName("TextureAtlas")) {
                        var me;
                        var _0x13268a;
                        var urls;
                        var nDigit;
                        var mode;
                        var requiredVersionPart;
                        var e;
                        var r20;
                        var restoreScript;
                        var mid;
                        var halfWidth;
                        var data = new($.FrameData);
                        var stack = dataAndEvents.getElementsByTagName('SubTexture');

                        var i = 0;
                        for (; i < stack.length; i++) {
                            _0x13268a = (urls = stack[i].attributes).name.value;

                            nDigit = parseInt(urls.x.value, 10);

                            mode = parseInt(urls.y.value, 10);

                            requiredVersionPart = parseInt(urls.width.value, 10);

                            e = parseInt(urls.height.value, 10);

                            r20 = null;

                            restoreScript = null;
                            if (urls.frameX) {
                                r20 = Math.abs(parseInt(urls.frameX.value, 10));
                                restoreScript = Math.abs(parseInt(urls.frameY.value, 10));

                                mid = parseInt(urls.frameWidth.value, 10);

                                halfWidth = parseInt(urls.frameHeight.value, 10);
                            }
                            me = data.addFrame(new($.Frame)(i, nDigit, mode, requiredVersionPart, e, _0x13268a));
                            if (!(null === r20 && null === restoreScript)) {
                                me.setTrim(true, requiredVersionPart, e, r20, restoreScript, mid, halfWidth);
                            }
                        }
                        return data;
                    }
                    console.warn('Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag');
                }
            }, $.Cache = function (dataAndEvents) {
                this.game = dataAndEvents;

                this.autoResolveURL = false;
                this._cache = {
                    "canvas": {},
                    "image": {},
                    "texture": {},
                    "sound": {},
                    "video": {},
                    "text": {},
                    "json": {},
                    "xml": {},
                    "physics": {},
                    "tilemap": {},
                    "binary": {},
                    "bitmapData": {},
                    "bitmapFont": {},
                    "shader": {},
                    "renderTexture": {},
                    "compressedTexture": {}
                };
                this._urlMap = {};

                this._urlResolver = new Image;

                this._urlTemp = null;
                this.onSoundUnlock = new($.Signal);

                this._cacheMap = [];
                this._cacheMap[$.Cache.CANVAS] = this._cache.canvas;
                this._cacheMap[$.Cache.IMAGE] = this._cache.image;
                this._cacheMap[$.Cache.TEXTURE] = this._cache.texture;
                this._cacheMap[$.Cache.SOUND] = this._cache.sound;
                this._cacheMap[$.Cache.TEXT] = this._cache.text;
                this._cacheMap[$.Cache.PHYSICS] = this._cache.physics;
                this._cacheMap[$.Cache.TILEMAP] = this._cache.tilemap;
                this._cacheMap[$.Cache.BINARY] = this._cache.binary;
                this._cacheMap[$.Cache.BITMAPDATA] = this._cache.bitmapData;
                this._cacheMap[$.Cache.BITMAPFONT] = this._cache.bitmapFont;
                this._cacheMap[$.Cache.JSON] = this._cache.json;
                this._cacheMap[$.Cache.XML] = this._cache.xml;
                this._cacheMap[$.Cache.VIDEO] = this._cache.video;
                this._cacheMap[$.Cache.SHADER] = this._cache.shader;
                this._cacheMap[$.Cache.RENDER_TEXTURE] = this._cache.renderTexture;

                this._pendingCount = 0;
                this.onReady = new($.Signal);
                this._addImages();
            }, $.Cache.CANVAS = 1, $.Cache.IMAGE = 2, $.Cache.TEXTURE = 3, $.Cache.SOUND = 4, $.Cache.TEXT = 5, $.Cache.PHYSICS = 6, $.Cache.TILEMAP = 7, $.Cache.BINARY = 8, $.Cache.BITMAPDATA = 9, $.Cache.BITMAPFONT = 10, $.Cache.JSON = 11, $.Cache.XML = 12, $.Cache.VIDEO =
            13, $.Cache.SHADER = 14, $.Cache.RENDER_TEXTURE = 15, $.Cache.DEFAULT = null, $.Cache.DEFAULT_KEY = "__default", $.Cache.DEFAULT_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==', $.Cache.MISSING = null, $.Cache.MISSING_KEY = '__missing', $.Cache.MISSING_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==', $.Cache.READY_TIMEOUT = 1E3, $.Cache.prototype = {

                "addCompressedTextureMetaData": function (name, newUrl, op, val) {
                    if (this.checkImageKey(name)) {
                        this.removeImage(name);
                    }
                    var value = op in $.LoaderParser ? $.LoaderParser[op](val) : val;
                    var options = {
                        "key": name,
                        "url": newUrl,
                        "data": value,
                        "base": new(PIXI.BaseTexture)(value, null, this.game.resolution),
                        "frame": new($.Frame)(0, 0, 0, value.width, value.height, name),
                        "frameData": new($.FrameData),
                        "fileFormat": op
                    };
                    return options.frameData.addFrame(new $.Frame(0, 0, 0, value.width, value.height, newUrl)), this._cache.image[name] = options, this._resolveURL(newUrl, options), options;
                },

                "addCanvas": function (key, canvas, context) {
                    if (void 0 === context) {
                        context = canvas.getContext("2d");
                    }
                    this._cache.canvas[key] = {
                        "canvas": canvas,
                        "context": context
                    };
                },

                "addImage": function (name, image, img) {
                    if (this.checkImageKey(name)) {
                        this.removeImage(name);
                    }
                    if (false === img.complete) {
                        console.warn('Phaser.Cache.addImage: Image "' + name + `" hasn't been retrieved yet`);
                    }
                    var options = {
                        "key": name,
                        "url": image,
                        "data": img,
                        "base": new(PIXI.BaseTexture)(img, null, this.game.resolution),
                        "frame": new($.Frame)(0, 0, 0, img.width, img.height, name),
                        "frameData": new $.FrameData
                    };
                    return options.frameData.addFrame(new($.Frame)(0, 0, 0, img.width, img.height, image)), this._cache.image[name] = options, this._resolveURL(image, options), "__default" === name ? $.Cache.DEFAULT = new(PIXI.Texture)(options.base) : '__missing' === name && ($.Cache.MISSING = new PIXI.Texture(options.base)), options;
                },

                "addImageAsync": function (type, v, target) {
                    var element = this;

                    var cache = new Image;

                    cache.onload = function () {
                        target.call(this, element.addImage(type, null, cache));
                        element._removePending();

                        cache.onload = null;
                    };
                    this._addPending();
                    cache.src = v;
                },

                "addDefaultImage": function () {
                    this.addImageAsync($.Cache.DEFAULT_KEY, $.Cache.DEFAULT_SRC, function (filenames) {

                        filenames.base.skipRender = true;
                        $.Cache.DEFAULT = new(PIXI.Texture)(filenames.base);
                    });
                },

                "addMissingImage": function () {
                    this.addImageAsync($.Cache.MISSING_KEY, $.Cache.MISSING_SRC, function (dataAndEvents) {
                        $.Cache.MISSING = new(PIXI.Texture)(dataAndEvents.base);
                    });
                },

                "addSound": function (key, file, data, webAudio, audioTag) {
                    if (void 0 === webAudio) {

                        webAudio = true;

                        audioTag = false;
                    }
                    if (void 0 === audioTag) {

                        webAudio = false;

                        audioTag = true;
                    }

                    var decoded = false;
                    if (audioTag) {

                        decoded = true;
                    }
                    this._cache.sound[key] = {
                        "url": file,
                        "data": data,
                        "isDecoding": false,
                        "decoded": decoded,
                        "webAudio": webAudio,
                        "audioTag": audioTag,
                        "locked": this.game.sound.touchLocked
                    };
                    this._resolveURL(file, this._cache.sound[key]);
                },

                "addText": function (i, name, initialValue) {
                    this._cache.text[i] = {
                        "url": name,
                        "data": initialValue
                    };
                    this._resolveURL(name, this._cache.text[i]);
                },

                "addPhysicsData": function (key, newUrl, task, formatString) {
                    this._cache.physics[key] = {
                        "url": newUrl,
                        "data": task,
                        "format": formatString
                    };
                    this._resolveURL(newUrl, this._cache.physics[key]);
                },

                "addTilemap": function (key, url, mapData, format) {
                    this._cache.tilemap[key] = {
                        "url": url,
                        "data": mapData,
                        "format": format
                    };
                    this._resolveURL(url, this._cache.tilemap[key]);
                },

                "addBinary": function (i, offsetPosition) {
                    this._cache.binary[i] = offsetPosition;
                },

                "addBitmapData": function (key, res, dataAndEvents) {
                    return res.key = key, void 0 === dataAndEvents && (dataAndEvents = new($.FrameData)).addFrame(res.textureFrame), this._cache.bitmapData[key] = {
                        "data": res,
                        "frameData": dataAndEvents
                    }, res;
                },

                "addBitmapFont": function (key, url, data, json, string, shimField, messages) {
                    var value = {
                        "url": url,
                        "data": data,
                        "font": null,
                        "base": new PIXI.BaseTexture(data, null, this.game.resolution)
                    };
                    if (void 0 === shimField) {

                        shimField = 0;
                    }
                    if (void 0 === messages) {

                        messages = 0;
                    }
                    value.font = "json" === string ? $.LoaderParser.jsonBitmapFont(json, value.base, shimField, messages, false, this.game.resolution) : $.LoaderParser.xmlBitmapFont(json, value.base, shimField, messages, false, this.game.resolution);
                    this._cache.bitmapFont[key] = value;
                    this._resolveURL(url, value);
                },

                "addBitmapFontFromAtlas": function (event, base, elems, dest, dataAndEvents, setValue, deepDataAndEvents) {
                    var ret = this.getFrameByName(base, elems);
                    if (ret) {
                        var options = {
                            "font": null,
                            "base": this.getBaseTexture(base),
                            "frame": ret
                        };
                        if (void 0 === setValue) {

                            setValue = 0;
                        }
                        if (void 0 === deepDataAndEvents) {

                            deepDataAndEvents = 0;
                        }
                        var pdataCur;
                        if ('json' === dataAndEvents) {
                            pdataCur = this.getJSON(dest);
                            options.font = $.LoaderParser.jsonBitmapFont(pdataCur, options.base, setValue, deepDataAndEvents, ret, this.game.resolution);
                        } else {
                            pdataCur = this.getXML(dest);
                            options.font = $.LoaderParser.xmlBitmapFont(pdataCur, options.base, setValue, deepDataAndEvents, ret, this.game.resolution);
                        }
                        this._cache.bitmapFont[event] = options;
                    }
                },

                "addJSON": function (i, path, task) {
                    this._cache.json[i] = {
                        "url": path,
                        "data": task
                    };
                    this._resolveURL(path, this._cache.json[i]);
                },

                "addXML": function (i, newUrl, task) {
                    this._cache.xml[i] = {
                        "url": newUrl,
                        "data": task
                    };
                    this._resolveURL(newUrl, this._cache.xml[i]);
                },

                "addVideo": function (key, url, blob, video_path) {
                    this._cache.video[key] = {
                        "url": url,
                        "data": blob,
                        "isBlob": video_path,
                        "locked": true
                    };
                    this._resolveURL(url, this._cache.video[key]);
                },

                "addShader": function (i, path, task) {
                    this._cache.shader[i] = {
                        "url": path,
                        "data": task
                    };
                    this._resolveURL(path, this._cache.shader[i]);
                },

                "addRenderTexture": function (key, texture) {
                    this._cache.renderTexture[key] = {
                        "texture": texture,
                        "frame": new($.Frame)(0, 0, 0, texture.width, texture.height, "", "")
                    };
                },

                "addSpriteSheet": function (key, url, data, frameWidth, frameHeight, frameMax, margin, spacing, deepDataAndEvents) {
                    if (void 0 === frameMax) {

                        frameMax = -1;
                    }
                    if (void 0 === margin) {

                        margin = 0;
                    }
                    if (void 0 === spacing) {

                        spacing = 0;
                    }
                    var defaults = {
                        "key": key,
                        "url": url,
                        "data": data,
                        "frameWidth": frameWidth,
                        "frameHeight": frameHeight,
                        "margin": margin,
                        "spacing": spacing,
                        "base": new(PIXI.BaseTexture)(data, null, this.game.resolution),
                        "frameData": $.AnimationParser.spriteSheet(this.game, data, frameWidth, frameHeight, frameMax, margin, spacing, deepDataAndEvents)
                    };
                    this._cache.image[key] = defaults;
                    this._resolveURL(url, defaults);
                },

                "addTextureAtlas": function (key, url, task, data, dataAndEvents) {
                    var o = {
                        "key": key,
                        "url": url,
                        "data": task,
                        "base": new PIXI.BaseTexture(task, null, this.game.resolution)
                    };
                    if (dataAndEvents === $.Loader.TEXTURE_ATLAS_XML_STARLING) {
                        o.frameData = $.AnimationParser.XMLData(this.game, data, key);
                    } else {
                        if (dataAndEvents === $.Loader.TEXTURE_ATLAS_JSON_PYXEL) {
                            o.frameData = $.AnimationParser.JSONDataPyxel(this.game, data, key);
                        } else {
                            if (Array.isArray(data.frames)) {
                                o.frameData = $.AnimationParser.JSONData(this.game, data, key);
                            } else {
                                o.frameData = $.AnimationParser.JSONDataHash(this.game, data, key);
                            }
                        }
                    }
                    this._cache.image[key] = o;
                    this._resolveURL(url, o);
                },

                "reloadSound": function (key) {
                    var attr = this;
                    var cache = this.getSound(key);
                    if (cache) {
                        cache.data.src = cache.url;
                        cache.data.addEventListener('canplaythrough', function () {
                            return attr.reloadSoundComplete(key);
                        }, false);
                        cache.data.load();
                    }
                },

                "reloadSoundComplete": function (key) {
                    var camelKey = this.getSound(key);
                    if (camelKey) {

                        camelKey.locked = false;
                        this.onSoundUnlock.dispatch(key);
                    }
                },

                "updateSound": function (separator, key, value) {
                    var flags = this.getSound(separator);
                    if (flags) {
                        flags[key] = value;
                    }
                },

                "decodedSound": function (key, value) {
                    var cache = this.getSound(key);
                    cache.data = value;

                    cache.decoded = true;

                    cache.isDecoding = false;
                },

                "isSoundDecoded": function (key) {
                    var camelKey = this.getItem(key, $.Cache.SOUND, 'isSoundDecoded');
                    if (camelKey) {
                        return camelKey.decoded;
                    }
                },

                "isSoundReady": function (key) {
                    var camelKey = this.getItem(key, $.Cache.SOUND, 'isSoundDecoded');
                    if (camelKey) {
                        return camelKey.decoded && !this.game.sound.touchLocked;
                    }
                },

                "checkKey": function (v, e) {
                    return !!this._cacheMap[v][e];
                },

                "checkURL": function (url) {
                    return !!this._urlMap[this._resolveURL(url)];
                },

                "checkCanvasKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.CANVAS, deepDataAndEvents);
                },

                "checkImageKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.IMAGE, deepDataAndEvents);
                },

                "checkTextureKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.TEXTURE, deepDataAndEvents);
                },

                "checkSoundKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.SOUND, deepDataAndEvents);
                },

                "checkTextKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.TEXT, deepDataAndEvents);
                },

                "checkPhysicsKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.PHYSICS, deepDataAndEvents);
                },

                "checkTilemapKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.TILEMAP, deepDataAndEvents);
                },

                "checkBinaryKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.BINARY, deepDataAndEvents);
                },

                "checkBitmapDataKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.BITMAPDATA, deepDataAndEvents);
                },

                "checkBitmapFontKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.BITMAPFONT, deepDataAndEvents);
                },

                "checkJSONKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.JSON, deepDataAndEvents);
                },

                "checkXMLKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.XML, deepDataAndEvents);
                },

                "checkVideoKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.VIDEO, deepDataAndEvents);
                },

                "checkShaderKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.SHADER, deepDataAndEvents);
                },

                "checkRenderTextureKey": function (deepDataAndEvents) {
                    return this.checkKey($.Cache.RENDER_TEXTURE, deepDataAndEvents);
                },

                "getItem": function (label, i, json, key) {
                    return this.checkKey(i, label) ? void 0 === key ? this._cacheMap[i][label] : this._cacheMap[i][label][key] : (json && console.warn('Phaser.Cache.' + json + ': Key "' + label + '" not found in Cache.'), null);
                },

                "getCanvas": function (width) {
                    return this.getItem(width, $.Cache.CANVAS, 'getCanvas', 'canvas');
                },

                "getImage": function (type, optional) {
                    if (!(void 0 !== type && null !== type)) {
                        type = '__default';
                    }
                    if (void 0 === optional) {

                        optional = false;
                    }
                    var match = this.getItem(type, $.Cache.IMAGE, 'getImage');
                    return null === match && (match = this.getItem('__missing', $.Cache.IMAGE, 'getImage')), optional ? match : match.data;
                },

                "getTextureFrame": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.TEXTURE, 'getTextureFrame', 'frame');
                },

                "getSound": function (sound) {
                    return this.getItem(sound, $.Cache.SOUND, 'getSound');
                },

                "getSoundData": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.SOUND, 'getSoundData', 'data');
                },

                "getText": function (elems) {
                    return this.getItem(elems, $.Cache.TEXT, 'getText', "data");
                },

                "getPhysicsData": function (argv, key, dataAndEvents) {
                    var options = this.getItem(argv, $.Cache.PHYSICS, 'getPhysicsData', 'data');
                    if (null === options || (void 0 === key || null === key)) {
                        return options;
                    }
                    if (options[key]) {
                        var copy = options[key];
                        if (!copy || !dataAndEvents) {
                            return copy;
                        }
                        var prop;
                        for (prop in copy) {
                            if ((prop = copy[prop]).fixtureKey === dataAndEvents) {
                                return prop;
                            }
                        }
                        console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + dataAndEvents + ' in ' + argv + '"');
                    } else {
                        console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + argv + ' / ' + key + '"');
                    }
                    return null;
                },

                "getTilemapData": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.TILEMAP, "getTilemapData");
                },

                "getBinary": function (elt) {
                    return this.getItem(elt, $.Cache.BINARY, 'getBinary');
                },

                "getBitmapData": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.BITMAPDATA, "getBitmapData", 'data');
                },

                "getBitmapFont": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.BITMAPFONT, "getBitmapFont");
                },

                "getJSON": function (data, method) {
                    var value = this.getItem(data, $.Cache.JSON, "getJSON", "data");
                    return value ? method ? $.Utils.extend(true, Array.isArray(value) ? [] : {}, value) : value : null;
                },

                "getXML": function (srcUrl) {
                    return this.getItem(srcUrl, $.Cache.XML, 'getXML', 'data');
                },

                "getVideo": function (error) {
                    return this.getItem(error, $.Cache.VIDEO, 'getVideo');
                },

                "getShader": function (shaderSrc) {
                    return this.getItem(shaderSrc, $.Cache.SHADER, 'getShader', 'data');
                },

                "getRenderTexture": function (deepDataAndEvents) {
                    return this.getItem(deepDataAndEvents, $.Cache.RENDER_TEXTURE, 'getRenderTexture');
                },

                "getBaseTexture": function (deepDataAndEvents, opt_obj2) {
                    return void 0 === opt_obj2 && (opt_obj2 = $.Cache.IMAGE), this.getItem(deepDataAndEvents, opt_obj2, "getBaseTexture", "base");
                },

                "getFrame": function (frame, $element) {
                    return void 0 === $element && ($element = $.Cache.IMAGE), this.getItem(frame, $element, 'getFrame', "frame");
                },

                "getFrameCount": function (valueAccessor, options) {
                    var settings = this.getFrameData(valueAccessor, options);
                    return settings ? settings.total : 0;
                },

                "getFrameData": function (at, tile) {
                    return void 0 === tile && (tile = $.Cache.IMAGE), this.getItem(at, tile, "getFrameData", 'frameData');
                },

                "hasFrameData": function (opt_obj2, deepDataAndEvents) {
                    return void 0 === deepDataAndEvents && (deepDataAndEvents = $.Cache.IMAGE), null !== this.getItem(opt_obj2, deepDataAndEvents, "", 'frameData');
                },

                "updateFrameData": function (col, dataAndEvents, row) {
                    if (void 0 === row) {
                        row = $.Cache.IMAGE;
                    }
                    if (this._cacheMap[row][col]) {
                        this._cacheMap[row][col].frameData = dataAndEvents;
                    }
                },

                "getFrameByIndex": function (frame, evt, elems) {
                    var ret = this.getFrameData(frame, elems);
                    return ret ? ret.getFrame(evt) : null;
                },

                "getFrameByName": function (key, refNode, protoProps) {
                    var child = this.getFrameData(key, protoProps);
                    return child ? child.getFrameByName(refNode) : null;
                },

                "getURL": function (callback) {
                    return (callback = this._resolveURL(callback)) ? this._urlMap[callback] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + callback + '" or Cache.autoResolveURL was false'), null);
                },

                "getKeys": function (namespace) {
                    if (void 0 === namespace) {
                        namespace = $.Cache.IMAGE;
                    }

                    var rv = [];
                    if (this._cacheMap[namespace]) {
                        var r20;
                        for (r20 in this._cacheMap[namespace]) {
                            if ('__default' !== r20) {
                                if ('__missing' !== r20) {
                                    rv.push(r20);
                                }
                            }
                        }
                    }
                    return rv;
                },

                "removeCanvas": function (key) {
                    delete this._cache.canvas[key];
                },

                "removeImage": function (key, id) {
                    if (void 0 === id) {

                        id = true;
                    }
                    var cache = this.getImage(key, true);
                    if (id) {
                        if (cache.base) {
                            cache.base.destroy();
                        }
                    }
                    delete this._cache.image[key];
                },

                "removeSound": function (key) {
                    delete this._cache.sound[key];
                },

                "removeText": function (featureId) {
                    delete this._cache.text[featureId];
                },

                "removePhysics": function (key) {
                    delete this._cache.physics[key];
                },

                "removeTilemap": function (timeoutKey) {
                    delete this._cache.tilemap[timeoutKey];
                },

                "removeBinary": function (timeoutKey) {
                    delete this._cache.binary[timeoutKey];
                },

                "removeBitmapData": function (timeoutKey) {
                    delete this._cache.bitmapData[timeoutKey];
                },

                "removeBitmapFont": function (timeoutKey) {
                    delete this._cache.bitmapFont[timeoutKey];
                },

                "removeJSON": function (i) {
                    delete this._cache.json[i];
                },

                "removeXML": function (timeoutKey) {
                    delete this._cache.xml[timeoutKey];
                },

                "removeVideo": function (timeoutKey) {
                    delete this._cache.video[timeoutKey];
                },

                "removeShader": function (timeoutKey) {
                    delete this._cache.shader[timeoutKey];
                },

                "removeRenderTexture": function (timeoutKey) {
                    delete this._cache.renderTexture[timeoutKey];
                },

                "removeSpriteSheet": function (timeoutKey) {
                    delete this._cache.spriteSheet[timeoutKey];
                },

                "removeTextureAtlas": function (timeoutKey) {
                    delete this._cache.image[timeoutKey];
                },

                "clearGLTextures": function () {
                    var unlock;
                    for (unlock in this._cache.image) {

                        this._cache.image[unlock].base._glTextures = [];
                    }
                },

                "_resolveURL": function (dataAndEvents, url) {
                    return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + dataAndEvents, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", url && (this._urlMap[this._urlTemp] = url), this._urlTemp) : null;
                },

                "destroy": function () {

                    var targetType = 0;
                    for (; targetType < this._cacheMap.length; targetType++) {
                        var map = this._cacheMap[targetType];
                        var letter;
                        for (letter in map) {
                            if ('__default' !== letter) {
                                if ('__missing' !== letter) {
                                    this.destroyItem(map[letter]);
                                    delete map[letter];
                                }
                            }
                        }
                    }

                    this._urlMap = null;

                    this._urlResolver = null;

                    this._urlTemp = null;
                },

                "destroyItem": function (series) {
                    if (series.destroy) {
                        series.destroy();
                    } else {
                        if (series.base) {
                            if (series.base.destroy) {
                                series.base.destroy();
                            }
                        }
                        if (series.data) {
                            if (series.data.destroy) {
                                series.data.destroy();
                            }
                        }
                        if (series.frameData) {
                            if (series.frameData.destroy) {
                                series.frameData.destroy();
                            }
                        }
                        if (series.texture) {
                            if (series.texture.destroy) {
                                series.texture.destroy(true);
                            }
                        }
                    }
                },

                "_addImages": function () {

                    this._pendingCount = 0;
                    this.addDefaultImage();
                    this.addMissingImage();
                    var isReady = this;
                    var ext = $.Cache.READY_TIMEOUT;
                    if ($.Cache.READY_TIMEOUT > 0) {
                        setTimeout(function () {
                            if (!isReady.isReady) {
                                console.warn("Phaser.Cache: Still waiting for images after %s ms.", ext);
                                isReady._ready();
                            }
                        }, $.Cache.READY_TIMEOUT);
                    } else {
                        this._ready();
                    }
                },

                "_addPending": function () {
                    this._pendingCount += 1;
                },

                "_removePending": function () {
                    this._pendingCount -= 1;
                    this._checkReady();
                },

                "_checkReady": function () {
                    if (this.isReady) {
                        this._ready();
                    }
                },

                "_ready": function () {

                    this._pendingCount = 0;
                    this.onReady.dispatch(this);
                }
            }, $.Cache.prototype.constructor = $.Cache, Object.defineProperty($.Cache.prototype, "isReady", {

                "get": function () {
                    return this._pendingCount <= 0;
                }
            }), $.Loader = function (dataAndEvents) {
                this.game = dataAndEvents;
                this.cache = dataAndEvents.cache;

                this.resetLocked = false;

                this.isLoading = false;

                this.hasLoaded = false;

                this.preloadSprite = null;

                this.crossOrigin = false;

                this.baseURL = "";

                this.path = "";
                this.headers = {
                    "requestedWith": false,
                    "json": 'application/json',
                    "xml": 'application/xml'
                };
                this.onLoadStart = new $.Signal;
                this.onBeforeLoadComplete = new($.Signal);
                this.onLoadComplete = new($.Signal);
                this.onPackComplete = new($.Signal);
                this.onFileStart = new($.Signal);
                this.onFileComplete = new $.Signal;
                this.onFileError = new($.Signal);

                this.enableParallel = true;

                this.maxParallelDownloads = 4;

                this._withSyncPointDepth = 0;

                this._fileList = [];

                this._flightQueue = [];

                this._processingHead = 0;

                this._fileLoadStarted = false;

                this._totalPackCount = 0;

                this._totalFileCount = 0;

                this._loadedPackCount = 0;

                this._loadedFileCount = 0;
            }, $.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, $.Loader.TEXTURE_ATLAS_JSON_HASH = 1, $.Loader.TEXTURE_ATLAS_XML_STARLING = 2, $.Loader.PHYSICS_LIME_CORONA_JSON = 3, $.Loader.PHYSICS_PHASER_JSON = 4, $.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, $.Loader.prototype = {

                "setPreloadSprite": function (params, direction) {
                    direction = direction || 0;
                    this.preloadSprite = {
                        "sprite": params,
                        "direction": direction,
                        "width": params.width,
                        "height": params.height,
                        "rect": null
                    };
                    this.preloadSprite.rect = 0 === direction ? new($.Rectangle)(0, 0, 1, params.height) : new($.Rectangle)(0, 0, params.width, 1);
                    params.crop(this.preloadSprite.rect);

                    params.visible = true;
                },

                "resize": function () {
                    if (this.preloadSprite) {
                        if (this.preloadSprite.height !== this.preloadSprite.sprite.height) {
                            this.preloadSprite.rect.height = this.preloadSprite.sprite.height;
                        }
                    }
                },

                "checkKeyExists": function (deepDataAndEvents, opt_obj2) {
                    return this.getAssetIndex(deepDataAndEvents, opt_obj2) > -1;
                },

                "getAssetIndex": function (listener, fn) {

                    var msg = -1;

                    var type = 0;
                    for (; type < this._fileList.length; type++) {
                        var listeners = this._fileList[type];
                        if (listeners.type === listener && (listeners.key === fn && (msg = type, !listeners.loaded && !listeners.loading))) {
                            break;
                        }
                    }
                    return msg;
                },

                "getAsset": function (filename, item) {
                    var i = this.getAssetIndex(filename, item);
                    return i > -1 && {
                        "index": i,
                        "file": this._fileList[i]
                    };
                },

                "reset": function (models, evt) {
                    if (void 0 === evt) {

                        evt = false;
                    }
                    if (!this.resetLocked) {
                        if (models) {

                            this.preloadSprite = null;
                        }

                        this.isLoading = false;

                        this._processingHead = 0;

                        this._fileList.length = 0;

                        this._flightQueue.length = 0;

                        this._fileLoadStarted = false;

                        this._totalFileCount = 0;

                        this._totalPackCount = 0;

                        this._loadedPackCount = 0;

                        this._loadedFileCount = 0;
                        if (evt) {
                            this.onLoadStart.removeAll();
                            this.onLoadComplete.removeAll();
                            this.onPackComplete.removeAll();
                            this.onFileStart.removeAll();
                            this.onFileComplete.removeAll();
                            this.onFileError.removeAll();
                        }
                    }
                },

                "addToFileList": function (type, value, url, save, dataAndEvents, link_id) {
                    if (void 0 === dataAndEvents && (dataAndEvents = false), void 0 === value || "" === value) {
                        return console.warn("Phaser.Loader: Invalid or no key given of type " + type), this;
                    }
                    if (void 0 === url || null === url) {
                        if (!link_id) {
                            return console.warn('Phaser.Loader: No URL given for file type: ' + type + ' key: ' + value), this;
                        }
                        url = value + link_id;
                    }
                    var defaults = {
                        "type": type,
                        "key": value,
                        "path": this.path,
                        "url": url,
                        "syncPoint": this._withSyncPointDepth > 0,
                        "data": null,
                        "loading": false,
                        "loaded": false,
                        "error": false
                    };
                    if (save) {
                        var i;
                        for (i in save) {
                            defaults[i] = save[i];
                        }
                    }
                    var key = this.getAssetIndex(type, value);
                    if (dataAndEvents && key > -1) {
                        var config = this._fileList[key];
                        if (config.loading || config.loaded) {
                            this._fileList.push(defaults);
                            this._totalFileCount++;
                        } else {
                            this._fileList[key] = defaults;
                        }
                    } else {
                        if (-1 === key) {
                            this._fileList.push(defaults);
                            this._totalFileCount++;
                        }
                    }
                    return this;
                },

                "replaceInFileList": function (deepDataAndEvents, opt_obj2, walkers, isXML) {
                    return this.addToFileList(deepDataAndEvents, opt_obj2, walkers, isXML, true);
                },

                "pack": function (name, img, done, length) {
                    if (void 0 === img && (img = null), void 0 === done && (done = null), void 0 === length && (length = null), !img && !done) {
                        return console.warn('Phaser.Loader.pack - Both url and data are null. One must be set.'), this;
                    }
                    var data = {
                        "type": 'packfile',
                        "key": name,
                        "url": img,
                        "path": this.path,
                        "syncPoint": true,
                        "data": null,
                        "loading": false,
                        "loaded": false,
                        "error": false,
                        "callbackContext": length
                    };
                    if (done) {
                        if ('string' == typeof done) {
                            done = JSON.parse(done);
                        }
                        data.data = done || {};

                        data.loaded = true;
                    }

                    var sel = 0;
                    for (; sel < this._fileList.length + 1; sel++) {
                        var rule = this._fileList[sel];
                        if (!rule || !rule.loaded && (!rule.loading && 'packfile' !== rule.type)) {
                            this._fileList.splice(sel, 0, data);
                            this._totalPackCount++;
                            break;
                        }
                    }
                    return this;
                },

                "image": function (ref, text, x) {
                    return 'object' == typeof text ? this.texture(ref, text, x) : this.addToFileList('image', ref, text, void 0, x, '.png');
                },

                "imageFromBitmapData": function (deepDataAndEvents, dataAndEvents, opt_obj2) {
                    return this.image(deepDataAndEvents, dataAndEvents.canvas.toDataURL("image/png"), opt_obj2);
                },

                "imageFromGrid": function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope, shallow) {
                    return this.imageFromBitmapData(deepDataAndEvents, this.game.create.grid(deepDataAndEvents, opt_obj2, walkers, isXML, next_scope, shallow, false));
                },

                "imageFromTexture": function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
                    return this.imageFromBitmapData(deepDataAndEvents, this.game.create.texture(deepDataAndEvents, opt_obj2, walkers, isXML, next_scope, false));
                },

                "texture": function (mapping, map, assetName) {
                    if (this.game.renderType === $.WEBGL) {
                        var letter;
                        var _0x4fecba = this.game.renderer.extensions.compression;
                        for (letter in map) {
                            if (letter.toUpperCase() in _0x4fecba) {
                                return this.addToFileList("texture", mapping, map[letter], void 0, assetName, '.pvr');
                            }
                        }
                    }
                    return map.truecolor && this.addToFileList('image', mapping, map.truecolor, void 0, assetName, '.png'), this;
                },

                "images": function (h, data) {
                    if (Array.isArray(data)) {

                        k = 0;
                        for (; k < h.length; k++) {
                            this.image(h[k], data[k]);
                        }
                    } else {

                        var k = 0;
                        for (; k < h.length; k++) {
                            this.image(h[k]);
                        }
                    }
                    return this;
                },

                "text": function (id, item, elem) {
                    return this.addToFileList("text", id, item, void 0, elem, '.txt');
                },

                "json": function (files, obj, httpStatus) {
                    return this.addToFileList('json', files, obj, void 0, httpStatus, '.json');
                },

                "shader": function (shaderSource, inputs, deepDataAndEvents) {
                    return this.addToFileList('shader', shaderSource, inputs, void 0, deepDataAndEvents, ".frag");
                },

                "xml": function (xml, xmlNode, indent) {
                    return this.addToFileList('xml', xml, xmlNode, void 0, indent, '.xml');
                },

                "script": function (xml, src, callback, inSrc) {
                    return void 0 === callback && (callback = false), false !== callback && (void 0 === inSrc && (inSrc = this)), this.addToFileList('script', xml, src, {
                        "syncPoint": true,
                        "callback": callback,
                        "callbackContext": inSrc
                    }, false, '.js');
                },

                "binary": function (left, right, op, callback) {
                    return void 0 === op && (op = false), false !== op && (void 0 === callback && (callback = op)), this.addToFileList("binary", left, right, {
                        "callback": op,
                        "callbackContext": callback
                    }, false, '.bin');
                },

                "spritesheet": function (numFrames, deepDataAndEvents, frameWidth, frameHeight, frameMax, margin, spacing, overwrite) {
                    return void 0 === frameMax && (frameMax = -1), void 0 === margin && (margin = 0), void 0 === spacing && (spacing = 0), void 0 === overwrite && (overwrite = 0), this.addToFileList('spritesheet', numFrames, deepDataAndEvents, {
                        "frameWidth": frameWidth,
                        "frameHeight": frameHeight,
                        "frameMax": frameMax,
                        "margin": margin,
                        "spacing": spacing,
                        "skipFrames": overwrite
                    }, false, '.png');
                },

                "audio": function (urls, files, autoDecode) {
                    return this.game.sound.noAudio ? this : (void 0 === autoDecode && (autoDecode = true), 'string' == typeof files && (files = [files]), this.addToFileList("audio", urls, files, {
                        "buffer": null,
                        "autoDecode": autoDecode
                    }));
                },

                "audioSprite": function (deepDataAndEvents, walkers, opt_scope, body, opt_obj2) {
                    return this.game.sound.noAudio ? this : (void 0 === opt_scope && (opt_scope = null), void 0 === body && (body = null), void 0 === opt_obj2 && (opt_obj2 = true), this.audio(deepDataAndEvents, walkers, opt_obj2), opt_scope ? this.json(deepDataAndEvents + '-audioatlas', opt_scope) : body ? ("string" == typeof body && (body = JSON.parse(body)), this.cache.addJSON(deepDataAndEvents + "-audioatlas", "", body)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"),
                        this);
                },

                "audiosprite": function (deepDataAndEvents, opt_obj2, walkers, isXML, next_scope) {
                    return this.audioSprite(deepDataAndEvents, opt_obj2, walkers, isXML, next_scope);
                },

                "video": function (deepDataAndEvents, options, dataAndEvents, url) {
                    return void 0 === dataAndEvents && (dataAndEvents = this.game.device.firefox ? "loadeddata" : 'canplaythrough'), void 0 === url && (url = false), 'string' == typeof options && (options = [options]), this.addToFileList("video", deepDataAndEvents, options, {
                        "buffer": null,
                        "asBlob": url,
                        "loadEvent": dataAndEvents
                    });
                },

                "tilemap": function (mapData, overwrite, basis, format) {
                    if (void 0 === overwrite && (overwrite = null), void 0 === basis && (basis = null), void 0 === format && (format = $.Tilemap.CSV), overwrite || (basis || (overwrite = format === $.Tilemap.CSV ? mapData + ".csv" : mapData + '.json')), basis) {
                        switch (format) {
                        case $.Tilemap.CSV:
                            break;
                        case $.Tilemap.TILED_JSON:
                            if ('string' == typeof basis) {
                                basis = JSON.parse(basis);
                            };
                        }
                        this.cache.addTilemap(mapData, null, basis, format);
                    } else {
                        this.addToFileList('tilemap', mapData, overwrite, {
                            "format": format
                        });
                    }
                    return this;
                },

                "physics": function (e, el, body, formatString) {
                    return void 0 === el && (el = null), void 0 === body && (body = null), void 0 === formatString && (formatString = $.Physics.LIME_CORONA_JSON), el || (body || (el = e + '.json')), body ? ('string' == typeof body && (body = JSON.parse(body)), this.cache.addPhysicsData(e, null, body, formatString)) : this.addToFileList('physics', e, el, {
                        "format": formatString
                    }), this;
                },

                "bitmapFont": function (xml, format, atlasURL, body, overwrite, xmlData) {
                    if (void 0 !== format && null !== format || (format = xml + ".png"), void 0 === atlasURL && (atlasURL = null), void 0 === body && (body = null), null === atlasURL && (null === body && (atlasURL = xml + '.xml')), void 0 === overwrite && (overwrite = 0), void 0 === xmlData && (xmlData = 0), atlasURL) {
                        this.addToFileList('bitmapfont', xml, format, {
                            "atlasURL": atlasURL,
                            "xSpacing": overwrite,
                            "ySpacing": xmlData
                        });
                    } else {
                        if ('string' == typeof body) {
                            var to;
                            var from;
                            try {
                                to = JSON.parse(body);
                            } catch (_0x2bf955) {
                                from = this.parseXml(body);
                            }
                            if (!from && !to) {
                                throw new Error('Phaser.Loader. Invalid Bitmap Font atlas given');
                            }
                            this.addToFileList('bitmapfont', xml, format, {
                                "atlasURL": null,
                                "atlasData": to || from,
                                "atlasType": to ? "json" : 'xml',
                                "xSpacing": overwrite,
                                "ySpacing": xmlData
                            });
                        }
                    }
                    return this;
                },

                "atlasJSONArray": function (dataUrl, atlasData, textureURL, data) {
                    return this.atlas(dataUrl, atlasData, textureURL, data, $.Loader.TEXTURE_ATLAS_JSON_ARRAY);
                },

                "atlasJSONHash": function (dataUrl, atlasData, textureURL, data) {
                    return this.atlas(dataUrl, atlasData, textureURL, data, $.Loader.TEXTURE_ATLAS_JSON_HASH);
                },

                "atlasXML": function (dataUrl, data, atlasData, textureURL) {
                    return void 0 === atlasData && (atlasData = null), void 0 === textureURL && (textureURL = null), atlasData || (textureURL || (atlasData = dataUrl + '.xml')), this.atlas(dataUrl, data, atlasData, textureURL, $.Loader.TEXTURE_ATLAS_XML_STARLING);
                },

                "atlas": function (line, code, atlasURL, data, format) {
                    if (void 0 !== code && null !== code || (code = line + '.png'), void 0 === atlasURL && (atlasURL = null), void 0 === data && (data = null), void 0 === format && (format = $.Loader.TEXTURE_ATLAS_JSON_ARRAY), atlasURL || (data || (atlasURL = format === $.Loader.TEXTURE_ATLAS_XML_STARLING ? line + '.xml' : line + '.json')), atlasURL) {
                        this.addToFileList('textureatlas', line, code, {
                            "atlasURL": atlasURL,
                            "format": format
                        });
                    } else {
                        switch (format) {
                        case $.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            if ('string' == typeof data) {
                                data = JSON.parse(data);
                            }
                            break;
                        case $.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ('string' == typeof data) {
                                var tmp = this.parseXml(data);
                                if (!tmp) {
                                    throw new Error('Phaser.Loader. Invalid Texture Atlas XML given');
                                }
                                data = tmp;
                            };
                        }
                        this.addToFileList("textureatlas", line, code, {
                            "atlasURL": null,
                            "atlasData": data,
                            "format": format
                        });
                    }
                    return this;
                },

                "withSyncPoint": function (dataAndEvents, deepDataAndEvents) {
                    this._withSyncPointDepth++;
                    try {
                        dataAndEvents.call(deepDataAndEvents || this, this);
                    } finally {
                        this._withSyncPointDepth--;
                    }
                    return this;
                },

                "addSyncPoint": function (entry, elems) {
                    var ret = this.getAsset(entry, elems);
                    return ret && (ret.file.syncPoint = true), this;
                },

                "removeFile": function (success, path) {
                    var res = this.getAsset(success, path);
                    if (res) {
                        if (!res.loaded) {
                            if (!res.loading) {
                                this._fileList.splice(res.index, 1);
                            }
                        }
                    }
                },

                "removeAll": function () {

                    this._fileList.length = 0;

                    this._flightQueue.length = 0;
                },

                "start": function () {
                    if (!this.isLoading) {

                        this.hasLoaded = false;

                        this.isLoading = true;
                        this.updateProgress();
                        this.processLoadQueue();
                    }
                },

                "processLoadQueue": function () {
                    if (!this.isLoading) {
                        return console.warn('Phaser.Loader - active loading canceled / reset'), void this.finishedLoading(true);
                    }

                    sel = 0;
                    for (; sel < this._flightQueue.length; sel++) {
                        if ((loaded = this._flightQueue[sel]).loaded || loaded.error) {
                            this._flightQueue.splice(sel, 1);
                            sel--;

                            loaded.loading = false;

                            loaded.requestUrl = null;

                            loaded.requestObject = null;
                            if (loaded.error) {
                                this.onFileError.dispatch(loaded.key, loaded);
                            }
                            if ('packfile' !== loaded.type) {
                                this._loadedFileCount++;
                                this.onFileComplete.dispatch(this.progress, loaded.key, !loaded.error, this._loadedFileCount, this._totalFileCount);
                            } else {
                                if ('packfile' === loaded.type) {
                                    if (loaded.error) {
                                        this._loadedPackCount++;
                                        this.onPackComplete.dispatch(loaded.key, !loaded.error, this._loadedPackCount, this._totalPackCount);
                                    }
                                }
                            }
                        }
                    }

                    var row = false;
                    var height = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1;
                    var sel = this._processingHead;
                    for (; sel < this._fileList.length; sel++) {
                        var loaded = this._fileList[sel];
                        if ('packfile' === loaded.type && (!loaded.error && (loaded.loaded && (sel === this._processingHead && (this.processPack(loaded), this._loadedPackCount++, this.onPackComplete.dispatch(loaded.key, !loaded.error, this._loadedPackCount, this._totalPackCount))))), loaded.loaded || loaded.error ? sel === this._processingHead && (this._processingHead = sel + 1) : !loaded.loading && (this._flightQueue.length <
                                height && ('packfile' !== loaded.type || loaded.data ? row || (this._fileLoadStarted || (this._fileLoadStarted = true, this.onLoadStart.dispatch()), this._flightQueue.push(loaded), loaded.loading = true, this.onFileStart.dispatch(this.progress, loaded.key, loaded.url), this.loadFile(loaded)) : (this._flightQueue.push(loaded), loaded.loading = true, this.loadFile(loaded)))),
                            !loaded.loaded && (loaded.syncPoint && (row = true)), this._flightQueue.length >= height || row && this._loadedPackCount === this._totalPackCount) {
                            break;
                        }
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) {
                        this.finishedLoading();
                    } else {
                        if (!this._flightQueue.length) {
                            console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                            var _0x1106ee = this;
                            setTimeout(function () {
                                _0x1106ee.finishedLoading(true);
                            }, 2E3);
                        }
                    }
                },

                "finishedLoading": function (dataAndEvents) {
                    if (!this.hasLoaded) {

                        this.hasLoaded = true;

                        this.isLoading = false;
                        if (!dataAndEvents) {
                            if (!this._fileLoadStarted) {

                                this._fileLoadStarted = true;
                                this.onLoadStart.dispatch();
                            }
                        }
                        this.game.state.loadUpdate();
                        this.onBeforeLoadComplete.dispatch();
                        this.reset();
                        this.onLoadComplete.dispatch();
                        if (this.game.state) {
                            this.game.state.loadComplete();
                        }
                    }
                },

                "asyncComplete": function (data, element) {
                    if (void 0 === element) {

                        element = "";
                    }

                    data.loaded = true;

                    data.error = !!element;
                    if (element) {

                        data.errorMessage = element;
                        console.warn('Phaser.Loader - ' + data.type + "[" + data.key + ']: ' + element);
                    }
                    this.processLoadQueue();
                },

                "processPack": function ($cookies) {
                    var sorted = $cookies.data[$cookies.key];
                    if (sorted) {

                        var key = 0;
                        for (; key < sorted.length; key++) {
                            var cache = sorted[key];
                            switch (cache.type) {
                            case 'image':
                                this.image(cache.key, cache.url, cache.overwrite);
                                break;
                            case 'text':
                                this.text(cache.key, cache.url, cache.overwrite);
                                break;
                            case 'json':
                                this.json(cache.key, cache.url, cache.overwrite);
                                break;
                            case 'xml':
                                this.xml(cache.key, cache.url, cache.overwrite);
                                break;
                            case 'script':
                                this.script(cache.key, cache.url, cache.callback, $cookies.callbackContext || this);
                                break;
                            case 'binary':
                                this.binary(cache.key, cache.url, cache.callback, $cookies.callbackContext || this);
                                break;
                            case 'spritesheet':
                                this.spritesheet(cache.key, cache.url, cache.frameWidth, cache.frameHeight, cache.frameMax, cache.margin, cache.spacing, cache.skipFrames);
                                break;
                            case 'video':
                                this.video(cache.key, cache.urls);
                                break;
                            case 'audio':
                                this.audio(cache.key, cache.urls, cache.autoDecode);
                                break;
                            case 'audiosprite':
                                this.audiosprite(cache.key, cache.urls, cache.jsonURL, cache.jsonData, cache.autoDecode);
                                break;
                            case 'tilemap':
                                this.tilemap(cache.key, cache.url, cache.data, $.Tilemap[cache.format]);
                                break;
                            case 'physics':
                                this.physics(cache.key, cache.url, cache.data, $.Loader[cache.format]);
                                break;
                            case 'bitmapFont':
                                this.bitmapFont(cache.key, cache.textureURL, cache.atlasURL, cache.atlasData, cache.xSpacing, cache.ySpacing);
                                break;
                            case 'atlasJSONArray':
                                this.atlasJSONArray(cache.key, cache.textureURL, cache.atlasURL, cache.atlasData);
                                break;
                            case 'atlasJSONHash':
                                this.atlasJSONHash(cache.key, cache.textureURL, cache.atlasURL, cache.atlasData);
                                break;
                            case 'atlasXML':
                                this.atlasXML(cache.key, cache.textureURL, cache.atlasURL, cache.atlasData);
                                break;
                            case "atlas":
                                this.atlas(cache.key, cache.textureURL, cache.atlasURL, cache.atlasData, $.Loader[cache.format]);
                                break;
                            case "shader":
                                this.shader(cache.key, cache.url, cache.overwrite);
                            }
                        }
                    } else {
                        console.warn('Phaser.Loader - ' + $cookies.key + ': pack has data, but not for pack key');
                    }
                },

                "transformUrl": function (dataAndEvents, url) {
                    return !!dataAndEvents && (dataAndEvents.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? dataAndEvents : this.baseURL + url.path + dataAndEvents);
                },

                "loadFile": function (args) {
                    switch (args.type) {
                    case 'packfile':
                        this.xhrLoad(args, this.transformUrl(args.url, args), 'text', this.fileComplete);
                        break;
                    case 'image':
                        ;
                    case 'spritesheet':
                        ;
                    case 'textureatlas':
                        ;
                    case "bitmapfont":
                        this.loadImageTag(args);
                        break;
                    case 'audio':
                        args.url = this.getAudioURL(args.url);
                        if (args.url) {
                            if (this.game.sound.usingWebAudio) {
                                this.xhrLoad(args, this.transformUrl(args.url, args), 'arraybuffer', this.fileComplete);
                            } else {
                                if (this.game.sound.usingAudioTag) {
                                    this.loadAudioTag(args);
                                }
                            }
                        } else {
                            this.fileError(args, null, 'No supported audio URL specified or device does not have audio playback support');
                        }
                        break;
                    case "video":
                        args.url = this.getVideoURL(args.url);
                        if (args.url) {
                            if (args.asBlob) {
                                this.xhrLoad(args, this.transformUrl(args.url, args), 'blob', this.fileComplete);
                            } else {
                                this.loadVideoTag(args);
                            }
                        } else {
                            this.fileError(args, null, 'No supported video URL specified or device does not have video playback support');
                        }
                        break;
                    case "json":
                        this.xhrLoad(args, this.transformUrl(args.url, args), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(args, this.transformUrl(args.url, args), 'text', this.xmlLoadComplete);
                        break;
                    case 'tilemap':
                        if (args.format === $.Tilemap.TILED_JSON) {
                            this.xhrLoad(args, this.transformUrl(args.url, args), "text", this.jsonLoadComplete);
                        } else {
                            if (args.format === $.Tilemap.CSV) {
                                this.xhrLoad(args, this.transformUrl(args.url, args), "text", this.csvLoadComplete);
                            } else {
                                this.asyncComplete(args, 'invalid Tilemap format: ' + args.format);
                            }
                        }
                        break;
                    case "text":
                        ;
                    case 'script':
                        ;
                    case 'shader':
                        ;
                    case 'physics':
                        this.xhrLoad(args, this.transformUrl(args.url, args), 'text', this.fileComplete);
                        break;
                    case 'texture':
                        if ('truecolor' === args.key.split("_").pop()) {
                            this.loadImageTag(args);
                        } else {
                            this.xhrLoad(args, this.transformUrl(args.url, args), "arraybuffer", this.fileComplete);
                        }
                        break;
                    case 'binary':
                        this.xhrLoad(args, this.transformUrl(args.url, args), 'arraybuffer', this.fileComplete);
                    }
                },

                "loadImageTag": function (images) {
                    var _0xb7b97d = this;

                    images.data = new Image;
                    images.data.name = images.key;
                    if (this.crossOrigin) {
                        images.data.crossOrigin = this.crossOrigin;
                    }

                    images.data.onload = function () {
                        if (images.data.onload) {

                            images.data.onload = null;

                            images.data.onerror = null;
                            _0xb7b97d.fileComplete(images);
                        }
                    };

                    images.data.onerror = function () {
                        if (images.data.onload) {

                            images.data.onload = null;

                            images.data.onerror = null;
                            _0xb7b97d.fileError(images);
                        }
                    };
                    images.data.src = this.transformUrl(images.url, images);
                    if (!this.game.device.firefox) {
                        if (images.data.complete) {
                            if (images.data.width) {
                                if (images.data.height) {

                                    images.data.onload = null;

                                    images.data.onerror = null;
                                    this.fileComplete(images);
                                }
                            }
                        }
                    }
                },

                "loadVideoTag": function (cache) {
                    var domParts = this;
                    cache.data = document.createElement('video');
                    cache.data.name = cache.key;

                    cache.data.controls = false;

                    cache.data.autoplay = false;

                    var handler = function () {
                        cache.data.removeEventListener(cache.loadEvent, handler, false);

                        cache.data.onerror = null;

                        cache.data.canplay = true;
                        $.GAMES[domParts.game.id].load.fileComplete(cache);
                    };

                    cache.data.onerror = function () {
                        cache.data.removeEventListener(cache.loadEvent, handler, false);

                        cache.data.onerror = null;

                        cache.data.canplay = false;
                        domParts.fileError(cache);
                    };
                    cache.data.addEventListener(cache.loadEvent, handler, false);
                    cache.data.src = this.transformUrl(cache.url, cache);
                    cache.data.load();
                },

                "loadAudioTag": function (obj) {
                    var _ = this;
                    if (this.game.sound.touchLocked) {
                        obj.data = new Audio;
                        obj.data.name = obj.key;
                        obj.data.preload = 'auto';
                        obj.data.src = this.transformUrl(obj.url, obj);
                        this.fileComplete(obj);
                    } else {
                        obj.data = new Audio;
                        obj.data.name = obj.key;

                        var listener = function () {
                            obj.data.removeEventListener("canplaythrough", listener, false);

                            obj.data.onerror = null;
                            _.fileComplete(obj);
                        };

                        obj.data.onerror = function () {
                            obj.data.removeEventListener('canplaythrough', listener, false);

                            obj.data.onerror = null;
                            _.fileError(obj);
                        };
                        obj.data.preload = 'auto';
                        obj.data.src = this.transformUrl(obj.url, obj);
                        obj.data.addEventListener("canplaythrough", listener, false);
                        obj.data.load();
                    }
                },

                "xhrLoad": function (data, element, n, $, options) {

                    var r = new XMLHttpRequest;
                    r.open('GET', element, true);
                    r.responseType = n;
                    if (false !== this.headers.requestedWith) {
                        r.setRequestHeader('X-Requested-With', this.headers.requestedWith);
                    }
                    if (this.headers[data.type]) {
                        r.setRequestHeader("Accept", this.headers[data.type]);
                    }
                    options = options || this.fileError;
                    var value = this;

                    r.onload = function () {
                        try {
                            return 4 === r.readyState && (r.status >= 400 && r.status <= 599) ? options.call(value, data, r) : $.call(value, data, r);
                        } catch (error) {
                            if (value.hasLoaded) {
                                if (window.console) {
                                    console.error(error);
                                }
                            } else {
                                value.asyncComplete(data, error.message || 'Exception');
                            }
                        }
                    };

                    r.onerror = function () {
                        try {
                            return options.call(value, data, r);
                        } catch (x) {
                            if (value.hasLoaded) {
                                if (window.console) {
                                    console.error(x);
                                }
                            } else {
                                value.asyncComplete(data, x.message || 'Exception');
                            }
                        }
                    };

                    data.requestObject = r;
                    data.requestUrl = element;
                    r.send();
                },

                "getVideoURL": function (params) {

                    var key = 0;
                    for (; key < params.length; key++) {
                        var r;
                        var t = params[key];
                        if (t.uri) {
                            if (r = t.type, t = t.uri, this.game.device.canPlayVideo(r)) {
                                return t;
                            }
                        } else {
                            if (0 === t.indexOf('blob:') || 0 === t.indexOf('data:')) {
                                return t;
                            }
                            if (t.indexOf("?") >= 0 && (t = t.substr(0, t.indexOf("?"))), r = t.substr((Math.max(0, t.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(r)) {
                                return params[key];
                            }
                        }
                    }
                    return null;
                },

                "getAudioURL": function (ob) {
                    if (this.game.sound.noAudio) {
                        return null;
                    }

                    var unlock = 0;
                    for (; unlock < ob.length; unlock++) {
                        var returnElement;
                        var cache = ob[unlock];
                        if (cache.uri) {
                            if (returnElement = cache.type, cache = cache.uri, this.game.device.canPlayAudio(returnElement)) {
                                return cache;
                            }
                        } else {
                            if (0 === cache.indexOf('blob:') || 0 === cache.indexOf("data:")) {
                                return cache;
                            }
                            if (cache.indexOf("?") >= 0 && (cache = cache.substr(0, cache.indexOf("?"))), returnElement = cache.substr((Math.max(0, cache.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(returnElement)) {
                                return ob[unlock];
                            }
                        }
                    }
                    return null;
                },

                "fileError": function (textStatus, namespaces, namespace) {
                    var copies = 'error loading asset from URL ' + (textStatus.requestUrl || this.transformUrl(textStatus.url, textStatus));
                    if (!namespace) {
                        if (namespaces) {
                            namespace = namespaces.status;
                        }
                    }
                    if (namespace) {

                        copies = copies + " (" + namespace + ")";
                    }
                    this.asyncComplete(textStatus, copies);
                },

                "fileComplete": function (cache, data) {

                    var _0x423d30 = true;
                    switch (cache.type) {
                    case 'packfile':
                        r20 = JSON.parse(data.responseText);
                        cache.data = r20 || {};
                        break;
                    case 'texture':
                        var restoreScript = /\.([^.]+)$/ ["exec"](cache.url.split("?", 1)[0])[1].toLowerCase();
                        if (null !== cache.data) {
                            this.cache.addCompressedTextureMetaData(cache.key, cache.url, restoreScript, cache.data);
                        } else {
                            this.cache.addCompressedTextureMetaData(cache.key, cache.url, restoreScript, data.response);
                        }
                        break;
                    case 'image':
                        this.cache.addImage(cache.key, cache.url, cache.data);
                        break;
                    case 'spritesheet':
                        this.cache.addSpriteSheet(cache.key, cache.url, cache.data, cache.frameWidth, cache.frameHeight, cache.frameMax, cache.margin, cache.spacing, cache.skipFrames);
                        break;
                    case 'textureatlas':
                        if (null == cache.atlasURL) {
                            this.cache.addTextureAtlas(cache.key, cache.url, cache.data, cache.atlasData, cache.format);
                        } else {
                            if (_0x423d30 = false, cache.format === $.Loader.TEXTURE_ATLAS_JSON_ARRAY || (cache.format === $.Loader.TEXTURE_ATLAS_JSON_HASH || cache.format === $.Loader.TEXTURE_ATLAS_JSON_PYXEL)) {
                                this.xhrLoad(cache, this.transformUrl(cache.atlasURL, cache), 'text', this.jsonLoadComplete);
                            } else {
                                if (cache.format !== $.Loader.TEXTURE_ATLAS_XML_STARLING) {
                                    throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + cache.format);
                                }
                                this.xhrLoad(cache, this.transformUrl(cache.atlasURL, cache), "text", this.xmlLoadComplete);
                            }
                        }
                        break;
                    case "bitmapfont":
                        if (cache.atlasURL) {

                            _0x423d30 = false;
                            this.xhrLoad(cache, this.transformUrl(cache.atlasURL, cache), 'text', function (deepDataAndEvents, value) {
                                var _0x1c2210;
                                try {
                                    _0x1c2210 = JSON.parse(value.responseText);
                                } catch (_0x53377d) {}
                                if (_0x1c2210) {
                                    deepDataAndEvents.atlasType = 'json';
                                    this.jsonLoadComplete(deepDataAndEvents, value);
                                } else {
                                    deepDataAndEvents.atlasType = 'xml';
                                    this.xmlLoadComplete(deepDataAndEvents, value);
                                }
                            });
                        } else {
                            this.cache.addBitmapFont(cache.key, cache.url, cache.data, cache.atlasData, cache.atlasType, cache.xSpacing, cache.ySpacing);
                        }
                        break;
                    case 'video':
                        if (cache.asBlob) {
                            try {
                                cache.data = data.response;
                            } catch (_0x53e808) {
                                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + cache.key);
                            }
                        }
                        this.cache.addVideo(cache.key, cache.url, cache.data, cache.asBlob);
                        break;
                    case "audio":
                        if (this.game.sound.usingWebAudio) {
                            cache.data = data.response;
                            this.cache.addSound(cache.key, cache.url, cache.data, true, false);
                            if (cache.autoDecode) {
                                this.game.sound.decode(cache.key);
                            }
                        } else {
                            this.cache.addSound(cache.key, cache.url, cache.data, false, true);
                        }
                        break;
                    case 'text':
                        cache.data = data.responseText;
                        this.cache.addText(cache.key, cache.url, cache.data);
                        break;
                    case 'shader':
                        cache.data = data.responseText;
                        this.cache.addShader(cache.key, cache.url, cache.data);
                        break;
                    case "physics":
                        var r20 = JSON.parse(data.responseText);
                        this.cache.addPhysicsData(cache.key, cache.url, r20, cache.format);
                        break;
                    case "script":
                        cache.data = document.createElement('script');

                        cache.data.language = "javascript";
                        cache.data.type = 'text/javascript';

                        cache.data.defer = false;
                        cache.data.text = data.responseText;
                        document.head.appendChild(cache.data);
                        if (cache.callback) {
                            cache.data = cache.callback.call(cache.callbackContext, cache.key, data.responseText);
                        }
                        break;
                    case "binary":
                        if (cache.callback) {
                            cache.data = cache.callback.call(cache.callbackContext, cache.key, data.response);
                        } else {
                            cache.data = data.response;
                        }
                        this.cache.addBinary(cache.key, cache.data);
                    }
                    if (_0x423d30) {
                        this.asyncComplete(cache);
                    }
                },

                "jsonLoadComplete": function (cache, value) {
                    var r20 = JSON.parse(value.responseText);
                    if ('tilemap' === cache.type) {
                        this.cache.addTilemap(cache.key, cache.url, r20, cache.format);
                    } else {
                        if ("bitmapfont" === cache.type) {
                            this.cache.addBitmapFont(cache.key, cache.url, cache.data, r20, cache.atlasType, cache.xSpacing, cache.ySpacing);
                        } else {
                            if ('json' === cache.type) {
                                this.cache.addJSON(cache.key, cache.url, r20);
                            } else {
                                this.cache.addTextureAtlas(cache.key, cache.url, cache.data, r20, cache.format);
                            }
                        }
                    }
                    this.asyncComplete(cache);
                },

                "csvLoadComplete": function (loadedImages, dataAndEvents) {
                    var r20 = dataAndEvents.responseText;
                    this.cache.addTilemap(loadedImages.key, loadedImages.url, r20, loadedImages.format);
                    this.asyncComplete(loadedImages);
                },

                "xmlLoadComplete": function (pending, args) {
                    var next = args.responseText;
                    var timeout = this.parseXml(next);
                    if (!timeout) {
                        var _0x412b52 = args.responseType || args.contentType;
                        return console.warn("Phaser.Loader - " + pending.key + ': invalid XML (' + _0x412b52 + ")"), void this.asyncComplete(pending, "invalid XML");
                    }
                    if ('bitmapfont' === pending.type) {
                        this.cache.addBitmapFont(pending.key, pending.url, pending.data, timeout, pending.atlasType, pending.xSpacing, pending.ySpacing);
                    } else {
                        if ("textureatlas" === pending.type) {
                            this.cache.addTextureAtlas(pending.key, pending.url, pending.data, timeout, pending.format);
                        } else {
                            if ("xml" === pending.type) {
                                this.cache.addXML(pending.key, pending.url, timeout);
                            }
                        }
                    }
                    this.asyncComplete(pending);
                },

                "parseXml": function (data) {
                    var xml;
                    try {
                        if (window.DOMParser) {

                            var parser = new DOMParser;
                            xml = parser.parseFromString(data, 'text/xml');
                        } else {
                            (xml = new ActiveXObject('Microsoft.XMLDOM')).async = 'false';
                            xml.loadXML(data);
                        }
                    } catch (_0x2d129f) {

                        xml = null;
                    }
                    return xml && (xml.documentElement && !xml.getElementsByTagName('parsererror').length) ? xml : null;
                },

                "updateProgress": function () {
                    if (this.preloadSprite) {
                        if (0 === this.preloadSprite.direction) {
                            this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress);
                        } else {
                            this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress);
                        }
                        if (this.preloadSprite.sprite) {
                            this.preloadSprite.sprite.updateCrop();
                        } else {

                            this.preloadSprite = null;
                        }
                    }
                },

                "totalLoadedFiles": function () {
                    return this._loadedFileCount;
                },

                "totalQueuedFiles": function () {
                    return this._totalFileCount - this._loadedFileCount;
                },

                "totalLoadedPacks": function () {
                    return this._totalPackCount;
                },

                "totalQueuedPacks": function () {
                    return this._totalPackCount - this._loadedPackCount;
                }
            }, Object.defineProperty($.Loader.prototype, 'progressFloat', {

                "get": function () {

                    var _0x529538 = this._loadedFileCount / this._totalFileCount * 100;
                    return $.Math.clamp(_0x529538 || 0, 0, 100);
                }
            }), Object.defineProperty($.Loader.prototype, 'progress', {

                "get": function () {
                    return Math.round(this.progressFloat);
                }
            }), $.Loader.prototype.constructor = $.Loader, $.LoaderParser = {

                "bitmapFont": function (xml, dataUrl, xmlData, cacheKey, overwrite, textureURL) {
                    return this.xmlBitmapFont(xml, dataUrl, xmlData, cacheKey, overwrite, textureURL);
                },

                "xmlBitmapFont": function (dataAndEvents, deepDataAndEvents, x, delta, keys, d) {
                    if (null == d) {

                        d = 1;
                    }
                    var ret = {};
                    var $ = dataAndEvents.getElementsByTagName("info")[0];
                    var el = dataAndEvents.getElementsByTagName("common")[0];
                    ret.font = $.getAttribute('face');

                    ret.size = parseInt($.getAttribute("size"), 10);
                    ret.lineHeight = parseInt(el.getAttribute('lineHeight'), 10) + delta;
                    ret.chars = {};
                    var vis = dataAndEvents.getElementsByTagName('char');
                    var length = keys ? keys.x : 0;
                    var j = keys ? keys.y : 0;

                    var i = 0;
                    for (; i < vis.length; i++) {

                        var n = parseInt(vis[i].getAttribute("id"), 10);
                        ret.chars[n] = {
                            "x": length + parseInt(vis[i].getAttribute("x"), 10),
                            "y": j + parseInt(vis[i].getAttribute("y"), 10),
                            "width": parseInt(vis[i].getAttribute('width'), 10),
                            "height": parseInt(vis[i].getAttribute('height'), 10),
                            "xOffset": parseInt(vis[i].getAttribute('xoffset'), 10) / d,
                            "yOffset": parseInt(vis[i].getAttribute('yoffset'), 10) / d,
                            "xAdvance": (parseInt(vis[i].getAttribute('xadvance'), 10) + x) / d,
                            "kerning": {}
                        };
                    }
                    var StepCount = dataAndEvents.getElementsByTagName('kerning');

                    i = 0;
                    for (; i < StepCount.length; i++) {

                        var key = parseInt(StepCount[i].getAttribute('first'), 10);

                        var k = parseInt(StepCount[i].getAttribute('second'), 10);

                        var t = parseInt(StepCount[i].getAttribute('amount'), 10) / d;

                        ret.chars[k].kerning[key] = t;
                    }
                    return this.finalizeBitmapFont(deepDataAndEvents, ret);
                },

                "jsonBitmapFont": function (row, deepDataAndEvents, x, topOffset, keys, d) {
                    if (null == d) {

                        d = 1;
                    }
                    var ret = {
                        "font": row.font.info._face,
                        "size": parseInt(row.font.info._size, 10),
                        "lineHeight": parseInt(row.font.common._lineHeight, 10) + topOffset,
                        "chars": {}
                    };
                    var j = keys ? keys.x : 0;
                    var length = keys ? keys.y : 0;
                    return row.font.chars.char.forEach(function (charObj) {

                        var n = parseInt(charObj._id, 10);
                        ret.chars[n] = {
                            "x": j + parseInt(charObj._x, 10),
                            "y": length + parseInt(charObj._y, 10),
                            "width": parseInt(charObj._width, 10),
                            "height": parseInt(charObj._height, 10),
                            "xOffset": parseInt(charObj._xoffset, 10) / d,
                            "yOffset": parseInt(charObj._yoffset, 10) / d,
                            "xAdvance": (parseInt(charObj._xadvance, 10) + x) / d,
                            "kerning": {}
                        };
                    }), row.font.kernings && (row.font.kernings.kerning && row.font.kernings.kerning.forEach(function (execResult) {

                        ret.chars[execResult._second].kerning[execResult._first] = parseInt(execResult._amount, 10) / d;
                    })), this.finalizeBitmapFont(deepDataAndEvents, ret);
                },

                "finalizeBitmapFont": function (dataAndEvents, response) {
                    return Object.keys(response.chars).forEach(function (status) {
                        var msg = response.chars[status];
                        msg.texture = new(PIXI.Texture)(dataAndEvents, new($.Rectangle)(msg.x, msg.y, msg.width, msg.height));
                    }), response;
                },

                "pvr": function (array) {
                    var stability;

                    var data = new Uint32Array(array.slice(0, 52));

                    var view = new Uint8Array(array);

                    var settings = null;

                    var code = data[3] << 32 | data[2];

                    var glExtensionFormat = 0;
                    if (55727696 === data[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(code) >= 0) {
                        switch (code >= 0 && code <= 3 ? stability = 'PVRTC' : code >= 7 && code <= 11 ? stability = 'S3TC' : 6 === code && (stability = 'ETC1'), code) {
                        case 0:

                            glExtensionFormat = 35841;
                            break;
                        case 1:

                            glExtensionFormat = 35843;
                            break;
                        case 2:

                            glExtensionFormat = 35840;
                            break;
                        case 3:

                            glExtensionFormat = 35842;
                            break;
                        case 6:

                            glExtensionFormat = 36196;
                            break;
                        case 7:

                            glExtensionFormat = 33777;
                            break;
                        case 9:

                            glExtensionFormat = 33778;
                            break;
                        case 11:

                            glExtensionFormat = 33779;
                            break;
                        default:

                            glExtensionFormat = -1;
                        }
                        settings = {
                            "complete": true,
                            "fileFormat": 'PVR',
                            "compressionAlgorithm": stability,
                            "flags": data[1],
                            "pixelFormat": code,
                            "colorSpace": data[4],
                            "channelType": data[5],
                            "height": data[6],
                            "width": data[7],
                            "depth": data[8],
                            "numberOfSurfaces": data[9],
                            "numberOfFaces": data[10],
                            "numberOfMipmaps": data[11],
                            "metaDataSize": data[12],
                            "textureData": view.subarray(52 + data[12], view.byteLength),
                            "glExtensionFormat": glExtensionFormat
                        };
                    }
                    return settings;
                },

                "dds": function (arrayBuffer) {

                    var uInt8 = new Uint8Array(arrayBuffer);

                    var data = new Uint32Array(arrayBuffer);

                    var config = null;
                    return 68 === uInt8[0] && (68 === uInt8[1] && (83 === uInt8[2] && (32 === uInt8[3] && ("DX10" === (config = {
                        "complete": true,
                        "fileFormat": "DDS",
                        "compressionAlgorithm": 'S3TC',
                        "size": data[1],
                        "flags": data[2],
                        "height": data[3],
                        "width": data[4],
                        "pitch": data[5],
                        "depth": data[6],
                        "mipmapCount": data[7],
                        "formatSize": data[19],
                        "formatFlag": data[19],
                        "formatFourCC": [String.fromCharCode(uInt8[84]), String.fromCharCode(uInt8[85]), String.fromCharCode(uInt8[86]), String.fromCharCode(uInt8[87])].join(""),
                        "formatBitCount": data[21],
                        "formatRBitMask": data[22],
                        "formatGBitMask": data[23],
                        "formatBBitMask": data[24],
                        "formatABitMask": data[25],
                        "caps1": data[26],
                        "caps2": data[27],
                        "caps3": data[28],
                        "caps4": data[29],
                        "reserved2": data[30],
                        "DXGIFormat": null,
                        "resourceDimension": null,
                        "miscFlag": null,
                        "arraySize": null,
                        "textureData": uInt8.subarray(data[1] + 4, uInt8.byteLength)
                    }).formatFourCC && (config.DXGIFormat = data[31], config.resourceDimension = data[32], config.miscFlag = data[33], config.arraySize = data[34], config.miscFlag = data[35]))))), config;
                },

                "ktx": function (length) {

                    var binary = new Uint8Array(length);

                    var result = new Uint32Array(length);

                    var glTypeSize = null;

                    var status = 16 + result[15] / 4 | 0;
                    var message = result[status];
                    var tail = result[7];

                    var compressionAlgorithm = 0;
                    if (171 === binary[0] && (75 === binary[1] && (84 === binary[2] && (88 === binary[3] && (32 === binary[4] && (49 === binary[5] && (49 === binary[6] && (187 === binary[7] && (13 === binary[8] && (10 === binary[9] && (26 === binary[10] && (10 === binary[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(tail) >= 0)))))))))))) {
                        switch (tail) {
                        case 36196:
                            compressionAlgorithm = 'ETC1';
                            break;
                        case 35840:
                            ;
                        case 35841:
                            ;
                        case 35842:
                            ;
                        case 35843:

                            compressionAlgorithm = "PVRTC";
                            break;
                        case 33776:
                            ;
                        case 33777:
                            ;
                        case 33778:
                            ;
                        case 33779:

                            compressionAlgorithm = "S3TC";
                        }
                        glTypeSize = {
                            "complete": true,
                            "fileFormat": 'KTX',
                            "compressionAlgorithm": compressionAlgorithm,
                            "endianness": result[3],
                            "glType": result[4],
                            "glTypeSize": result[5],
                            "glFormat": result[6],
                            "glInternalFormat": result[7],
                            "glBaseInternalFormat": result[8],
                            "width": result[9],
                            "height": result[10],
                            "pixelDepth": result[11],
                            "numberOfArrayElements": result[12],
                            "numberOfFaces": result[13],
                            "numberOfMipmapLevels": result[14],
                            "bytesOfKeyValueData": result[15],
                            "keyAndValueByteSize": result[16],
                            "imageSize": message,
                            "textureData": binary.subarray(4 * (status + 1), message + 100)
                        };
                    }
                    return glTypeSize;
                },

                "pkm": function (array) {

                    var view = new Uint8Array(array);

                    var config = null;
                    return 80 === view[0] && (75 === view[1] && (77 === view[2] && (32 === view[3] && (config = {
                        "complete": true,
                        "fileFormat": 'PKM',
                        "compressionAlgorithm": 'ETC1',
                        "format": 65535 & (view[6] << 8 | view[7]),
                        "width": 65535 & (view[8] << 8 | view[9]),
                        "height": 65535 & (view[10] << 8 | view[11]),
                        "originalWidth": 65535 & (view[12] << 8 | view[13]),
                        "originalHeight": 65535 & (view[14] << 8 | view[15]),
                        "textureData": view.subarray(16, view.length)
                    })))), config;
                }
            }, $.AudioSprite = function (deepDataAndEvents, dataAndEvents) {
                this.game = deepDataAndEvents;
                this.key = dataAndEvents;
                this.config = this.game.cache.getJSON(dataAndEvents + '-audioatlas');

                this.autoplayKey = null;

                this.autoplay = false;
                this.sounds = {};
                var name;
                for (name in this.config.spritemap) {
                    var args = this.config.spritemap[name];
                    var obj = this.game.add.sound(this.key);
                    obj.addMarker(name, args.start, args.end - args.start, null, args.loop);
                    this.sounds[name] = obj;
                }
                if (this.config.autoplay) {
                    this.autoplayKey = this.config.autoplay;
                    this.play(this.autoplayKey);
                    this.autoplay = this.sounds[this.autoplayKey];
                }
            }, $.AudioSprite.prototype = {

                "play": function (time, action) {
                    return void 0 === action && (action = 1), this.sounds[time].play(time, null, action);
                },

                "stop": function (src) {
                    if (src) {
                        this.sounds[src].stop();
                    } else {
                        var unlock;
                        for (unlock in this.sounds) {
                            this.sounds[unlock].stop();
                        }
                    }
                },

                "get": function (opt_key) {
                    return this.sounds[opt_key];
                }
            }, $.AudioSprite.prototype.constructor = $.AudioSprite, $.Sound = function (sounds, deepDataAndEvents, dataAndEvents, value, ignoreMethodDoesntExist) {
                if (void 0 === dataAndEvents) {

                    dataAndEvents = 1;
                }
                if (void 0 === value) {

                    value = false;
                }
                if (void 0 === ignoreMethodDoesntExist) {
                    ignoreMethodDoesntExist = sounds.sound.connectToMaster;
                }

                this.game = sounds;
                this.name = deepDataAndEvents;
                this.key = deepDataAndEvents;

                this.loop = value;
                this.markers = {};

                this.context = null;

                this.autoplay = false;

                this.totalDuration = 0;

                this.startTime = 0;

                this.currentTime = 0;

                this.duration = 0;

                this.durationMS = 0;

                this.position = 0;

                this.stopTime = 0;

                this.paused = false;

                this.pausedPosition = 0;

                this.pausedTime = 0;

                this.isPlaying = false;

                this.currentMarker = "";

                this.fadeTween = null;

                this.pendingPlayback = false;

                this.override = false;

                this.allowMultiple = false;

                this.playOnce = false;
                this.usingWebAudio = this.game.sound.usingWebAudio;
                this.usingAudioTag = this.game.sound.usingAudioTag;

                this.externalNode = null;

                this.masterGainNode = null;

                this.gainNode = null;

                this._sound = null;

                this._globalVolume = 1;

                this._markedToDelete = false;

                this._removeFromSoundManager = false;
                if (this.usingWebAudio) {
                    this.context = this.game.sound.context;
                    this.masterGainNode = this.game.sound.masterGain;
                    if (void 0 === this.context.createGain) {
                        this.gainNode = this.context.createGainNode();
                    } else {
                        this.gainNode = this.context.createGain();
                    }

                    this.gainNode.gain.value = dataAndEvents;
                    if (ignoreMethodDoesntExist) {
                        this.gainNode.connect(this.masterGainNode);
                    }
                } else {
                    if (this.usingAudioTag) {
                        if (this.game.cache.getSound(deepDataAndEvents) && this.game.cache.isSoundReady(deepDataAndEvents)) {
                            this._sound = this.game.cache.getSoundData(deepDataAndEvents);

                            this.totalDuration = 0;
                            if (this._sound.duration) {
                                this.totalDuration = this._sound.duration;
                            }
                        } else {
                            this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);
                        }
                    }
                }
                this.onDecoded = new($.Signal);
                this.onPlay = new($.Signal);
                this.onPause = new($.Signal);
                this.onResume = new($.Signal);
                this.onLoop = new($.Signal);
                this.onStop = new $.Signal;
                this.onMute = new $.Signal;
                this.onMarkerComplete = new($.Signal);
                this.onFadeComplete = new($.Signal);

                this._volume = dataAndEvents;

                this._buffer = null;

                this._muted = false;

                this._tempMarker = 0;

                this._tempPosition = 0;

                this._tempVolume = 0;

                this._tempPause = 0;

                this._muteVolume = 0;

                this._tempLoop = 0;

                this._paused = false;

                this._onDecodedEventDispatched = false;
            }, $.Sound.prototype = {

                "soundHasUnlocked": function (dataAndEvents) {
                    if (dataAndEvents === this.key) {
                        this._sound = this.game.cache.getSoundData(this.key);
                        this.totalDuration = this._sound.duration;
                    }
                },

                "addMarker": function (name, start, duration, volume, loop) {
                    if (!(void 0 !== duration && null !== duration)) {

                        duration = 1;
                    }
                    if (!(void 0 !== volume && null !== volume)) {

                        volume = 1;
                    }
                    if (void 0 === loop) {

                        loop = false;
                    }
                    this.markers[name] = {
                        "name": name,
                        "start": start,
                        "stop": start + duration,
                        "volume": volume,
                        "duration": duration,
                        "durationMS": 1E3 * duration,
                        "loop": loop
                    };
                },

                "removeMarker": function (line) {
                    delete this.markers[line];
                },

                "onEndedHandler": function () {

                    this._sound.onended = null;

                    this.isPlaying = false;
                    this.currentTime = this.durationMS;
                    this.stop();
                    if (this.playOnce) {

                        this._markedToDelete = true;

                        this._removeFromSoundManager = true;
                    }
                    if (this._markedToDelete) {
                        if (this.externalNode) {
                            this._sound.disconnect(this.externalNode);
                        } else {
                            if (this.gainNode) {
                                this._sound.disconnect(this.gainNode);
                            }
                        }
                        if (this._removeFromSoundManager) {
                            this.game.sound.remove(this);
                        } else {
                            this.markers = {};

                            this.context = null;

                            this._buffer = null;

                            this.externalNode = null;
                            this.onDecoded.dispose();
                            this.onPlay.dispose();
                            this.onPause.dispose();
                            this.onResume.dispose();
                            this.onLoop.dispose();
                            this.onStop.dispose();
                            this.onMute.dispose();
                            this.onMarkerComplete.dispose();
                        }
                    }
                },

                "update": function () {
                    if (this.game.cache.checkSoundKey(this.key)) {
                        if (this.isDecoded) {
                            if (!this._onDecodedEventDispatched) {
                                this.onDecoded.dispatch(this);

                                this._onDecodedEventDispatched = true;
                            }
                        }
                        if (this.pendingPlayback) {
                            if (this.game.cache.isSoundReady(this.key)) {

                                this.pendingPlayback = false;
                                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);
                            }
                        }
                        if (this.isPlaying) {

                            this.currentTime = this.game.time.time - this.startTime;
                            if (this.currentTime >= this.durationMS) {
                                if (this.usingWebAudio) {
                                    if (this.loop) {
                                        this.onLoop.dispatch(this);

                                        this.isPlaying = false;
                                        if ("" === this.currentMarker) {

                                            this.currentTime = 0;
                                            this.startTime = this.game.time.time;

                                            this.isPlaying = true;
                                        } else {
                                            this.onMarkerComplete.dispatch(this.currentMarker, this);
                                            this.play(this.currentMarker, 0, this.volume, true, true);
                                        }
                                    } else {
                                        if ("" !== this.currentMarker) {
                                            this.stop();
                                        }
                                    }
                                } else {
                                    if (this.loop) {
                                        this.onLoop.dispatch(this);
                                        if ("" === this.currentMarker) {

                                            this.currentTime = 0;
                                            this.startTime = this.game.time.time;
                                        }

                                        this.isPlaying = false;
                                        this.play(this.currentMarker, 0, this.volume, true, true);
                                    } else {
                                        this.stop();
                                    }
                                }
                            }
                        }
                    } else {
                        this.destroy();
                    }
                },

                "loopFull": function (deepDataAndEvents) {
                    return this.play(null, 0, deepDataAndEvents, true);
                },

                "play": function (val, x, action, options, gotoStart) {
                    if (void 0 !== val && (false !== val && null !== val) || (val = ""), void 0 === gotoStart && (gotoStart = true), this.isPlaying && (!this.allowMultiple && (!gotoStart && !this.override))) {
                        return this;
                    }
                    if (this._sound && (this.isPlaying && (!this.allowMultiple && (this.override || gotoStart)))) {
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) {
                                this._sound.noteOff(0);
                            } else {
                                try {
                                    this._sound.stop(0);
                                } catch (_0x5a9780) {}
                            }
                            if (this.externalNode) {
                                this._sound.disconnect(this.externalNode);
                            } else {
                                if (this.gainNode) {
                                    this._sound.disconnect(this.gainNode);
                                }
                            }
                        } else {
                            if (this.usingAudioTag) {
                                this._sound.pause();

                                this._sound.currentTime = 0;
                            }
                        }

                        this.isPlaying = false;
                    }
                    if ("" === val && Object.keys(this.markers).length > 0) {
                        return this;
                    }
                    if ("" !== val) {
                        if (!this.markers[val]) {
                            return console.warn('Phaser.Sound.play: audio marker ' + val + " doesn't exist"), this;
                        }

                        this.currentMarker = val;
                        this.position = this.markers[val].start;
                        this.volume = this.markers[val].volume;
                        this.loop = this.markers[val].loop;
                        this.duration = this.markers[val].duration;
                        this.durationMS = this.markers[val].durationMS;
                        if (void 0 !== action) {

                            this.volume = action;
                        }
                        if (void 0 !== options) {

                            this.loop = options;
                        }

                        this._tempMarker = val;
                        this._tempPosition = this.position;
                        this._tempVolume = this.volume;
                        this._tempLoop = this.loop;
                    } else {
                        x = x || 0;
                        if (void 0 === action) {
                            action = this._volume;
                        }
                        if (void 0 === options) {
                            options = this.loop;
                        }
                        this.position = Math.max(0, x);

                        this.volume = action;

                        this.loop = options;

                        this.duration = 0;

                        this.durationMS = 0;

                        this._tempMarker = val;

                        this._tempPosition = x;

                        this._tempVolume = action;

                        this._tempLoop = options;
                    }
                    return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop &&
                            ("" === val && (this._sound.loop = true)), this.loop || ("" !== val || (this._sound.onended = this.onEndedHandler.bind(this))), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1E3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0,
                                this.position, this.duration) : this.loop && "" === val ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = true, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = true, this.game.cache.getSound(this.key) &&
                            (false === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this))) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = true) : this._sound &&
                        (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this._sound.loop = this.loop, this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1E3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted =
                            this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = true, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = true, this.playOnce &&
                        (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = true, this._removeFromSoundManager = true), this;
                },

                "restart": function (reason, port, format, suppressEvents) {
                    reason = reason || "";
                    port = port || 0;
                    format = format || 1;
                    if (void 0 === suppressEvents) {

                        suppressEvents = false;
                    }
                    this.play(reason, port, format, suppressEvents, true);
                },

                "pause": function () {
                    if (this.isPlaying) {
                        if (this._sound) {

                            this.paused = true;
                            this.pausedPosition = this.currentTime;
                            this.pausedTime = this.game.time.time;
                            this._tempPause = this._sound.currentTime;
                            this.onPause.dispatch(this);
                            this.stop();
                        }
                    }
                },

                "resume": function () {
                    if (this.paused && this._sound) {
                        if (this.usingWebAudio) {
                            var r20 = Math.max(0, this.position + this.pausedPosition / 1E3);
                            this._sound = this.context.createBufferSource();
                            this._sound.buffer = this._buffer;
                            if (this.externalNode) {
                                this._sound.connect(this.externalNode);
                            } else {
                                this._sound.connect(this.gainNode);
                            }
                            if ("" === this.currentMarker) {
                                if (this.loop) {

                                    this._sound.loop = true;
                                } else {
                                    this._sound.onended = this.onEndedHandler.bind(this);
                                }
                            }

                            var restoreScript = this.duration - this.pausedPosition / 1E3;
                            if (void 0 === this._sound.start) {
                                this._sound.noteGrainOn(0, r20, restoreScript);
                            } else {
                                if (this.loop && this.game.device.chrome) {
                                    if (42 === this.game.device.chromeVersion) {
                                        this._sound.start(0);
                                    } else {
                                        if ("" === this.currentMarker) {
                                            this._sound.start(0, r20);
                                        } else {
                                            this._sound.start(0, r20, restoreScript);
                                        }
                                    }
                                } else {
                                    this._sound.start(0, r20, restoreScript);
                                }
                            }
                        } else {
                            this._sound.currentTime = this._tempPause;
                            this._sound.play();
                        }

                        this.isPlaying = true;

                        this.paused = false;
                        this.startTime += this.game.time.time - this.pausedTime;
                        this.onResume.dispatch(this);
                    }
                },

                "stop": function () {
                    if (this.isPlaying && this._sound) {
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) {
                                this._sound.noteOff(0);
                            } else {
                                try {
                                    this._sound.stop(0);
                                } catch (_0x441d3e) {}
                            }
                            if (this.externalNode) {
                                this._sound.disconnect(this.externalNode);
                            } else {
                                if (this.gainNode) {
                                    this._sound.disconnect(this.gainNode);
                                }
                            }
                        } else {
                            if (this.usingAudioTag) {
                                this._sound.pause();

                                this._sound.currentTime = 0;
                            }
                        }
                    }
                    if (this.pendingPlayback = false, this.isPlaying = false, !this.paused) {
                        var r20 = this.currentMarker;
                        if ("" !== this.currentMarker) {
                            this.onMarkerComplete.dispatch(this.currentMarker, this);
                        }

                        this.currentMarker = "";
                        if (null !== this.fadeTween) {
                            this.fadeTween.stop();
                        }
                        this.onStop.dispatch(this, r20);
                    }
                },

                "fadeIn": function (callback, milliseconds, easing) {
                    if (void 0 === milliseconds) {

                        milliseconds = false;
                    }
                    if (void 0 === easing) {
                        easing = this.currentMarker;
                    }
                    if (!this.paused) {
                        this.play(easing, 0, 0, milliseconds);
                        this.fadeTo(callback, 1);
                    }
                },

                "fadeOut": function (tooltip) {
                    this.fadeTo(tooltip, 0);
                },

                "fadeTo": function (speed, callback) {
                    if (this.isPlaying) {
                        if (!this.paused) {
                            if (callback !== this.volume) {
                                if (void 0 === speed) {

                                    speed = 1E3;
                                }
                                if (void 0 !== callback) {
                                    this.fadeTween = this.game.add.tween(this).to({
                                        "volume": callback
                                    }, speed, $.Easing.Linear.None, true);
                                    this.fadeTween.onComplete.add(this.fadeComplete, this);
                                } else {
                                    console.warn('Phaser.Sound.fadeTo: No Volume Specified.');
                                }
                            }
                        }
                    }
                },

                "fadeComplete": function () {
                    this.onFadeComplete.dispatch(this, this.volume);
                    if (0 === this.volume) {
                        this.stop();
                    }
                },

                "updateGlobalVolume": function (dataAndEvents) {
                    if (this.usingAudioTag) {
                        if (this._sound) {
                            this._globalVolume = dataAndEvents;

                            this._sound.volume = this._globalVolume * this._volume;
                        }
                    }
                },

                "destroy": function (removeResizeFix) {
                    if (void 0 === removeResizeFix) {

                        removeResizeFix = true;
                    }

                    this._markedToDelete = true;

                    this._removeFromSoundManager = removeResizeFix;
                    this.stop();
                    if (removeResizeFix) {
                        this.game.sound.remove(this);
                    } else {
                        this.markers = {};

                        this.context = null;

                        this._buffer = null;

                        this.externalNode = null;
                        this.onDecoded.dispose();
                        this.onPlay.dispose();
                        this.onPause.dispose();
                        this.onResume.dispose();
                        this.onLoop.dispose();
                        this.onStop.dispose();
                        this.onMute.dispose();
                        this.onMarkerComplete.dispose();
                    }
                }
            }, $.Sound.prototype.constructor = $.Sound, Object.defineProperty($.Sound.prototype, 'isDecoding', {

                "get": function () {
                    return this.game.cache.getSound(this.key).isDecoding;
                }
            }), Object.defineProperty($.Sound.prototype, "isDecoded", {

                "get": function () {
                    return this.game.cache.isSoundDecoded(this.key);
                }
            }), Object.defineProperty($.Sound.prototype, 'mute', {

                "get": function () {
                    return this._muted || this.game.sound.mute;
                },

                "set": function (z) {
                    if ((z = z || false) !== this._muted) {
                        if (z) {

                            this._muted = true;
                            this._muteVolume = this._tempVolume;
                            if (this.usingWebAudio) {

                                this.gainNode.gain.value = 0;
                            } else {
                                if (this.usingAudioTag) {
                                    if (this._sound) {

                                        this._sound.volume = 0;
                                    }
                                }
                            }
                        } else {

                            this._muted = false;
                            if (this.usingWebAudio) {
                                this.gainNode.gain.value = this._muteVolume;
                            } else {
                                if (this.usingAudioTag) {
                                    if (this._sound) {
                                        this._sound.volume = this._muteVolume;
                                    }
                                }
                            }
                        }
                        this.onMute.dispatch(this);
                    }
                }
            }), Object.defineProperty($.Sound.prototype, 'volume', {

                "get": function () {
                    return this._volume;
                },

                "set": function (ms) {
                    if (this.usingAudioTag) {
                        ms = this.game.math.clamp(ms, 0, 1);
                    }
                    if (this._muted) {

                        this._muteVolume = ms;
                    } else {

                        this._tempVolume = ms;

                        this._volume = ms;
                        if (this.usingWebAudio) {

                            this.gainNode.gain.value = ms;
                        } else {
                            if (this.usingAudioTag) {
                                if (this._sound) {

                                    this._sound.volume = this._globalVolume * ms;
                                }
                            }
                        }
                    }
                }
            }), $.SoundManager = function (dataAndEvents) {
                this.game = dataAndEvents;
                this.onSoundDecode = new($.Signal);
                this.onVolumeChange = new($.Signal);
                this.onMute = new($.Signal);
                this.onUnMute = new $.Signal;
                this.onTouchUnlock = new($.Signal);

                this.context = null;

                this.usingWebAudio = false;

                this.usingAudioTag = false;

                this.noAudio = false;

                this.connectToMaster = true;

                this.touchLocked = false;

                this.channels = 32;

                this.muteOnPause = true;

                this._codeMuted = false;

                this._muted = false;

                this._unlockSource = null;

                this._volume = 1;

                this._sounds = [];
                this._watchList = new($.ArraySet);

                this._watching = false;

                this._watchCallback = null;

                this._watchContext = null;
            }, $.SoundManager.prototype = {

                "boot": function () {
                    var device = this.game.device;
                    var api = window.PhaserGlobal;
                    if (device.iOS && (false === device.webAudio && (this.channels = 1)), api) {
                        if (true === api.disableAudio) {
                            return this.noAudio = true, void(this.touchLocked = false);
                        }
                        if (true === api.disableWebAudio) {
                            return this.usingAudioTag = true, void(this.touchLocked = false);
                        }
                    }
                    if (api && api.audioContext) {
                        this.context = api.audioContext;
                    } else {
                        if (window.AudioContext) {
                            try {
                                this.context = new(window.AudioContext);
                            } catch (_0x56f8e3) {

                                this.context = null;

                                this.usingWebAudio = false;

                                this.touchLocked = false;
                            }
                        } else {
                            if (window.webkitAudioContext) {
                                try {
                                    this.context = new(window.webkitAudioContext);
                                } catch (_0x55a0fb) {

                                    this.context = null;

                                    this.usingWebAudio = false;

                                    this.touchLocked = false;
                                }
                            }
                        }
                    }
                    if (null === this.context) {
                        if (void 0 === window.Audio) {
                            return void(this.noAudio = true);
                        }

                        this.usingAudioTag = true;
                    } else {

                        this.usingWebAudio = true;
                        if (void 0 === this.context.createGain) {
                            this.masterGain = this.context.createGainNode();
                        } else {
                            this.masterGain = this.context.createGain();
                        }

                        this.masterGain.gain.value = 1;
                        this.masterGain.connect(this.context.destination);
                    }
                    if (!this.noAudio) {
                        if (device.needsTouchUnlock()) {
                            this.setTouchLock();
                        }
                    }
                    if (this.usingWebAudio) {
                        if (device.chrome) {
                            if (device.chromeVersion <= 65) {
                                console.log('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>');
                            }
                        }
                    }
                },

                "setTouchLock": function () {
                    if (!this.noAudio) {
                        if (!(window.PhaserGlobal && true === window.PhaserGlobal.disableAudio)) {
                            this.game.input.addTouchLockCallback(this.unlock, this, true);

                            this.touchLocked = true;
                        }
                    }
                },

                "setTouchUnlock": function () {

                    this.touchLocked = false;

                    this._unlockSource = null;
                    this.onTouchUnlock.dispatch();
                },

                "unlock": function () {
                    if (this.noAudio || (!this.touchLocked || null !== this._unlockSource)) {
                        return true;
                    }
                    if (this.usingAudioTag) {
                        this.setTouchUnlock();
                    } else {
                        if (this.usingWebAudio) {
                            var items = this.context.createBuffer(1, 1, 22050);
                            this._unlockSource = this.context.createBufferSource();
                            this._unlockSource.buffer = items;
                            this._unlockSource.connect(this.context.destination);
                            if (void 0 === this._unlockSource.start) {
                                this._unlockSource.noteOn(0);
                            } else {
                                this._unlockSource.start(0);
                            }
                            if ('suspended' === this._unlockSource.context.state) {
                                this._unlockSource.context.resume();
                            }
                        }
                    }
                    return true;
                },

                "stopAll": function () {
                    if (!this.noAudio) {

                        var unlock = 0;
                        for (; unlock < this._sounds.length; unlock++) {
                            if (this._sounds[unlock]) {
                                this._sounds[unlock].stop();
                            }
                        }
                    }
                },

                "pauseAll": function () {
                    if (!this.noAudio) {

                        var unlock = 0;
                        for (; unlock < this._sounds.length; unlock++) {
                            if (this._sounds[unlock]) {
                                this._sounds[unlock].pause();
                            }
                        }
                    }
                },

                "resumeAll": function () {
                    if (!this.noAudio) {

                        var i = 0;
                        for (; i < this._sounds.length; i++) {
                            if (this._sounds[i]) {
                                this._sounds[i].resume();
                            }
                        }
                    }
                },

                "decode": function (key, eq) {
                    eq = eq || null;
                    var camelKey = this.game.cache.getSoundData(key);
                    if (camelKey && false === this.game.cache.isSoundDecoded(key)) {
                        this.game.cache.updateSound(key, 'isDecoding', true);
                        var tokens = this;
                        try {
                            this.context.decodeAudioData(camelKey, function (deepDataAndEvents) {
                                if (deepDataAndEvents) {
                                    tokens.game.cache.decodedSound(key, deepDataAndEvents);
                                    tokens.onSoundDecode.dispatch(key, eq);
                                }
                            });
                        } catch (_0x2d0d10) {}
                    }
                },

                "setDecodedCallback": function (labels, collection, resp) {
                    if ('string' == typeof labels) {

                        labels = [labels];
                    }
                    this._watchList.reset();

                    var j = 0;
                    for (; j < labels.length; j++) {
                        if (labels[j] instanceof $.Sound) {
                            if (!this.game.cache.isSoundDecoded(labels[j].key)) {
                                this._watchList.add(labels[j].key);
                            }
                        } else {
                            if (!this.game.cache.isSoundDecoded(labels[j])) {
                                this._watchList.add(labels[j]);
                            }
                        }
                    }
                    if (0 === this._watchList.total) {

                        this._watching = false;
                        collection.call(resp);
                    } else {

                        this._watching = true;

                        this._watchCallback = collection;
                        this._watchContext = resp;
                    }
                },

                "update": function () {
                    if (!this.noAudio) {
                        if (!!this.touchLocked) {
                            if (!(null === this._unlockSource)) {
                                if (!(this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE)) {
                                    this.setTouchUnlock();
                                }
                            }
                        }

                        var unlock = 0;
                        for (; unlock < this._sounds.length; unlock++) {
                            this._sounds[unlock].update();
                        }
                        if (this._watching) {
                            var r20 = this._watchList.first;
                            for (; r20;) {
                                if (this.game.cache.isSoundDecoded(r20)) {
                                    this._watchList.remove(r20);
                                }
                                r20 = this._watchList.next;
                            }
                            if (0 === this._watchList.total) {

                                this._watching = false;
                                this._watchCallback.call(this._watchContext);
                            }
                        }
                    }
                },

                "add": function (vec0, proxyObj, data, models) {
                    if (void 0 === proxyObj) {

                        proxyObj = 1;
                    }
                    if (void 0 === data) {

                        data = false;
                    }
                    if (void 0 === models) {
                        models = this.connectToMaster;
                    }
                    var edge = new($.Sound)(this.game, vec0, proxyObj, data, models);
                    return this._sounds.push(edge), edge;
                },

                "addSprite": function (sprite) {
                    return new $.AudioSprite(this.game, sprite);
                },

                "remove": function (keepData) {
                    var sel = this._sounds.length;
                    for (; sel--;) {
                        if (this._sounds[sel] === keepData) {
                            return this._sounds[sel].destroy(false), this._sounds.splice(sel, 1), true;
                        }
                    }
                    return false;
                },

                "removeAll": function () {
                    this.stopAll();

                    var i = 0;
                    for (; i < this._sounds.length; i++) {
                        if (this._sounds[i]) {
                            this._sounds[i].destroy();
                        }
                    }

                    this._sounds.length = 0;
                },

                "removeByKey": function (needle) {
                    var len = this._sounds.length;

                    var removed = 0;
                    for (; len--;) {
                        if (this._sounds[len].key === needle) {
                            this._sounds[len].destroy(false);
                            this._sounds.splice(len, 1);
                            removed++;
                        }
                    }
                    return removed;
                },

                "play": function (element, options, delay) {
                    if (!this.noAudio) {
                        var id = this.add(element, options, delay);
                        return id.play(), id;
                    }
                },

                "setMute": function () {
                    if (!this._muted) {

                        this._muted = true;
                        if (this.usingWebAudio) {
                            this._muteVolume = this.masterGain.gain.value;

                            this.masterGain.gain.value = 0;
                        }

                        var unlock = 0;
                        for (; unlock < this._sounds.length; unlock++) {
                            if (this._sounds[unlock].usingAudioTag) {

                                this._sounds[unlock].mute = true;
                            }
                        }
                        this.onMute.dispatch();
                    }
                },

                "unsetMute": function () {
                    if (this._muted && !this._codeMuted) {

                        this._muted = false;
                        if (this.usingWebAudio) {
                            this.masterGain.gain.value = this._muteVolume;
                        }

                        var unlock = 0;
                        for (; unlock < this._sounds.length; unlock++) {
                            if (this._sounds[unlock].usingAudioTag) {

                                this._sounds[unlock].mute = false;
                            }
                        }
                        this.onUnMute.dispatch();
                    }
                },

                "destroy": function () {
                    this.removeAll();
                    this.onSoundDecode.dispose();
                    if (this.context) {
                        if (window.PhaserGlobal) {
                            window.PhaserGlobal.audioContext = this.context;
                        } else {
                            if (this.context.close) {
                                this.context.close();
                            }
                        }
                    }
                }
            }, $.SoundManager.prototype.constructor = $.SoundManager, Object.defineProperty($.SoundManager.prototype, "mute", {

                "get": function () {
                    return this._muted;
                },

                "set": function (z) {
                    if (z = z || false) {
                        if (this._muted) {
                            return;
                        }

                        this._codeMuted = true;
                        this.setMute();
                    } else {
                        if (!this._muted) {
                            return;
                        }

                        this._codeMuted = false;
                        this.unsetMute();
                    }
                }
            }), Object.defineProperty($.SoundManager.prototype, 'volume', {

                "get": function () {
                    return this._volume;
                },

                "set": function (opt_path) {
                    if (opt_path < 0 ? opt_path = 0 : opt_path > 1 && (opt_path = 1), this._volume !== opt_path) {
                        if (this._volume = opt_path, this.usingWebAudio) {

                            this.masterGain.gain.value = opt_path;
                        } else {

                            var unlock = 0;
                            for (; unlock < this._sounds.length; unlock++) {
                                if (this._sounds[unlock].usingAudioTag) {
                                    this._sounds[unlock].updateGlobalVolume(opt_path);
                                }
                            }
                        }
                        this.onVolumeChange.dispatch(opt_path);
                    }
                }
            }), $.ScaleManager = function (exports, deepDataAndEvents, opt_obj2) {

                this.game = exports;
                this.dom = $.DOM;

                this.grid = null;

                this.width = 0;

                this.height = 0;

                this.minWidth = null;

                this.maxWidth = null;

                this.minHeight = null;

                this.maxHeight = null;
                this.offset = new($.Point);

                this.forceLandscape = false;

                this.forcePortrait = false;

                this.incorrectOrientation = false;

                this._pageAlignHorizontally = false;

                this._pageAlignVertically = false;
                this.onOrientationChange = new $.Signal;
                this.enterIncorrectOrientation = new($.Signal);
                this.leaveIncorrectOrientation = new($.Signal);

                this.hasPhaserSetFullScreen = false;

                this.fullScreenTarget = null;

                this._createdFullScreenTarget = null;
                this.onFullScreenInit = new($.Signal);
                this.onFullScreenChange = new($.Signal);
                this.onFullScreenError = new($.Signal);
                this.screenOrientation = this.dom.getScreenOrientation();
                this.scaleFactor = new $.Point(1, 1);
                this.scaleFactorInversed = new($.Point)(1, 1);
                this.margin = {
                    "left": 0,
                    "top": 0,
                    "right": 0,
                    "bottom": 0,
                    "x": 0,
                    "y": 0
                };
                this.bounds = new $.Rectangle;

                this.aspectRatio = 0;

                this.sourceAspectRatio = 0;

                this.event = null;
                this.windowConstraints = {
                    "right": 'layout',
                    "bottom": ""
                };
                this.compatibility = {
                    "supportsFullScreen": false,
                    "orientationFallback": null,
                    "noMargins": false,
                    "scrollTo": null,
                    "forceMinimumDocumentHeight": false,
                    "canExpandParent": true,
                    "clickTrampoline": ""
                };
                this._scaleMode = $.ScaleManager.NO_SCALE;
                this._fullScreenScaleMode = $.ScaleManager.NO_SCALE;

                this.parentIsWindow = false;

                this.parentNode = null;
                this.parentScaleFactor = new $.Point(1, 1);

                this.trackParentInterval = 2E3;
                this.onSizeChange = new($.Signal);

                this.onResize = null;

                this.onResizeContext = null;

                this._pendingScaleMode = null;

                this._fullScreenRestore = null;
                this._gameSize = new($.Rectangle);
                this._userScaleFactor = new($.Point)(1, 1);
                this._userScaleTrim = new($.Point)(0, 0);

                this._lastUpdate = 0;

                this._updateThrottle = 0;

                this._updateThrottleReset = 100;
                this._parentBounds = new($.Rectangle);
                this._tempBounds = new($.Rectangle);
                this._lastReportedCanvasSize = new $.Rectangle;
                this._lastReportedGameSize = new $.Rectangle;

                this._booted = false;
                if (exports.config) {
                    this.parseConfig(exports.config);
                }
                this.setupScale(deepDataAndEvents, opt_obj2);
            }, $.ScaleManager.EXACT_FIT = 0, $.ScaleManager.NO_SCALE = 1, $.ScaleManager.SHOW_ALL = 2, $.ScaleManager.RESIZE = 3, $.ScaleManager.USER_SCALE = 4, $.ScaleManager.MODES = ['EXACT_FIT', 'NO_SCALE', 'SHOW_ALL', "RESIZE", "USER_SCALE"], $.ScaleManager.prototype = {

                "boot": function () {
                    var attr = this.compatibility;
                    attr.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS;
                    if (!this.game.device.iPad) {
                        if (!this.game.device.webApp) {
                            if (!this.game.device.desktop) {
                                if (this.game.device.android && !this.game.device.chrome) {
                                    attr.scrollTo = new($.Point)(0, 1);
                                } else {
                                    attr.scrollTo = new $.Point(0, 0);
                                }
                            }
                        }
                    }
                    if (this.game.device.desktop) {
                        attr.orientationFallback = 'screen';
                        attr.clickTrampoline = 'when-not-mouse';
                    } else {

                        attr.orientationFallback = "";

                        attr.clickTrampoline = "";
                    }
                    var collection = this;

                    this._orientationChange = function (resp) {
                        return collection.orientationChange(resp);
                    };

                    this._windowResize = function (resp) {
                        return collection.windowResize(resp);
                    };
                    window.addEventListener('orientationchange', this._orientationChange, false);
                    window.addEventListener('resize', this._windowResize, false);
                    if (this.compatibility.supportsFullScreen) {

                        this._fullScreenChange = function (resp) {
                            return collection.fullScreenChange(resp);
                        };

                        this._fullScreenError = function (resp) {
                            return collection.fullScreenError(resp);
                        };
                        document.addEventListener('webkitfullscreenchange', this._fullScreenChange, false);
                        document.addEventListener("mozfullscreenchange", this._fullScreenChange, false);
                        document.addEventListener('MSFullscreenChange', this._fullScreenChange, false);
                        document.addEventListener('fullscreenchange', this._fullScreenChange, false);
                        document.addEventListener('webkitfullscreenerror', this._fullScreenError, false);
                        document.addEventListener('mozfullscreenerror', this._fullScreenError, false);
                        document.addEventListener('MSFullscreenError', this._fullScreenError, false);
                        document.addEventListener('fullscreenerror', this._fullScreenError, false);
                    }
                    this.game.onResume.add(this._gameResumed, this);
                    this.dom.getOffset(this.game.canvas, this.offset);
                    this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
                    this.setGameSize(this.game.width, this.game.height);
                    this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
                    if ($.FlexGrid) {
                        this.grid = new($.FlexGrid)(this, this.width, this.height);
                    }

                    this._booted = true;
                    if (null !== this._pendingScaleMode) {
                        this.scaleMode = this._pendingScaleMode;

                        this._pendingScaleMode = null;
                    }
                },

                "parseConfig": function (attNameList) {
                    if (void 0 !== attNameList.scaleMode) {
                        if (this._booted) {
                            this.scaleMode = attNameList.scaleMode;
                        } else {
                            this._pendingScaleMode = attNameList.scaleMode;
                        }
                    }
                    if (void 0 !== attNameList.fullScreenScaleMode) {
                        this.fullScreenScaleMode = attNameList.fullScreenScaleMode;
                    }
                    if (attNameList.fullScreenTarget) {
                        this.fullScreenTarget = attNameList.fullScreenTarget;
                    }
                    this.pageAlignHorizontally = attNameList.alignH || false;
                    this.pageAlignVertically = attNameList.alignV || false;
                    if (attNameList.scaleH) {
                        if (attNameList.scaleV) {
                            this.setUserScale(attNameList.scaleH, attNameList.scaleV, attNameList.trimH, attNameList.trimV);
                        }
                    }
                },

                "setupScale": function (m1, v) {
                    var klass;
                    var self = new($.Rectangle);
                    if ("" !== this.game.parent) {
                        if ('string' == typeof this.game.parent) {
                            klass = document.getElementById(this.game.parent);
                        } else {
                            if (this.game.parent) {
                                if (1 === this.game.parent.nodeType) {
                                    klass = this.game.parent;
                                }
                            }
                        }
                    }
                    if (klass) {
                        this.parentNode = klass;

                        this.parentIsWindow = false;
                        this.getParentBounds(this._parentBounds, this.parentNode);
                        self.width = this._parentBounds.width;
                        self.height = this._parentBounds.height;
                        this.offset.set(this._parentBounds.x, this._parentBounds.y);
                    } else {

                        this.parentNode = null;

                        this.parentIsWindow = true;
                        self.width = this.dom.visualBounds.width;
                        self.height = this.dom.visualBounds.height;
                        this.offset.set(0, 0);
                    }

                    var hue = 0;

                    var currentValue = 0;
                    if ('number' == typeof m1) {

                        hue = m1;
                    } else {

                        this.parentScaleFactor.x = parseInt(m1, 10) / 100;

                        hue = self.width * this.parentScaleFactor.x;
                    }
                    if ('number' == typeof v) {

                        currentValue = v;
                    } else {

                        this.parentScaleFactor.y = parseInt(v, 10) / 100;

                        currentValue = self.height * this.parentScaleFactor.y;
                    }
                    hue = Math.floor(hue);
                    currentValue = Math.floor(currentValue);
                    this._gameSize.setTo(0, 0, hue, currentValue);
                    this.updateDimensions(hue, currentValue, false);
                },

                "_gameResumed": function () {
                    this.queueUpdate(true);
                },

                "setGameSize": function (deepDataAndEvents, opt_obj2) {
                    this._gameSize.setTo(0, 0, deepDataAndEvents, opt_obj2);
                    if (this.currentScaleMode !== $.ScaleManager.RESIZE) {
                        this.updateDimensions(deepDataAndEvents, opt_obj2, true);
                    }
                    this.queueUpdate(true);
                },

                "setUserScale": function (deepDataAndEvents, opt_obj2, dataAndEvents, ignoreMethodDoesntExist, textAlt, walkers) {
                    this._userScaleFactor.setTo(deepDataAndEvents, opt_obj2);
                    this._userScaleTrim.setTo(0 | dataAndEvents, 0 | ignoreMethodDoesntExist);
                    if (void 0 === textAlt) {

                        textAlt = true;
                    }
                    if (void 0 === walkers) {

                        walkers = true;
                    }
                    if (textAlt) {
                        this.queueUpdate(walkers);
                    }
                },

                "setResizeCallback": function (dataAndEvents, deepDataAndEvents) {
                    this.onResize = dataAndEvents;
                    this.onResizeContext = deepDataAndEvents;
                },

                "signalSizeChange": function () {
                    if (!$.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !$.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                        var r20 = this.width;
                        var dh = this.height;
                        this._lastReportedCanvasSize.setTo(0, 0, r20, dh);
                        this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height);
                        if (this.grid) {
                            this.grid.onResize(r20, dh);
                        }
                        this.onSizeChange.dispatch(this, r20, dh);
                        if (this.currentScaleMode === $.ScaleManager.RESIZE) {
                            this.game.state.resize(r20, dh);
                            this.game.load.resize(r20, dh);
                        }
                    }
                },

                "setMinMax": function (dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents, textAlt) {
                    this.minWidth = dataAndEvents;
                    this.minHeight = ignoreMethodDoesntExist;
                    if (void 0 !== deepDataAndEvents) {

                        this.maxWidth = deepDataAndEvents;
                    }
                    if (void 0 !== textAlt) {

                        this.maxHeight = textAlt;
                    }
                },

                "preUpdate": function () {
                    if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                        var src = this._updateThrottle;

                        this._updateThrottleReset = src >= 400 ? 0 : 100;
                        this.dom.getOffset(this.game.canvas, this.offset);
                        var width = this._parentBounds.width;
                        var height = this._parentBounds.height;
                        var oldPos = this.getParentBounds(this._parentBounds);

                        var program = oldPos.width !== width || oldPos.height !== height;
                        var inverse = this.updateOrientationState();
                        if (program || inverse) {
                            if (this.onResize) {
                                this.onResize.call(this.onResizeContext, this, oldPos);
                            }
                            this.updateLayout();
                            this.signalSizeChange();
                        }

                        var pdataOld = 2 * this._updateThrottle;
                        if (this._updateThrottle < src) {
                            pdataOld = Math.min(src, this._updateThrottleReset);
                        }
                        this._updateThrottle = $.Math.clamp(pdataOld, 25, this.trackParentInterval);
                        this._lastUpdate = this.game.time.time;
                    }
                },

                "pauseUpdate": function () {
                    this.preUpdate();
                    this._updateThrottle = this.trackParentInterval;
                },

                "updateDimensions": function (zoomChanged, sign, dimensions) {

                    this.width = zoomChanged * this.parentScaleFactor.x;

                    this.height = sign * this.parentScaleFactor.y;
                    this.game.width = this.width;
                    this.game.height = this.height;

                    this.sourceAspectRatio = this.width / this.height;
                    this.updateScalingAndBounds();
                    if (dimensions) {
                        this.game.renderer.resize(this.width, this.height);
                        this.game.camera.setSize(this.width, this.height);
                        this.game.world.resize(this.width, this.height);
                    }
                },

                "updateScalingAndBounds": function () {

                    this.scaleFactor.x = this.game.width / this.width;

                    this.scaleFactor.y = this.game.height / this.height;

                    this.scaleFactorInversed.x = this.width / this.game.width;

                    this.scaleFactorInversed.y = this.height / this.game.height;

                    this.aspectRatio = this.width / this.height;
                    if (this.game.canvas) {
                        this.dom.getOffset(this.game.canvas, this.offset);
                    }
                    this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height);
                    if (this.game.input) {
                        if (this.game.input.scale) {
                            this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y);
                        }
                    }
                },

                "forceOrientation": function (dataAndEvents, deepDataAndEvents) {
                    if (void 0 === deepDataAndEvents) {

                        deepDataAndEvents = false;
                    }
                    if (true !== dataAndEvents || true !== deepDataAndEvents) {

                        this.forceLandscape = dataAndEvents;

                        this.forcePortrait = deepDataAndEvents;
                        this.queueUpdate(true);
                    } else {
                        console.warn('Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.');
                    }
                },

                "classifyOrientation": function (dataAndEvents) {
                    return 'portrait-primary' === dataAndEvents || 'portrait-secondary' === dataAndEvents ? "portrait" : 'landscape-primary' === dataAndEvents || 'landscape-secondary' === dataAndEvents ? "landscape" : null;
                },

                "updateOrientationState": function () {
                    var internalData = this.screenOrientation;
                    var until = this.incorrectOrientation;
                    this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback);
                    this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;

                    var haveInternalData = internalData !== this.screenOrientation;

                    var truncate = until !== this.incorrectOrientation;
                    return truncate && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (haveInternalData || truncate) && this.onOrientationChange.dispatch(this, internalData, until), haveInternalData || truncate;
                },

                "orientationChange": function (inEvent) {
                    this.event = inEvent;
                    this.queueUpdate(true);
                },

                "windowResize": function (listener) {
                    this.event = listener;
                    this.queueUpdate(true);
                },

                "scrollTop": function () {
                    var urls = this.compatibility.scrollTo;
                    if (urls) {
                        window.scrollTo(urls.x, urls.y);
                    }
                },

                "refresh": function () {
                    this.scrollTop();
                    this.queueUpdate(true);
                },

                "updateLayout": function () {
                    var value1 = this.currentScaleMode;
                    if (value1 !== $.ScaleManager.RESIZE) {
                        if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : value1 === $.ScaleManager.EXACT_FIT ? this.setExactFit() : value1 === $.ScaleManager.SHOW_ALL ? !this.isFullScreen && (this.boundingParent && this.compatibility.canExpandParent) ? (this.setShowAll(true), this.resetCanvas(),
                                this.setShowAll()) : this.setShowAll() : value1 === $.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : value1 === $.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y),
                            !this.compatibility.canExpandParent && (value1 === $.ScaleManager.SHOW_ALL || value1 === $.ScaleManager.USER_SCALE)) {
                            var space = this.getParentBounds(this._tempBounds);
                            this.width = Math.min(this.width, space.width);
                            this.height = Math.min(this.height, space.height);
                        }

                        this.width = 0 | this.width;

                        this.height = 0 | this.height;
                        this.reflowCanvas();
                    } else {
                        this.reflowGame();
                    }
                },

                "getParentBounds": function (_obj, opt_radix) {
                    var obj = _obj || new $.Rectangle;
                    var radix = opt_radix || this.boundingParent;
                    var p = this.dom.visualBounds;
                    var n = this.dom.layoutBounds;
                    if (radix) {
                        var args = radix.getBoundingClientRect();
                        var b = radix.offsetParent ? radix.offsetParent.getBoundingClientRect() : radix.getBoundingClientRect();
                        obj.setTo(args.left - b.left, args.top - b.top, args.width, args.height);
                        var layout = this.windowConstraints;
                        if (layout.right && (k = "layout" === layout.right ? n : p, obj.right = Math.min(obj.right, k.width)), layout.bottom) {
                            var k = 'layout' === layout.bottom ? n : p;
                            obj.bottom = Math.min(obj.bottom, k.height);
                        }
                    } else {
                        obj.setTo(0, 0, p.width, p.height);
                    }
                    return obj.setTo(Math.round(obj.x), Math.round(obj.y), Math.round(obj.width), Math.round(obj.height)), obj;
                },

                "align": function (step, value) {
                    if (null != step) {

                        this.pageAlignHorizontally = step;
                    }
                    if (null != value) {

                        this.pageAlignVertically = value;
                    }
                },

                "alignCanvas": function (dataAndEvents, deepDataAndEvents) {
                    var a = this.getParentBounds(this._tempBounds);
                    var element = this.game.canvas;
                    var data = this.margin;
                    if (dataAndEvents) {
                        if (data.left = data.right = 0, b = element.getBoundingClientRect(), this.width < a.width && !this.incorrectOrientation) {

                            var step = b.left - a.x;

                            var currentValue = a.width / 2 - this.width / 2;

                            var value = (currentValue = Math.max(currentValue, 0)) - step;
                            data.left = Math.round(value);
                        }
                        element.style.marginLeft = data.left + "px";
                        if (0 !== data.left) {

                            data.right = -(a.width - b.width - data.left);
                            element.style.marginRight = data.right + "px";
                        }
                    }
                    if (deepDataAndEvents) {

                        data.top = data.bottom = 0;
                        var b = element.getBoundingClientRect();
                        if (this.height < a.height && !this.incorrectOrientation) {

                            step = b.top - a.y;

                            currentValue = a.height / 2 - this.height / 2;

                            value = (currentValue = Math.max(currentValue, 0)) - step;
                            data.top = Math.round(value);
                        }
                        element.style.marginTop = data.top + "px";
                        if (0 !== data.top) {

                            data.bottom = -(a.height - b.height - data.top);
                            element.style.marginBottom = data.bottom + "px";
                        }
                    }
                    data.x = data.left;
                    data.y = data.top;
                },

                "reflowGame": function () {
                    this.resetCanvas("", "");
                    var space = this.getParentBounds(this._tempBounds);
                    this.updateDimensions(space.width, space.height, true);
                },

                "reflowCanvas": function () {
                    if (!this.incorrectOrientation) {
                        this.width = $.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width);
                        this.height = $.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height);
                    }
                    this.resetCanvas();
                    if (!this.compatibility.noMargins) {
                        if (this.isFullScreen && this._createdFullScreenTarget) {
                            this.alignCanvas(true, true);
                        } else {
                            this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically);
                        }
                    }
                    this.updateScalingAndBounds();
                },

                "resetCanvas": function (width, cellWidth) {
                    if (void 0 === width) {
                        width = this.width + "px";
                    }
                    if (void 0 === cellWidth) {
                        cellWidth = this.height + "px";
                    }
                    var styles = this.game.canvas;
                    if (!this.compatibility.noMargins) {

                        styles.style.marginLeft = "";

                        styles.style.marginTop = "";

                        styles.style.marginRight = "";

                        styles.style.marginBottom = "";
                    }

                    styles.style.width = width;

                    styles.style.height = cellWidth;
                },

                "queueUpdate": function (immediate) {
                    if (immediate) {

                        this._parentBounds.width = 0;

                        this._parentBounds.height = 0;
                    }
                    this._updateThrottle = this._updateThrottleReset;
                },

                "reset": function (models) {
                    if (models) {
                        if (this.grid) {
                            this.grid.reset();
                        }
                    }
                },

                "setMaximum": function () {
                    this.width = this.dom.visualBounds.width;
                    this.height = this.dom.visualBounds.height;
                },

                "setShowAll": function (isXML) {
                    var part;
                    var args = this.getParentBounds(this._tempBounds);
                    var pageY = args.width;
                    var pageX = args.height;
                    part = isXML ? Math.max(pageX / this.game.height, pageY / this.game.width) : Math.min(pageX / this.game.height, pageY / this.game.width);
                    this.width = Math.round(this.game.width * part);
                    this.height = Math.round(this.game.height * part);
                },

                "setExactFit": function () {
                    var img = this.getParentBounds(this._tempBounds);
                    this.width = img.width;
                    this.height = img.height;
                    if (!this.isFullScreen) {
                        if (this.maxWidth) {
                            this.width = Math.min(this.width, this.maxWidth);
                        }
                        if (this.maxHeight) {
                            this.height = Math.min(this.height, this.maxHeight);
                        }
                    }
                },

                "createFullScreenTarget": function () {
                    var params = document.createElement('div');
                    return params.style.margin = "0", params.style.padding = "0", params.style.background = '#000', params;
                },

                "startFullScreen": function (antialias, gameSrc) {
                    if (this.isFullScreen) {
                        return false;
                    }
                    if (this.compatibility.supportsFullScreen) {
                        if ('when-not-mouse' === this.compatibility.clickTrampoline) {
                            var m = this.game.input;
                            if (m.activePointer && (m.activePointer !== m.mousePointer && (gameSrc || false !== gameSrc))) {
                                return void m.activePointer.addClickTrampoline('startFullScreen', this.startFullScreen, this, [antialias, false]);
                            }
                        }
                        if (void 0 !== antialias) {
                            if (this.game.renderType === $.CANVAS) {

                                this.game.stage.smoothed = antialias;
                            }
                        }
                        var targetElement = this.fullScreenTarget;
                        if (!targetElement) {
                            this.cleanupCreatedTarget();
                            this._createdFullScreenTarget = this.createFullScreenTarget();
                            targetElement = this._createdFullScreenTarget;
                        }
                        var restoreScript = {
                            "targetElement": targetElement
                        };
                        if (this.hasPhaserSetFullScreen = true, this.onFullScreenInit.dispatch(this, restoreScript), this._createdFullScreenTarget) {
                            var r20 = this.game.canvas;
                            r20.parentNode.insertBefore(targetElement, r20);
                            targetElement.appendChild(r20);
                        }
                        return this.game.device.fullscreenKeyboard ? targetElement[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : targetElement[this.game.device.requestFullscreen](), true;
                    }
                    var _0x4bd0ab = this;
                    setTimeout(function () {
                        _0x4bd0ab.fullScreenError();
                    }, 10);
                },

                "stopFullScreen": function () {
                    return !(!this.isFullScreen || (!this.compatibility.supportsFullScreen || (this.hasPhaserSetFullScreen = false, document[this.game.device.cancelFullscreen](), 0)));
                },

                "cleanupCreatedTarget": function () {
                    var event = this._createdFullScreenTarget;
                    if (event && event.parentNode) {
                        var eventHandlers = event.parentNode;
                        eventHandlers.insertBefore(this.game.canvas, event);
                        eventHandlers.removeChild(event);
                    }

                    this._createdFullScreenTarget = null;
                },

                "prepScreenMode": function (dataAndEvents) {

                    var _0x1a9942 = !!this._createdFullScreenTarget;
                    var params = this._createdFullScreenTarget || this.fullScreenTarget;
                    if (dataAndEvents) {
                        if (_0x1a9942 || this.fullScreenScaleMode === $.ScaleManager.EXACT_FIT) {
                            if (params !== this.game.canvas) {
                                this._fullScreenRestore = {
                                    "targetWidth": params.style.width,
                                    "targetHeight": params.style.height
                                };
                                params.style.width = '100%';

                                params.style.height = "100%";
                            }
                        }
                    } else {
                        if (this._fullScreenRestore) {
                            params.style.width = this._fullScreenRestore.targetWidth;
                            params.style.height = this._fullScreenRestore.targetHeight;

                            this._fullScreenRestore = null;
                        }
                        this.updateDimensions(this._gameSize.width, this._gameSize.height, true);
                        this.resetCanvas();
                    }
                },

                "fullScreenChange": function (event) {
                    this.event = event;
                    if (this.isFullScreen) {
                        this.prepScreenMode(true);
                        this.updateLayout();
                        this.queueUpdate(true);
                    } else {
                        this.prepScreenMode(false);
                        this.cleanupCreatedTarget();
                        this.updateLayout();
                        this.queueUpdate(true);
                    }
                    this.onFullScreenChange.dispatch(this, this.width, this.height);
                },

                "fullScreenError": function (dataAndEvents) {
                    this.event = dataAndEvents;
                    this.cleanupCreatedTarget();
                    console.warn('Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API');
                    this.onFullScreenError.dispatch(this);
                },

                "scaleSprite": function (params, a, defaultValue, k) {
                    if (void 0 === a && (a = this.width), void 0 === defaultValue && (defaultValue = this.height), void 0 === k && (k = false), !params || !params.scale) {
                        return params;
                    }
                    if (params.scale.x = 1, params.scale.y = 1, params.width <= 0 || (params.height <= 0 || (a <= 0 || defaultValue <= 0))) {
                        return params;
                    }

                    var number = a;

                    var groupers = params.height * a / params.width;

                    var fk = params.width * defaultValue / params.height;

                    var value = defaultValue;

                    var v = fk > a;
                    return (v = v ? k : !k) ? (params.width = Math.floor(number), params.height = Math.floor(groupers)) : (params.width = Math.floor(fk), params.height = Math.floor(value)), params;
                },

                "destroy": function () {
                    this.game.onResume.remove(this._gameResumed, this);
                    window.removeEventListener('orientationchange', this._orientationChange, false);
                    window.removeEventListener('resize', this._windowResize, false);
                    if (this.compatibility.supportsFullScreen) {
                        document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, false);
                        document.removeEventListener("mozfullscreenchange", this._fullScreenChange, false);
                        document.removeEventListener('MSFullscreenChange', this._fullScreenChange, false);
                        document.removeEventListener('fullscreenchange', this._fullScreenChange, false);
                        document.removeEventListener('webkitfullscreenerror', this._fullScreenError, false);
                        document.removeEventListener('mozfullscreenerror', this._fullScreenError, false);
                        document.removeEventListener('MSFullscreenError', this._fullScreenError, false);
                        document.removeEventListener('fullscreenerror', this._fullScreenError, false);
                    }
                }
            }, $.ScaleManager.prototype.constructor = $.ScaleManager, Object.defineProperty($.ScaleManager.prototype, 'boundingParent', {

                "get": function () {
                    return this.parentIsWindow || this.isFullScreen && (this.hasPhaserSetFullScreen && !this._createdFullScreenTarget) ? null : this.game.canvas && this.game.canvas.parentNode || null;
                }
            }), Object.defineProperty($.ScaleManager.prototype, "scaleMode", {

                "get": function () {
                    return this._scaleMode;
                },

                "set": function (mL) {
                    return mL !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, true), this.queueUpdate(true)), this._scaleMode = mL), this._scaleMode;
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'fullScreenScaleMode', {

                "get": function () {
                    return this._fullScreenScaleMode;
                },

                "set": function (mL) {
                    return mL !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(false), this._fullScreenScaleMode = mL, this.prepScreenMode(true), this.queueUpdate(true)) : this._fullScreenScaleMode = mL), this._fullScreenScaleMode;
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'currentScaleMode', {

                "get": function () {
                    return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode;
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'pageAlignHorizontally', {

                "get": function () {
                    return this._pageAlignHorizontally;
                },

                "set": function (mL) {
                    if (mL !== this._pageAlignHorizontally) {
                        this._pageAlignHorizontally = mL;
                        this.queueUpdate(true);
                    }
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'pageAlignVertically', {

                "get": function () {
                    return this._pageAlignVertically;
                },

                "set": function (mL) {
                    if (mL !== this._pageAlignVertically) {
                        this._pageAlignVertically = mL;
                        this.queueUpdate(true);
                    }
                }
            }), Object.defineProperty($.ScaleManager.prototype, "isFullScreen", {

                "get": function () {
                    return !!(document.fullscreenElement || (document.webkitFullscreenElement || (document.mozFullScreenElement || document.msFullscreenElement)));
                }
            }), Object.defineProperty($.ScaleManager.prototype, "isPortrait", {

                "get": function () {
                    return 'portrait' === this.classifyOrientation(this.screenOrientation);
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'isLandscape', {

                "get": function () {
                    return 'landscape' === this.classifyOrientation(this.screenOrientation);
                }
            }), Object.defineProperty($.ScaleManager.prototype, 'isGamePortrait', {

                "get": function () {
                    return this.height > this.width;
                }
            }), Object.defineProperty($.ScaleManager.prototype, "isGameLandscape", {

                "get": function () {
                    return this.width > this.height;
                }
            }), $.Utils.Debug = function (dataAndEvents) {
                this.game = dataAndEvents;

                this.sprite = null;

                this.bmd = null;

                this.canvas = null;

                this.context = null;
                this.font = '14px Courier';

                this.columnWidth = 100;

                this.lineHeight = 16;

                this.lineWidth = 1;

                this.renderShadow = true;

                this.currentColor = null;

                this.currentX = 0;

                this.currentY = 0;

                this.currentAlpha = 1;

                this.dirty = false;

                this.isDisabled = false;

                this._line = null;

                this._rect = null;
            }, $.Utils.Debug.prototype = {

                "boot": function () {
                    if (this.game.renderType === $.CANVAS) {
                        this.context = this.game.context;
                    } else {
                        this.bmd = new($.BitmapData)(this.game, '__DEBUG', this.game.width, this.game.height, true);
                        this.sprite = this.game.make.image(0, 0, this.bmd);
                        this.game.stage.addChild(this.sprite);
                        this.game.scale.onSizeChange.add(this.resize, this);
                        this.canvas = $.CanvasPool.create(this, this.game.width, this.game.height);
                        this.context = this.canvas.getContext("2d");
                    }
                    this._line = new($.Line);
                    this._rect = new($.Rectangle);
                },

                "resize": function () {
                    this.bmd.resize(this.game.width, this.game.height);
                    this.canvas.width = this.game.width;
                    this.canvas.height = this.game.height;
                },

                "preUpdate": function () {
                    if (this.dirty) {
                        if (this.sprite) {
                            this.bmd.clear();
                            this.bmd.draw(this.canvas, 0, 0);
                            this.context.clearRect(0, 0, this.game.width, this.game.height);

                            this.dirty = false;
                        }
                    }
                },

                "reset": function () {
                    if (this.context) {
                        this.context.clearRect(0, 0, this.game.width, this.game.height);
                    }
                    if (this.sprite) {
                        this.bmd.clear();
                    }
                },

                "start": function (ui, onFailed, args, persistent) {
                    if ('number' != typeof ui) {

                        ui = 0;
                    }
                    if ('number' != typeof onFailed) {

                        onFailed = 0;
                    }
                    args = args || 'rgb(255,255,255)';
                    if (void 0 === persistent) {

                        persistent = 0;
                    }

                    this.currentX = ui;

                    this.currentY = onFailed;
                    this.currentColor = args;

                    this.columnWidth = persistent;

                    this.dirty = true;
                    this.context.save();
                    this.context.setTransform(1, 0, 0, 1, 0, 0);
                    this.context.strokeStyle = args;
                    this.context.fillStyle = args;
                    this.context.font = this.font;
                    this.context.globalAlpha = this.currentAlpha;
                },

                "stop": function () {
                    this.context.restore();
                },

                "line": function () {
                    var r20 = this.currentX;

                    var elementArgumentPos = 0;
                    for (; elementArgumentPos < arguments.length; elementArgumentPos++) {
                        if (this.renderShadow) {
                            this.context.fillStyle = 'rgb(0,0,0)';
                            this.context.fillText(arguments[elementArgumentPos], r20 + 1, this.currentY + 1);
                            this.context.fillStyle = this.currentColor;
                        }
                        this.context.fillText(arguments[elementArgumentPos], r20, this.currentY);
                        r20 += this.columnWidth;
                    }
                    this.currentY += this.lineHeight;
                },

                "sound": function (vol, pitch, s) {
                    var res = this.game.sound;
                    this.start(vol, pitch, s);
                    if (res.noAudio) {
                        this.line('Audio is disabled');
                    } else {
                        this.line("Volume: " + res.volume.toFixed(2) + (res.mute ? ' (Mute)' : ""));
                        this.line('Mute on pause: ' + res.muteOnPause);
                        this.line('Using: ' + (res.usingWebAudio ? "Web Audio - " + res.context.state : 'Audio Tag'));
                        this.line('Touch locked: ' + res.touchLocked);
                        this.line('Sounds: ' + res._sounds.length);
                    }
                    this.stop();
                },

                "soundInfo": function (values, deepDataAndEvents, opt_obj2, walkers) {
                    this.start(deepDataAndEvents, opt_obj2, walkers);
                    this.line('Sound: ' + values.key + ' Touch locked: ' + values.game.sound.touchLocked);
                    this.line("Is Ready?: " + this.game.cache.isSoundReady(values.key) + ' Pending Playback: ' + values.pendingPlayback);
                    this.line("Decoded: " + values.isDecoded + ' Decoding: ' + values.isDecoding);
                    this.line('Playing: ' + values.isPlaying + ' Loop: ' + values.loop);
                    this.line('Time: ' + values.currentTime + 'ms Total: ' + values.totalDuration.toFixed(3) + "s");
                    this.line('Volume: ' + values.volume.toFixed(2) + (values.mute ? ' (Mute)' : ""));
                    this.line('Using: ' + (values.usingWebAudio ? 'Web Audio' : 'Audio Tag'));
                    if ("" !== values.currentMarker) {
                        this.line('Marker: ' + values.currentMarker + ' Duration: ' + values.duration + ' (ms: ' + values.durationMS + ")");
                        this.line('Start: ' + values.markers[values.currentMarker].start + ' Stop: ' + values.markers[values.currentMarker].stop);
                        this.line('Position: ' + values.position);
                    }
                    this.stop();
                },

                "camera": function (v, device, _args) {
                    var neXY = v.deadzone;
                    var p2 = v.target;
                    var swXY = v.view;
                    if (neXY) {
                        this._rect.setTo(swXY.x + neXY.x, swXY.y + neXY.y, neXY.width, neXY.height);
                        this.rectangle(this._rect, device, _args);
                    }
                    if (p2) {
                        this._line.setTo(swXY.centerX, swXY.centerY, p2.x, p2.y);
                        this.geom(this._line, device, _args);
                        this.geom(p2, device, false, 3);
                    }
                },

                "cameraInfo": function (data, startCoords, event, deepDataAndEvents) {
                    var o = data.bounds;
                    var row = data.deadzone;
                    var value = data.target;
                    var urls = data.view;
                    this.start(startCoords, event, deepDataAndEvents);
                    this.line('Camera (' + data.width + ' x ' + data.height + ")");
                    this.line("x: " + data.x + ' y: ' + data.y);
                    this.line('Bounds: ' + (o ? 'x: ' + o.x + " y: " + o.y + " w: " + o.width + ' h: ' + o.height : 'none'));
                    this.line("View: x: " + urls.x + ' y: ' + urls.y + ' w: ' + urls.width + ' h: ' + urls.height);
                    this.line('Deadzone: ' + (row ? 'x: ' + row.x + ' y: ' + row.y + " w: " + row.width + ' h: ' + row.height : row));
                    this.line('Total in view: ' + data.totalInView);
                    this.line('At limit: x: ' + data.atLimit.x + ' y: ' + data.atLimit.y);
                    this.line('Target: ' + (value ? value.name || value : "none"));
                    this.stop();
                },

                "timer": function (options, ms, timer, scheduler) {
                    this.start(ms, timer, scheduler);
                    this.line('Timer (running: ' + options.running + ' expired: ' + options.expired + ")");
                    this.line('Next Tick: ' + options.next + " Duration: " + options.duration);
                    this.line('Paused: ' + options.paused + ' Length: ' + options.length);
                    this.stop();
                },

                "pointer": function (cells, el, segment, center, event) {
                    if (null != cells) {
                        if (void 0 === el) {

                            el = false;
                        }
                        segment = segment || 'rgba(0,255,0,0.5)';
                        center = center || 'rgba(255,0,0,0.5)';
                        if (!(true === el && true === cells.isUp)) {
                            this.start(cells.x, cells.y - 100, event);
                            this.context.beginPath();
                            this.context.arc(cells.x, cells.y, cells.circle.radius, 0, 2 * Math.PI);
                            if (cells.active) {
                                this.context.fillStyle = segment;
                            } else {
                                this.context.fillStyle = center;
                            }
                            this.context.fill();
                            this.context.closePath();
                            this.context.beginPath();
                            this.context.moveTo(cells.positionDown.x, cells.positionDown.y);
                            this.context.lineTo(cells.position.x, cells.position.y);

                            this.context.lineWidth = 2;
                            this.context.stroke();
                            this.context.closePath();
                            this.line('ID: ' + cells.id + ' Active: ' + cells.active);
                            this.line("World X: " + cells.worldX + ' World Y: ' + cells.worldY);
                            this.line('Screen X: ' + cells.x + " Screen Y: " + cells.y + ' In: ' + cells.withinGame);
                            this.line('Duration: ' + cells.duration + ' ms');
                            this.line('is Down: ' + cells.isDown + ' is Up: ' + cells.isUp);
                            this.stop();
                        }
                    }
                },

                "spriteInputInfo": function (self, startCoords, event, deepDataAndEvents) {
                    this.start(startCoords, event, deepDataAndEvents);
                    this.line('Sprite Input: (' + self.width + ' x ' + self.height + ")");
                    this.line('x: ' + self.input.pointerX().toFixed(1) + ' y: ' + self.input.pointerY().toFixed(1));
                    this.line('over: ' + self.input.pointerOver() + ' duration: ' + self.input.overDuration().toFixed(0));
                    this.line('down: ' + self.input.pointerDown() + ' duration: ' + self.input.downDuration().toFixed(0));
                    this.line('just over: ' + self.input.justOver() + ' just out: ' + self.input.justOut());
                    this.stop();
                },

                "key": function (map, owner, index, context) {
                    this.start(owner, index, context, 150);
                    this.line('Key:', map.keyCode, 'isDown:', map.isDown);
                    this.line("justDown:", map.justDown, 'justUp:', map.justUp);
                    this.line('Time Down:', map.timeDown.toFixed(0), "duration:", map.duration.toFixed(0));
                    this.stop();
                },

                "inputInfo": function (startCoords, event, deepDataAndEvents) {
                    this.start(startCoords, event, deepDataAndEvents);
                    this.line("Input");
                    this.line('X: ' + this.game.input.x + " Y: " + this.game.input.y);
                    this.line('World X: ' + this.game.input.worldX + ' World Y: ' + this.game.input.worldY);
                    this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + ' Scale Y: ' + this.game.input.scale.x.toFixed(1));
                    this.line("Screen X: " + this.game.input.activePointer.screenX + ' Screen Y: ' + this.game.input.activePointer.screenY);
                    this.stop();
                },

                "spriteBounds": function (dataAndEvents, deepDataAndEvents, opt_obj2) {
                    var urls = dataAndEvents.getBounds();
                    urls.x += this.game.camera.x;
                    urls.y += this.game.camera.y;
                    this.rectangle(urls, deepDataAndEvents, opt_obj2);
                },

                "ropeSegments": function (dataAndEvents, options, deepDataAndEvents) {
                    var collection = this;
                    dataAndEvents.segments.forEach(function (resp) {
                        collection.rectangle(resp, options, deepDataAndEvents);
                    }, this);
                },

                "spriteInfo": function (hash, deepDataAndEvents, opt_obj2, walkers) {
                    this.start(deepDataAndEvents, opt_obj2, walkers);
                    this.line('Sprite: ' + (hash.name || "") + " (" + hash.width + " x " + hash.height + ') anchor: ' + hash.anchor.x + ' x ' + hash.anchor.y);
                    this.line("x: " + hash.x.toFixed(1) + ' y: ' + hash.y.toFixed(1));
                    this.line('angle: ' + hash.angle.toFixed(1) + ' rotation: ' + hash.rotation.toFixed(1));
                    this.line('visible: ' + hash.visible + ' in camera: ' + hash.inCamera);
                    this.line("bounds x: " + hash._bounds.x.toFixed(1) + ' y: ' + hash._bounds.y.toFixed(1) + ' w: ' + hash._bounds.width.toFixed(1) + ' h: ' + hash._bounds.height.toFixed(1));
                    this.stop();
                },

                "spriteCoords": function (data, deepDataAndEvents, opt_obj2, walkers) {
                    this.start(deepDataAndEvents, opt_obj2, walkers, 100);
                    if (data.name) {
                        this.line(data.name);
                    }
                    this.line("x:", data.x.toFixed(2), "y:", data.y.toFixed(2));
                    this.line('pos x:', data.position.x.toFixed(2), 'pos y:', data.position.y.toFixed(2));
                    this.line("world x:", data.world.x.toFixed(2), 'world y:', data.world.y.toFixed(2));
                    this.stop();
                },

                "lineInfo": function (data, line, deepDataAndEvents, opt_obj2) {
                    this.start(line, deepDataAndEvents, opt_obj2, 80);
                    this.line('start.x:', data.start.x.toFixed(2), 'start.y:', data.start.y.toFixed(2));
                    this.line('end.x:', data.end.x.toFixed(2), "end.y:", data.end.y.toFixed(2));
                    this.line('length:', data.length.toFixed(2), "angle:", data.angle);
                    this.stop();
                },

                "pixel": function (tx, ty, dataAndEvents, made) {
                    made = made || 2;
                    this.start();
                    this.context.fillStyle = dataAndEvents;
                    this.context.fillRect(tx, ty, made, made);
                    this.stop();
                },

                "geom": function (data, dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents) {
                    if (void 0 === ignoreMethodDoesntExist) {

                        ignoreMethodDoesntExist = true;
                    }
                    if (void 0 === deepDataAndEvents) {

                        deepDataAndEvents = 0;
                    }
                    dataAndEvents = dataAndEvents || "rgba(0,255,0,0.4)";
                    this.start();

                    this.context.fillStyle = dataAndEvents;

                    this.context.strokeStyle = dataAndEvents;
                    this.context.lineWidth = this.lineWidth;
                    if (data instanceof $.Rectangle || 1 === deepDataAndEvents) {
                        if (ignoreMethodDoesntExist) {
                            this.context.fillRect(data.x - this.game.camera.x, data.y - this.game.camera.y, data.width, data.height);
                        } else {
                            this.context.strokeRect(data.x - this.game.camera.x, data.y - this.game.camera.y, data.width, data.height);
                        }
                    } else {
                        if (data instanceof $.Circle || 2 === deepDataAndEvents) {
                            this.context.beginPath();
                            this.context.arc(data.x - this.game.camera.x, data.y - this.game.camera.y, data.radius, 0, 2 * Math.PI, false);
                            this.context.closePath();
                            if (ignoreMethodDoesntExist) {
                                this.context.fill();
                            } else {
                                this.context.stroke();
                            }
                        } else {
                            if (data instanceof $.Point || 3 === deepDataAndEvents) {
                                this.context.fillRect(data.x - this.game.camera.x, data.y - this.game.camera.y, 4, 4);
                            } else {
                                if (data instanceof $.Line || 4 === deepDataAndEvents) {
                                    this.context.beginPath();
                                    this.context.moveTo(data.start.x + 0.5 - this.game.camera.x, data.start.y + 0.5 - this.game.camera.y);
                                    this.context.lineTo(data.end.x + 0.5 - this.game.camera.x, data.end.y + 0.5 - this.game.camera.y);
                                    this.context.closePath();
                                    this.context.stroke();
                                } else {
                                    if (data instanceof $.Ellipse || 5 === deepDataAndEvents) {
                                        this.context.beginPath();
                                        this.context.ellipse(data.x - this.game.camera.x, data.y - this.game.camera.y, data.width / 2, data.height / 2, 0, 2 * Math.PI, false);
                                        this.context.closePath();
                                        if (ignoreMethodDoesntExist) {
                                            this.context.fill();
                                        } else {
                                            this.context.stroke();
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.stop();
                },

                "rectangle": function (el, options, err) {
                    if (void 0 === err) {

                        err = true;
                    }
                    options = options || 'rgba(0, 255, 0, 0.4)';
                    this.start();
                    if (err) {
                        this.context.fillStyle = options;
                        this.context.fillRect(el.x - this.game.camera.x, el.y - this.game.camera.y, el.width, el.height);
                    } else {
                        this.context.lineWidth = this.lineWidth;
                        this.context.strokeStyle = options;
                        this.context.strokeRect(el.x - this.game.camera.x, el.y - this.game.camera.y, el.width, el.height);
                    }
                    this.stop();
                },

                "text": function (item, elem, x, id, font) {
                    id = id || "rgb(255,255,255)";
                    font = font || this.font;
                    this.start();

                    this.context.font = font;
                    if (this.renderShadow) {
                        this.context.fillStyle = 'rgb(0,0,0)';
                        this.context.fillText(item, elem + 1, x + 1);
                    }

                    this.context.fillStyle = id;
                    this.context.fillText(item, elem, x);
                    this.stop();
                },

                "quadTree": function (json, dataAndEvents) {
                    dataAndEvents = dataAndEvents || "rgba(255,0,0,0.3)";
                    this.start();
                    var text = json.bounds;
                    if (0 === json.nodes.length) {

                        this.context.strokeStyle = dataAndEvents;
                        this.context.strokeRect(text.x, text.y, text.width, text.height);
                        this.text('size: ' + json.objects.length, text.x + 4, text.y + 16, 'rgb(0,200,0)', '12px Courier');
                        this.context.strokeStyle = 'rgb(0,255,0)';

                        i = 0;
                        for (; i < json.objects.length; i++) {
                            this.context.strokeRect(json.objects[i].x, json.objects[i].y, json.objects[i].width, json.objects[i].height);
                        }
                    } else {

                        var i = 0;
                        for (; i < json.nodes.length; i++) {
                            this.quadTree(json.nodes[i]);
                        }
                    }
                    this.stop();
                },

                "body": function (req, job, selection) {
                    if (req.body) {
                        this.start();
                        if (req.body.type === $.Physics.ARCADE) {
                            $.Physics.Arcade.Body.render(this.context, req.body, job, selection, this.lineWidth);
                        } else {
                            if (req.body.type === $.Physics.NINJA) {
                                $.Physics.Ninja.Body.render(this.context, req.body, job, selection);
                            } else {
                                if (req.body.type === $.Physics.BOX2D) {
                                    $.Physics.Box2D.renderBody(this.context, req.body, job);
                                }
                            }
                        }
                        this.stop();
                    }
                },

                "bodyInfo": function (dataAndEvents, startCoords, event, deepDataAndEvents) {
                    if (dataAndEvents.body) {
                        this.start(startCoords, event, deepDataAndEvents, 210);
                        if (dataAndEvents.body.type === $.Physics.ARCADE) {
                            $.Physics.Arcade.Body.renderBodyInfo(this, dataAndEvents.body);
                        } else {
                            if (dataAndEvents.body.type === $.Physics.BOX2D) {
                                this.game.physics.box2d.renderBodyInfo(this, dataAndEvents.body);
                            }
                        }
                        this.stop();
                    }
                },

                "box2dWorld": function () {
                    this.start();
                    this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0);
                    this.game.physics.box2d.renderDebugDraw(this.context);
                    this.stop();
                },

                "box2dBody": function (deepDataAndEvents, opt_obj2) {
                    this.start();
                    $.Physics.Box2D.renderBody(this.context, deepDataAndEvents, opt_obj2);
                    this.stop();
                },

                "displayList": function (res) {
                    if (void 0 === res && (res = this.game.world), res.hasOwnProperty("renderOrderID") ? console.log("[" + res.renderOrderID + "]", res) : console.log("[]", res), res.children && res.children.length > 0) {

                        var firstFieldName = 0;
                        for (; firstFieldName < res.children.length; firstFieldName++) {
                            this.game.debug.displayList(res.children[firstFieldName]);
                        }
                    }
                },

                "renderer": function (id, td, text) {
                    var ns = this.game.renderer;
                    var name = ns.renderSession;
                    if (this.start(id, td, text), this.line((ns.gl ? 'WebGL' : "Canvas") + ' Renderer (' + ns.width + ' x ' + ns.height + ")"), this.line('autoResize: ' + ns.autoResize), this.line('clearBeforeRender: ' + ns.clearBeforeRender), this.line('resolution: ' + ns.resolution), this.line('transparent: ' + ns.transparent), this.line('renderSession:'), ns.gl) {
                        this.line('  currentBatchedTextures: (' + ns.currentBatchedTextures.length + ")");

                        var action = 0;
                        for (; action < ns.currentBatchedTextures.length; action++) {
                            this.line("    " + ns.currentBatchedTextures[action]);
                        }
                        this.line('  drawCount: ' + name.drawCount);
                        this.line('  maxTextures: ' + ns.maxTextures);
                        this.line('  maxTextureSize: ' + ns.maxTextureSize);
                        this.line("  maxTextureAvailableSpace: " + name.maxTextureAvailableSpace);
                        this.line('  roundPixels: ' + name.roundPixels);
                    } else {
                        this.line('  roundPixels: ' + name.roundPixels);
                        this.line('  scaleMode: ' + (0 === name.scaleMode ? "LINEAR" : 1 === name.scaleMode ? 'NEAREST' : name.scaleMode));
                    }
                    this.stop();
                },

                "canvasPool": function (deepDataAndEvents, opt_obj2, walkers, dataAndEvents) {
                    var _0x1e8e43 = $.CanvasPool;
                    this.start(deepDataAndEvents, opt_obj2, walkers, dataAndEvents || 100);
                    this.line('Canvas Pool');
                    this.line('Used:', _0x1e8e43.getTotal());
                    this.line('Free:', _0x1e8e43.getFree());
                    this.line("Total:", _0x1e8e43.length);
                    this.stop();
                },

                "physicsGroup": function (dataAndEvents, deepDataAndEvents, opt_obj2, walkers) {
                    dataAndEvents.forEach(this.body, this, walkers, deepDataAndEvents, opt_obj2);
                },

                "phaser": function (deepDataAndEvents, opt_obj2, walkers) {
                    this.text('Phaser v' + $.VERSION + " " + (this.game.renderType === $.WEBGL ? 'WebGL' : 'Canvas') + " " + (this.game.device.webAudio ? 'WebAudio' : 'HTML Audio'), deepDataAndEvents, opt_obj2, walkers, this.font);
                },

                "scale": function (_, basis, border) {
                    this.start(_, basis, border);
                    var data = this.game.scale;
                    var urls = data.scaleFactorInversed;
                    var value = data._parentBounds;
                    _ = ' x ';
                    this.line('Game: ' + this.game.width + _ + this.game.height);
                    this.line('Canvas: ' + data.width + _ + data.height + " (" + urls.x.toFixed(2) + _ + urls.y.toFixed(2) + ') [' + data.aspectRatio.toFixed(2) + "]");
                    this.line('Mode: ' + $.ScaleManager.MODES[data.currentScaleMode] + (data.currentScaleMode === $.ScaleManager.USER_SCALE ? " (" + data._userScaleFactor.x + _ + data._userScaleFactor.y + ")" : ""));
                    this.line("Parent: " + (data.parentIsWindow ? 'window' : data.parentNode) + (value.empty ? "" : " (" + value.width + _ + value.height + ")"));
                    this.line("Screen: " + data.classifyOrientation(data.screenOrientation) + (data.incorrectOrientation ? ' (incorrect)' : ""));
                    this.stop();
                },

                "loader": function (res, ref, bool, next) {
                    var success = $.Utils.pad;
                    this.start(ref, bool, next);
                    if (res.hasLoaded) {
                        this.line('Complete' + (res.resetLocked ? ' [locked]' : ""));
                    } else {
                        if (res.isLoading) {
                            this.line('Loading');
                        } else {
                            this.line('Not started');
                        }
                    }
                    if (!(res.hasLoaded && !res.resetLocked)) {
                        this.line("Progress: " + success(res.progress, 3) + "%");
                        this.line("Files: " + res._loadedFileCount + ' of ' + res._totalFileCount);
                        this.line('Packs: ' + res._loadedPackCount + ' of ' + res._loadedPackCount);
                    }
                    this.stop();
                },

                "destroy": function () {
                    $.CanvasPool.remove(this);
                }
            }, $.Utils.Debug.prototype.constructor = $.Utils.Debug, $.DOM = {

                "getOffset": function (cfiStr, offset) {
                    offset = offset || new($.Point);
                    var bounds = cfiStr.getBoundingClientRect();
                    var top = $.DOM.scrollY;
                    var left = $.DOM.scrollX;
                    var topScroll = document.documentElement.clientTop;
                    var localY2Sin = document.documentElement.clientLeft;
                    return offset.x = bounds.left + left - localY2Sin, offset.y = bounds.top + top - topScroll, offset;
                },

                "getBounds": function (el, latLng) {
                    return void 0 === latLng && (latLng = 0), !(!(el = el && !el.nodeType ? el[0] : el) || 1 !== el.nodeType) && this.calibrate(el.getBoundingClientRect(), latLng);
                },

                "calibrate": function (bounds, top) {

                    top = +top || 0;
                    var view = {
                        "width": 0,
                        "height": 0,
                        "left": 0,
                        "right": 0,
                        "top": 0,
                        "bottom": 0
                    };
                    return view.width = (view.right = bounds.right + top) - (view.left = bounds.left - top), view.height = (view.bottom = bounds.bottom + top) - (view.top = bounds.top - top), view;
                },

                "getAspectRatio": function (req) {
                    var fn = (req = null == req ? this.visualBounds : 1 === req.nodeType ? this.getBounds(req) : req).width;
                    var obj = req.height;
                    return "function" == typeof fn && (fn = fn.call(req)), "function" == typeof obj && (obj = obj.call(req)), fn / obj;
                },

                "inLayoutViewport": function (boundary, minutes) {
                    var offset = this.getBounds(boundary, minutes);
                    return !!offset && (offset.bottom >= 0 && (offset.right >= 0 && (offset.top <= this.layoutBounds.width && offset.left <= this.layoutBounds.height)));
                },

                "getScreenOrientation": function (dataAndEvents) {
                    var m = window.screen;
                    var getScreenOrientation = m.orientation || (m.mozOrientation || m.msOrientation);
                    if (getScreenOrientation && 'string' == typeof getScreenOrientation.type) {
                        return getScreenOrientation.type;
                    }
                    if ('string' == typeof getScreenOrientation) {
                        return getScreenOrientation;
                    }
                    var _0xddb113 = 'portrait-primary';

                    var landscape_primary = "landscape-primary";
                    if ("screen" === dataAndEvents) {
                        return m.height > m.width ? _0xddb113 : landscape_primary;
                    }
                    if ('viewport' === dataAndEvents) {
                        return this.visualBounds.height > this.visualBounds.width ? _0xddb113 : landscape_primary;
                    }
                    if ("window.orientation" === dataAndEvents && 'number' == typeof window.orientation) {
                        return 0 === window.orientation || 180 === window.orientation ? _0xddb113 : landscape_primary;
                    }
                    if (window.matchMedia) {
                        if (window.matchMedia('(orientation: portrait)').matches) {
                            return _0xddb113;
                        }
                        if (window.matchMedia('(orientation: landscape)').matches) {
                            return landscape_primary;
                        }
                    }
                    return this.visualBounds.height > this.visualBounds.width ? _0xddb113 : landscape_primary;
                },
                "visualBounds": new($.Rectangle),
                "layoutBounds": new($.Rectangle),
                "documentBounds": new($.Rectangle)
            }, $.Device.whenReady(function (dataAndEvents) {

                var getFunc = window && "pageXOffset" in window ? function () {
                    return window.pageXOffset;
                } : function () {
                    return document.documentElement.scrollLeft;
                };

                var get = window && "pageYOffset" in window ? function () {
                    return window.pageYOffset;
                } : function () {
                    return document.documentElement.scrollTop;
                };
                if (Object.defineProperty($.DOM, 'scrollX', {

                        "get": getFunc
                    }), Object.defineProperty($.DOM, 'scrollY', {

                        "get": get
                    }), Object.defineProperty($.DOM.visualBounds, "x", {

                        "get": getFunc
                    }), Object.defineProperty($.DOM.visualBounds, "y", {

                        "get": get
                    }), Object.defineProperty($.DOM.layoutBounds, "x", {
                        "value": 0
                    }), Object.defineProperty($.DOM.layoutBounds, "y", {
                        "value": 0
                    }), dataAndEvents.desktop && (document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight)) {

                    var update = function () {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth);
                    };

                    var woot = function () {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight);
                    };
                    Object.defineProperty($.DOM.visualBounds, 'width', {

                        "get": update
                    });
                    Object.defineProperty($.DOM.visualBounds, "height", {

                        "get": woot
                    });
                    Object.defineProperty($.DOM.layoutBounds, "width", {

                        "get": update
                    });
                    Object.defineProperty($.DOM.layoutBounds, "height", {

                        "get": woot
                    });
                } else {
                    Object.defineProperty($.DOM.visualBounds, 'width', {

                        "get": function () {
                            return window.innerWidth;
                        }
                    });
                    Object.defineProperty($.DOM.visualBounds, "height", {

                        "get": function () {
                            return window.innerHeight;
                        }
                    });
                    Object.defineProperty($.DOM.layoutBounds, 'width', {

                        "get": function () {
                            var max = document.documentElement.clientWidth;
                            var value = window.innerWidth;
                            return max < value ? value : max;
                        }
                    });
                    Object.defineProperty($.DOM.layoutBounds, "height", {

                        "get": function () {
                            var client = document.documentElement.clientHeight;
                            var inner = window.innerHeight;
                            return client < inner ? inner : client;
                        }
                    });
                }
                Object.defineProperty($.DOM.documentBounds, "x", {
                    "value": 0
                });
                Object.defineProperty($.DOM.documentBounds, "y", {
                    "value": 0
                });
                Object.defineProperty($.DOM.documentBounds, 'width', {

                    "get": function () {
                        var version = document.documentElement;
                        return Math.max(version.clientWidth, version.offsetWidth, version.scrollWidth);
                    }
                });
                Object.defineProperty($.DOM.documentBounds, 'height', {

                    "get": function () {
                        var version = document.documentElement;
                        return Math.max(version.clientHeight, version.offsetHeight, version.scrollHeight);
                    }
                });
            }, null, true), $.ArraySet = function (dataAndEvents) {

                this.position = 0;
                this.list = dataAndEvents || [];
            }, $.ArraySet.prototype = {

                "add": function (v2) {
                    return this.exists(v2) || this.list.push(v2), v2;
                },

                "getIndex": function (prevId) {
                    return this.list.indexOf(prevId);
                },

                "getByKey": function (key, needle) {
                    var ii = this.list.length;
                    for (; ii--;) {
                        if (this.list[ii][key] === needle) {
                            return this.list[ii];
                        }
                    }
                    return null;
                },

                "exists": function (err) {
                    return this.list.indexOf(err) > -1;
                },

                "reset": function () {

                    this.list.length = 0;
                },

                "remove": function (owner) {
                    var unlock = this.list.indexOf(owner);
                    if (unlock > -1) {
                        return this.list.splice(unlock, 1), owner;
                    }
                },

                "setAll": function (key, value) {
                    var j = this.list.length;
                    for (; j--;) {
                        if (this.list[j]) {
                            this.list[j][key] = value;
                        }
                    }
                },

                "callAll": function (arg) {
                    var expectedArgs = Array.prototype.slice.call(arguments, 1);
                    var unlock = this.list.length;
                    for (; unlock--;) {
                        if (this.list[unlock]) {
                            if (this.list[unlock][arg]) {
                                this.list[unlock][arg].apply(this.list[unlock], expectedArgs);
                            }
                        }
                    }
                },

                "removeAll": function (silent) {
                    if (void 0 === silent) {

                        silent = false;
                    }
                    var unlock = this.list.length;
                    for (; unlock--;) {
                        if (this.list[unlock]) {
                            var _0x4700cb = this.remove(this.list[unlock]);
                            if (silent) {
                                _0x4700cb.destroy();
                            }
                        }
                    }

                    this.position = 0;

                    this.list = [];
                }
            }, Object.defineProperty($.ArraySet.prototype, 'total', {

                "get": function () {
                    return this.list.length;
                }
            }), Object.defineProperty($.ArraySet.prototype, "first", {

                "get": function () {
                    return this.position = 0, this.list.length > 0 ? this.list[0] : null;
                }
            }), Object.defineProperty($.ArraySet.prototype, 'next', {

                "get": function () {
                    return this.position < this.list.length ? (this.position++, this.list[this.position]) : null;
                }
            }), $.ArraySet.prototype.constructor = $.ArraySet, $.ArrayUtils = {

                "getRandomItem": function (xs, type, x) {
                    if (null === xs) {
                        return null;
                    }
                    if (void 0 === type) {

                        type = 0;
                    }
                    if (void 0 === x) {
                        x = xs.length;
                    }
                    var key = type + Math.floor(Math.random() * x);
                    return void 0 === xs[key] ? null : xs[key];
                },

                "removeRandomItem": function (result, dataAndEvents, digit) {
                    if (null == result) {
                        return null;
                    }
                    if (void 0 === dataAndEvents) {

                        dataAndEvents = 0;
                    }
                    if (void 0 === digit) {
                        digit = result.length;
                    }
                    var text = dataAndEvents + Math.floor(Math.random() * digit);
                    if (text < result.length) {
                        var code = result.splice(text, 1);
                        return void 0 === code[0] ? null : code[0];
                    }
                    return null;
                },

                "remove": function (items, keepData, i) {
                    var ii = items.length;
                    if (!(keepData >= ii || 0 === i)) {
                        if (null == i) {

                            i = 1;
                        }

                        var value = ii - i;

                        var key = keepData;
                        for (; key < value; ++key) {
                            items[key] = items[key + i];
                        }

                        items.length = value;
                    }
                },

                "shuffle": function (shuffled) {

                    var index = shuffled.length - 1;
                    for (; index > 0; index--) {
                        var rand = Math.floor(Math.random() * (index + 1));
                        var value = shuffled[index];
                        shuffled[index] = shuffled[rand];
                        shuffled[rand] = value;
                    }
                    return shuffled;
                },

                "transposeMatrix": function (from) {
                    var n = from.length;
                    var length = from[0].length;

                    var result = new Array(length);

                    var i = 0;
                    for (; i < length; i++) {

                        result[i] = new Array(n);

                        var j = n - 1;
                        for (; j > -1; j--) {
                            result[i][j] = from[j][i];
                        }
                    }
                    return result;
                },

                "rotateMatrix": function (args, value) {
                    if ('string' != typeof value && (value = (value % 360 + 360) % 360), 90 === value || (-270 === value || 'rotateLeft' === value)) {
                        args = (args = $.ArrayUtils.transposeMatrix(args)).reverse();
                    } else {
                        if (-90 === value || (270 === value || "rotateRight" === value)) {
                            args = args.reverse();
                            args = $.ArrayUtils.transposeMatrix(args);
                        } else {
                            if (180 === Math.abs(value) || "rotate180" === value) {

                                var argname = 0;
                                for (; argname < args.length; argname++) {
                                    args[argname].reverse();
                                }
                                args = args.reverse();
                            }
                        }
                    }
                    return args;
                },

                "findClosest": function (value, array) {
                    if (!array.length) {
                        return NaN;
                    }
                    if (1 === array.length || value < array[0]) {
                        return array[0];
                    }

                    var i = 1;
                    for (; array[i] < value;) {
                        i++;
                    }
                    var prev = array[i - 1];
                    var target = i < array.length ? array[i] : Number.POSITIVE_INFINITY;
                    return target - value <= value - prev ? target : prev;
                },

                "rotateRight": function (node) {
                    var val = node.pop();
                    return node.unshift(val), val;
                },

                "rotateLeft": function (lValue) {
                    var r20 = lValue.shift();
                    return lValue.push(r20), r20;
                },

                "numberArray": function (textAlt, text) {
                    if (!(void 0 !== text && null !== text)) {

                        text = textAlt;

                        textAlt = 0;
                    }

                    var missing = [];

                    var dep = textAlt;
                    for (; dep <= text; dep++) {
                        missing.push(dep);
                    }
                    return missing;
                },

                "numberArrayStep": function (x, right, chunk) {
                    if (!(void 0 !== x && null !== x)) {

                        x = 0;
                    }
                    if (!(void 0 !== right && null !== right)) {

                        right = x;

                        x = 0;
                    }
                    if (void 0 === chunk) {

                        chunk = 1;
                    }

                    var console = [];
                    var padLength = Math.max($.Math.roundAwayFromZero((right - x) / (chunk || 1)), 0);

                    var i = 0;
                    for (; i < padLength; i++) {
                        console.push(x);
                        x += chunk;
                    }
                    return console;
                }
            }, $.LinkedList = function () {

                this.next = null;

                this.prev = null;

                this.first = null;

                this.last = null;

                this.total = 0;
            }, $.LinkedList.prototype = {

                "add": function (next) {
                    return 0 === this.total && (null === this.first && null === this.last) ? (this.first = next, this.last = next, this.next = next, next.prev = this, this.total++, next) : (this.last.next = next, next.prev = this.last, this.last = next, this.total++, next);
                },

                "reset": function () {

                    this.first = null;

                    this.last = null;

                    this.next = null;

                    this.prev = null;

                    this.total = 0;
                },

                "remove": function (node) {
                    if (1 === this.total) {
                        return this.reset(), void(node.next = node.prev = null);
                    }
                    if (node === this.first) {
                        this.first = this.first.next;
                    } else {
                        if (node === this.last) {
                            this.last = this.last.prev;
                        }
                    }
                    if (node.prev) {
                        node.prev.next = node.next;
                    }
                    if (node.next) {
                        node.next.prev = node.prev;
                    }

                    node.next = node.prev = null;
                    if (null === this.first) {

                        this.last = null;
                    }
                    this.total--;
                },

                "callAll": function (context) {
                    if (this.first && this.last) {
                        var fn = this.first;
                        do {
                            if (fn) {
                                if (fn[context]) {
                                    fn[context].call(fn);
                                }
                            }
                            fn = fn.next;
                        } while (fn !== this.last.next);
                    }
                }
            }, $.LinkedList.prototype.constructor = $.LinkedList, $.Create = function (dataAndEvents) {
                this.game = dataAndEvents;

                this.bmd = null;

                this.canvas = null;

                this.ctx = null;

                this.palettes = [{
                    0: '#000',
                    1: "#9D9D9D",
                    2: '#FFF',
                    3: '#BE2633',
                    4: '#E06F8B',
                    5: '#493C2B',
                    6: '#A46422',
                    7: '#EB8931',
                    8: '#F7E26B',
                    9: '#2F484E',
                    "A": '#44891A',
                    "B": "#A3CE27",
                    "C": '#1B2632',
                    "D": "#005784",
                    "E": '#31A2F2',
                    "F": '#B2DCEF'
                }, {
                    0: '#000',
                    1: '#191028',
                    2: '#46af45',
                    3: '#a1d685',
                    4: '#453e78',
                    5: "#7664fe",
                    6: '#833129',
                    7: '#9ec2e8',
                    8: '#dc534b',
                    9: "#e18d79",
                    "A": "#d6b97b",
                    "B": "#e9d8a1",
                    "C": '#216c4b',
                    "D": '#d365c8',
                    "E": "#afaab9",
                    "F": '#f5f4eb'
                }, {
                    0: '#000',
                    1: '#2234d1',
                    2: "#0c7e45",
                    3: '#44aacc',
                    4: "#8a3622",
                    5: '#5c2e78',
                    6: '#aa5c3d',
                    7: '#b5b5b5',
                    8: '#5e606e',
                    9: '#4c81fb',
                    "A": '#6cd947',
                    "B": '#7be2f9',
                    "C": '#eb8a60',
                    "D": '#e23d69',
                    "E": '#ffd93f',
                    "F": '#fff'
                }, {
                    0: '#000',
                    1: "#fff",
                    2: '#8b4131',
                    3: '#7bbdc5',
                    4: '#8b41ac',
                    5: '#6aac41',
                    6: "#3931a4",
                    7: '#d5de73',
                    8: "#945a20",
                    9: '#5a4100',
                    "A": '#bd736a',
                    "B": "#525252",
                    "C": "#838383",
                    "D": "#acee8b",
                    "E": "#7b73de",
                    "F": "#acacac"
                }, {
                    0: '#000',
                    1: '#191028',
                    2: '#46af45',
                    3: '#a1d685',
                    4: '#453e78',
                    5: '#7664fe',
                    6: '#833129',
                    7: '#9ec2e8',
                    8: "#dc534b",
                    9: "#e18d79",
                    "A": '#d6b97b',
                    "B": "#e9d8a1",
                    "C": "#216c4b",
                    "D": '#d365c8',
                    "E": '#afaab9',
                    "F": '#fff'
                }];
            }, $.Create.PALETTE_ARNE = 0, $.Create.PALETTE_JMP = 1, $.Create.PALETTE_CGA = 2, $.Create.PALETTE_C64 = 3, $.Create.PALETTE_JAPANESE_MACHINE = 4, $.Create.prototype = {

                "texture": function (mapping, options, fx, type, image, texture, assetName, filename) {
                    if (void 0 === fx) {

                        fx = 8;
                    }
                    if (void 0 === type) {

                        type = fx;
                    }
                    if (void 0 === image) {

                        image = 0;
                    }
                    if (void 0 === texture) {

                        texture = true;
                    }

                    var r20 = options[0].length * fx;

                    var restoreScript = options.length * type;
                    if (null === this.bmd) {
                        this.bmd = this.game.make.bitmapData();
                        this.canvas = this.bmd.canvas;
                        this.ctx = this.bmd.context;
                    }
                    this.bmd.resize(r20, restoreScript);
                    this.bmd.clear();

                    var i = 0;
                    for (; i < options.length; i++) {
                        var hc = options[i];

                        var unlock = 0;
                        for (; unlock < hc.length; unlock++) {
                            var cache = hc[unlock];
                            if ("." !== cache) {
                                if (" " !== cache) {
                                    this.ctx.fillStyle = this.palettes[image][cache];
                                    this.ctx.fillRect(unlock * fx, i * type, fx, type);
                                }
                            }
                        }
                    }
                    return texture ? this.bmd.generateTexture(mapping, assetName, filename) : this.copy();
                },

                "grid": function (sc, opt_data, tx, data, options, ro, opt_ignored, x, tile) {
                    if (void 0 === opt_ignored) {

                        opt_ignored = true;
                    }
                    if (null === this.bmd) {
                        this.bmd = this.game.make.bitmapData();
                        this.canvas = this.bmd.canvas;
                        this.ctx = this.bmd.context;
                    }
                    this.bmd.resize(opt_data, tx);
                    this.ctx.fillStyle = ro;

                    var ex = 0;
                    for (; ex < tx; ex += options) {
                        this.ctx.fillRect(0, ex, opt_data, 1);
                    }

                    var out = 0;
                    for (; out < opt_data; out += data) {
                        this.ctx.fillRect(out, 0, 1, tx);
                    }
                    return opt_ignored ? this.bmd.generateTexture(sc, x, tile) : this.copy();
                },

                "copy": function (obj, callback, next, methods, newId, destination, out) {
                    return null == obj && (obj = this.game.make.bitmapData()), obj.resize(this.bmd.width, this.bmd.height), obj.draw(this.bmd, callback, next, methods, newId, destination, out);
                }
            }, $.Create.prototype.constructor = $.Create, $.FlexGrid = function (dataAndEvents, imageHeight, imageWidth) {
                this.game = dataAndEvents.game;
                this.manager = dataAndEvents;

                this.width = imageHeight;

                this.height = imageWidth;
                this.boundsCustom = new($.Rectangle)(0, 0, imageHeight, imageWidth);
                this.boundsFluid = new($.Rectangle)(0, 0, imageHeight, imageWidth);
                this.boundsFull = new($.Rectangle)(0, 0, imageHeight, imageWidth);
                this.boundsNone = new($.Rectangle)(0, 0, imageHeight, imageWidth);
                this.positionCustom = new($.Point)(0, 0);
                this.positionFluid = new $.Point(0, 0);
                this.positionFull = new($.Point)(0, 0);
                this.positionNone = new($.Point)(0, 0);
                this.scaleCustom = new $.Point(1, 1);
                this.scaleFluid = new($.Point)(1, 1);
                this.scaleFluidInversed = new($.Point)(1, 1);
                this.scaleFull = new $.Point(1, 1);
                this.scaleNone = new($.Point)(1, 1);

                this.customWidth = 0;

                this.customHeight = 0;

                this.customOffsetX = 0;

                this.customOffsetY = 0;

                this.ratioH = imageHeight / imageWidth;

                this.ratioV = imageWidth / imageHeight;

                this.multiplier = 0;

                this.layers = [];
            }, $.FlexGrid.prototype = {

                "setSize": function (width, w) {

                    this.width = width;

                    this.height = w;

                    this.ratioH = width / w;

                    this.ratioV = w / width;
                    this.scaleNone = new($.Point)(1, 1);
                    this.boundsNone.width = this.width;
                    this.boundsNone.height = this.height;
                    this.refresh();
                },

                "createCustomLayer": function (dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents, value) {
                    if (void 0 === value) {

                        value = true;
                    }
                    this.customWidth = dataAndEvents;
                    this.customHeight = ignoreMethodDoesntExist;
                    this.boundsCustom.width = dataAndEvents;
                    this.boundsCustom.height = ignoreMethodDoesntExist;
                    var core_rnotwhite = new $.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                    return value && this.game.world.add(core_rnotwhite), this.layers.push(core_rnotwhite), void 0 !== deepDataAndEvents && (null !== typeof deepDataAndEvents && core_rnotwhite.addMultiple(deepDataAndEvents)), core_rnotwhite;
                },

                "createFluidLayer": function (deepDataAndEvents, value) {
                    if (void 0 === value) {

                        value = true;
                    }
                    var core_rnotwhite = new($.FlexLayer)(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                    return value && this.game.world.add(core_rnotwhite), this.layers.push(core_rnotwhite), void 0 !== deepDataAndEvents && (null !== typeof deepDataAndEvents && core_rnotwhite.addMultiple(deepDataAndEvents)), core_rnotwhite;
                },

                "createFullLayer": function (prop) {
                    var e = new $.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== prop && e.addMultiple(prop), e;
                },

                "createFixedLayer": function (prop) {
                    var e = new($.FlexLayer)(this, this.positionNone, this.boundsNone, this.scaleNone);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== prop && e.addMultiple(prop), e;
                },

                "reset": function () {
                    var sel = this.layers.length;
                    for (; sel--;) {
                        if (!this.layers[sel].persist) {

                            this.layers[sel].position = null;

                            this.layers[sel].scale = null;
                            this.layers.slice(sel, 1);
                        }
                    }
                },

                "onResize": function (h, w) {

                    this.ratioH = h / w;

                    this.ratioV = w / h;
                    this.refresh(h, w);
                },

                "refresh": function () {
                    this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width);
                    this.boundsFluid.width = Math.round(this.width * this.multiplier);
                    this.boundsFluid.height = Math.round(this.height * this.multiplier);
                    this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height);
                    this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height);
                    this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height);
                    this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x);
                    this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y);
                    this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
                    this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY);
                    this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y);
                    this.positionNone.set(this.boundsNone.x, this.boundsNone.y);
                },

                "fitSprite": function (urls) {
                    this.manager.scaleSprite(urls);
                    urls.x = this.manager.bounds.centerX;
                    urls.y = this.manager.bounds.centerY;
                },

                "debug": function () {
                    this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16);
                    this.game.debug.geom(this.boundsFluid, 'rgba(255,0,0,0.9', false);
                }
            }, $.FlexGrid.prototype.constructor = $.FlexGrid, $.FlexLayer = function (deepDataAndEvents, ignoreMethodDoesntExist, dataAndEvents, textAlt) {
                $.Group.call(this, deepDataAndEvents.game, null, '__flexLayer' + deepDataAndEvents.game.rnd.uuid(), false);
                this.manager = deepDataAndEvents.manager;
                this.grid = deepDataAndEvents;

                this.persist = false;
                this.position = ignoreMethodDoesntExist;

                this.bounds = dataAndEvents;
                this.scale = textAlt;
                this.topLeft = dataAndEvents.topLeft;
                this.topMiddle = new $.Point(dataAndEvents.halfWidth, 0);
                this.topRight = dataAndEvents.topRight;
                this.bottomLeft = dataAndEvents.bottomLeft;
                this.bottomMiddle = new($.Point)(dataAndEvents.halfWidth, dataAndEvents.bottom);
                this.bottomRight = dataAndEvents.bottomRight;
            }, $.FlexLayer.prototype = Object.create($.Group.prototype), $.FlexLayer.prototype.constructor = $.FlexLayer, $.FlexLayer.prototype.resize = function () {}, $.FlexLayer.prototype.debug = function () {
                this.game.debug.text(this.bounds.width + ' x ' + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16);
                this.game.debug.geom(this.bounds, 'rgba(0,0,255,0.9', false);
                this.game.debug.geom(this.topLeft, 'rgba(255,255,255,0.9');
                this.game.debug.geom(this.topMiddle, 'rgba(255,255,255,0.9');
                this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9");
            }, $.Color = {
                "RED": 16711680,
                "ORANGE": 16750848,
                "YELLOW": 16776960,
                "GREEN": 65280,
                "AQUA": 65535,
                "BLUE": 255,
                "VIOLET": 16711935,
                "WHITE": 16777215,
                "BLACK": 0,
                "GRAY": 6710886,

                "packPixel": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
                    return $.Device.LITTLE_ENDIAN ? (textAlt << 24 | ignoreMethodDoesntExist << 16 | deepDataAndEvents << 8 | dataAndEvents) >>> 0 : (dataAndEvents << 24 | deepDataAndEvents << 16 | ignoreMethodDoesntExist << 8 | textAlt) >>> 0;
                },

                "unpackPixel": function (element, data, dataAndEvents, deepDataAndEvents) {
                    return void 0 !== data && null !== data || (data = $.Color.createColor()), void 0 !== dataAndEvents && null !== dataAndEvents || (dataAndEvents = false), void 0 !== deepDataAndEvents && null !== deepDataAndEvents || (deepDataAndEvents = false), $.Device.LITTLE_ENDIAN ? (data.a = (4278190080 & element) >>> 24, data.b = (16711680 & element) >>> 16, data.g = (65280 & element) >>> 8, data.r = 255 & element) : (data.r = (4278190080 & element) >>> 24,
                        data.g = (16711680 & element) >>> 16, data.b = (65280 & element) >>> 8, data.a = 255 & element), data.color = element, data.rgba = 'rgba(' + data.r + "," + data.g + "," + data.b + "," + data.a / 255 + ")", dataAndEvents && $.Color.RGBtoHSL(data.r, data.g, data.b, data), deepDataAndEvents && $.Color.RGBtoHSV(data.r, data.g, data.b, data), data;
                },

                "fromRGBA": function (dataAndEvents, s) {
                    return s || (s = $.Color.createColor()), s.r = (4278190080 & dataAndEvents) >>> 24, s.g = (16711680 & dataAndEvents) >>> 16, s.b = (65280 & dataAndEvents) >>> 8, s.a = 255 & dataAndEvents, s.rgba = 'rgba(' + s.r + "," + s.g + "," + s.b + "," + s.a + ")", s;
                },

                "toRGBA": function (alpha, red, val, color) {
                    return alpha << 24 | red << 16 | val << 8 | color;
                },

                "toABGR": function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
                    return (textAlt << 24 | ignoreMethodDoesntExist << 16 | deepDataAndEvents << 8 | dataAndEvents) >>> 0;
                },

                "hexToRGBArray": function (dataAndEvents) {
                    return [(dataAndEvents >> 16 & 255) / 255, (dataAndEvents >> 8 & 255) / 255, (255 & dataAndEvents) / 255];
                },

                "RGBArrayToHex": function (dataAndEvents) {
                    return (255 * dataAndEvents[0] << 16) + (255 * dataAndEvents[1] << 8) + 255 * dataAndEvents[2];
                },

                "RGBtoHSL": function (env, x, y, ret) {
                    if (!ret) {
                        ret = $.Color.createColor(env, x, y, 1);
                    }
                    env /= 255;
                    x /= 255;
                    y /= 255;
                    var b = Math.min(env, x, y);
                    var a = Math.max(env, x, y);
                    if (ret.h = 0, ret.s = 0, ret.l = (a + b) / 2, a !== b) {

                        var scale = a - b;

                        ret.s = ret.l > 0.5 ? scale / (2 - a - b) : scale / (a + b);
                        if (a === env) {

                            ret.h = (x - y) / scale + (x < y ? 6 : 0);
                        } else {
                            if (a === x) {

                                ret.h = (y - env) / scale + 2;
                            } else {
                                if (a === y) {

                                    ret.h = (env - x) / scale + 4;
                                }
                            }
                        }
                        ret.h /= 6;
                    }
                    return ret;
                },

                "HSLtoRGB": function (stack, s, l, ret) {
                    if (ret ? (ret.r = l, ret.g = l, ret.b = l) : ret = $.Color.createColor(l, l, l), 0 !== s) {

                        var v = l < 0.5 ? l * (1 + s) : l + s - l * s;

                        var r = 2 * l - v;
                        ret.r = $.Color.hueToColor(r, v, stack + 1 / 3);
                        ret.g = $.Color.hueToColor(r, v, stack);
                        ret.b = $.Color.hueToColor(r, v, stack - 1 / 3);
                    }
                    return ret.r = Math.floor(255 * ret.r | 0), ret.g = Math.floor(255 * ret.g | 0), ret.b = Math.floor(255 * ret.b | 0), $.Color.updateColor(ret), ret;
                },

                "RGBtoHSV": function (r, g, b, m) {
                    if (!m) {
                        m = $.Color.createColor(r, g, b, 255);
                    }
                    r /= 255;
                    g /= 255;
                    b /= 255;
                    var min = Math.min(r, g, b);
                    var max = Math.max(r, g, b);

                    var delta = max - min;
                    return m.h = 0, m.s = 0 === max ? 0 : delta / max, m.v = max, max !== min && (max === r ? m.h = (g - b) / delta + (g < b ? 6 : 0) : max === g ? m.h = (b - r) / delta + 2 : max === b && (m.h = (r - g) / delta + 4), m.h /= 6), m;
                },

                "HSVtoRGB": function (v, alpha, background, seed) {
                    if (void 0 === seed) {
                        seed = $.Color.createColor(0, 0, 0, 1, v, alpha, 0, background);
                    }
                    var ret;
                    var callback;
                    var name;
                    var nSent = Math.floor(6 * v);

                    var amount = 6 * v - nSent;

                    var c = background * (1 - alpha);

                    var option = background * (1 - amount * alpha);

                    var token = background * (1 - (1 - amount) * alpha);
                    switch (nSent % 6) {
                    case 0:

                        ret = background;

                        callback = token;

                        name = c;
                        break;
                    case 1:

                        ret = option;

                        callback = background;

                        name = c;
                        break;
                    case 2:

                        ret = c;

                        callback = background;

                        name = token;
                        break;
                    case 3:

                        ret = c;

                        callback = option;

                        name = background;
                        break;
                    case 4:

                        ret = token;

                        callback = c;

                        name = background;
                        break;
                    case 5:

                        ret = background;

                        callback = c;

                        name = option;
                    }
                    return seed.r = Math.floor(255 * ret), seed.g = Math.floor(255 * callback), seed.b = Math.floor(255 * name), $.Color.updateColor(seed), seed;
                },

                "hueToColor": function (m1, m2, h) {
                    return h < 0 && (h += 1), h > 1 && (h -= 1), h < 1 / 6 ? m1 + 6 * (m2 - m1) * h : h < 0.5 ? m2 : h < 2 / 3 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1;
                },

                "createColor": function (r, dataAndEvents, b, src, h, deepDataAndEvents, lt, val) {
                    var color = {
                        "r": r || 0,
                        "g": dataAndEvents || 0,
                        "b": b || 0,
                        "a": src || 1,
                        "h": h || 0,
                        "s": deepDataAndEvents || 0,
                        "l": lt || 0,
                        "v": val || 0,
                        "color": 0,
                        "color32": 0,
                        "rgba": ""
                    };
                    return $.Color.updateColor(color);
                },

                "updateColor": function (m) {
                    return m.rgba = 'rgba(' + m.r.toFixed() + "," + m.g.toFixed() + "," + m.b.toFixed() + "," + m.a.toString() + ")", m.color = $.Color.getColor(m.r, m.g, m.b), m.color32 = $.Color.getColor32(255 * m.a, m.r, m.g, m.b), m;
                },

                "getColor32": function (blue, green, red, alpha) {
                    return blue << 24 | green << 16 | red << 8 | alpha;
                },

                "getColor": function (red, green, v) {
                    return red << 16 | green << 8 | v;
                },

                "RGBtoString": function (opt_obj2, isXML, deepDataAndEvents, walkers, val) {
                    return void 0 === walkers && (walkers = 255), void 0 === val && (val = "#"), "#" === val ? "#" + ((1 << 24) + (opt_obj2 << 16) + (isXML << 8) + deepDataAndEvents).toString(16).slice(1) : "0x" + $.Color.componentToHex(walkers) + $.Color.componentToHex(opt_obj2) + $.Color.componentToHex(isXML) + $.Color.componentToHex(deepDataAndEvents);
                },

                "hexToRGB": function (angle) {
                    var c = $.Color.hexToColor(angle);
                    if (c) {
                        return $.Color.getColor32(c.a, c.r, c.g, c.b);
                    }
                },

                "hexToColor": function (data, result) {
                    data = data.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (dataAndEvents, $1, $2, a_text) {
                        return $1 + $1 + $2 + $2 + a_text + a_text;
                    });
                    var bits = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i ['exec'](data);
                    if (bits) {

                        var temp = parseInt(bits[1], 16);

                        var buffer = parseInt(bits[2], 16);

                        var key = parseInt(bits[3], 16);
                        if (result) {

                            result.r = temp;

                            result.g = buffer;

                            result.b = key;
                        } else {
                            result = $.Color.createColor(temp, buffer, key);
                        }
                    }
                    return result;
                },

                "webToColor": function (info, seed) {
                    if (!seed) {
                        seed = $.Color.createColor();
                    }
                    var match = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/ ['exec'](info);
                    return match && (seed.r = ~~Number(match[1]), seed.g = ~~Number(match[2]), seed.b = ~~Number(match[3]), seed.a = void 0 !== match[4] ? Number(match[4]) : 1, $.Color.updateColor(seed)), seed;
                },

                "valueToColor": function (err, c) {
                    if (c || (c = $.Color.createColor()), "string" == typeof err) {
                        return 0 === err.indexOf('rgb') ? $.Color.webToColor(err, c) : (c.a = 1, $.Color.hexToColor(err, c));
                    }
                    if ('number' == typeof err) {
                        var a = $.Color.getRGB(err);
                        return c.r = a.r, c.g = a.g, c.b = a.b, c.a = a.a / 255, c;
                    }
                    return c;
                },

                "componentToHex": function (c) {
                    var _0x2ef3b5 = c.toString(16);
                    return 1 === _0x2ef3b5.length ? "0" + _0x2ef3b5 : _0x2ef3b5;
                },

                "HSVColorWheel": function (deepDataAndEvents, mod) {
                    if (void 0 === deepDataAndEvents) {

                        deepDataAndEvents = 1;
                    }
                    if (void 0 === mod) {

                        mod = 1;
                    }

                    var color = [];

                    var _0x1a0094 = 0;
                    for (; _0x1a0094 <= 359; _0x1a0094++) {
                        color.push($.Color.HSVtoRGB(_0x1a0094 / 359, deepDataAndEvents, mod));
                    }
                    return color;
                },

                "HSLColorWheel": function (xhr, deepDataAndEvents) {
                    if (void 0 === xhr) {

                        xhr = 0.5;
                    }
                    if (void 0 === deepDataAndEvents) {

                        deepDataAndEvents = 0.5;
                    }

                    var collection = [];

                    var _0x2b4bf5 = 0;
                    for (; _0x2b4bf5 <= 359; _0x2b4bf5++) {
                        collection.push($.Color.HSLtoRGB(_0x2b4bf5 / 359, xhr, deepDataAndEvents));
                    }
                    return collection;
                },

                "interpolateColor": function (env, alpha, max, min, color1, scalar) {
                    if (void 0 === color1) {

                        color1 = 255;
                    }
                    if (void 0 === scalar) {

                        scalar = 0;
                    }
                    var b = $.Color.getRGB(env);
                    var a = $.Color.getRGB(alpha);
                    if (0 === scalar) {
                        var elem = (a.red - b.red) * min / max + b.red;
                        var gesture = (a.green - b.green) * min / max + b.green;
                        var bucket = (a.blue - b.blue) * min / max + b.blue;
                    }
                    if (1 === scalar) {
                        var _COOKIE_NAME;
                        var args = $.Color.RGBtoHSV(b.r, b.g, b.b);
                        var handlers = $.Color.RGBtoHSV(a.r, a.g, a.b);

                        var halfWidth = handlers.h - args.h;
                        if (args.h > handlers.h) {
                            var handler = handlers.h;
                            handlers.h = args.h;
                            args.h = handler;

                            halfWidth = -halfWidth;

                            min = max - min;
                        }
                        if (halfWidth > 0.5) {
                            args.h = args.h + 1;

                            _COOKIE_NAME = ((handlers.h - args.h) * min / max + args.h) % 1;
                        }
                        if (halfWidth <= 0.5) {
                            _COOKIE_NAME = (handlers.h - args.h) * min / max + args.h;
                        }
                        var hashname = (handlers.s - args.s) * min / max + args.s;
                        var r20 = (handlers.v - args.v) * min / max + args.v;
                        var seed = $.Color.HSVtoRGB(_COOKIE_NAME, hashname, r20, seed);
                        elem = seed.r;
                        gesture = seed.g;
                        bucket = seed.b;
                    }
                    return $.Color.getColor32(color1, elem, gesture, bucket);
                },

                "interpolateColorWithRGB": function (b, r, g, r2, steps, currentStep) {
                    var bp = $.Color.getRGB(b);
                    var r20 = (r - bp.red) * currentStep / steps + bp.red;
                    var restoreScript = (g - bp.green) * currentStep / steps + bp.green;
                    var rreturn = (r2 - bp.blue) * currentStep / steps + bp.blue;
                    return $.Color.getColor(r20, restoreScript, rreturn);
                },

                "interpolateRGB": function (b1, g1, r1, b2, g2, r2, steps, currentStep) {
                    var c1 = (b2 - b1) * currentStep / steps + b1;
                    var r20 = (g2 - g1) * currentStep / steps + g1;
                    var xm = (r2 - r1) * currentStep / steps + r1;
                    return $.Color.getColor(c1, r20, xm);
                },

                "linear": function (n, diff, p) {
                    return this.interpolateColor(n, diff, 1, p);
                },

                "linearInterpolation": function (result, opt_obj) {
                    var i = $.Math.linear(0, result.length - 1, opt_obj);
                    var tail = result[Math.floor(i)];
                    var digit = result[Math.ceil(i)];
                    return this.linear(tail, digit, i % 1);
                },

                "getRandomColor": function (start, end, alpha) {
                    if (void 0 === start && (start = 0), void 0 === end && (end = 255), void 0 === alpha && (alpha = 255), end > 255 || start > end) {
                        return $.Color.getColor(255, 255, 255);
                    }
                    var deleteEnd = start + Math.round(Math.random() * (end - start));
                    var next = start + Math.round(Math.random() * (end - start));
                    var lim = start + Math.round(Math.random() * (end - start));
                    return $.Color.getColor32(alpha, deleteEnd, next, lim);
                },

                "getRGB": function (color) {
                    return color > 16777215 ? {
                        "alpha": color >>> 24,
                        "red": color >> 16 & 255,
                        "green": color >> 8 & 255,
                        "blue": 255 & color,
                        "a": color >>> 24,
                        "r": color >> 16 & 255,
                        "g": color >> 8 & 255,
                        "b": 255 & color
                    } : {
                        "alpha": 255,
                        "red": color >> 16 & 255,
                        "green": color >> 8 & 255,
                        "blue": 255 & color,
                        "a": 255,
                        "r": color >> 16 & 255,
                        "g": color >> 8 & 255,
                        "b": 255 & color
                    };
                },

                "getWebRGB": function (data) {
                    if ("object" == typeof data) {
                        return 'rgba(' + data.r.toString() + "," + data.g.toString() + "," + data.b.toString() + "," + (data.a / 255).toString() + ")";
                    }
                    var d = $.Color.getRGB(data);
                    return "rgba(" + d.r.toString() + "," + d.g.toString() + "," + d.b.toString() + "," + (d.a / 255).toString() + ")";
                },

                "getAlpha": function (color) {
                    return color >>> 24;
                },

                "getAlphaFloat": function (dataAndEvents) {
                    return (dataAndEvents >>> 24) / 255;
                },

                "getRed": function (color) {
                    return color >> 16 & 255;
                },

                "getGreen": function (color) {
                    return color >> 8 & 255;
                },

                "getBlue": function (color) {
                    return 255 & color;
                },

                "blendNormal": function (dataAndEvents) {
                    return dataAndEvents;
                },

                "blendLighten": function (date2, date1) {
                    return date1 > date2 ? date1 : date2;
                },

                "blendDarken": function (value, min) {
                    return min > value ? value : min;
                },

                "blendMultiply": function (a4, b1) {
                    return a4 * b1 / 255;
                },

                "blendAverage": function (far, near) {
                    return (far + near) / 2;
                },

                "blendAdd": function (far, near) {
                    return Math.min(255, far + near);
                },

                "blendSubtract": function (far, near) {
                    return Math.max(0, far + near - 255);
                },

                "blendDifference": function (far, near) {
                    return Math.abs(far - near);
                },

                "blendNegation": function (deepDataAndEvents, dataAndEvents) {
                    return 255 - Math.abs(255 - deepDataAndEvents - dataAndEvents);
                },

                "blendScreen": function (dataAndEvents, deepDataAndEvents) {
                    return 255 - ((255 - dataAndEvents) * (255 - deepDataAndEvents) >> 8);
                },

                "blendExclusion": function (far, near) {
                    return far + near - 2 * far * near / 255;
                },

                "blendOverlay": function (dataAndEvents, deepDataAndEvents) {
                    return deepDataAndEvents < 128 ? 2 * dataAndEvents * deepDataAndEvents / 255 : 255 - 2 * (255 - dataAndEvents) * (255 - deepDataAndEvents) / 255;
                },

                "blendSoftLight": function (dataAndEvents, deepDataAndEvents) {
                    return deepDataAndEvents < 128 ? 2 * (64 + (dataAndEvents >> 1)) * (deepDataAndEvents / 255) : 255 - 2 * (255 - (64 + (dataAndEvents >> 1))) * (255 - deepDataAndEvents) / 255;
                },

                "blendHardLight": function (deepDataAndEvents, opt_obj2) {
                    return $.Color.blendOverlay(opt_obj2, deepDataAndEvents);
                },

                "blendColorDodge": function (dataAndEvents, deepDataAndEvents) {
                    return 255 === deepDataAndEvents ? deepDataAndEvents : Math.min(255, (dataAndEvents << 8) / (255 - deepDataAndEvents));
                },

                "blendColorBurn": function (dataAndEvents, deepDataAndEvents) {
                    return 0 === deepDataAndEvents ? deepDataAndEvents : Math.max(0, 255 - (255 - dataAndEvents << 8) / deepDataAndEvents);
                },

                "blendLinearDodge": function (deepDataAndEvents, opt_obj2) {
                    return $.Color.blendAdd(deepDataAndEvents, opt_obj2);
                },

                "blendLinearBurn": function (deepDataAndEvents, opt_obj2) {
                    return $.Color.blendSubtract(deepDataAndEvents, opt_obj2);
                },

                "blendLinearLight": function (toX, dx) {
                    return dx < 128 ? $.Color.blendLinearBurn(toX, 2 * dx) : $.Color.blendLinearDodge(toX, 2 * (dx - 128));
                },

                "blendVividLight": function (toX, dx) {
                    return dx < 128 ? $.Color.blendColorBurn(toX, 2 * dx) : $.Color.blendColorDodge(toX, 2 * (dx - 128));
                },

                "blendPinLight": function (toX, dx) {
                    return dx < 128 ? $.Color.blendDarken(toX, 2 * dx) : $.Color.blendLighten(toX, 2 * (dx - 128));
                },

                "blendHardMix": function (deepDataAndEvents, opt_obj2) {
                    return $.Color.blendVividLight(deepDataAndEvents, opt_obj2) < 128 ? 0 : 255;
                },

                "blendReflect": function (near, left) {
                    return 255 === left ? left : Math.min(255, near * near / (255 - left));
                },

                "blendGlow": function (deepDataAndEvents, opt_obj2) {
                    return $.Color.blendReflect(opt_obj2, deepDataAndEvents);
                },

                "blendPhoenix": function (n, m) {
                    return Math.min(n, m) - Math.max(n, m) + 255;
                }
            }, $.Physics = function (dataAndEvents, details) {
                details = details || {};
                this.game = dataAndEvents;

                this.config = details;

                this.arcade = null;

                this.p2 = null;

                this.ninja = null;

                this.box2d = null;

                this.chipmunk = null;

                this.matter = null;
                this.parseConfig();
            }, $.Physics.ARCADE = 0, $.Physics.P2JS = 1, $.Physics.NINJA = 2, $.Physics.BOX2D = 3, $.Physics.CHIPMUNK = 4, $.Physics.MATTERJS = 5, $.Physics.prototype = {

                "parseConfig": function () {
                    if (!(this.config.hasOwnProperty('arcade') && true !== this.config.arcade)) {
                        if (!!$.Physics.hasOwnProperty("Arcade")) {
                            this.arcade = new $.Physics.Arcade(this.game);
                        }
                    }
                    if (this.config.hasOwnProperty('ninja')) {
                        if (true === this.config.ninja) {
                            if ($.Physics.hasOwnProperty("Ninja")) {
                                this.ninja = new $.Physics.Ninja(this.game);
                            }
                        }
                    }
                    if (this.config.hasOwnProperty("p2")) {
                        if (true === this.config.p2) {
                            if ($.Physics.hasOwnProperty("P2")) {
                                this.p2 = new $.Physics.P2(this.game, this.config);
                            }
                        }
                    }
                    if (this.config.hasOwnProperty("box2d")) {
                        if (true === this.config.box2d) {
                            if ($.Physics.hasOwnProperty('BOX2D')) {
                                this.box2d = new($.Physics.BOX2D)(this.game, this.config);
                            }
                        }
                    }
                    if (this.config.hasOwnProperty('matter')) {
                        if (true === this.config.matter) {
                            if ($.Physics.hasOwnProperty('Matter')) {
                                this.matter = new($.Physics.Matter)(this.game, this.config);
                            }
                        }
                    }
                },

                "startSystem": function (dataAndEvents) {
                    if (dataAndEvents === $.Physics.ARCADE) {
                        this.arcade = new($.Physics.Arcade)(this.game);
                    } else {
                        if (dataAndEvents === $.Physics.P2JS) {
                            if (null === this.p2) {
                                this.p2 = new($.Physics.P2)(this.game, this.config);
                            } else {
                                this.p2.reset();
                            }
                        } else {
                            if (dataAndEvents === $.Physics.NINJA) {
                                this.ninja = new($.Physics.Ninja)(this.game);
                            } else {
                                if (dataAndEvents === $.Physics.BOX2D) {
                                    if (null === this.box2d) {
                                        this.box2d = new($.Physics.Box2D)(this.game, this.config);
                                    } else {
                                        this.box2d.reset();
                                    }
                                } else {
                                    if (dataAndEvents === $.Physics.MATTERJS) {
                                        if (null === this.matter) {
                                            this.matter = new $.Physics.Matter(this.game, this.config);
                                        } else {
                                            this.matter.reset();
                                        }
                                    }
                                }
                            }
                        }
                    }
                },

                "enable": function (fieldObject, className, state) {
                    if (void 0 === className) {
                        className = $.Physics.ARCADE;
                    }
                    if (void 0 === state) {

                        state = false;
                    }
                    if (className === $.Physics.ARCADE) {
                        this.arcade.enable(fieldObject);
                    } else {
                        if (className === $.Physics.P2JS && this.p2) {
                            this.p2.enable(fieldObject, state);
                        } else {
                            if (className === $.Physics.NINJA && this.ninja) {
                                this.ninja.enableAABB(fieldObject);
                            } else {
                                if (className === $.Physics.BOX2D && this.box2d) {
                                    this.box2d.enable(fieldObject);
                                } else {
                                    if (className === $.Physics.MATTERJS && this.matter) {
                                        this.matter.enable(fieldObject);
                                    } else {
                                        console.warn(fieldObject.key + " is attempting to enable a physics body using an unknown physics system.");
                                    }
                                }
                            }
                        }
                    }
                },

                "preUpdate": function () {
                    if (this.p2) {
                        this.p2.preUpdate();
                    }
                    if (this.box2d) {
                        this.box2d.preUpdate();
                    }
                    if (this.matter) {
                        this.matter.preUpdate();
                    }
                },

                "update": function () {
                    if (this.p2) {
                        this.p2.update();
                    }
                    if (this.box2d) {
                        this.box2d.update();
                    }
                    if (this.matter) {
                        this.matter.update();
                    }
                },

                "setBoundsToWorld": function () {
                    if (this.arcade) {
                        this.arcade.setBoundsToWorld();
                    }
                    if (this.ninja) {
                        this.ninja.setBoundsToWorld();
                    }
                    if (this.p2) {
                        this.p2.setBoundsToWorld();
                    }
                    if (this.box2d) {
                        this.box2d.setBoundsToWorld();
                    }
                    if (this.matter) {
                        this.matter.setBoundsToWorld();
                    }
                },

                "clear": function () {
                    if (this.p2) {
                        this.p2.clear();
                    }
                    if (this.box2d) {
                        this.box2d.clear();
                    }
                    if (this.matter) {
                        this.matter.clear();
                    }
                },

                "reset": function () {
                    if (this.p2) {
                        this.p2.reset();
                    }
                    if (this.box2d) {
                        this.box2d.reset();
                    }
                    if (this.matter) {
                        this.matter.reset();
                    }
                },

                "destroy": function () {
                    if (this.p2) {
                        this.p2.destroy();
                    }
                    if (this.box2d) {
                        this.box2d.destroy();
                    }
                    if (this.matter) {
                        this.matter.destroy();
                    }

                    this.arcade = null;

                    this.ninja = null;

                    this.p2 = null;

                    this.box2d = null;

                    this.matter = null;
                }
            }, $.Physics.prototype.constructor = $.Physics, $.Particles = function (dataAndEvents) {
                this.game = dataAndEvents;
                this.emitters = {};

                this.ID = 0;
            }, $.Particles.prototype = {

                "add": function (models) {
                    return this.emitters[models.id] = models, models;
                },

                "remove": function (keepData) {
                    delete this.emitters[keepData.id];
                }
            }, $.Particles.prototype.constructor = $.Particles, $.Video = function (dataAndEvents, test, deepDataAndEvents) {
                if (void 0 === test && (test = null), void 0 === deepDataAndEvents && (deepDataAndEvents = null), this.game = dataAndEvents, this.key = test, this.width = 0, this.height = 0, this.type = $.VIDEO, this.disableTextureUpload = false, this.touchLocked = false, this.onPlay = new $.Signal, this.onChangeSource = new($.Signal), this.onComplete = new($.Signal), this.onAccess = new($.Signal),
                    this.onError = new $.Signal, this.onTimeout = new $.Signal, this.onTouchUnlock = new($.Signal), this.playWhenUnlocked = true, this.timeout = 15E3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = false, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = false, this._muted = false, this._codePaused =
                    false, this._paused = false, this._pending = false, this._pendingChangeSource = false, this._autoplay = false, this._endCallback = null, this._playCallback = null, test && this.game.cache.checkVideoKey(test)) {
                    var cache = this.game.cache.getVideo(test);
                    if (cache.isBlob) {
                        this.createVideoFromBlob(cache.data);
                    } else {
                        this.video = cache.data;
                    }
                    this.width = this.video.videoWidth;
                    this.height = this.video.videoHeight;
                } else {
                    if (deepDataAndEvents) {
                        this.createVideoFromURL(deepDataAndEvents, false);
                    }
                }
                if (this.video && !deepDataAndEvents) {
                    this.baseTexture = new PIXI.BaseTexture(this.video, null, this.game.resolution);
                    this.baseTexture.forceLoaded(this.width, this.height);
                } else {
                    this.baseTexture = new PIXI.BaseTexture($.Cache.DEFAULT.baseTexture.source, null, this.game.resolution);
                    this.baseTexture.forceLoaded(this.width, this.height);
                }
                this.texture = new(PIXI.Texture)(this.baseTexture);
                this.textureFrame = new($.Frame)(0, 0, 0, this.width, this.height, 'video');
                this.texture.setFrame(this.textureFrame);

                this.texture.valid = false;
                if (null !== test) {
                    if (this.video) {
                        this.texture.valid = this.video.canplay;
                    }
                }

                this.snapshot = null;
                if ($.BitmapData) {
                    this.snapshot = new($.BitmapData)(this.game, "", this.width, this.height);
                }
                if (this.game.device.needsTouchUnlock()) {
                    this.setTouchLock();
                } else {
                    if (cache) {

                        cache.locked = false;
                    }
                }
            }, $.Video.prototype = {

                "connectToMediaStream": function (p1, p2) {
                    return p1 && (p2 && (this.video = p1, this.videoStream = p2, this.isStreaming = true, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this))), this;
                },

                "startMediaStream": function (audio, dataAndEvents, v) {
                    if (void 0 === audio && (audio = false), void 0 === dataAndEvents && (dataAndEvents = null), void 0 === v && (v = null), !this.game.device.getUserMedia) {
                        return this.onError.dispatch(this, 'No getUserMedia'), false;
                    }
                    if (null !== this.videoStream) {
                        if (this.videoStream.active) {

                            this.videoStream.active = false;
                        } else {
                            this.videoStream.stop();
                        }
                    }
                    this.removeVideoElement();
                    this.video = document.createElement('video');
                    this.video.setAttribute('autoplay', 'autoplay');
                    if (null !== dataAndEvents) {

                        this.video.width = dataAndEvents;
                    }
                    if (null !== v) {

                        this.video.height = v;
                    }
                    this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                    try {
                        navigator.getUserMedia({
                            "audio": audio,
                            "video": true
                        }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this));
                    } catch (r20) {
                        this.getUserMediaError(r20);
                    }
                    return this;
                },

                "getUserMediaTimeout": function () {
                    clearTimeout(this._timeOutID);
                    this.onTimeout.dispatch(this);
                },

                "getUserMediaError": function (e) {
                    clearTimeout(this._timeOutID);
                    this.onError.dispatch(this, e);
                },

                "getUserMediaSuccess": function (URL) {
                    clearTimeout(this._timeOutID);
                    this.videoStream = URL;
                    if (void 0 !== this.video.mozSrcObject) {
                        this.video.mozSrcObject = URL;
                    } else {
                        this.video.src = window.URL && window.URL.createObjectURL(URL) || URL;
                    }
                    var tests = this;

                    this.video.onloadeddata = function () {

                        function focus() {
                            if (_0x2bb459 > 0) {
                                if (tests.video.videoWidth > 0) {
                                    var restoreScript = tests.video.videoWidth;
                                    var r20 = tests.video.videoHeight;
                                    if (isNaN(tests.video.videoHeight)) {

                                        r20 = restoreScript / (4 / 3);
                                    }
                                    tests.video.play();

                                    tests.isStreaming = true;
                                    tests.baseTexture.source = tests.video;
                                    tests.updateTexture(null, restoreScript, r20);
                                    tests.onAccess.dispatch(tests);
                                } else {
                                    window.setTimeout(focus, 500);
                                }
                            } else {
                                console.warn('Unable to connect to video stream. Webcam error?');
                            }
                            _0x2bb459--;
                        }

                        var _0x2bb459 = 10;
                        focus();
                    };
                },

                "createVideoFromBlob": function (deepDataAndEvents) {
                    var collection = this;
                    return this.video = document.createElement('video'), this.video.controls = false, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function (resp) {
                        collection.updateTexture(resp);
                    }, true), this.video.src = window.URL.createObjectURL(deepDataAndEvents), this.video.canplay = true, this;
                },

                "createVideoFromURL": function (value, dataAndEvents) {
                    return void 0 === dataAndEvents && (dataAndEvents = false), this.texture && (this.texture.valid = false), this.video = document.createElement("video"), this.video.controls = false, dataAndEvents && this.video.setAttribute('autoplay', "autoplay"), this.video.src = value, this.video.canplay = true, this.video.load(), this.retry = this.retryLimit,
                        this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = value, this;
                },

                "updateTexture": function (ctx, displayObject, following) {

                    var _0x4e885f = false;
                    if (!(void 0 !== displayObject && null !== displayObject)) {
                        displayObject = this.video.videoWidth;

                        _0x4e885f = true;
                    }
                    if (!(void 0 !== following && null !== following)) {
                        following = this.video.videoHeight;
                    }

                    this.width = displayObject;

                    this.height = following;
                    if (this.baseTexture.source !== this.video) {
                        this.baseTexture.source = this.video;
                    }
                    this.baseTexture.forceLoaded(displayObject, following);
                    this.texture.frame.resize(displayObject, following);

                    this.texture.width = displayObject;

                    this.texture.height = following;

                    this.texture.valid = true;
                    if (this.snapshot) {
                        this.snapshot.resize(displayObject, following);
                    }
                    if (_0x4e885f) {
                        if (null !== this.key) {
                            this.onChangeSource.dispatch(this, displayObject, following);
                            if (this._autoplay) {
                                this.video.play();
                                this.onPlay.dispatch(this, this.loop, this.playbackRate);
                            }
                        }
                    }
                },

                "complete": function () {
                    this.onComplete.dispatch(this);
                },

                "play": function (delay, action) {
                    return this._pendingChangeSource ? this : (void 0 === delay && (delay = false), void 0 === action && (action = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume,
                        this), this._endCallback = this.complete.bind(this), this.video.addEventListener('ended', this._endCallback, true), this.video.addEventListener('webkitendfullscreen', this._endCallback, true), this.video.loop = delay ? "loop" : "", this.video.playbackRate = action, this.touchLocked ? this._pending = true : (this._pending = false, null !== this.key && (4 !== this.video.readyState ?
                        (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener('playing', this._playCallback, true))), this.video.play(), this.onPlay.dispatch(this, delay, action)), this);
                },

                "playHandler": function () {
                    this.video.removeEventListener('playing', this._playCallback, true);
                    this.updateTexture();
                },

                "stop": function () {
                    return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(),
                        this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = false : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function (dataAndEvents) {
                        dataAndEvents.stop();
                    }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = false) : (this.video.removeEventListener('ended', this._endCallback, true), this.video.removeEventListener('webkitendfullscreen', this._endCallback, true), this.video.removeEventListener('playing', this._playCallback, true), this.touchLocked ? this._pending = false : this.video.pause()), this;
                },

                "add": function (map) {
                    if (Array.isArray(map)) {

                        var objUid = 0;
                        for (; objUid < map.length; objUid++) {
                            if (map[objUid].loadTexture) {
                                map[objUid].loadTexture(this);
                            }
                        }
                    } else {
                        map.loadTexture(this);
                    }
                    return this;
                },

                "addToWorld": function (owner, deepDataAndEvents, opt_obj2, walkers, made, options) {
                    made = made || 1;
                    options = options || 1;
                    var unlock = this.game.add.image(owner, deepDataAndEvents, this);
                    return unlock.anchor.set(opt_obj2, walkers), unlock.scale.set(made, options), unlock;
                },

                "render": function () {
                    if (!this.disableTextureUpload) {
                        if (this.playing) {
                            this.baseTexture.dirty();
                        }
                    }
                },

                "setMute": function () {
                    if (!this._muted) {

                        this._muted = true;

                        this.video.muted = true;
                    }
                },

                "unsetMute": function () {
                    if (this._muted) {
                        if (!this._codeMuted) {

                            this._muted = false;

                            this.video.muted = false;
                        }
                    }
                },

                "setPause": function () {
                    if (!this._paused) {
                        if (!this.touchLocked) {

                            this._paused = true;
                            this.video.pause();
                        }
                    }
                },

                "setResume": function () {
                    if (!!this._paused) {
                        if (!this._codePaused) {
                            if (!this.touchLocked) {

                                this._paused = false;
                                if (!this.video.ended) {
                                    this.video.play();
                                }
                            }
                        }
                    }
                },

                "changeSource": function (poster, lyrics) {
                    return void 0 === lyrics && (lyrics = true), this.texture.valid = false, this.video.pause(), this._pendingChangeSource = true, this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = poster, this.video.load(), this._autoplay = lyrics, lyrics || (this.paused =
                        true), this;
                },

                "checkVideoProgress": function () {
                    if (4 === this.video.readyState) {

                        this._pendingChangeSource = false;
                        this.updateTexture();
                    } else {
                        if (--this.retry > 0) {
                            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);
                        } else {
                            console.warn("Phaser.Video: Unable to start downloading video in time", this.isStreaming);
                        }
                    }
                },

                "setTouchLock": function () {
                    this.game.input.addTouchLockCallback(this.unlock, this, true);

                    this.touchLocked = true;
                },

                "unlock": function () {
                    if (this.touchLocked = false, this.playWhenUnlocked && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)), this.key) {
                        var _0x55dcc1 = this.game.cache.getVideo(this.key);
                        if (_0x55dcc1) {
                            if (!_0x55dcc1.isBlob) {

                                _0x55dcc1.locked = false;
                            }
                        }
                    }
                    return this.onTouchUnlock.dispatch(this), true;
                },

                "grab": function (a, where, el) {
                    if (void 0 === a && (a = false), void 0 === where && (where = 1), void 0 === el && (el = null), null !== this.snapshot) {
                        return a && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, where, el), this.snapshot;
                    }
                    console.warn('Video.grab cannot run because Phaser.BitmapData is unavailable');
                },

                "removeVideoElement": function () {
                    if (this.video) {
                        if (this.video.parentNode) {
                            this.video.parentNode.removeChild(this.video);
                        }
                        for (; this.video.hasChildNodes();) {
                            this.video.removeChild(this.video.firstChild);
                        }
                        this.video.removeAttribute("autoplay");
                        this.video.removeAttribute('src');

                        this.video = null;
                    }
                },

                "destroy": function () {
                    this.stop();
                    this.removeVideoElement();
                    if (this.touchLocked) {
                        this.game.input.touch.removeTouchLockCallback(this.unlock, this);
                    }
                    if (this._retryID) {
                        window.clearTimeout(this._retryID);
                    }
                }
            }, Object.defineProperty($.Video.prototype, 'currentTime', {

                "get": function () {
                    return this.video ? this.video.currentTime : 0;
                },

                "set": function (mL) {
                    this.video.currentTime = mL;
                }
            }), Object.defineProperty($.Video.prototype, 'duration', {

                "get": function () {
                    return this.video ? this.video.duration : 0;
                }
            }), Object.defineProperty($.Video.prototype, 'progress', {

                "get": function () {
                    return this.video ? this.video.currentTime / this.video.duration : 0;
                }
            }), Object.defineProperty($.Video.prototype, "mute", {

                "get": function () {
                    return this._muted;
                },

                "set": function (z) {
                    if (z = z || null) {
                        if (this._muted) {
                            return;
                        }

                        this._codeMuted = true;
                        this.setMute();
                    } else {
                        if (!this._muted) {
                            return;
                        }

                        this._codeMuted = false;
                        this.unsetMute();
                    }
                }
            }), Object.defineProperty($.Video.prototype, 'paused', {

                "get": function () {
                    return this._paused;
                },

                "set": function (z) {
                    if (z = z || null, !this.touchLocked) {
                        if (z) {
                            if (this._paused) {
                                return;
                            }

                            this._codePaused = true;
                            this.setPause();
                        } else {
                            if (!this._paused) {
                                return;
                            }

                            this._codePaused = false;
                            this.setResume();
                        }
                    }
                }
            }), Object.defineProperty($.Video.prototype, 'volume', {

                "get": function () {
                    return this.video ? this.video.volume : 1;
                },

                "set": function (mL) {
                    if (mL < 0) {

                        mL = 0;
                    } else {
                        if (mL > 1) {

                            mL = 1;
                        }
                    }
                    if (this.video) {

                        this.video.volume = mL;
                    }
                }
            }), Object.defineProperty($.Video.prototype, 'playbackRate', {

                "get": function () {
                    return this.video ? this.video.playbackRate : 1;
                },

                "set": function (mL) {
                    if (this.video) {
                        this.video.playbackRate = mL;
                    }
                }
            }), Object.defineProperty($.Video.prototype, 'loop', {

                "get": function () {
                    return !!this.video && this.video.loop;
                },

                "set": function (mL) {
                    if (mL && this.video) {
                        this.video.loop = 'loop';
                    } else {
                        if (this.video) {

                            this.video.loop = "";
                        }
                    }
                }
            }), Object.defineProperty($.Video.prototype, "playing", {

                "get": function () {
                    return !(!this.video || this.video.paused && this.video.ended);
                }
            }), $.Video.prototype.constructor = $.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = $.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = $.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new(PIXI.Texture)(new(PIXI.BaseTexture))), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new($.Matrix)),
            PIXI.TextureSilentFail = true, PIXI.canUseNewCanvasBlendModes = function () {
                return $.Device.canUseMultiply;
            }, 'undefined' != typeof exports ? ('undefined' != typeof module && (module.exports && (exports = module.exports = $)), exports.Phaser = $) : 'undefined' != typeof define && define.amd ? define("Phaser", a.Phaser = $) : a.Phaser = $, $;
    } ['call'](this),
    function (config) {

        function ce() {
            do {
                if (uncaughtException == e) {

                    uncaughtException = 0;
                } else {
                    uncaughtException++;
                }
            } while (o.hasOwnProperty(uncaughtException));
            return uncaughtException;
        }
        if (!(navigator.userAgent.toLowerCase().indexOf('firefox') > -1)) {
            try {

                var data = new Blob(["var fakeIdToId = {};onmessage = function (event) {	var data = event.data,		name = data.name,		fakeId = data.fakeId,		time;	if(data.hasOwnProperty('time')) {		time = data.time;	}	switch (name) {		case 'setInterval':			fakeIdToId[fakeId] = setInterval(function () {				postMessage({fakeId: fakeId});			}, time);			break;		case 'clearInterval':			if (fakeIdToId.hasOwnProperty (fakeId)) {				clearInterval(fakeIdToId[fakeId]);				delete fakeIdToId[fakeId];			}			break;		case 'setTimeout':			fakeIdToId[fakeId] = setTimeout(function () {				postMessage({fakeId: fakeId});				if (fakeIdToId.hasOwnProperty (fakeId)) {					delete fakeIdToId[fakeId];				}			}, time);			break;		case 'clearTimeout':			if (fakeIdToId.hasOwnProperty (fakeId)) {				clearTimeout(fakeIdToId[fakeId]);				delete fakeIdToId[fakeId];			}			break;	}}"]);
                config = window.URL.createObjectURL(data);
            } catch (_0x5730eb) {}
            var project;
            var o = {};

            var uncaughtException = 0;

            var e = 2147483647;
            var tag = 'HackTimer.js by turuslan: ';
            if ("undefined" != typeof Worker) {
                try {

                    project = new Worker(config);

                    window.setInterval = function (callback, time) {
                        var eventName = ce();
                        return o[eventName] = {

                            "callback": callback,
                            "parameters": Array.prototype.slice.call(arguments, 2)
                        }, project.postMessage({
                            "name": "setInterval",
                            "fakeId": eventName,
                            "time": time
                        }), eventName;
                    };

                    window.clearInterval = function (eventName) {
                        if (o.hasOwnProperty(eventName)) {
                            delete o[eventName];
                            project.postMessage({
                                "name": 'clearInterval',
                                "fakeId": eventName
                            });
                        }
                    };

                    window.setTimeout = function (callback, time) {
                        var eventName = ce();
                        return o[eventName] = {

                            "callback": callback,
                            "parameters": Array.prototype.slice.call(arguments, 2),
                            "isTimeout": true
                        }, project.postMessage({
                            "name": 'setTimeout',
                            "fakeId": eventName,
                            "time": time
                        }), eventName;
                    };

                    window.clearTimeout = function (eventName) {
                        if (o.hasOwnProperty(eventName)) {
                            delete o[eventName];
                            project.postMessage({
                                "name": 'clearTimeout',
                                "fakeId": eventName
                            });
                        }
                    };

                    project.onmessage = function (hashtable) {
                        var callbacks;
                        var dropCB;
                        var fn;
                        var match = hashtable.data;
                        var eventName = match.fakeId;
                        if (o.hasOwnProperty(eventName) && (callbacks = o[eventName], fn = callbacks.callback, dropCB = callbacks.parameters, callbacks.hasOwnProperty('isTimeout') && (callbacks.isTimeout && delete o[eventName])), 'string' == typeof fn) {
                            try {

                                fn = new Function(fn);
                            } catch (ext) {
                                console.log(tag + 'Error parsing callback code string: ', ext);
                            }
                        }
                        if ("function" == typeof fn) {
                            fn.apply(window, dropCB);
                        }
                    };

                    project.onerror = function (x) {
                        console.log(x);
                    };
                } catch (x) {
                    console.log(tag + 'Initialisation failed');
                    console.error(x);
                }
            } else {
                console.log(tag + 'Initialisation failed - HTML5 Web Worker is not supported');
            }
        }
    }('HackTimerWorker.js');
var fakeIdToId = {};
onmessage = function (message) {
        var frequency;
        var result = message.data;
        var tail = result.name;
        var id = result.fakeId;
        switch (result.hasOwnProperty('time') && (frequency = result.time), tail) {
        case 'setInterval':

            fakeIdToId[id] = setInterval(function () {
                postMessage({
                    "fakeId": id
                });
            }, frequency);
            break;
        case 'clearInterval':
            if (fakeIdToId.hasOwnProperty(id)) {
                clearInterval(fakeIdToId[id]);
                delete fakeIdToId[id];
            }
            break;
        case 'setTimeout':

            fakeIdToId[id] = setTimeout(function () {
                postMessage({
                    "fakeId": id
                });
                if (fakeIdToId.hasOwnProperty(id)) {
                    delete fakeIdToId[id];
                }
            }, frequency);
            break;
        case 'clearTimeout':
            if (fakeIdToId.hasOwnProperty(id)) {
                clearTimeout(fakeIdToId[id]);
                delete fakeIdToId[id];
            };
        }
    },
    function (keys) {

        function parseInt(array) {
            var i;
            var m;
            var x;

            var padLength = array.length - 1;

            var t = "";
            var v = array[0];
            if (padLength > 0) {
                t += v;

                i = 1;
                for (; i < padLength; i++) {
                    x = array[i] + "";

                    m = l - x.length;
                    if (m) {
                        t += fn(m);
                    }
                    t += x;
                }
                v = array[i];

                x = v + "";

                m = l - x.length;
                if (m) {
                    t += fn(m);
                }
            } else {
                if (0 === v) {
                    return "0";
                }
            }
            for (; v % 10 == 0;) {
                v /= 10;
            }
            return t + v;
        }

        function expect(x, recurring, opt_attributes) {
            if (x !== ~~x || (x < recurring || x > opt_attributes)) {
                throw Error(_ + x);
            }
        }

        function f(self, j, recurring, obj) {
            var i;
            var value;
            var _0x295db5;
            var val;
            value = self[0];
            for (; value >= 10; value /= 10) {
                --j;
            }
            return --j < 0 ? (j += l, i = 0) : (i = Math.ceil((j + 1) / l), j %= l), value = pad(10, l - j), val = self[i] % value | 0, null == obj ? j < 3 ? (0 == j ? val = val / 100 | 0 : 1 == j && (val = val / 10 | 0), _0x295db5 = recurring < 4 && 99999 == val || (recurring > 3 && 49999 == val || (5E4 == val || 0 == val))) : _0x295db5 = (recurring < 4 && val + 1 == value || recurring > 3 && val + 1 == value / 2) && (self[i + 1] / value / 100 | 0) == pad(10, j - 2) - 1 || (val == value / 2 || 0 == val) &&
                0 == (self[i + 1] / value / 100 | 0) : j < 4 ? (0 == j ? val = val / 1E3 | 0 : 1 == j ? val = val / 100 | 0 : 2 == j && (val = val / 10 | 0), _0x295db5 = (obj || recurring < 4) && 9999 == val || !obj && (recurring > 3 && 4999 == val)) : _0x295db5 = ((obj || recurring < 4) && val + 1 == value || !obj && (recurring > 3 && val + 1 == value / 2)) && (self[i + 1] / value / 1E3 | 0) == pad(10, j - 3) - 1, _0x295db5;
        }

        function create(var_args, collection, item) {
            var j;
            var part;

            var parts = [0];

            var i = 0;
            var padLength = var_args.length;
            for (; i < padLength;) {
                part = parts.length;
                for (; part--;) {
                    parts[part] *= collection;
                }
                parts[0] += classNames.indexOf(var_args.charAt(i++));

                j = 0;
                for (; j < parts.length; j++) {
                    if (parts[j] > item - 1) {
                        if (void 0 === parts[j + 1]) {

                            parts[j + 1] = 0;
                        }
                        parts[j + 1] += parts[j] / item | 0;
                        parts[j] %= item;
                    }
                }
            }
            return parts.reverse();
        }

        function extend(a, b) {
            var y;
            var rg;
            var deltaX = b.d.length;
            if (deltaX < 32) {
                y = Math.ceil(deltaX / 3);
                rg = Math.pow(4, -y).toString();
            } else {

                y = 16;

                rg = "2.3283064365386962890625e-10";
            }
            a.precision += y;
            b = md5_ii(a, 1, b.times(rg), new a(1));
            var tileV = y;
            for (; tileV--;) {
                var bp = b.times(b);
                b = bp.times(bp).minus(bp).times(8).plus(1);
            }
            return a.precision -= y, b;
        }

        function clone(d, dataAndEvents, recurring, deepDataAndEvents) {
            var px;
            var max;
            var width;
            var b;
            var j;
            var _0x5da8fb;
            var g;
            var a;
            var i;
            var el = d.constructor;
            _0x40630b: {
                if (null != dataAndEvents) {
                    if (!(a = d.d)) {
                        return d;
                    }

                    px = 1;
                    b = a[0];
                    for (; b >= 10; b /= 10) {
                        px++;
                    }
                    if ((max = dataAndEvents - px) < 0) {
                        max += l;

                        width = dataAndEvents;
                        g = a[i = 0];

                        j = g / pad(10, px - width - 1) % 10 | 0;
                    } else {
                        if (i = Math.ceil((max + 1) / l), b = a.length, i >= b) {
                            if (!deepDataAndEvents) {
                                break _0x40630b;
                            }
                            for (; b++ <= i;) {
                                a.push(0);
                            }

                            g = j = 0;

                            px = 1;
                            max %= l;

                            width = max - l + 1;
                        } else {
                            g = b = a[i];

                            px = 1;
                            for (; b >= 10; b /= 10) {
                                px++;
                            }
                            max %= l;

                            width = max - l + px;

                            j = width < 0 ? 0 : g / pad(10, px - width - 1) % 10 | 0;
                        }
                    }
                    if (deepDataAndEvents = deepDataAndEvents || (dataAndEvents < 0 || (void 0 !== a[i + 1] || (width < 0 ? g : g % pad(10, px - width - 1)))), _0x5da8fb = recurring < 4 ? (j || deepDataAndEvents) && (0 == recurring || recurring == (d.s < 0 ? 3 : 2)) : j > 5 || 5 == j && (4 == recurring || (deepDataAndEvents || (6 == recurring && (max > 0 ? width > 0 ? g / pad(10, px - width) : 0 : a[i - 1]) % 10 & 1 || recurring == (d.s < 0 ? 8 : 7)))), dataAndEvents < 1 || !a[0]) {
                        return a.length = 0, _0x5da8fb ? (dataAndEvents -= d.e + 1, a[0] = pad(10, (l - dataAndEvents % l) % l), d.e = -dataAndEvents || 0) : a[0] = d.e = 0, d;
                    }
                    if (0 == max ? (a.length = i, b = 1, i--) : (a.length = i + 1, b = pad(10, l - max), a[i] = width > 0 ? (g / pad(10, px - width) % pad(10, width) | 0) * b : 0), _0x5da8fb) {
                        for (;;) {
                            if (0 == i) {

                                max = 1;
                                width = a[0];
                                for (; width >= 10; width /= 10) {
                                    max++;
                                }
                                width = a[0] += b;

                                b = 1;
                                for (; width >= 10; width /= 10) {
                                    b++;
                                }
                                if (max != b) {
                                    d.e++;
                                    if (a[0] == className) {

                                        a[0] = 1;
                                    }
                                }
                                break;
                            }
                            if (a[i] += b, a[i] != className) {
                                break;
                            }

                            a[i--] = 0;

                            b = 1;
                        }
                    }
                    max = a.length;
                    for (; 0 === a[--max];) {
                        a.pop();
                    }
                }
            }
            return prefix && (d.e > el.maxE ? (d.d = null, d.e = NaN) : d.e < el.minE && (d.e = 0, d.d = [0])), d;
        }

        function callback(o, recurring, r) {
            if (!o.isFinite()) {
                return format(o);
            }
            var text;
            var n = o.e;
            var result = parseInt(o.d);
            var length = result.length;
            return recurring ? (r && (text = r - length) > 0 ? result = result.charAt(0) + "." + result.slice(1) + fn(text) : length > 1 && (result = result.charAt(0) + "." + result.slice(1)), result = result + (o.e < 0 ? "e" : "e+") + o.e) : n < 0 ? (result = "0." + fn(-n - 1) + result, r && ((text = r - length) > 0 && (result += fn(text)))) : n >= length ? (result += fn(n + 1 - length), r && ((text = r - n - 1) > 0 && (result = result + "." + fn(text)))) :
                ((text = n + 1) < length && (result = result.slice(0, text) + "." + result.slice(text)), r && ((text = r - length) > 0 && (n + 1 === length && (result += "."), result += fn(text)))), result;
        }

        function Number(a, value) {
            var next = a[0];
            value *= l;
            for (; next >= 10; next /= 10) {
                value++;
            }
            return value;
        }

        function each(arr, dataAndEvents, a) {
            if (dataAndEvents > _0x5c4beb) {
                throw prefix = true, a && (arr.precision = a), Error(message);
            }
            return clone(new arr(y), dataAndEvents, 1, true);
        }

        function validate(input, value, recurring) {
            if (value > max) {
                throw Error(message);
            }
            return clone(new input(x), value, recurring, true);
        }

        function cleanup(e) {

            var t = e.length - 1;

            var res = t * l + 1;
            if (t = e[t]) {
                for (; t % 10 == 0; t /= 10) {
                    res--;
                }
                t = e[0];
                for (; t >= 10; t /= 10) {
                    res++;
                }
            }
            return res;
        }

        function fn(event) {

            var out = "";
            for (; event--;) {
                out += "0";
            }
            return out;
        }

        function filter(keepData, data, i, xs) {
            var length;
            var cache = new keepData(1);
            var udataCur = Math.ceil(xs / l + 4);

            prefix = false;
            for (;;) {
                if (i % 2 && (cache = cache.times(data), isArray(cache.d, udataCur) && (length = true)), 0 === (i = next(i / 2))) {

                    i = cache.d.length - 1;
                    if (length) {
                        if (0 === cache.d[i]) {
                            ++cache.d[i];
                        }
                    }
                    break;
                }
                data = data.times(data);
                isArray(data.d, udataCur);
            }
            return prefix = true, cache;
        }

        function unfoldSoak(o) {
            return 1 & o.d[o.d.length - 1];
        }

        function done(dataAndEvents, collection, type) {
            var key;
            var attrs = new dataAndEvents(collection[0]);

            var method = 0;
            for (; ++method < collection.length;) {
                if (key = new dataAndEvents(collection[method]), !key.s) {
                    attrs = key;
                    break;
                }
                if (attrs[type](key)) {
                    attrs = key;
                }
            }
            return attrs;
        }

        function _sprintf_format(elements, value) {
            var r20;
            var start;
            var error;
            var e;
            var data;
            var result;
            var end;

            var suiteView = 0;

            var _0x29c08b = 0;

            var a2 = 0;
            var obj = elements.constructor;
            var recurring = obj.rounding;
            var val = obj.precision;
            if (!elements.d || (!elements.d[0] || elements.e > 17)) {
                return new obj(elements.d ? elements.d[0] ? elements.s < 0 ? 0 : 1 / 0 : 1 : elements.s ? elements.s < 0 ? 0 : elements : NaN);
            }
            if (null == value) {

                prefix = false;
                end = val;
            } else {

                end = value;
            }
            result = new obj(0.03125);
            for (; elements.e > -2;) {
                elements = elements.times(result);
                a2 += 5;
            }

            start = Math.log(pad(2, a2)) / Math.LN10 * 2 + 5 | 0;
            end += start;
            r20 = e = data = new obj(1);

            obj.precision = end;
            for (;;) {
                if (e = clone(e.times(elements), end, 1), r20 = r20.times(++_0x29c08b), result = data.plus(parseFloat(e, r20, end, 1)), parseInt(result.d).slice(0, end) === parseInt(data.d).slice(0, end)) {

                    error = a2;
                    for (; error--;) {
                        data = clone(data.times(data), end, 1);
                    }
                    if (null != value) {
                        return obj.precision = val, data;
                    }
                    if (!(suiteView < 3 && f(data.d, end - start, recurring, suiteView))) {
                        return clone(data, obj.precision = val, recurring, prefix = true);
                    }

                    obj.precision = end += 10;
                    r20 = e = result = new obj(1);

                    _0x29c08b = 0;
                    suiteView++;
                }
                data = result;
            }
        }

        function decode(key, utf8) {
            var nDigit;
            var _0x4245ed;
            var stack;
            var el;
            var d;
            var memory;
            var a;
            var t;
            var args;
            var doneResults;
            var value;

            var _0xb1b9d5 = 1;
            var data = key;
            var cDigit = data.d;
            var children = data.constructor;
            var recurring = children.rounding;
            var node = children.precision;
            if (data.s < 0 || (!cDigit || (!cDigit[0] || !data.e && (1 == cDigit[0] && 1 == cDigit.length)))) {
                return new children(cDigit && !cDigit[0] ? -1 / 0 : 1 != data.s ? NaN : cDigit ? 0 : data);
            }
            if (null == utf8 ? (prefix = false, args = node) : args = utf8, children.precision = args += 10, nDigit = parseInt(cDigit), _0x4245ed = nDigit.charAt(0), !(Math.abs(el = data.e) < 15E14)) {
                return t = each(children, args + 2, node).times(el + ""), data = decode(new children(_0x4245ed + "." + nDigit.slice(1)), args - 10).plus(t), children.precision = node, null == utf8 ? clone(data, node, recurring, prefix = true) : data;
            }
            for (; _0x4245ed < 7 && 1 != _0x4245ed || 1 == _0x4245ed && nDigit.charAt(1) > 3;) {
                data = data.times(key);
                nDigit = parseInt(data.d);
                _0x4245ed = nDigit.charAt(0);
                _0xb1b9d5++;
            }
            el = data.e;
            if (_0x4245ed > 1) {
                data = new children("0." + nDigit);
                el++;
            } else {
                data = new children(_0x4245ed + "." + nDigit.slice(1));
            }
            doneResults = data;
            a = d = data = parseFloat(data.minus(1), data.plus(1), args, 1);
            value = clone(data.times(data), args, 1);

            stack = 3;
            for (;;) {
                if (d = clone(d.times(value), args, 1), t = a.plus(parseFloat(d, new children(stack), args, 1)), parseInt(t.d).slice(0, args) === parseInt(a.d).slice(0, args)) {
                    if (a = a.times(2), 0 !== el && (a = a.plus(each(children, args + 2, node).times(el + ""))), a = parseFloat(a, new children(_0xb1b9d5), args, 1), null != utf8) {
                        return children.precision = node, a;
                    }
                    if (!f(a.d, args - 10, recurring, memory)) {
                        return clone(a, children.precision = node, recurring, prefix = true);
                    }

                    children.precision = args += 10;
                    t = d = data = parseFloat(doneResults.minus(1), doneResults.plus(1), args, 1);
                    value = clone(data.times(data), args, 1);

                    stack = memory = 1;
                }
                a = t;
                stack += 2;
            }
        }

        function format(value) {
            return String(value.s * value.s / 0);
        }

        function init(scope, data) {
            var first;
            var i;
            var camelKey;
            if ((first = data.indexOf(".")) > -1) {
                data = data.replace(".", "");
            }
            if ((i = data.search(/e/i)) > 0) {
                if (first < 0) {
                    first = i;
                }
                first += +data.slice(i + 1);
                data = data.substring(0, i);
            } else {
                if (first < 0) {
                    first = data.length;
                }
            }

            i = 0;
            for (; 48 === data.charCodeAt(i); i++) {}
            camelKey = data.length;
            for (; 48 === data.charCodeAt(camelKey - 1); --camelKey) {}
            if (data = data.slice(i, camelKey)) {
                if (camelKey -= i, scope.e = first = first - i - 1, scope.d = [], i = (first + 1) % l, first < 0 && (i += l), i < camelKey) {
                    if (i) {
                        scope.d.push(+data.slice(0, i));
                    }
                    camelKey -= l;
                    for (; i < camelKey;) {
                        scope.d.push(+data.slice(i, i += l));
                    }
                    data = data.slice(i);

                    i = l - data.length;
                } else {
                    i -= camelKey;
                }
                for (; i--;) {
                    data += "0";
                }
                scope.d.push(+data);
                if (prefix) {
                    if (scope.e > scope.constructor.maxE) {

                        scope.d = null;

                        scope.e = NaN;
                    } else {
                        if (scope.e < scope.constructor.minE) {

                            scope.e = 0;

                            scope.d = [0];
                        }
                    }
                }
            } else {

                scope.e = 0;

                scope.d = [0];
            }
            return scope;
        }

        function parse(data, name) {
            var args;
            var key;
            var result;
            var i;
            var rv;
            var c;
            var x;
            var value;
            var udataCur;
            if ("Infinity" === name || "NaN" === name) {
                return +name || (data.s = NaN), data.e = NaN, data.d = null, data;
            }
            if (rchecked.test(name)) {

                args = 16;
                name = name.toLowerCase();
            } else {
                if (temp.test(name)) {

                    args = 2;
                } else {
                    if (!exclude.test(name)) {
                        throw Error(_ + name);
                    }

                    args = 8;
                }
            }
            i = name.search(/p/i);
            if (i > 0) {

                x = +name.slice(i + 1);
                name = name.substring(2, i);
            } else {
                name = name.slice(2);
            }
            i = name.indexOf(".");

            rv = i >= 0;
            key = data.constructor;
            if (rv) {
                name = name.replace(".", "");
                c = name.length;

                i = c - i;
                result = filter(key, new key(args), i, 2 * i);
            }
            value = create(name, args, className);

            udataCur = value.length - 1;

            i = udataCur;
            for (; 0 === value[i]; --i) {
                value.pop();
            }
            return i < 0 ? new key(0 * data.s) : (data.e = Number(value, udataCur), data.d = value, prefix = false, rv && (data = parseFloat(data, result, 4 * c)), x && (data = data.times(Math.abs(x) < 54 ? Math.pow(2, x) : A.pow(2, x))), prefix = true, data);
        }

        function $(a, b) {
            var _0xe5afcc;
            var currentValue = b.d.length;
            if (currentValue < 3) {
                return md5_ii(a, 2, b, b);
            }

            _0xe5afcc = 1.4 * Math.sqrt(currentValue);

            _0xe5afcc = _0xe5afcc > 16 ? 16 : 0 | _0xe5afcc;
            b = b.times(Math.pow(5, -_0xe5afcc));
            b = md5_ii(a, 2, b, b);
            var date;
            var crazy = new a(5);
            var f = new a(16);
            var r20 = new a(20);
            for (; _0xe5afcc--;) {
                date = b.times(b);
                b = b.times(crazy.plus(date.times(f.times(date).minus(r20))));
            }
            return b;
        }

        function md5_ii(a, expectedNumberOfNonCommentArgs, thisObj, x, dataAndEvents) {
            var i;
            var data;
            var t;
            var val;

            var _0x212b6f = 1;
            var z = a.precision;
            var d = Math.ceil(z / l);

            prefix = false;
            val = thisObj.times(thisObj);
            t = new a(x);
            for (;;) {
                if (data = parseFloat(t.times(val), new a(expectedNumberOfNonCommentArgs++ * expectedNumberOfNonCommentArgs++), z, 1), t = dataAndEvents ? x.plus(data) : x.minus(data), x = parseFloat(data.times(val), new a(expectedNumberOfNonCommentArgs++ * expectedNumberOfNonCommentArgs++), z, 1), data = t.plus(x), void 0 !== data.d[d]) {
                    i = d;
                    for (; data.d[i] === t.d[i] && i--;) {}
                    if (-1 == i) {
                        break;
                    }
                }
                i = t;

                t = x;
                x = data;
                data = i;
                _0x212b6f++;
            }
            return prefix = true, data.d.length = d + 1, data;
        }

        function test(string, args) {
            var o;

            var frameMasked = args.s < 0;
            var data = validate(string, string.precision, 1);
            var message = data.times(0.5);
            if (args = args.abs(), args.lte(message)) {
                return state = frameMasked ? 4 : 1, args;
            }
            if (o = args.divToInt(data), o.isZero()) {

                state = frameMasked ? 3 : 2;
            } else {
                if (args = args.minus(o.times(data)), args.lte(message)) {
                    return state = unfoldSoak(o) ? frameMasked ? 2 : 3 : frameMasked ? 4 : 1, args;
                }

                state = unfoldSoak(o) ? frameMasked ? 1 : 4 : frameMasked ? 3 : 2;
            }
            return args.minus(data).abs();
        }

        function write(data, value, j, string) {
            var args;
            var i;
            var a;
            var b;
            var l;
            var fn;
            var p;
            var d;
            var o;
            var Data = data.constructor;

            var _0x4fb5f5 = void 0 !== j;
            if (_0x4fb5f5 ? (expect(j, 1, attributes), void 0 === string ? string = Data.rounding : expect(string, 0, 8)) : (j = Data.precision, string = Data.rounding), data.isFinite()) {
                p = callback(data);
                a = p.indexOf(".");
                if (_0x4fb5f5) {

                    args = 2;
                    if (16 == value) {

                        j = 4 * j - 3;
                    } else {
                        if (8 == value) {

                            j = 3 * j - 2;
                        }
                    }
                } else {

                    args = value;
                }
                if (a >= 0) {
                    p = p.replace(".", "");
                    o = new Data(1);

                    o.e = p.length - a;
                    o.d = create(callback(o), 10, args);
                    o.e = o.d.length;
                }
                d = create(p, 10, args);
                i = l = d.length;
                for (; 0 == d[--l];) {
                    d.pop();
                }
                if (d[0]) {
                    if (a < 0 ? i-- : (data = new Data(data), data.d = d, data.e = i, data = parseFloat(data, o, j, string, 0, args), d = data.d, i = data.e, fn = selector), a = d[j], b = args / 2, fn = fn || void 0 !== d[j + 1], fn = string < 4 ? (void 0 !== a || fn) && (0 === string || string === (data.s < 0 ? 3 : 2)) : a > b || a === b && (4 === string || (fn || (6 === string && 1 & d[j - 1] || string === (data.s < 0 ? 8 : 7)))), d.length = j, fn) {
                        for (; ++d[--j] > args - 1;) {

                            d[j] = 0;
                            if (!j) {
                                ++i;
                                d.unshift(1);
                            }
                        }
                    }
                    l = d.length;
                    for (; !d[l - 1]; --l) {}

                    a = 0;

                    p = "";
                    for (; a < l; a++) {
                        p += classNames.charAt(d[a]);
                    }
                    if (_0x4fb5f5) {
                        if (l > 1) {
                            if (16 == value || 8 == value) {

                                a = 16 == value ? 4 : 3;
                                --l;
                                for (; l % a; l++) {
                                    p += "0";
                                }
                                d = create(p, args, value);
                                l = d.length;
                                for (; !d[l - 1]; --l) {}

                                a = 1;

                                p = "1.";
                                for (; a < l; a++) {
                                    p += classNames.charAt(d[a]);
                                }
                            } else {
                                p = p.charAt(0) + "." + p.slice(1);
                            }
                        }

                        p = p + (i < 0 ? "p" : "p+") + i;
                    } else {
                        if (i < 0) {
                            for (; ++i;) {

                                p = "0" + p;
                            }

                            p = "0." + p;
                        } else {
                            if (++i > l) {
                                i -= l;
                                for (; i--;) {
                                    p += "0";
                                }
                            } else {
                                if (i < l) {
                                    p = p.slice(0, i) + "." + p.slice(i);
                                }
                            }
                        }
                    }
                } else {

                    p = _0x4fb5f5 ? "0p+0" : "0";
                }

                p = (16 == value ? "0x" : 2 == value ? "0b" : 8 == value ? "0o" : "") + p;
            } else {
                p = format(data);
            }
            return data.s < 0 ? "-" + p : p;
        }

        function isArray(x, value) {
            if (x.length > value) {
                return x.length = value, true;
            }
        }

        function appendee(dataAndEvents) {
            return (new this(dataAndEvents)).abs();
        }

        function text(id) {
            return (new this(id)).acos();
        }

        function k(a) {
            return (new this(a)).acosh();
        }

        function cloneNode(dataAndEvents, deepDataAndEvents) {
            return (new this(dataAndEvents)).plus(deepDataAndEvents);
        }

        function report(failing_message) {
            return (new this(failing_message)).asin();
        }

        function ty(y) {
            return (new this(y)).asinh();
        }

        function atan(a) {
            return (new this(a)).atan();
        }

        function byId(id) {
            return (new this(id)).atanh();
        }

        function n(a, b) {
            a = new this(a);
            b = new this(b);
            var r;
            var udataCur = this.precision;
            var recurring = this.rounding;
            var pdataOld = udataCur + 4;
            return a.s && b.s ? a.d || b.d ? !b.d || a.isZero() ? (r = b.s < 0 ? validate(this, udataCur, recurring) : new this(0), r.s = a.s) : !a.d || b.isZero() ? (r = validate(this, pdataOld, 1).times(0.5), r.s = a.s) : b.s < 0 ? (this.precision = pdataOld, this.rounding = 1, r = this.atan(parseFloat(a, b, pdataOld, 1)), b = validate(this, pdataOld, 1), this.precision = udataCur, this.rounding = recurring, r = a.s <
                0 ? r.minus(b) : r.plus(b)) : r = this.atan(parseFloat(a, b, pdataOld, 1)) : (r = validate(this, pdataOld, 1).times(b.s > 0 ? 0.25 : 0.75), r.s = a.s) : r = new this(NaN), r;
        }

        function grid(opt_ignored) {
            return (new this(opt_ignored)).cbrt();
        }

        function attr(val) {
            return clone(val = new this(val), val.e + 1, 2);
        }

        function setup(map) {
            if (!map || 'object' != typeof map) {
                throw Error(header + 'Object expected');
            }
            var j;
            var name;
            var val;

            var _0x382d2b = true === map.defaults;

            var parts = ['precision', 1, attributes, "rounding", 0, 8, 'toExpNeg', -file, 0, "toExpPos", 0, file, 'maxE', 0, file, 'minE', -file, 0, 'modulo', 0, 9];

            j = 0;
            for (; j < parts.length; j += 3) {
                if (name = parts[j], _0x382d2b && (this[name] = old[name]), void 0 !== (val = map[name])) {
                    if (!(next(val) === val && (val >= parts[j + 1] && val <= parts[j + 2]))) {
                        throw Error(_ + name + ": " + val);
                    }
                    this[name] = val;
                }
            }
            if (name = 'crypto', _0x382d2b && (this[name] = old[name]), void 0 !== (val = map[name])) {
                if (true !== val && (false !== val && (0 !== val && 1 !== val))) {
                    throw Error(_ + name + ": " + val);
                }
                if (val) {
                    if ('undefined' == typeof crypto || (!crypto || !crypto.getRandomValues && !crypto.randomBytes)) {
                        throw Error(exception);
                    }

                    this[name] = true;
                } else {

                    this[name] = false;
                }
            }
            return this;
        }

        function error(textStatus) {
            return (new this(textStatus)).cos();
        }

        function array_to_hash(a) {
            return (new this(a)).cosh();
        }

        function getOwnPropertyNames(old) {

            function ret(value) {
                var fn;
                var mode;
                var tooltip;
                var result = this;
                if (!(result instanceof ret)) {
                    return new ret(value);
                }
                if (result.constructor = ret, value instanceof ret) {
                    return result.s = value.s, result.e = value.e, void(result.d = (value = value.d) ? value.slice() : value);
                }
                if ('number' === (tooltip = typeof value)) {
                    if (0 === value) {
                        return result.s = 1 / value < 0 ? -1 : 1, result.e = 0, void(result.d = [0]);
                    }
                    if (value < 0 ? (value = -value, result.s = -1) : result.s = 1, value === ~~value && value < 1E7) {

                        fn = 0;

                        mode = value;
                        for (; mode >= 10; mode /= 10) {
                            fn++;
                        }
                        return result.e = fn, void(result.d = [value]);
                    }
                    return 0 * value != 0 ? (value || (result.s = NaN), result.e = NaN, void(result.d = null)) : init(result, value.toString());
                }
                if ('string' !== tooltip) {
                    throw Error(_ + value);
                }
                return 45 === value.charCodeAt(0) ? (value = value.slice(1), result.s = -1) : result.s = 1, nodes.test(value) ? init(result, value) : parse(result, value);
            }
            var i;
            var name;
            var attrNames;
            if (ret.prototype = node, ret.ROUND_UP = 0, ret.ROUND_DOWN = 1, ret.ROUND_CEIL = 2, ret.ROUND_FLOOR = 3, ret.ROUND_HALF_UP = 4, ret.ROUND_HALF_DOWN = 5, ret.ROUND_HALF_EVEN = 6, ret.ROUND_HALF_CEIL = 7, ret.ROUND_HALF_FLOOR = 8, ret.EUCLID = 9, ret.config = ret.set = setup, ret.clone = getOwnPropertyNames, ret.isDecimal = array, ret.abs = appendee, ret.acos = text, ret.acosh = k,
                ret.add = cloneNode, ret.asin = report, ret.asinh = ty, ret.atan = atan, ret.atanh = byId, ret.atan2 = n, ret.cbrt = grid, ret.ceil = attr, ret.cos = error, ret.cosh = array_to_hash, ret.div = t, ret.exp = start, ret.floor = err, ret.hypot = s, ret.ln = val, ret.log = width, ret.log10 = log, ret.log2 =
                h, ret.max = value, ret.min = result, ret.mod = insertBefore, ret.mul = type, ret.pow = newCoord, ret.random = replacer, ret.round = e, ret.sign = transform, ret.sin = sin, ret.sinh = v, ret.sqrt = sqrt, ret.sub = element, ret.tan = search, ret.tanh = height, ret.trunc = number, void 0 === old && (old = {}), old && true !== old.defaults) {

                attrNames = ['precision', 'rounding', "toExpNeg", 'toExpPos', "maxE", 'minE', "modulo", 'crypto'];

                i = 0;
                for (; i < attrNames.length;) {
                    if (!old.hasOwnProperty(name = attrNames[i++])) {
                        old[name] = this[name];
                    }
                }
            }
            return ret.config(old), ret;
        }

        function t(a, off) {
            return (new this(a)).div(off);
        }

        function start(ui) {
            return (new this(ui)).exp();
        }

        function err(s) {
            return clone(s = new this(s), s.e + 1, 3);
        }

        function s() {
            var current;
            var dir;
            var t = new this(0);

            prefix = false;

            current = 0;
            for (; current < arguments.length;) {
                if (dir = new this(arguments[current++]), dir.d) {
                    if (t.d) {
                        t = t.plus(dir.times(dir));
                    }
                } else {
                    if (dir.s) {
                        return prefix = true, new this(1 / 0);
                    }
                    t = dir;
                }
            }
            return prefix = true, t.sqrt();
        }

        function array(b) {
            return b instanceof A || (b && "[object Decimal]" === b.name || false);
        }

        function val(value) {
            return (new this(value)).ln();
        }

        function width(_, datum) {
            return (new this(_)).log(datum);
        }

        function h(s) {
            return (new this(s)).log(2);
        }

        function log(msgString) {
            return (new this(msgString)).log(10);
        }

        function value() {
            return done(this, arguments, "lt");
        }

        function result() {
            return done(this, arguments, "gt");
        }

        function insertBefore(arr, opt_obj2) {
            return (new this(arr)).mod(opt_obj2);
        }

        function type(obj, path) {
            return (new this(obj)).mul(path);
        }

        function newCoord(x, y) {
            return (new this(x)).pow(y);
        }

        function replacer(x) {
            var keys;
            var s;
            var b;
            var key;

            var j = 0;
            var target = new this(1);

            var data = [];
            if (void 0 === x ? x = this.precision : expect(x, 1, attributes), b = Math.ceil(x / l), this.crypto) {
                if (crypto.getRandomValues) {
                    keys = crypto.getRandomValues(new Uint32Array(b));
                    for (; j < b;) {
                        key = keys[j];
                        if (key >= 429E7) {
                            keys[j] = crypto.getRandomValues(new Uint32Array(1))[0];
                        } else {

                            data[j++] = key % 1E7;
                        }
                    }
                } else {
                    if (!crypto.randomBytes) {
                        throw Error(exception);
                    }
                    keys = crypto.randomBytes(b *= 4);
                    for (; j < b;) {
                        key = keys[j] + (keys[j + 1] << 8) + (keys[j + 2] << 16) + ((127 & keys[j + 3]) << 24);
                        if (key >= 214E7) {
                            crypto.randomBytes(4).copy(keys, j);
                        } else {
                            data.push(key % 1E7);
                            j += 4;
                        }
                    }

                    j = b / 4;
                }
            } else {
                for (; j < b;) {

                    data[j++] = 1E7 * Math.random() | 0;
                }
            }
            b = data[--j];
            x %= l;
            if (b) {
                if (x) {
                    key = pad(10, l - x);

                    data[j] = (b / key | 0) * key;
                }
            }
            for (; 0 === data[j]; j--) {
                data.pop();
            }
            if (j < 0) {

                s = 0;

                data = [0];
            } else {

                s = -1;
                for (; 0 === data[0]; s -= l) {
                    data.shift();
                }

                b = 1;
                key = data[0];
                for (; key >= 10; key /= 10) {
                    b++;
                }
                if (b < l) {
                    s -= l - b;
                }
            }
            return target.e = s, target.d = data, target;
        }

        function e(n) {
            return clone(n = new this(n), n.e + 1, this.rounding);
        }

        function transform(dir) {
            return dir = new this(dir), dir.d ? dir.d[0] ? dir.s : 0 * dir.s : dir.s || NaN;
        }

        function sin(x) {
            return (new this(x)).sin();
        }

        function v(scope) {
            return (new this(scope)).sinh();
        }

        function sqrt(a) {
            return (new this(a)).sqrt();
        }

        function element(settings, original) {
            return (new this(settings)).sub(original);
        }

        function search(elements) {
            return (new this(elements)).tan();
        }

        function height(ul) {
            return (new this(ul)).tanh();
        }

        function number(n) {
            return clone(n = new this(n), n.e + 1, 1);
        }
        var A;
        var selector;
        var key;
        var state;

        var file = 9E15;

        var attributes = 1E9;
        var classNames = '0123456789abcdef';
        var y = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058';

        var x = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
        var old = {
            "precision": 20,
            "rounding": 4,
            "modulo": 1,
            "toExpNeg": -7,
            "toExpPos": 21,
            "minE": -file,
            "maxE": file,
            "crypto": false
        };

        var prefix = true;
        var header = '[DecimalError] ';

        var _ = header + "Invalid argument: ";
        var message = header + 'Precision limit exceeded';
        var exception = header + 'crypto unavailable';
        var next = Math.floor;
        var pad = Math.pow;

        var temp = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;

        var rchecked = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;

        var exclude = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;

        var nodes = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

        var className = 1E7;

        var l = 7;

        var _0x5c4beb = y.length - 1;

        var max = x.length - 1;
        var node = {
            "name": '[object Decimal]'
        };

        node.absoluteValue = node.abs = function () {
            var opts = new(this.constructor)(this);
            return opts.s < 0 && (opts.s = 1), clone(opts);
        };

        node.ceil = function () {
            return clone(new(this.constructor)(this), this.e + 1, 2);
        };

        node.comparedTo = node.cmp = function (n) {
            var i;
            var padLength;
            var a;
            var b;
            var obj = this;
            var x = obj.d;
            var y = (n = new(obj.constructor)(n)).d;
            var end = obj.s;
            var start = n.s;
            if (!x || !y) {
                return end && start ? end !== start ? end : x === y ? 0 : !x ^ end < 0 ? 1 : -1 : NaN;
            }
            if (!x[0] || !y[0]) {
                return x[0] ? end : y[0] ? -start : 0;
            }
            if (end !== start) {
                return end;
            }
            if (obj.e !== n.e) {
                return obj.e > n.e ^ end < 0 ? 1 : -1;
            }
            a = x.length;
            b = y.length;

            i = 0;
            padLength = a < b ? a : b;
            for (; i < padLength; ++i) {
                if (x[i] !== y[i]) {
                    return x[i] > y[i] ^ end < 0 ? 1 : -1;
                }
            }
            return a === b ? 0 : a > b ^ end < 0 ? 1 : -1;
        };

        node.cosine = node.cos = function () {
            var res;
            var recurring;
            var o = this;
            var obj = o.constructor;
            return o.d ? o.d[0] ? (res = obj.precision, recurring = obj.rounding, obj.precision = res + Math.max(o.e, o.sd()) + l, obj.rounding = 1, o = extend(obj, test(obj, o)), obj.precision = res, obj.rounding = recurring, clone(2 == state || 3 == state ? o.neg() : o, res, recurring, true)) : new obj(1) : new obj(NaN);
        };

        node.cubeRoot = node.cbrt = function () {
            var _ref;
            var deepDataAndEvents;
            var number;
            var a;
            var needsFilter;
            var n;
            var r20;
            var value;
            var type;
            var element;
            var options = this;
            var server = options.constructor;
            if (!options.isFinite() || options.isZero()) {
                return new server(options);
            }

            prefix = false;

            n = options.s * Math.pow(options.s * options, 1 / 3);
            if (n && Math.abs(n) != 1 / 0) {
                a = new server(n.toString());
            } else {
                number = parseInt(options.d);
                _ref = options.e;
                if (n = (_ref - number.length + 1) % 3) {
                    number += 1 == n || -2 == n ? "0" : "00";
                }
                n = Math.pow(number, 1 / 3);

                _ref = next((_ref + 1) / 3) - (_ref % 3 == (_ref < 0 ? -1 : 2));
                if (n == 1 / 0) {

                    number = "5e" + _ref;
                } else {
                    number = n.toExponential();
                    number = number.slice(0, number.indexOf("e") + 1) + _ref;
                }
                a = new server(number);
                a.s = options.s;
            }
            r20 = (_ref = server.precision) + 3;
            for (;;) {
                if (value = a, type = value.times(value).times(value), element = type.plus(options), a = parseFloat(element.plus(options).times(value), element.plus(type), r20 + 2, 1), parseInt(value.d).slice(0, r20) === (number = parseInt(a.d)).slice(0, r20)) {
                    if ('9999' != (number = number.slice(r20 - 3, r20 + 1)) && (needsFilter || "4999" != number)) {
                        if (!(+number && (+number.slice(1) || "5" != number.charAt(0)))) {
                            clone(a, _ref + 1, 1);

                            deepDataAndEvents = !a.times(a).times(a).eq(options);
                        }
                        break;
                    }
                    if (!needsFilter && (clone(value, _ref + 1, 0), value.times(value).times(value).eq(options))) {
                        a = value;
                        break;
                    }
                    r20 += 4;

                    needsFilter = 1;
                }
            }
            return prefix = true, clone(a, _ref, server.rounding, deepDataAndEvents);
        };

        node.decimalPlaces = node.dp = function () {
            var line;
            var lines = this.d;

            var N = NaN;
            if (lines) {
                if (line = lines.length - 1, N = (line - next(this.e / l)) * l, line = lines[line]) {
                    for (; line % 10 == 0; line /= 10) {
                        N--;
                    }
                }
                if (N < 0) {

                    N = 0;
                }
            }
            return N;
        };

        node.dividedBy = node.div = function (settings) {
            return parseFloat(this, new this.constructor(settings));
        };

        node.dividedToIntegerBy = node.divToInt = function (dataAndEvents) {
            var path = this;
            var piece = path.constructor;
            return clone(parseFloat(path, new piece(dataAndEvents), 0, 1, 1), piece.precision, piece.rounding);
        };

        node.equals = node.eq = function (deepDataAndEvents) {
            return 0 === this.cmp(deepDataAndEvents);
        };

        node.floor = function () {
            return clone(new(this.constructor)(this), this.e + 1, 3);
        };

        node.greaterThan = node.gt = function (deepDataAndEvents) {
            return this.cmp(deepDataAndEvents) > 0;
        };

        node.greaterThanOrEqualTo = node.gte = function (owner) {
            var unlock = this.cmp(owner);
            return 1 == unlock || 0 === unlock;
        };

        node.hyperbolicCosine = node.cosh = function () {
            var YY_START;
            var dataPointer;
            var val;
            var tdir;
            var deltaX;
            var data = this;
            var d = data.constructor;
            var _0x199616 = new d(1);
            if (!data.isFinite()) {
                return new d(data.s ? 1 / 0 : NaN);
            }
            if (data.isZero()) {
                return _0x199616;
            }
            val = d.precision;
            tdir = d.rounding;
            d.precision = val + Math.max(data.e, data.sd()) + 4;

            d.rounding = 1;
            deltaX = data.d.length;
            if (deltaX < 32) {
                YY_START = Math.ceil(deltaX / 3);
                dataPointer = Math.pow(4, -YY_START).toString();
            } else {

                YY_START = 16;
                dataPointer = '2.3283064365386962890625e-10';
            }
            data = md5_ii(d, 1, data.times(dataPointer), new d(1), true);
            var xml;
            var YYSTATE = YY_START;
            var r20 = new d(8);
            for (; YYSTATE--;) {
                xml = data.times(data);
                data = _0x199616.minus(xml.times(r20.minus(xml.times(r20))));
            }
            return clone(data, d.precision = val, d.rounding = tdir, true);
        };

        node.hyperbolicSine = node.sinh = function () {
            var _0x4519b2;
            var node;
            var recurring;
            var currentValue;
            var b = this;
            var a = b.constructor;
            if (!b.isFinite() || b.isZero()) {
                return new a(b);
            }
            if (node = a.precision, recurring = a.rounding, a.precision = node + Math.max(b.e, b.sd()) + 4, a.rounding = 1, (currentValue = b.d.length) < 3) {
                b = md5_ii(a, 2, b, b, true);
            } else {

                _0x4519b2 = 1.4 * Math.sqrt(currentValue);

                _0x4519b2 = _0x4519b2 > 16 ? 16 : 0 | _0x4519b2;
                b = b.times(Math.pow(5, -_0x4519b2));
                b = md5_ii(a, 2, b, b, true);
                var date;
                var crazy = new a(5);
                var f = new a(16);
                var r20 = new a(20);
                for (; _0x4519b2--;) {
                    date = b.times(b);
                    b = b.times(crazy.plus(date.times(f.times(date).plus(r20))));
                }
            }
            return a.precision = node, a.rounding = recurring, clone(b, node, recurring, true);
        };

        node.hyperbolicTangent = node.tanh = function () {
            var key;
            var k;
            var options = this;
            var keys = options.constructor;
            return options.isFinite() ? options.isZero() ? new keys(options) : (key = keys.precision, k = keys.rounding, keys.precision = key + 7, keys.rounding = 1, parseFloat(options.sinh(), options.cosh(), keys.precision = key, keys.rounding = k)) : new keys(options.s);
        };

        node.inverseCosine = node.acos = function () {
            var onCreateListeners;
            var scope = this;
            var data = scope.constructor;
            var _0x1866a0 = scope.abs().cmp(1);
            var value = data.precision;
            var val = data.rounding;
            return -1 !== _0x1866a0 ? 0 === _0x1866a0 ? scope.isNeg() ? validate(data, value, val) : new data(0) : new data(NaN) : scope.isZero() ? validate(data, value + 4, val).times(0.5) : (data.precision = value + 6, data.rounding = 1, scope = scope.asin(), onCreateListeners = validate(data, value + 4, val).times(0.5), data.precision = value, data.rounding = val, onCreateListeners.minus(scope));
        };

        node.inverseHyperbolicCosine = node.acosh = function () {
            var key;
            var k;
            var p = this;
            var keys = p.constructor;
            return p.lte(1) ? new keys(p.eq(1) ? 0 : NaN) : p.isFinite() ? (key = keys.precision, k = keys.rounding, keys.precision = key + Math.max(Math.abs(p.e), p.sd()) + 4, keys.rounding = 1, prefix = false, p = p.times(p).minus(1).sqrt().plus(p), prefix = true, keys.precision = key, keys.rounding = k, p.ln()) : new keys(p);
        };

        node.inverseHyperbolicSine = node.asinh = function () {
            var key;
            var k;
            var ls = this;
            var keys = ls.constructor;
            return !ls.isFinite() || ls.isZero() ? new keys(ls) : (key = keys.precision, k = keys.rounding, keys.precision = key + 2 * Math.max(Math.abs(ls.e), ls.sd()) + 6, keys.rounding = 1, prefix = false, ls = ls.times(ls).plus(1).sqrt().plus(ls), prefix = true, keys.precision = key, keys.rounding = k, ls.ln());
        };

        node.inverseHyperbolicTangent = node.atanh = function () {
            var audio;
            var file;
            var j;
            var x;
            var data = this;
            var files = data.constructor;
            return data.isFinite() ? data.e >= 0 ? new files(data.abs().eq(1) ? data.s / 0 : data.isZero() ? data : NaN) : (audio = files.precision, file = files.rounding, x = data.sd(), Math.max(x, audio) < 2 * -data.e - 1 ? clone(new files(data), audio, file, true) : (files.precision = j = x - data.e, data = parseFloat(data.plus(1), (new files(1)).minus(data), j + audio, 1), files.precision = audio + 4,
                files.rounding = 1, data = data.ln(), files.precision = audio, files.rounding = file, data.times(0.5))) : new files(NaN);
        };

        node.inverseSine = node.asin = function () {
            var r;
            var h;
            var g;
            var value;
            var a = this;
            var data = a.constructor;
            return a.isZero() ? new data(a) : (h = a.abs().cmp(1), g = data.precision, value = data.rounding, -1 !== h ? 0 === h ? (r = validate(data, g + 4, value).times(0.5), r.s = a.s, r) : new data(NaN) : (data.precision = g + 6, data.rounding = 1, a = a.div((new data(1)).minus(a.times(a)).sqrt().plus(1)).atan(), data.precision = g,
                data.rounding = value, a.times(2)));
        };

        node.inverseTangent = node.atan = function () {
            var i;
            var s;
            var mediaBlockCount;
            var _0x1f5273;
            var nDigit;
            var dimensions;
            var event;
            var x;
            var cDigit;
            var originalEvent = this;
            var data = originalEvent.constructor;
            var y = data.precision;
            var val = data.rounding;
            if (originalEvent.isFinite()) {
                if (originalEvent.isZero()) {
                    return new data(originalEvent);
                }
                if (originalEvent.abs().eq(1) && y + 4 <= max) {
                    return event = validate(data, y + 4, val).times(0.25), event.s = originalEvent.s, event;
                }
            } else {
                if (!originalEvent.s) {
                    return new data(NaN);
                }
                if (y + 4 <= max) {
                    return event = validate(data, y + 4, val).times(0.5), event.s = originalEvent.s, event;
                }
            }
            data.precision = x = y + 10;

            data.rounding = 1;
            mediaBlockCount = Math.min(28, x / l + 2 | 0);
            i = mediaBlockCount;
            for (; i; --i) {
                originalEvent = originalEvent.div(originalEvent.times(originalEvent).plus(1).sqrt().plus(1));
            }

            prefix = false;
            s = Math.ceil(x / l);

            _0x1f5273 = 1;
            cDigit = originalEvent.times(originalEvent);
            event = new data(originalEvent);
            nDigit = originalEvent;
            for (; - 1 !== i;) {
                if (nDigit = nDigit.times(cDigit), dimensions = event.minus(nDigit.div(_0x1f5273 += 2)), nDigit = nDigit.times(cDigit), event = dimensions.plus(nDigit.div(_0x1f5273 += 2)), void 0 !== event.d[s]) {
                    i = s;
                    for (; event.d[i] === dimensions.d[i] && i--;) {}
                }
            }
            return mediaBlockCount && (event = event.times(2 << mediaBlockCount - 1)), prefix = true, clone(event, data.precision = y, data.rounding = val, true);
        };

        node.isFinite = function () {
            return !!this.d;
        };

        node.isInteger = node.isInt = function () {
            return !!this.d && next(this.e / l) > this.d.length - 2;
        };

        node.isNaN = function () {
            return !this.s;
        };

        node.isNegative = node.isNeg = function () {
            return this.s < 0;
        };

        node.isPositive = node.isPos = function () {
            return this.s > 0;
        };

        node.isZero = function () {
            return !!this.d && 0 === this.d[0];
        };

        node.lessThan = node.lt = function (deepDataAndEvents) {
            return this.cmp(deepDataAndEvents) < 0;
        };

        node.lessThanOrEqualTo = node.lte = function (deepDataAndEvents) {
            return this.cmp(deepDataAndEvents) < 1;
        };

        node.logarithm = node.log = function (h) {
            var raw;
            var g;
            var olda;
            var end;
            var found;
            var str;
            var i;
            var a;
            var data = this;
            var queue = data.constructor;
            var node = queue.precision;
            var recurring = queue.rounding;
            if (null == h) {
                h = new queue(10);

                raw = true;
            } else {
                if (h = new queue(h), g = h.d, h.s < 0 || (!g || (!g[0] || h.eq(1)))) {
                    return new queue(NaN);
                }
                raw = h.eq(10);
            }
            if (g = data.d, data.s < 0 || (!g || (!g[0] || data.eq(1)))) {
                return new queue(g && !g[0] ? -1 / 0 : 1 != data.s ? NaN : g ? 0 : 1 / 0);
            }
            if (raw) {
                if (g.length > 1) {

                    found = true;
                } else {
                    end = g[0];
                    for (; end % 10 == 0;) {
                        end /= 10;
                    }

                    found = 1 !== end;
                }
            }
            if (prefix = false, i = node + 5, str = decode(data, i), olda = raw ? each(queue, i + 10) : decode(h, i), a = parseFloat(str, olda, i, 1), f(a.d, end = node, recurring)) {
                do {
                    if (i += 10, str = decode(data, i), olda = raw ? each(queue, i + 10) : decode(h, i), a = parseFloat(str, olda, i, 1), !found) {
                        if (+parseInt(a.d).slice(end + 1, end + 15) + 1 == 1E14) {
                            a = clone(a, node + 1, 0);
                        }
                        break;
                    }
                } while (f(a.d, end += 10, recurring));
            }
            return prefix = true, clone(a, node, recurring);
        };

        node.minus = node.sub = function (b) {
            var data;
            var i;
            var j;
            var g;
            var index;
            var jj;
            var dataAndEvents;
            var recurring;
            var d;
            var k;
            var newKey;
            var x;
            var a = this;
            var Vec3 = a.constructor;
            if (b = new Vec3(b), !a.d || !b.d) {
                return a.s && b.s ? a.d ? b.s = -b.s : b = new Vec3(b.d || a.s !== b.s ? a : NaN) : b = new Vec3(NaN), b;
            }
            if (a.s != b.s) {
                return b.s = -b.s, a.plus(b);
            }
            if (d = a.d, x = b.d, dataAndEvents = Vec3.precision, recurring = Vec3.rounding, !d[0] || !x[0]) {
                if (x[0]) {

                    b.s = -b.s;
                } else {
                    if (!d[0]) {
                        return new Vec3(3 === recurring ? -0 : 0);
                    }
                    b = new Vec3(a);
                }
                return prefix ? clone(b, dataAndEvents, recurring) : b;
            }
            if (i = next(b.e / l), k = next(a.e / l), d = d.slice(), index = k - i) {

                newKey = index < 0;
                if (newKey) {
                    data = d;

                    index = -index;
                    jj = x.length;
                } else {
                    data = x;
                    i = k;
                    jj = d.length;
                }
                j = Math.max(Math.ceil(dataAndEvents / l), jj) + 2;
                if (index > j) {
                    index = j;

                    data.length = 1;
                }
                data.reverse();
                j = index;
                for (; j--;) {
                    data.push(0);
                }
                data.reverse();
            } else {
                j = d.length;
                jj = x.length;

                newKey = j < jj;
                if (newKey) {
                    jj = j;
                }

                j = 0;
                for (; j < jj; j++) {
                    if (d[j] != x[j]) {

                        newKey = d[j] < x[j];
                        break;
                    }
                }

                index = 0;
            }
            if (newKey) {
                data = d;
                d = x;
                x = data;

                b.s = -b.s;
            }
            jj = d.length;

            j = x.length - jj;
            for (; j > 0; --j) {

                d[jj++] = 0;
            }
            j = x.length;
            for (; j > index;) {
                if (d[--j] < x[j]) {
                    g = j;
                    for (; g && 0 === d[--g];) {

                        d[g] = className - 1;
                    }
                    --d[g];
                    d[j] += className;
                }
                d[j] -= x[j];
            }
            for (; 0 === d[--jj];) {
                d.pop();
            }
            for (; 0 === d[0]; d.shift()) {
                --i;
            }
            return d[0] ? (b.d = d, b.e = Number(d, i), prefix ? clone(b, dataAndEvents, recurring) : b) : new Vec3(3 === recurring ? -0 : 0);
        };

        node.modulo = node.mod = function (b) {
            var a;
            var x = this;
            var Vec3 = x.constructor;
            return b = new Vec3(b), !x.d || (!b.s || b.d && !b.d[0]) ? new Vec3(NaN) : !b.d || x.d && !x.d[0] ? clone(new Vec3(x), Vec3.precision, Vec3.rounding) : (prefix = false, 9 == Vec3.modulo ? (a = parseFloat(x, b.abs(), 0, 3, 1), a.s *= b.s) : a = parseFloat(x, b, 0, Vec3.modulo, 1), a = a.times(b), prefix = true, x.minus(a));
        };

        node.naturalExponential = node.exp = function () {
            return _sprintf_format(this);
        };

        node.naturalLogarithm = node.ln = function () {
            return decode(this);
        };

        node.negated = node.neg = function () {
            var opts = new(this.constructor)(this);
            return opts.s = -opts.s, clone(opts);
        };

        node.plus = node.add = function (b) {
            var z1;
            var tmp;
            var e;
            var i;
            var r;
            var value;
            var dataAndEvents;
            var recurring;
            var data;
            var x;
            var a = this;
            var Vec3 = a.constructor;
            if (b = new Vec3(b), !a.d || !b.d) {
                return a.s && b.s ? a.d || (b = new Vec3(b.d || a.s === b.s ? a : NaN)) : b = new Vec3(NaN), b;
            }
            if (a.s != b.s) {
                return b.s = -b.s, a.minus(b);
            }
            if (data = a.d, x = b.d, dataAndEvents = Vec3.precision, recurring = Vec3.rounding, !data[0] || !x[0]) {
                return x[0] || (b = new Vec3(a)), prefix ? clone(b, dataAndEvents, recurring) : b;
            }
            if (r = next(a.e / l), e = next(b.e / l), data = data.slice(), i = r - e) {
                if (i < 0) {
                    tmp = data;

                    i = -i;
                    value = x.length;
                } else {
                    tmp = x;
                    e = r;
                    value = data.length;
                }
                r = Math.ceil(dataAndEvents / l);
                value = r > value ? r + 1 : value + 1;
                if (i > value) {
                    i = value;

                    tmp.length = 1;
                }
                tmp.reverse();
                for (; i--;) {
                    tmp.push(0);
                }
                tmp.reverse();
            }
            value = data.length;
            i = x.length;
            if (value - i < 0) {
                i = value;
                tmp = x;
                x = data;
                data = tmp;
            }

            z1 = 0;
            for (; i;) {

                z1 = (data[--i] = data[i] + x[i] + z1) / className | 0;
                data[i] %= className;
            }
            if (z1) {
                data.unshift(z1);
                ++e;
            }
            value = data.length;
            for (; 0 == data[--value];) {
                data.pop();
            }
            return b.d = data, b.e = Number(data, e), prefix ? clone(b, dataAndEvents, recurring) : b;
        };

        node.precision = node.sd = function (name) {
            var previousValidIndex;
            var data = this;
            if (void 0 !== name && (name !== !!name && (1 !== name && 0 !== name))) {
                throw Error(_ + name);
            }
            return data.d ? (previousValidIndex = cleanup(data.d), name && (data.e + 1 > previousValidIndex && (previousValidIndex = data.e + 1))) : previousValidIndex = NaN, previousValidIndex;
        };

        node.round = function () {
            var val = this;
            var Splice = val.constructor;
            return clone(new Splice(val), val.e + 1, Splice.rounding);
        };

        node.sine = node.sin = function () {
            var node;
            var recurring;
            var data = this;
            var elem = data.constructor;
            return data.isFinite() ? data.isZero() ? new elem(data) : (node = elem.precision, recurring = elem.rounding, elem.precision = node + Math.max(data.e, data.sd()) + l, elem.rounding = 1, data = $(elem, test(elem, data)), elem.precision = node, elem.rounding = recurring, clone(state > 2 ? data.neg() : data, node, recurring, true)) : new elem(NaN);
        };

        node.squareRoot = node.sqrt = function () {
            var deepDataAndEvents;
            var result;
            var r20;
            var b;
            var _0x5ba12f;
            var a;
            var data = this;
            var index = data.d;
            var g = data.e;
            var text = data.s;
            var Buffer = data.constructor;
            if (1 !== text || (!index || !index[0])) {
                return new Buffer(!text || text < 0 && (!index || index[0]) ? NaN : index ? data : 1 / 0);
            }

            prefix = false;
            text = Math.sqrt(+data);
            if (0 == text || text == 1 / 0) {
                result = parseInt(index);
                if ((result.length + g) % 2 == 0) {
                    result += "0";
                }
                text = Math.sqrt(result);

                g = next((g + 1) / 2) - (g < 0 || g % 2);
                if (text == 1 / 0) {

                    result = "1e" + g;
                } else {
                    result = text.toExponential();
                    result = result.slice(0, result.indexOf("e") + 1) + g;
                }
                b = new Buffer(result);
            } else {
                b = new Buffer(text.toString());
            }
            r20 = (g = Buffer.precision) + 3;
            for (;;) {
                if (a = b, b = a.plus(parseFloat(data, a, r20 + 2, 1)).times(0.5), parseInt(a.d).slice(0, r20) === (result = parseInt(b.d)).slice(0, r20)) {
                    if ('9999' != (result = result.slice(r20 - 3, r20 + 1)) && (_0x5ba12f || "4999" != result)) {
                        if (!(+result && (+result.slice(1) || "5" != result.charAt(0)))) {
                            clone(b, g + 1, 1);

                            deepDataAndEvents = !b.times(b).eq(data);
                        }
                        break;
                    }
                    if (!_0x5ba12f && (clone(a, g + 1, 0), a.times(a).eq(data))) {
                        b = a;
                        break;
                    }
                    r20 += 4;

                    _0x5ba12f = 1;
                }
            }
            return prefix = true, clone(b, g, Buffer.rounding, deepDataAndEvents);
        };

        node.tangent = node.tan = function () {
            var value;
            var option;
            var a = this;
            var options = a.constructor;
            return a.isFinite() ? a.isZero() ? new options(a) : (value = options.precision, option = options.rounding, options.precision = value + 10, options.rounding = 1, a = a.sin(), a.s = 1, a = parseFloat(a, (new options(1)).minus(a.times(a)).sqrt(), value + 10, 0), options.precision = value, options.rounding = option, clone(2 == state || 4 == state ? a.neg() : a, value, option,
                true)) : new options(NaN);
        };

        node.times = node.mul = function (a) {
            var n;
            var udataCur;
            var i;
            var k;
            var c;
            var start;
            var msg;
            var j;
            var offset;
            var scope = this;
            var Annotation = scope.constructor;
            var m = scope.d;
            var p = (a = new Annotation(a)).d;
            if (a.s *= scope.s, !(m && (m[0] && (p && p[0])))) {
                return new Annotation(!a.s || (m && (!m[0] && !p) || p && (!p[0] && !m)) ? NaN : m && p ? 0 * a.s : a.s / 0);
            }
            udataCur = next(scope.e / l) + next(a.e / l);
            j = m.length;
            offset = p.length;
            if (j < offset) {
                c = m;
                m = p;
                p = c;
                start = j;
                j = offset;
                offset = start;
            }

            c = [];
            start = j + offset;
            i = start;
            for (; i--;) {
                c.push(0);
            }
            i = offset;
            for (; --i >= 0;) {

                n = 0;
                k = j + i;
                for (; k > i;) {
                    msg = c[k] + p[i] * m[k - i - 1] + n;

                    c[k--] = msg % className | 0;

                    n = msg / className | 0;
                }

                c[k] = (c[k] + n) % className | 0;
            }
            for (; !c[--start];) {
                c.pop();
            }
            return n ? ++udataCur : c.shift(), a.d = c, a.e = Number(c, udataCur), prefix ? clone(a, Annotation.precision, Annotation.rounding) : a;
        };

        node.toBinary = function (key, message) {
            return write(this, 2, key, message);
        };

        node.toDecimalPlaces = node.toDP = function (array, recurring) {
            var a = this;
            var Annotation = a.constructor;
            return a = new Annotation(a), void 0 === array ? a : (expect(array, 0, attributes), void 0 === recurring ? recurring = Annotation.rounding : expect(recurring, 0, 8), clone(a, array + a.e + 1, recurring));
        };

        node.toExponential = function (g, recurring) {
            var v;
            var val = this;
            var Splice = val.constructor;
            return void 0 === g ? v = callback(val, true) : (expect(g, 0, attributes), void 0 === recurring ? recurring = Splice.rounding : expect(recurring, 0, 8), val = clone(new Splice(val), g + 1, recurring), v = callback(val, true, g + 1)), val.isNeg() && !val.isZero() ? "-" + v : v;
        };

        node.toFixed = function (sum, recurring) {
            var v;
            var a;
            var val = this;
            var Splice = val.constructor;
            return void 0 === sum ? v = callback(val) : (expect(sum, 0, attributes), void 0 === recurring ? recurring = Splice.rounding : expect(recurring, 0, 8), a = clone(new Splice(val), sum + val.e + 1, recurring), v = callback(a, false, sum + a.e + 1)), val.isNeg() && !val.isZero() ? "-" + v : v;
        };

        node.toFraction = function (name) {
            var value;
            var originalEvent;
            var event;
            var result;
            var i;
            var index;
            var e;
            var n;
            var prop;
            var key;
            var ret;
            var _0x4cbd4f;
            var options = this;
            var data = options.d;
            var keys = options.constructor;
            if (!data) {
                return new keys(options);
            }
            if (prop = originalEvent = new keys(1), event = n = new keys(0), value = new keys(event), i = value.e = cleanup(data) - options.e - 1, index = i % l, value.d[0] = pad(10, index < 0 ? l + index : index), null == name) {
                name = i > 0 ? value : prop;
            } else {
                if (e = new keys(name), !e.isInt() || e.lt(prop)) {
                    throw Error(_ + e);
                }
                name = e.gt(value) ? i > 0 ? value : prop : e;
            }

            prefix = false;
            e = new keys(parseInt(data));
            key = keys.precision;

            keys.precision = i = data.length * l * 2;
            for (; ret = parseFloat(e, value, 0, 1, 1), result = originalEvent.plus(ret.times(event)), 1 != result.cmp(name);) {
                originalEvent = event;
                event = result;
                result = prop;
                prop = n.plus(ret.times(result));
                n = result;
                result = value;
                value = e.minus(ret.times(result));
                e = result;
            }
            return result = parseFloat(name.minus(originalEvent), event, 0, 1, 1), n = n.plus(result.times(prop)), originalEvent = originalEvent.plus(result.times(event)), n.s = prop.s = options.s, _0x4cbd4f = parseFloat(prop, event, i, 1).minus(options).abs().cmp(parseFloat(n, originalEvent, i, 1).minus(options).abs()) < 1 ? [prop, event] : [n, originalEvent], keys.precision = key, prefix = true,
                _0x4cbd4f;
        };

        node.toHexadecimal = node.toHex = function (key, message) {
            return write(this, 16, key, message);
        };

        node.toNearest = function (result, v) {
            var data = this;
            var Buffer = data.constructor;
            if (data = new Buffer(data), null == result) {
                if (!data.d) {
                    return data;
                }
                result = new Buffer(1);
                v = Buffer.rounding;
            } else {
                if (result = new Buffer(result), void 0 === v ? v = Buffer.rounding : expect(v, 0, 8), !data.d) {
                    return result.s ? data : result;
                }
                if (!result.d) {
                    return result.s && (result.s = data.s), result;
                }
            }
            return result.d[0] ? (prefix = false, data = parseFloat(data, result, 0, v, 1).times(result), prefix = true, clone(data)) : (result.s = data.s, data = result), data;
        };

        node.toNumber = function () {
            return +this;
        };

        node.toOctal = function (key, message) {
            return write(this, 8, key, message);
        };

        node.toPower = node.pow = function (t) {
            var i;
            var w;
            var value;
            var data;
            var recurring;
            var g;
            var a = this;
            var name = a.constructor;

            var width = +(t = new name(t));
            if (!(a.d && (t.d && (a.d[0] && t.d[0])))) {
                return new name(pad(+a, width));
            }
            if (a = new name(a), a.eq(1)) {
                return a;
            }
            if (value = name.precision, recurring = name.rounding, t.eq(1)) {
                return clone(a, value, recurring);
            }
            if ((i = next(t.e / l)) >= t.d.length - 1 && (w = width < 0 ? -width : width) <= 9007199254740991) {
                return data = filter(name, a, w, value), t.s < 0 ? (new name(1)).div(data) : clone(data, value, recurring);
            }
            if ((g = a.s) < 0) {
                if (i < t.d.length - 1) {
                    return new name(NaN);
                }
                if (0 == (1 & t.d[i]) && (g = 1), 0 == a.e && (1 == a.d[0] && 1 == a.d.length)) {
                    return a.s = g, a;
                }
            }
            return w = pad(+a, width), (i = 0 != w && isFinite(w) ? (new name(w + "")).e : next(width * (Math.log("0." + parseInt(a.d)) / Math.LN10 + a.e + 1))) > name.maxE + 1 || i < name.minE - 1 ? new name(i > 0 ? g / 0 : 0) : (prefix = false, name.rounding = a.s = 1, w = Math.min(12, (i + "").length), data = _sprintf_format(t.times(decode(a, value + w)), value), data.d && (data = clone(data, value + 5, 1), f(data.d,
                value, recurring) && (i = value + 10, data = clone(_sprintf_format(t.times(decode(a, i + w)), i), i + 5, 1), +parseInt(data.d).slice(value + 1, value + 15) + 1 == 1E14 && (data = clone(data, value + 1, 0)))), data.s = g, prefix = true, name.rounding = recurring, clone(data, value, recurring));
        };

        node.toPrecision = function (key, recurring) {
            var result;
            var data = this;
            var type = data.constructor;
            return void 0 === key ? result = callback(data, data.e <= type.toExpNeg || data.e >= type.toExpPos) : (expect(key, 1, attributes), void 0 === recurring ? recurring = type.rounding : expect(recurring, 0, 8), data = clone(new type(data), key, recurring), result = callback(data, key <= data.e || data.e <= type.toExpNeg, key)), data.isNeg() && !data.isZero() ? "-" + result : result;
        };

        node.toSignificantDigits = node.toSD = function (node, recurring) {
            var elems = this;
            var elem = elems.constructor;
            return void 0 === node ? (node = elem.precision, recurring = elem.rounding) : (expect(node, 1, attributes), void 0 === recurring ? recurring = elem.rounding : expect(recurring, 0, 8)), clone(new elem(elems), node, recurring);
        };

        node.toString = function () {
            var a = this;
            var b = a.constructor;
            var result = callback(a, a.e <= b.toExpNeg || a.e >= b.toExpPos);
            return a.isNeg() && !a.isZero() ? "-" + result : result;
        };

        node.truncated = node.trunc = function () {
            return clone(new this.constructor(this), this.e + 1, 1);
        };

        node.valueOf = node.toJSON = function () {
            var a = this;
            var b = a.constructor;
            var result = callback(a, a.e <= b.toExpNeg || a.e >= b.toExpPos);
            return a.isNeg() ? "-" + result : result;
        };
        var parseFloat = function () {

            function format(data, value, b) {
                var a;

                var params = 0;
                var i = data.length;
                data = data.slice();
                for (; i--;) {

                    a = data[i] * value + params;

                    data[i] = a % b | 0;

                    params = a / b | 0;
                }
                return params && data.unshift(params), data;
            }

            function fn(a, b, x, y) {
                var i;
                var out;
                if (x != y) {

                    out = x > y ? 1 : -1;
                } else {

                    i = out = 0;
                    for (; i < x; i++) {
                        if (a[i] != b[i]) {

                            out = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return out;
            }

            function callback(a, b, i, t) {

                var n = 0;
                for (; i--;) {
                    a[i] -= n;

                    n = a[i] < b[i] ? 1 : 0;

                    a[i] = n * t + a[i] - b[i];
                }
                for (; !a[0] && a.length > 1;) {
                    a.shift();
                }
            }
            return function (a, b, i, recurring, caseSensitive, s) {
                var ret;
                var k;
                var j;
                var key;
                var f;
                var until;
                var value;
                var c;
                var m;
                var keys;
                var result;
                var total;
                var xhtml;
                var x;
                var n;
                var error;
                var jj;
                var val;
                var e;
                var results;
                var a12 = a.constructor;

                var node = a.s == b.s ? 1 : -1;
                var data = a.d;
                var d = b.d;
                if (!(data && (data[0] && (d && d[0])))) {
                    return new a12(a.s && (b.s && (data ? !d || data[0] != d[0] : d)) ? data && 0 == data[0] || !d ? 0 * node : node / 0 : NaN);
                }
                if (s) {

                    f = 1;

                    k = a.e - b.e;
                } else {

                    s = className;

                    f = l;

                    k = next(a.e / f) - next(b.e / f);
                }
                e = d.length;
                jj = data.length;
                m = new a12(node);

                keys = m.d = [];

                j = 0;
                for (; d[j] == (data[j] || 0); j++) {}
                if (d[j] > (data[j] || 0) && k--, null == i ? (x = i = a12.precision, recurring = a12.rounding) : x = caseSensitive ? i + (a.e - b.e) + 1 : i, x < 0) {
                    keys.push(1);

                    until = true;
                } else {
                    if (x = x / f + 2 | 0, j = 0, 1 == e) {

                        key = 0;
                        d = d[0];
                        x++;
                        for (;
                            (j < jj || key) && x--; j++) {
                            n = key * s + (data[j] || 0);

                            keys[j] = n / d | 0;

                            key = n % d | 0;
                        }

                        until = key || j < jj;
                    } else {

                        key = s / (d[0] + 1) | 0;
                        if (key > 1) {
                            d = format(d, key, s);
                            data = format(data, key, s);
                            e = d.length;
                            jj = data.length;
                        }
                        error = e;
                        result = data.slice(0, e);
                        total = result.length;
                        for (; total < e;) {

                            result[total++] = 0;
                        }
                        results = d.slice();
                        results.unshift(0);
                        val = d[0];
                        if (d[1] >= s / 2) {
                            ++val;
                        }
                        do {

                            key = 0;
                            ret = fn(d, result, e, total);
                            if (ret < 0) {
                                xhtml = result[0];
                                if (e != total) {
                                    xhtml = xhtml * s + (result[1] || 0);
                                }

                                key = xhtml / val | 0;
                                if (key > 1) {
                                    if (key >= s) {

                                        key = s - 1;
                                    }
                                    value = format(d, key, s);
                                    c = value.length;
                                    total = result.length;
                                    if (1 == (ret = fn(value, result, c, total))) {
                                        key--;
                                        callback(value, e < c ? results : d, c, s);
                                    }
                                } else {
                                    if (0 == key) {

                                        ret = key = 1;
                                    }
                                    value = d.slice();
                                }
                                c = value.length;
                                if (c < total) {
                                    value.unshift(0);
                                }
                                callback(result, value, total, s);
                                if (-1 == ret) {
                                    total = result.length;
                                    if ((ret = fn(d, result, e, total)) < 1) {
                                        key++;
                                        callback(result, e < total ? results : d, total, s);
                                    }
                                }
                                total = result.length;
                            } else {
                                if (0 === ret) {
                                    key++;

                                    result = [0];
                                }
                            }

                            keys[j++] = key;
                            if (ret && result[0]) {
                                result[total++] = data[error] || 0;
                            } else {

                                result = [data[error]];

                                total = 1;
                            }
                        } while ((error++ < jj || void 0 !== result[0]) && x--);

                        until = void 0 !== result[0];
                    }
                    if (!keys[0]) {
                        keys.shift();
                    }
                }
                if (1 == f) {
                    m.e = k;

                    selector = until;
                } else {

                    j = 1;
                    key = keys[0];
                    for (; key >= 10; key /= 10) {
                        j++;
                    }

                    m.e = j + k * f - 1;
                    clone(m, caseSensitive ? i + m.e + 1 : i, recurring, until);
                }
                return m;
            };
        }();
        A = getOwnPropertyNames(old);
        A.default = A.Decimal = A;
        y = new A(y);
        x = new A(x);
        if ('function' == typeof define && define.amd) {
            define(function () {
                return A;
            });
        } else {
            if ('undefined' != typeof module && module.exports) {
                module.exports = A;
            } else {
                if (!keys) {

                    keys = 'undefined' != typeof self && (self && self.self == self) ? self : window;
                }
                key = keys.Decimal;

                A.noConflict = function () {
                    return keys.Decimal = key, A;
                };
                keys.Decimal = A;
            }
        }
    }(this);
var CryptoJS = CryptoJS || function (Math, dataAndEvents) {
    var _0x1d7970 = {};
    var res = _0x1d7970.lib = {};

    var ThisClass = function () {};
    var clone = res.Base = {

        "extend": function (protoProps) {
            ThisClass.prototype = this;
            var prototype = new ThisClass;
            return protoProps && prototype.mixIn(protoProps), prototype.hasOwnProperty('init') || (prototype.init = function () {
                prototype.$super.init.apply(this, arguments);
            }), prototype.init.prototype = prototype, prototype.$super = this, prototype;
        },

        "create": function () {
            var r20 = this.extend();
            return r20.init.apply(r20, arguments), r20;
        },

        "init": function () {},

        "mixIn": function (helper) {
            var key;
            for (key in helper) {
                if (helper.hasOwnProperty(key)) {
                    this[key] = helper[key];
                }
            }
            if (helper.hasOwnProperty('toString')) {
                this.toString = helper.toString;
            }
        },

        "clone": function () {
            return this.init.prototype.extend(this);
        }
    };
    var $ = res.WordArray = clone.extend({

        "init": function (props, allBindingsAccessor) {
            props = this.words = props || [];
            this.sigBytes = void 0 != allBindingsAccessor ? allBindingsAccessor : 4 * props.length;
        },

        "toString": function (type) {
            return (type || fx).stringify(this);
        },

        "concat": function (b) {
            var r20 = this.words;
            var p2 = b.words;
            var sum = this.sigBytes;
            if (b = b.sigBytes, this.clamp(), sum % 4) {

                var x = 0;
                for (; x < b; x++) {
                    r20[sum + x >>> 2] |= (p2[x >>> 2] >>> 24 - x % 4 * 8 & 255) << 24 - (sum + x) % 4 * 8;
                }
            } else {
                if (65535 < p2.length) {

                    x = 0;
                    for (; x < b; x += 4) {
                        r20[sum + x >>> 2] = p2[x >>> 2];
                    }
                } else {
                    r20.push.apply(r20, p2);
                }
            }
            return this.sigBytes += b, this;
        },

        "clamp": function () {
            var words = this.words;
            var i = this.sigBytes;
            words[i >>> 2] &= 4294967295 << 32 - i % 4 * 8;
            words.length = Math.ceil(i / 4);
        },

        "clone": function () {
            var _0x2c8a12 = clone.clone.call(this);
            return _0x2c8a12.words = this.words.slice(0), _0x2c8a12;
        },

        "random": function (min) {

            var context = [];

            var value = 0;
            for (; value < min; value += 4) {
                context.push(4294967296 * Math.random() | 0);
            }
            return new($.init)(context, min);
        }
    });
    var stringify = _0x1d7970.enc = {};
    var fx = stringify.Hex = {

        "stringify": function (obj) {
            var temp = obj.words;
            obj = obj.sigBytes;

            var dashes = [];

            var ncount = 0;
            for (; ncount < obj; ncount++) {

                var _0x551775 = temp[ncount >>> 2] >>> 24 - ncount % 4 * 8 & 255;
                dashes.push((_0x551775 >>> 4).toString(16));
                dashes.push((15 & _0x551775).toString(16));
            }
            return dashes.join("");
        },

        "parse": function (execResult) {
            var padLength = execResult.length;

            var words = [];

            var i = 0;
            for (; i < padLength; i += 2) {
                words[i >>> 3] |= parseInt(execResult.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new $.init(words, padLength / 2);
        }
    };
    var _ = stringify.Latin1 = {

        "stringify": function (obj) {
            var temp = obj.words;
            obj = obj.sigBytes;

            var paths = [];

            var ncount = 0;
            for (; ncount < obj; ncount++) {
                paths.push(String.fromCharCode(temp[ncount >>> 2] >>> 24 - ncount % 4 * 8 & 255));
            }
            return paths.join("");
        },

        "parse": function (execResult) {
            var url = execResult.length;

            var context = [];

            var r20 = 0;
            for (; r20 < url; r20++) {
                context[r20 >>> 2] |= (255 & execResult.charCodeAt(r20)) << 24 - r20 % 4 * 8;
            }
            return new($.init)(context, url);
        }
    };
    var e = stringify.Utf8 = {

        "stringify": function (obj) {
            try {
                return decodeURIComponent(escape(_.stringify(obj)));
            } catch (_0x29cf76) {
                throw Error('Malformed UTF-8 data');
            }
        },

        "parse": function (text) {
            return _.parse(unescape(encodeURIComponent(text)));
        }
    };
    var components = res.BufferedBlockAlgorithm = clone.extend({

        "reset": function () {
            this._data = new $.init;

            this._nDataBytes = 0;
        },

        "_append": function (prop) {
            if ('string' == typeof prop) {
                prop = e.parse(prop);
            }
            this._data.concat(prop);
            this._nDataBytes += prop.sigBytes;
        },

        "_process": function (r) {
            var a = this._data;
            var a12 = a.words;
            var x = a.sigBytes;
            var q = this.blockSize;

            var v = x / (4 * q);
            v = r ? Math.ceil(v) : Math.max((0 | v) - this._minBufferSize, 0);
            if (r = v * q, x = Math.min(4 * r, x), r) {

                var $w = 0;
                for (; $w < r; $w += q) {
                    this._doProcessBlock(a12, $w);
                }
                $w = a12.splice(0, r);
                a.sigBytes -= x;
            }
            return new($.init)($w, x);
        },

        "clone": function () {
            var _0x2c8a12 = clone.clone.call(this);
            return _0x2c8a12._data = this._data.clone(), _0x2c8a12;
        },
        "_minBufferSize": 0
    });
    res.Hasher = components.extend({
        "cfg": clone.extend(),

        "init": function (params) {
            this.cfg = this.cfg.extend(params);
            this.reset();
        },

        "reset": function () {
            components.reset.call(this);
            this._doReset();
        },

        "update": function (bytes) {
            return this._append(bytes), this._process(), this;
        },

        "finalize": function (error) {
            return error && this._append(error), this._doFinalize();
        },
        "blockSize": 16,

        "_createHelper": function (event) {
            return function (deepDataAndEvents, dataAndEvents) {
                return (new(event.init)(dataAndEvents)).finalize(deepDataAndEvents);
            };
        },

        "_createHmacHelper": function (hasher) {
            return function (deepDataAndEvents, dataAndEvents) {
                return (new(HMAC.HMAC.init)(hasher, dataAndEvents)).finalize(deepDataAndEvents);
            };
        }
    });
    var HMAC = _0x1d7970.algo = {};
    return _0x1d7970;
}(Math);
! function () {
    var C = CryptoJS;
    var data = C.lib.WordArray;
    C.enc.Base64 = {

        "stringify": function (args) {
            var message = args.words;
            var count = args.sigBytes;
            var _0x34064b = this._map;
            args.clamp();

            args = [];

            var i = 0;
            for (; i < count; i += 3) {

                var _0x274f79 = (message[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (message[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | message[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;

                var HOUR = 0;
                for (; 4 > HOUR && i + 0.75 * HOUR < count; HOUR++) {
                    args.push(_0x34064b.charAt(_0x274f79 >>> 6 * (3 - HOUR) & 63));
                }
            }
            if (message = _0x34064b.charAt(64)) {
                for (; args.length % 4;) {
                    args.push(message);
                }
            }
            return args.join("");
        },

        "parse": function (execResult) {
            var url = execResult.length;
            var classNames = this._map;
            var parameter = classNames.charAt(64);
            if (parameter) {
                if (-1 != (parameter = execResult.indexOf(parameter))) {
                    url = parameter;
                }
            }

            parameter = [];

            var relationOptions = 0;

            var r20 = 0;
            for (; r20 < url; r20++) {
                if (r20 % 4) {

                    var b1 = classNames.indexOf(execResult.charAt(r20 - 1)) << r20 % 4 * 2;

                    var b2 = classNames.indexOf(execResult.charAt(r20)) >>> 6 - r20 % 4 * 2;
                    parameter[relationOptions >>> 2] |= (b1 | b2) << 24 - relationOptions % 4 * 8;
                    relationOptions++;
                }
            }
            return data.create(parameter, relationOptions);
        },
        "_map": 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}(),
function (Math) {

    function md5_gg(x, b, c, d, regex, opt_attributes, t) {
        return ((x = x + (b & c | ~b & d) + regex + t) << opt_attributes | x >>> 32 - opt_attributes) + b;
    }

    function md5_ff(x, b, c, d, regex, opt_attributes, t) {
        return ((x = x + (b & d | c & ~d) + regex + t) << opt_attributes | x >>> 32 - opt_attributes) + b;
    }

    function md5_ii(x, b, c, d, regex, opt_attributes, t) {
        return ((x = x + (b ^ c ^ d) + regex + t) << opt_attributes | x >>> 32 - opt_attributes) + b;
    }

    function md5_hh(x, b, c, d, regex, opt_attributes, t) {
        return ((x = x + (c ^ (b | ~d)) + regex + t) << opt_attributes | x >>> 32 - opt_attributes) + b;
    }
    var options = CryptoJS;
    var option = options.lib;
    var checked = option.WordArray;
    var handler = option.Hasher;
    option = options.algo;

    var map = [];

    var objUid = 0;
    for (; 64 > objUid; objUid++) {

        map[objUid] = 4294967296 * Math.abs(Math.sin(objUid + 1)) | 0;
    }
    option = option.MD5 = handler.extend({

        "_doReset": function () {
            this._hash = new(checked.init)([1732584193, 4023233417, 2562383102, 271733878]);
        },

        "_doProcessBlock": function (options, type) {

            var d = 0;
            for (; 16 > d; d++) {
                var key = type + d;
                var option = options[key];

                options[key] = 16711935 & (option << 8 | option >>> 24) | 4278255360 & (option << 24 | option >>> 8);
            }
            d = this._hash.words;
            key = options[type + 0];
            option = options[type + 1];
            var r20 = options[type + 2];
            var rreturn = options[type + 3];
            var rclass = options[type + 4];
            var cx = options[type + 5];
            var rxhtmlTag = options[type + 6];
            var START_TAG_REGEXP = options[type + 7];
            var listEl = options[type + 8];
            var nbspRegExp = options[type + 9];
            var dir = options[type + 10];
            var trimEndRegexp = options[type + 11];
            var oldDir = options[type + 12];
            var END_TAG_REGEXP = options[type + 13];
            var AMP = options[type + 14];
            var trimRight = options[type + 15];
            var f = d[0];
            var a = d[1];
            var b = d[2];
            var c = d[3];
            f = md5_gg(f, a, b, c, key, 7, map[0]);
            c = md5_gg(c, f, a, b, option, 12, map[1]);
            b = md5_gg(b, c, f, a, r20, 17, map[2]);
            a = md5_gg(a, b, c, f, rreturn, 22, map[3]);
            f = md5_gg(f, a, b, c, rclass, 7, map[4]);
            c = md5_gg(c, f, a, b, cx, 12, map[5]);
            b = md5_gg(b, c, f, a, rxhtmlTag, 17, map[6]);
            a = md5_gg(a, b, c, f, START_TAG_REGEXP, 22, map[7]);
            f = md5_gg(f, a, b, c, listEl, 7, map[8]);
            c = md5_gg(c, f, a, b, nbspRegExp, 12, map[9]);
            b = md5_gg(b, c, f, a, dir, 17, map[10]);
            a = md5_gg(a, b, c, f, trimEndRegexp, 22, map[11]);
            f = md5_gg(f, a, b, c, oldDir, 7, map[12]);
            c = md5_gg(c, f, a, b, END_TAG_REGEXP, 12, map[13]);
            b = md5_gg(b, c, f, a, AMP, 17, map[14]);
            a = md5_gg(a, b, c, f, trimRight, 22, map[15]);
            f = md5_ff(f, a, b, c, option, 5, map[16]);
            c = md5_ff(c, f, a, b, rxhtmlTag, 9, map[17]);
            b = md5_ff(b, c, f, a, trimEndRegexp, 14, map[18]);
            a = md5_ff(a, b, c, f, key, 20, map[19]);
            f = md5_ff(f, a, b, c, cx, 5, map[20]);
            c = md5_ff(c, f, a, b, dir, 9, map[21]);
            b = md5_ff(b, c, f, a, trimRight, 14, map[22]);
            a = md5_ff(a, b, c, f, rclass, 20, map[23]);
            f = md5_ff(f, a, b, c, nbspRegExp, 5, map[24]);
            c = md5_ff(c, f, a, b, AMP, 9, map[25]);
            b = md5_ff(b, c, f, a, rreturn, 14, map[26]);
            a = md5_ff(a, b, c, f, listEl, 20, map[27]);
            f = md5_ff(f, a, b, c, END_TAG_REGEXP, 5, map[28]);
            c = md5_ff(c, f, a, b, r20, 9, map[29]);
            b = md5_ff(b, c, f, a, START_TAG_REGEXP, 14, map[30]);
            a = md5_ff(a, b, c, f, oldDir, 20, map[31]);
            f = md5_ii(f, a, b, c, cx, 4, map[32]);
            c = md5_ii(c, f, a, b, listEl, 11, map[33]);
            b = md5_ii(b, c, f, a, trimEndRegexp, 16, map[34]);
            a = md5_ii(a, b, c, f, AMP, 23, map[35]);
            f = md5_ii(f, a, b, c, option, 4, map[36]);
            c = md5_ii(c, f, a, b, rclass, 11, map[37]);
            b = md5_ii(b, c, f, a, START_TAG_REGEXP, 16, map[38]);
            a = md5_ii(a, b, c, f, dir, 23, map[39]);
            f = md5_ii(f, a, b, c, END_TAG_REGEXP, 4, map[40]);
            c = md5_ii(c, f, a, b, key, 11, map[41]);
            b = md5_ii(b, c, f, a, rreturn, 16, map[42]);
            a = md5_ii(a, b, c, f, rxhtmlTag, 23, map[43]);
            f = md5_ii(f, a, b, c, nbspRegExp, 4, map[44]);
            c = md5_ii(c, f, a, b, oldDir, 11, map[45]);
            b = md5_ii(b, c, f, a, trimRight, 16, map[46]);
            a = md5_ii(a, b, c, f, r20, 23, map[47]);
            f = md5_hh(f, a, b, c, key, 6, map[48]);
            c = md5_hh(c, f, a, b, START_TAG_REGEXP, 10, map[49]);
            b = md5_hh(b, c, f, a, AMP, 15, map[50]);
            a = md5_hh(a, b, c, f, cx, 21, map[51]);
            f = md5_hh(f, a, b, c, oldDir, 6, map[52]);
            c = md5_hh(c, f, a, b, rreturn, 10, map[53]);
            b = md5_hh(b, c, f, a, dir, 15, map[54]);
            a = md5_hh(a, b, c, f, option, 21, map[55]);
            f = md5_hh(f, a, b, c, listEl, 6, map[56]);
            c = md5_hh(c, f, a, b, trimRight, 10, map[57]);
            b = md5_hh(b, c, f, a, rxhtmlTag, 15, map[58]);
            a = md5_hh(a, b, c, f, END_TAG_REGEXP, 21, map[59]);
            f = md5_hh(f, a, b, c, rclass, 6, map[60]);
            c = md5_hh(c, f, a, b, trimEndRegexp, 10, map[61]);
            b = md5_hh(b, c, f, a, r20, 15, map[62]);
            a = md5_hh(a, b, c, f, nbspRegExp, 21, map[63]);

            d[0] = d[0] + f | 0;

            d[1] = d[1] + a | 0;

            d[2] = d[2] + b | 0;

            d[3] = d[3] + c | 0;
        },

        "_doFinalize": function () {
            var options = this._data;
            var copy = options.words;

            var n = 8 * this._nDataBytes;

            var prop = 8 * options.sigBytes;
            copy[prop >>> 5] |= 128 << 24 - prop % 32;
            var w = Math.floor(n / 4294967296);

            copy[15 + (prop + 64 >>> 9 << 4)] = 16711935 & (w << 8 | w >>> 24) | 4278255360 & (w << 24 | w >>> 8);

            copy[14 + (prop + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8);

            options.sigBytes = 4 * (copy.length + 1);
            this._process();
            options = this._hash;
            copy = options.words;

            n = 0;
            for (; 4 > n; n++) {
                prop = copy[n];

                copy[n] = 16711935 & (prop << 8 | prop >>> 24) | 4278255360 & (prop << 24 | prop >>> 8);
            }
            return options;
        },

        "clone": function () {
            var doc = handler.clone.call(this);
            return doc._hash = this._hash.clone(), doc;
        }
    });
    options.MD5 = handler._createHelper(option);
    options.HmacMD5 = handler._createHmacHelper(option);
}(Math),
function () {
    var ast = CryptoJS;
    var args = ast.lib;
    var pageY = args.Base;
    var pageX = args.WordArray;
    args = ast.algo;
    var collection = args.EvpKDF = pageY.extend({
        "cfg": pageY.extend({
            "keySize": 4,
            "hasher": args.MD5,
            "iterations": 1
        }),

        "init": function (params) {
            this.cfg = this.cfg.extend(params);
        },

        "compute": function (par, i) {
            var f = this.cfg;
            var params = f.hasher.create();
            var extensions = pageX.create();
            var extent = extensions.words;
            var val = f.keySize;
            f = f.iterations;
            for (; extent.length < val;) {
                if (c) {
                    params.update(c);
                }
                var c = params.update(par).finalize(i);
                params.reset();

                var indexf = 1;
                for (; indexf < f; indexf++) {
                    c = params.finalize(c);
                    params.reset();
                }
                extensions.concat(c);
            }
            return extensions.sigBytes = 4 * val, extensions;
        }
    });

    ast.EvpKDF = function (deepDataAndEvents, opt_obj2, resp) {
        return collection.create(resp).compute(deepDataAndEvents, opt_obj2);
    };
}(), CryptoJS.lib.Cipher || function (dataAndEvents) {
        var sourcesArray = CryptoJS;
        var listener = sourcesArray.lib;
        var fn = listener.Base;
        var args = listener.WordArray;
        var scope = listener.BufferedBlockAlgorithm;
        var r20 = sourcesArray.enc.Base64;
        var _0x4dc9b1 = sourcesArray.algo.EvpKDF;
        var _0x5aba93 = listener.Cipher = scope.extend({
            "cfg": fn.extend(),

            "createEncryptor": function (cipher, iv) {
                return this.create(this._ENC_XFORM_MODE, cipher, iv);
            },

            "createDecryptor": function (cipher, iv) {
                return this.create(this._DEC_XFORM_MODE, cipher, iv);
            },

            "init": function (allBindingsAccessor, depMaps, opt_handler) {
                this.cfg = this.cfg.extend(opt_handler);
                this._xformMode = allBindingsAccessor;
                this._key = depMaps;
                this.reset();
            },

            "reset": function () {
                scope.reset.call(this);
                this._doReset();
            },

            "process": function (last) {
                return this._append(last), this._process();
            },

            "finalize": function (error) {
                return error && this._append(error), this._doFinalize();
            },
            "keySize": 4,
            "ivSize": 4,
            "_ENC_XFORM_MODE": 1,
            "_DEC_XFORM_MODE": 2,

            "_createHelper": function (event) {
                return {

                    "encrypt": function (string, seed, aKey) {
                        return ('string' == typeof seed ? _0x1187e9 : map).encrypt(event, string, seed, aKey);
                    },

                    "decrypt": function (string, seed, aValue) {
                        return ('string' == typeof seed ? _0x1187e9 : map).decrypt(event, string, seed, aValue);
                    }
                };
            }
        });
        listener.StreamCipher = _0x5aba93.extend({

            "_doFinalize": function () {
                return this._process(true);
            },
            "blockSize": 1
        });
        var type = sourcesArray.mode = {};

        var clone = function (dataAndEvents, deepDataAndEvents, events) {
            var map = this._iv;
            if (map) {
                this._iv = void 0;
            } else {
                map = this._prevBlock;
            }

            var objUid = 0;
            for (; objUid < events; objUid++) {
                dataAndEvents[deepDataAndEvents + objUid] ^= map[objUid];
            }
        };
        var padding = (listener.BlockCipherMode = fn.extend({

            "createEncryptor": function (cipher, iv) {
                return this.Encryptor.create(cipher, iv);
            },

            "createDecryptor": function (cipher, iv) {
                return this.Decryptor.create(cipher, iv);
            },

            "init": function (allBindingsAccessor, depMaps) {
                this._cipher = allBindingsAccessor;
                this._iv = depMaps;
            }
        })).extend();
        padding.Encryptor = padding.extend({

            "processBlock": function (event, statements) {
                var events = this._cipher;
                var eventFns = events.blockSize;
                clone.call(this, event, statements, eventFns);
                events.encryptBlock(event, statements);
                this._prevBlock = event.slice(statements, statements + eventFns);
            }
        });
        padding.Decryptor = padding.extend({

            "processBlock": function (event, next) {
                var events = this._cipher;
                var eventFns = events.blockSize;
                var timeout = event.slice(next, next + eventFns);
                events.decryptBlock(event, next);
                clone.call(this, event, next, eventFns);
                this._prevBlock = timeout;
            }
        });
        type = type.CBC = padding;
        padding = (sourcesArray.pad = {}).Pkcs7 = {

            "pad": function (n, size) {

                var length = 4 * size;

                length = length - n.sigBytes % length;

                var r20 = length << 24 | length << 16 | length << 8 | length;

                var message = [];

                var times = 0;
                for (; times < length; times += 4) {
                    message.push(r20);
                }
                length = args.create(message, length);
                n.concat(length);
            },

            "unpad": function (message) {
                message.sigBytes -= 255 & message.words[message.sigBytes - 1 >>> 2];
            }
        };
        listener.BlockCipher = _0x5aba93.extend({
            "cfg": _0x5aba93.cfg.extend({
                "mode": type,
                "padding": padding
            }),

            "reset": function () {
                _0x5aba93.reset.call(this);
                var args = this.cfg;
                var parent = args.iv;
                args = args.mode;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                    var arg = args.createEncryptor
                } else {
                    arg = args.createDecryptor;

                    this._minBufferSize = 1;
                }
                this._mode = arg.call(args, this, parent && parent.words);
            },

            "_doProcessBlock": function (M, offset) {
                this._mode.processBlock(M, offset);
            },

            "_doFinalize": function () {
                var collection = this.cfg.padding;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                    collection.pad(this._data, this.blockSize);
                    var resp = this._process(true);
                } else {
                    resp = this._process(true);
                    collection.unpad(resp);
                }
                return resp;
            },
            "blockSize": 4
        });
        var SELF = listener.CipherParams = fn.extend({

            "init": function (opt_handler) {
                this.mixIn(opt_handler);
            },

            "toString": function (idt) {
                return (idt || this.formatter).stringify(this);
            }
        });
        type = (sourcesArray.format = {}).OpenSSL = {

            "stringify": function (c) {
                var name = c.ciphertext;
                return c = c.salt, (c ? args.create([1398893684, 1701076831]).concat(c).concat(name) : name).toString(r20);
            },

            "parse": function (parts) {
                parts = r20.parse(parts);
                var spaceAfter = parts.words;
                if (1398893684 == spaceAfter[0] && 1701076831 == spaceAfter[1]) {
                    var salt = args.create(spaceAfter.slice(2, 4));
                    spaceAfter.splice(0, 4);
                    parts.sigBytes -= 16;
                }
                return SELF.create({
                    "ciphertext": parts,
                    "salt": salt
                });
            }
        };
        var map = listener.SerializableCipher = fn.extend({
            "cfg": fn.extend({
                "format": type
            }),

            "encrypt": function (cipher, callback, key, seed) {
                seed = this.cfg.extend(seed);
                var parts = cipher.createEncryptor(key, seed);
                return callback = parts.finalize(callback), parts = parts.cfg, SELF.create({
                    "ciphertext": callback,
                    "key": key,
                    "iv": parts.iv,
                    "algorithm": cipher,
                    "mode": parts.mode,
                    "padding": parts.padding,
                    "blockSize": cipher.blockSize,
                    "formatter": seed.format
                });
            },

            "decrypt": function (options, callback, string, seed) {
                return seed = this.cfg.extend(seed), callback = this._parse(callback, seed.format), options.createDecryptor(string, seed).finalize(callback.ciphertext);
            },

            "_parse": function (s, ctx) {
                return 'string' == typeof s ? ctx.parse(s, this) : s;
            }
        });
        sourcesArray = (sourcesArray.kdf = {}).OpenSSL = {

            "execute": function (model, keySize, ivSize, options) {
                return options || (options = args.random(8)), model = _0x4dc9b1.create({
                    "keySize": keySize + ivSize
                }).compute(model, options), ivSize = args.create(model.words.slice(keySize), 4 * ivSize), model.sigBytes = 4 * keySize, SELF.create({
                    "key": model,
                    "iv": ivSize,
                    "salt": options
                });
            }
        };
        var _0x1187e9 = listener.PasswordBasedCipher = map.extend({
            "cfg": map.cfg.extend({
                "kdf": sourcesArray
            }),

            "encrypt": function (string, iv, user, params) {
                return params = this.cfg.extend(params), user = params.kdf.execute(user, string.keySize, string.ivSize), params.iv = user.iv, string = map.encrypt.call(this, string, iv, user.key, params), string.mixIn(user), string;
            },

            "decrypt": function (seed, callback, user, params) {
                return params = this.cfg.extend(params), callback = this._parse(callback, params.format), user = params.kdf.execute(user, seed.keySize, seed.ivSize, callback.salt), params.iv = user.iv, map.decrypt.call(this, seed, callback, user.key, params);
            }
        });
    }(),
    function () {
        var branchDataJSON = CryptoJS;
        var collection = branchDataJSON.lib.BlockCipher;
        var condition = branchDataJSON.algo;

        var groups = [];

        var _cache = [];

        var returnValue = [];

        var libs = [];

        var currentRecord = [];

        var memory = [];

        var originalEvent = [];

        var key_types = [];

        var validObj = [];

        var flags = [];

        var cache = [];

        var docUid = 0;
        for (; 256 > docUid; docUid++) {

            cache[docUid] = 128 > docUid ? docUid << 1 : docUid << 1 ^ 283;
        }

        var data = 0;

        var selector = 0;

        docUid = 0;
        for (; 256 > docUid; docUid++) {

            var key = selector ^ selector << 1 ^ selector << 2 ^ selector << 3 ^ selector << 4;

            key = key >>> 8 ^ 255 & key ^ 99;

            groups[data] = key;

            _cache[key] = data;
            var cacheKey = cache[data];
            var template = cache[cacheKey];
            var parsed = cache[template];

            var value = 257 * cache[key] ^ 16843008 * key;

            returnValue[data] = value << 24 | value >>> 8;

            libs[data] = value << 16 | value >>> 16;

            currentRecord[data] = value << 8 | value >>> 24;

            memory[data] = value;

            value = 16843009 * parsed ^ 65537 * template ^ 257 * cacheKey ^ 16843008 * data;

            originalEvent[key] = value << 24 | value >>> 8;

            key_types[key] = value << 16 | value >>> 16;

            validObj[key] = value << 8 | value >>> 24;

            flags[key] = value;
            if (data) {

                data = cacheKey ^ cache[cache[cache[parsed ^ cacheKey]]];
                selector ^= cache[cache[selector]];
            } else {

                data = selector = 1;
            }
        }

        var _0x14b366 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        condition = condition.AES = collection.extend({

            "_doReset": function () {
                var l = this._key;
                var obj = l.words;

                var b = l.sigBytes / 4;

                l = 4 * ((this._nRounds = b + 6) + 1);

                var args = this._keySchedule = [];

                var a = 0;
                for (; a < l; a++) {
                    if (a < b) {
                        args[a] = obj[a];
                    } else {
                        var value = args[a - 1];
                        if (a % b) {
                            if (6 < b) {
                                if (4 == a % b) {

                                    value = groups[value >>> 24] << 24 | groups[value >>> 16 & 255] << 16 | groups[value >>> 8 & 255] << 8 | groups[255 & value];
                                }
                            }
                        } else {

                            value = value << 8 | value >>> 24;

                            value = groups[value >>> 24] << 24 | groups[value >>> 16 & 255] << 16 | groups[value >>> 8 & 255] << 8 | groups[255 & value];
                            value ^= _0x14b366[a / b | 0] << 24;
                        }

                        args[a] = args[a - b] ^ value;
                    }
                }

                obj = this._invKeySchedule = [];

                b = 0;
                for (; b < l; b++) {

                    a = l - b;
                    value = b % 4 ? args[a] : args[a - 4];
                    obj[b] = 4 > b || 4 >= a ? value : originalEvent[groups[value >>> 24]] ^ key_types[groups[value >>> 16 & 255]] ^ validObj[groups[value >>> 8 & 255]] ^ flags[groups[255 & value]];
                }
            },

            "encryptBlock": function (M, aKey) {
                this._doCryptBlock(M, aKey, this._keySchedule, returnValue, libs, currentRecord, memory, groups);
            },

            "decryptBlock": function (parts, M) {
                var part = parts[M + 1];
                parts[M + 1] = parts[M + 3];
                parts[M + 3] = part;
                this._doCryptBlock(parts, M, this._invKeySchedule, originalEvent, key_types, validObj, flags, _cache);
                part = parts[M + 1];
                parts[M + 1] = parts[M + 3];
                parts[M + 3] = part;
            },

            "_doCryptBlock": function (M, offset, keySchedule, b, a, subKeys, SUB_MIX_1, key) {
                var padLength = this._nRounds;

                var doneResults = M[offset] ^ keySchedule[0];

                var j = M[offset + 1] ^ keySchedule[1];

                var l = M[offset + 2] ^ keySchedule[2];

                var t2 = M[offset + 3] ^ keySchedule[3];

                var ksRow = 4;

                var i = 1;
                for (; i < padLength; i++) {

                    var data = b[doneResults >>> 24] ^ a[j >>> 16 & 255] ^ subKeys[l >>> 8 & 255] ^ SUB_MIX_1[255 & t2] ^ keySchedule[ksRow++];

                    var t = b[j >>> 24] ^ a[l >>> 16 & 255] ^ subKeys[t2 >>> 8 & 255] ^ SUB_MIX_1[255 & doneResults] ^ keySchedule[ksRow++];

                    var c = b[l >>> 24] ^ a[t2 >>> 16 & 255] ^ subKeys[doneResults >>> 8 & 255] ^ SUB_MIX_1[255 & j] ^ keySchedule[ksRow++];

                    t2 = b[t2 >>> 24] ^ a[doneResults >>> 16 & 255] ^ subKeys[j >>> 8 & 255] ^ SUB_MIX_1[255 & l] ^ keySchedule[ksRow++];

                    doneResults = data;

                    j = t;

                    l = c;
                }

                data = (key[doneResults >>> 24] << 24 | key[j >>> 16 & 255] << 16 | key[l >>> 8 & 255] << 8 | key[255 & t2]) ^ keySchedule[ksRow++];

                t = (key[j >>> 24] << 24 | key[l >>> 16 & 255] << 16 | key[t2 >>> 8 & 255] << 8 | key[255 & doneResults]) ^ keySchedule[ksRow++];

                c = (key[l >>> 24] << 24 | key[t2 >>> 16 & 255] << 16 | key[doneResults >>> 8 & 255] << 8 | key[255 & j]) ^ keySchedule[ksRow++];

                t2 = (key[t2 >>> 24] << 24 | key[doneResults >>> 16 & 255] << 16 | key[j >>> 8 & 255] << 8 | key[255 & l]) ^ keySchedule[ksRow++];

                M[offset] = data;

                M[offset + 1] = t;

                M[offset + 2] = c;

                M[offset + 3] = t2;
            },
            "keySize": 8
        });
        branchDataJSON.AES = collection._createHelper(condition);
    }(), String.prototype.includes || (String.prototype.includes = function (oldItem) {

        var _0x469648 = false;
        return -1 !== this.indexOf(oldItem) && (_0x469648 = true), _0x469648;
    }), Luts = {
        "version": "1.2.113",
        "release": true,
        "cordova": false,
        "fullscreen": false,
        "quality": 1,
        "State": {},
        "Object": {},
        "Util": {},
        "Events": {
            "onAfterResize": new Phaser.Signal
        },
        "Config": {},
        "currentState": {},
        "Credits": [{
            "type": 'general',
            "author": "Lutz SchÃ¶nfelder"
        }],
        "gamePaused": false,
        "track": false,
        "trackLog": false,
        "mtxEnabled": true,
        "Name": 'Idle dice',
        "Id": 'idle-dice',
        "isActive": true,
        "GAME_WIDTH": 960,
        "GAME_HEIGHT": 540,
        "scale": 1,
        "res": 2,
        "turnPrompt": false,
        "DEBUG": false,
        "TEMP_STORE": false,
        "GAME_SPEED": 100,
        "isLocal": window.location.href.toString().includes('localhost'),
        "isKong": window.location.href.toString().includes('kongregate'),
        "isCG": window.location.href.toString().includes('crazygames'),
        "gameAnalytics": {
            "id": "",
            "secret": ""
        },
        "playfab": {
            "id": '6043'
        },
        "dbServer": 'https://lutsgames.herokuapp.com/db'
    }, init = function () {
        Luts.Store.init(Luts.Name, Luts.TEMP_STORE);
        Luts.Upgrades.init();
        Luts.Shop.init();
        Luts.quality = new(Luts.Setting)("quality", 1, 'Quality');
        this.webgl = new(Luts.Setting)('canvas', false, 'Use WebGL (Requires Restart)', 'Switch this if you have performance issues');
        Luts.numberFormat = new(Luts.Setting)('numberformat', false, 'Use Engineering Notation');
        var element = new(Phaser.Game)(Luts.GAME_WIDTH, Luts.GAME_HEIGHT, this.webgl.value ? Phaser.WEBGL_MULTI : Phaser.CANVAS, null, null, false, true);
        element.state.add('Boot', Luts.State.Boot);
        element.state.add('Preloader', Luts.State.Preloader);
        element.state.add('Menu', Luts.State.Menu);
        element.state.add("Credits", Luts.State.Credits);
        element.state.add('Settings', Luts.State.Settings);
        element.state.add('LevelSelection', Luts.State.LevelSelection);
        element.state.add('Game', Luts.State.Game);
        Luts.Connect.CrazyGames();
        Luts.Ad.init();
        Luts.Ad.requestAd();
        Luts.Connect.Kongregate(function () {
            Luts.Connect.Store(function () {
                if (Luts.Util.isCMG() || Luts.isLocal) {
                    element.state.start('Boot');
                } else {
                    element.state.start('Boot');
                }
            } ['bind'](this));
        } ['bind'](this));
    }, 'serviceWorker' in navigator && (Luts.release && Luts.isLocal), document.addEventListener("deviceready", onDeviceReady, false), Phaser.Image.prototype.preUpdate = function () {
        return !!this.worldVisible && (!(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore());
    }, Phaser.Text.prototype.preUpdate = function () {
        return !!this.worldVisible && (!!(this.preUpdatePhysics() && (this.preUpdateLifeSpan() && this.preUpdateInWorld())) && this.preUpdateCore());
    }, PIXI.Sprite.prototype._renderCanvas = function (options, key) {
        if (!this.worldVisible) {
            return false;
        }
        if (!(!this.visible || (0 === this.alpha || (!this.renderable || (this.texture.crop.width <= 0 || this.texture.crop.height <= 0))))) {
            var data = this.worldTransform;
            if (key && (data = key), this.blendMode !== options.currentBlendMode && (options.currentBlendMode = this.blendMode, options.context.globalCompositeOperation = PIXI.blendModesCanvas[options.currentBlendMode]), this._mask && options.maskManager.pushMask(this._mask, options), !this.texture.valid) {

                var i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i]._renderCanvas(options);
                }
                return void(this._mask && options.maskManager.popMask(options));
            }

            var d = this.texture.baseTexture.resolution / options.resolution;
            options.context.globalAlpha = this.worldAlpha;
            if (options.smoothProperty) {
                if (options.scaleMode !== this.texture.baseTexture.scaleMode) {
                    options.scaleMode = this.texture.baseTexture.scaleMode;

                    options.context[options.smoothProperty] = options.scaleMode === PIXI.scaleModes.LINEAR;
                }
            }

            var t = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;

            var r20 = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;
            var closeTag = data.tx * options.resolution + options.shakeX;
            var fromIndex = data.ty * options.resolution + options.shakeY;
            var value = this.texture.crop.width;
            var currentValue = this.texture.crop.height;
            if (this.texture.rotated) {
                var v = data.a;
                var p = data.b;
                var a = data.c;
                var x = data.d;
                var ret = value;
                closeTag = data.c * currentValue + closeTag;
                fromIndex = data.d * currentValue + fromIndex;

                data.a = 6.123233995736766E-17 * v - a;

                data.b = 6.123233995736766E-17 * p - x;
                data.c = v + 6.123233995736766E-17 * a;
                data.d = p + 6.123233995736766E-17 * x;
                value = currentValue;
                currentValue = ret;
            }
            if (options.roundPixels ? (options.context.setTransform(data.a, data.b, data.c, data.d, 0 | closeTag, 0 | fromIndex), t |= 0, r20 |= 0) : options.context.setTransform(data.a, data.b, data.c, data.d, closeTag, fromIndex), t /= d, r20 /= d, 16777215 !== this.tint) {
                if (this.texture.requiresReTint || this.cachedTint !== this.tint) {
                    this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);
                    this.cachedTint = this.tint;

                    this.texture.requiresReTint = false;
                }
                options.context.drawImage(this.tintedTexture, 0, 0, value, currentValue, t, r20, value / d, currentValue / d);
            } else {
                var at_n = this.texture.crop.x;
                var typename = this.texture.crop.y;
                value = Math.floor(value);
                currentValue = Math.floor(currentValue);
                options.context.drawImage(this.texture.baseTexture.source, at_n, typename, value, currentValue, t, r20, value / d, currentValue / d);
            }

            i = 0;
            for (; i < this.children.length; i++) {
                this.children[i]._renderCanvas(options);
            }
            if (this._mask) {
                options.maskManager.popMask(options);
            }
        }
    }, PIXI.Sprite.prototype._renderWebGL = function (deepDataAndEvents, textAlt) {
        if (this.worldVisible && (this.visible && (!(this.alpha <= 0) && this.renderable))) {
            var text = this.worldTransform;
            if (textAlt && (text = textAlt), this._mask || this._filters) {
                var inserts = deepDataAndEvents.spriteBatch;
                if (this._filters) {
                    inserts.flush();
                    deepDataAndEvents.filterManager.pushFilter(this._filterBlock);
                }
                if (this._mask) {
                    inserts.stop();
                    deepDataAndEvents.maskManager.pushMask(this.mask, deepDataAndEvents);
                    inserts.start();
                }
                inserts.render(this);

                var i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i]._renderWebGL(deepDataAndEvents);
                }
                inserts.stop();
                if (this._mask) {
                    deepDataAndEvents.maskManager.popMask(this._mask, deepDataAndEvents);
                }
                if (this._filters) {
                    deepDataAndEvents.filterManager.popFilter();
                }
                inserts.start();
            } else {
                deepDataAndEvents.spriteBatch.render(this);

                i = 0;
                for (; i < this.children.length; i++) {
                    this.children[i]._renderWebGL(deepDataAndEvents, text);
                }
            }
        }
    }, Luts.State.BaseState = function (dataAndEvents) {
        this.game = dataAndEvents;
        Luts.currentState = this;

        this.lastScale = 1;
    }, Luts.State.BaseState.constructor = Luts.State.BaseState, Luts.State.BaseState.prototype = Object.create(Phaser.State.prototype), Luts.State.BaseState.prototype.init = function () {}, Luts.State.BaseState.prototype.preload = function () {}, Luts.State.BaseState.prototype.create = function () {}, Luts.State.BaseState.prototype.resize = function (dataAndEvents, deepDataAndEvents) {
        var r20 = Math.min(this.game.height / Luts.GAME_HEIGHT, this.game.width / Luts.GAME_WIDTH);
        this.lastScale = r20;

        var unlock = 0;
        for (; unlock < this.world.children.length; unlock++) {
            var cache = this.world.children[unlock];
            this.setPosition(cache, r20);
        }
        if (!this.game.device.desktop) {
            if (Luts.turnPrompt) {
                if (this.game.width > this.game.height && Luts.GAME_WIDTH < Luts.GAME_HEIGHT || this.game.width < this.game.height && Luts.GAME_WIDTH > Luts.GAME_HEIGHT) {

                    document.getElementById('turn').style.display = "block";
                } else {
                    document.getElementById('turn').style.display = 'none';
                }
            }
        }
        Luts.Events.onAfterResize.dispatch(r20);
    }, Luts.State.BaseState.prototype.setPosition = function (data, n) {
        if (data.responsivePosition && (data.cameraOffset.x = this.game.width * data.responsivePosition.x, data.cameraOffset.y = this.game.height * data.responsivePosition.y, data.scale.set(n * data.scl * Luts.scale / this.world.scale.x), data.options && (data.options.scaleWithGame && data.scale.set(data.scl * Luts.scale *
                (this.game.width / Luts.GAME_WIDTH), data.scl * Luts.scale * (this.game.height / Luts.GAME_HEIGHT)), data.options.isBackground))) {

            var currentValue = data.scl * Luts.scale * (this.game.width / Luts.GAME_WIDTH);

            var suggestedValue = data.scl * Luts.scale * (this.game.height / Luts.GAME_HEIGHT);
            data.scale.set(Math.max(currentValue, suggestedValue));
        }

        var value_idx = 0;
        for (; value_idx < data.children.length; value_idx++) {
            this.setPosition(data.children[value_idx], n);
        }
    }, Luts.State.BaseState.prototype.addResponsive = function (moveX, moveY, partials, success) {
        var result = this.game.add.image(this.game.width * moveX, this.game.height * moveY, partials, success);
        return result.responsivePosition = {
            "x": moveX,
            "y": moveY
        }, result.scl = 1, result.scale.set(this.game.width / Luts.GAME_WIDTH), result.fixedToCamera = true, result;
    }, Luts.State.BaseState.prototype.setResponsive = function (a, m13) {
        a.responsivePosition = {
            "x": a.x / Luts.GAME_WIDTH,
            "y": a.y / Luts.GAME_HEIGHT
        };
        if (a.scale) {
            a.scl = a.scale.x;
        } else {

            a.scl = 1;
        }
        a.rWidth = a.width;
        a.rHeight = a.height;
        a.options = m13;

        a.fixedToCamera = true;
        this.resize();
    }, Luts.State.Boot = function (dataAndEvents) {}, Luts.State.Boot.constructor = Luts.State.Boot, Luts.State.Boot.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Boot.prototype.init = function () {

        this.game.input.maxPointers = 1;

        this.game.stage.disableVisibilityChange = true;
        if (this.game.device.desktop && !Luts.release || Luts.isKong) {
            this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
        } else {
            this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;
            this.scale.setResizeCallback(this.resizeCallback, this);
            if (Luts.release) {
                if (Luts.fullscreen) {
                    document.documentElement.onclick = function () {
                        this.game.scale.startFullScreen();
                    } ['bind'](this);
                }
            }
        }

        this.game.time.advancedTiming = true;
        Luts.Events.onMouseWheel = new(Phaser.Signal);

        this.game.input.mouse.mouseWheelCallback = function (dataAndEvents) {
            return Luts.Events.onMouseWheel.dispatch(dataAndEvents.deltaY), false;
        };

        document.onmousewheel = function () {
            return false;
        };
        document.documentElement.onclick = function () {
            window.focus();
        } ["bind"](this);
        Luts.Events.onActive = new Phaser.Signal;
        Luts.Events.onInactive = new Phaser.Signal;
    }, Luts.State.Boot.prototype.resizeCallback = function (a, dataAndEvents, deepDataAndEvents) {
        if (deepDataAndEvents || (a.width != window.innerWidth || a.height != window.innerHeight)) {

            var y = window.innerWidth / Luts.GAME_WIDTH;

            var x = window.innerHeight / Luts.GAME_HEIGHT;

            var currentValue = 2 / Math.max(y, x);

            var diffCosAngle = Math.min(currentValue, this.game.device.desktop ? 1 : window.devicePixelRatio) * (Luts.quality.value / 2 + 0.5);
            a.setGameSize(Luts.GAME_WIDTH * y * diffCosAngle, Luts.GAME_HEIGHT * x * diffCosAngle);
            a.setUserScale(1 / diffCosAngle);
            this.game.state.resize(y, x);
        }
    }, Luts.State.Boot.prototype.preload = function () {
        this.game.load.json('preload', './data/preload.json');
        this.game.load.json('config', './data/config.json');
    }, Luts.State.Boot.prototype.create = function () {
        this.game.state.start('Preloader');
        Luts.Config = this.game.cache.getJSON('config');
    }, Luts.State.Preloader = function (dataAndEvents) {}, Luts.State.Preloader.constructor = Luts.State.Preloader, Luts.State.Preloader.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Preloader.prototype.init = function () {

        this.images = [];
        this.loadingText = new(Luts.Object.Text)(this, this.game.width / 2, this.game.height / 2, 'text', 'Loading..', 50);
        this.loadingText.anchor.set(0.5);
        this.game.add.tween(this.loadingText.scale).to({
            "x": 0.45,
            "y": 0.45
        }, 1E3, Phaser.Easing.Sinusoidal.InOut, true, 0, -1, true);
        this.percentText = new(Luts.Object.Text)(this, this.loadingText.x, this.loadingText.y + 50, 'regular', "0%", 40);
        this.percentText.anchor.set(0.5);
        this.currentText = new(Luts.Object.Text)(this, this.loadingText.x, this.loadingText.y + 80, 'text', "", 15);
        this.currentText.anchor.set(0.5);
        this.versionText = new(Luts.Object.Text)(this, 0, 0, 'text', 'Version: ' + Luts.version, 15);
        this.resize();
        this.game.load.onFileComplete.add(function (dataAndEvents, front, deepDataAndEvents, tag, file1) {

            this.percentText.text = dataAndEvents + "%";

            this.currentText.text = front + " (" + tag + "/" + file1 + ")";
        }, this);
    }, Luts.State.Preloader.prototype.preload = function () {
        var result;
        var i;
        var cache = this.game.cache.getJSON("preload");
        if (cache.image) {
            result = cache.image;

            i = 0;
            for (; i < result.length; i++) {
                this.game.load.image(result[i].name, 'assets/img/' + result[i].url);
                this.images.push(result[i].name);
            }
        }
        if (cache.atlas) {
            result = cache.atlas;

            i = 0;
            for (; i < result.length; i++) {
                this.game.load.atlas(result[i].name, 'assets/img/' + result[i].urlImg, 'assets/img/' + result[i].urlData);
                this.images.push(result[i].name);
            }
        }
        if (cache.json) {
            result = cache.json;

            i = 0;
            for (; i < result.length; i++) {
                this.game.load.json(result[i].name, 'data/' + result[i].url);
            }
        }
        if (cache.font) {
            result = cache.font;

            i = 0;
            for (; i < result.length; i++) {
                this.game.load.bitmapFont(result[i].name, 'assets/img/font/' + result[i].url, 'assets/img/font/' + result[i].data);
            }
        }
        if (cache.sound && Luts.Sound.load) {
            result = cache.sound;

            i = 0;
            for (; i < result.length; i++) {
                this.game.load.audio(result[i].name, 'assets/sounds/' + result[i].file + '.m4a', "assets/sounds/" + result[i].file + '.ogg');
                this.checkforCredits(result[i], "sound");
            }
        }
    }, Luts.State.Preloader.prototype.checkforCredits = function ($cookies, deepDataAndEvents) {
        if ($cookies.credits) {
            var value = $cookies.credits;
            this.addToCredits(deepDataAndEvents, value.author, value.name, value.url);
        }
    }, Luts.State.Preloader.prototype.addToCredits = function (paramType, author, errorName, requestUrl) {
        Luts.Credits.push({
            "type": paramType,
            "author": author,
            "name": errorName,
            "url": requestUrl
        });
    }, Luts.State.Preloader.prototype.create = function () {
        this.game.renderer.setTexturePriority(this.images);
        this.game.state.start("Menu");
        console.log('Version ' + Luts.version);
    }, Luts.State.Menu = function (dataAndEvents) {}, Luts.State.Menu.constructor = Luts.State.Menu, Luts.State.Menu.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Menu.prototype.init = function () {}, Luts.State.Menu.prototype.create = function () {
        this.background = this.game.add.image(Luts.GAME_WIDTH / 2, Luts.GAME_HEIGHT / 2, 'cmg');
        this.background.anchor.set(0.5);
        this.setResponsive(this.background, {
            "isBackground": true
        });
        this.game.add.tween(this.background).from({
            "alpha": 0
        }, 1E3, Phaser.Easing.Linear.None, true).onComplete.add(function () {
            this.game.state.start('Game');
        }, this);
    }, Luts.State.Credits = function (dataAndEvents) {}, Luts.State.Credits.constructor = Luts.State.Credits, Luts.State.Credits.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Credits.prototype.init = function () {}, Luts.State.Credits.prototype.create = function () {
        this.addResponsive(0.5, 0.5, 'whiteSquare').anchor.set(0.5);
        this.game.state.start('Credits');
    }, Luts.State.Settings = function (dataAndEvents) {}, Luts.State.Settings.constructor = Luts.State.Settings, Luts.State.Settings.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Settings.prototype.init = function () {}, Luts.State.Settings.prototype.create = function () {
        this.addResponsive(0.5, 0.5, 'whiteSquare').anchor.set(0.5);
        this.game.state.start('Settings');
    }, Luts.State.LevelSelection = function (dataAndEvents) {}, Luts.State.LevelSelection.constructor = Luts.State.LevelSelection, Luts.State.LevelSelection.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.LevelSelection.prototype.init = function () {}, Luts.State.LevelSelection.prototype.create = function () {
        this.game.state.start('Game', true, false, 0);
    }, Luts.State.Game = function (dataAndEvents) {

        this.PRESTIGE_POW = 0.14;

        this.PRESTIGE_DIV = 1E6;

        this.CARDPROGESS_COST_INCREASE = 1.15;
    }, Luts.State.Game.constructor = Luts.State.Game, Luts.State.Game.prototype = Object.create(Luts.State.BaseState.prototype), Luts.State.Game.prototype.init = function (color) {
        this.level = color;

        this.game.stage.disableVisibilityChange = true;
        Luts.currentState = this;
    }, Luts.State.Game.prototype.v102fix = function () {
        if (Luts.Lock.get('goldenDeck').unlocked && Luts.Lock.unlock('godlikeAchievements'), Luts.Lock.get('casinoFix').unlocked || (Luts.Lock.unlock('casinoFix'), Luts.Upgrades.changeCurrency(5, this.casinos.v)), !Luts.Lock.get('bpFix').unlocked) {
            Luts.Lock.unlock('bpFix');

            var r20 = 0;
            Luts.Achievements.achievements.forEach(function (dataAndEvents) {
                if (dataAndEvents.level > 0) {
                    r20 += Luts.Object.AchievementsHandler.categoryToBP(dataAndEvents.category);
                }
            } ['bind'](this));
            r20 += 5 * Math.floor(Luts.Time.passivePlaytime / 864E5);
            Luts.Upgrades.changeCurrency(6, r20);
            if (r20 > 0) {
                new(Luts.Object.Popup)(this, "You received " + r20 + ' BP from your Achievements and playtime! The new Update added Bonus Points with that you can buy special multipliers. Check out the Shop');
            }
        }
        if (this.diceContainers[0].dices[0].upgrade.level > 1 || this.diceContainers[0].dices[0].ascentNum.modValue().greaterThanOrEqualTo(1)) {
            Luts.Lock.unlock("autoRoll");
        }
        if (this.getPrestigeMulti().greaterThanOrEqualTo(2)) {
            Luts.Lock.unlock('advancedAchievements');
        }
        if (this.unlockedCards >= 10) {
            Luts.Lock.unlock('roulette');
            Luts.Lock.unlock('expertAchievements');
        }
        if (this.unlockedCards >= 26) {
            Luts.Lock.unlock('buyAll');
        }
        if (this.unlockedCards >= 32) {
            Luts.Lock.unlock('autoAscend');
        }
        if (this.unlockedCards >= 52) {
            Luts.Lock.unlock('decks');
            Luts.Lock.unlock('legendaryAchievements');
        }
        if (this.rouletteSpins.modValue().greaterThanOrEqualTo(50)) {
            Luts.Lock.unlock('autoSpin');
        }
        if (this.rouletteLevel.modValue().greaterThanOrEqualTo(20)) {
            Luts.Lock.unlock('autoDraw');
        }
        if (this.rouletteLevel.modValue().greaterThanOrEqualTo(25)) {
            Luts.Lock.unlock('autoGild');
        }
        if (this.rouletteLevel.modValue().greaterThanOrEqualTo(35)) {
            if (this.casinos.modValue().greaterThanOrEqualTo(1)) {
                Luts.Lock.unlock('slotMachines');
            }
        }
        if (this.goldenCards >= 52) {
            Luts.Lock.unlock('goldenDeck');
            Luts.Lock.unlock('godlikeAchievements');
        }
        if (this.focusCharge.modValue().greaterThanOrEqualTo(10)) {
            Luts.Lock.unlock('autoRouletteFocus');
        }
        if (Luts.Upgrades.get("rerollChance").level >= 100) {
            Luts.Lock.unlock('autoroll100');
        }
        if (this.casinos.modValue().greaterThanOrEqualTo(2)) {
            Luts.Lock.unlock('autoRouletteUpgrade');
        }
        if (this.casinos.modValue().greaterThanOrEqualTo(12)) {
            Luts.Lock.unlock('autoConvert');
        }
        if (this.casinos.modValue().greaterThanOrEqualTo(21)) {
            Luts.Lock.unlock('autoUpgrade');
        }
    }, Luts.State.Game.prototype.handleGameVersion = function () {
        if (null == Luts.Store.getItem("ver", null)) {
            if (Luts.Connect.kong) {
                Luts.Store.setItem('ver', "kong");
            } else {
                Luts.Store.setItem('ver', "nonKong");
            }
        }
    }, Luts.State.Game.prototype.create = function () {
        this.handleGameVersion();
        Luts.Time.init(this);
        Luts.Events.onGainMoney = new(Phaser.Signal);
        Luts.Events.onUpdate = new(Phaser.Signal);
        Luts.Events.onAsyncUpdate = new(Phaser.Signal);
        Luts.Events.onUnlockedDice = new Phaser.Signal;
        Luts.Events.onPrestige = new(Phaser.Signal);
        Luts.Events.onPrestige2 = new Phaser.Signal;
        Luts.Events.onPrestige3 = new(Phaser.Signal);
        Luts.Events.onAfterPrestige2 = new(Phaser.Signal);
        Luts.Events.onRoll = new Phaser.Signal;
        Luts.Events.onRolledCombo = new(Phaser.Signal);
        Luts.Events.onDrawCard = new(Phaser.Signal);
        Luts.Upgrades.createCurrency('Points');
        Luts.Upgrades.createCurrency('CardsPoints');
        Luts.Upgrades.createCurrency('GoldenCardsPoints');
        Luts.Upgrades.createCurrency("LuckPoints");
        Luts.Upgrades.createCurrency('Chips');
        Luts.Upgrades.createCurrency('Skillpoints');
        Luts.Upgrades.createCurrency('BonusPoints');
        Luts.Upgrades.createCurrency('SlotSpins');
        Luts.Upgrades.createCurrency('Diamonds');
        Luts.Upgrades.createCurrency('DiamondCardPoints');
        Luts.Sound.init(this);
        Luts.Sound.play('music', 0.3, true);
        Luts.CardRules.init(this);
        Luts.Save.init();
        this.enableScreenShake = new(Luts.Setting)('screenShake', true, 'Enable Screenshake');
        this.autoAscend = new(Luts.Setting)('autoAscend', false, 'Auto Ascend');
        this.focusOnCard = new(Luts.Setting)('focusOnCard', true, 'Focus on Card', 'Automatically set the focus to card on prestige');
        this.autoSpin = new(Luts.Setting)('autoSpin', false, 'Auto Spin', 'Spin the roulette automatically if you can afford it');
        this.autoRouletteUpgrade = new Luts.Setting("autoRouletteUpgrade", false, 'Auto Roulette Upgrade', 'Upgrade the roulette automatically if you can afford it');
        this.autoRouletteFocus = new Luts.Setting('autoRouletteFocus', false, 'Auto Roulette Focus', 'Focus the roulette automatically if you can afford it');
        this.autoDraw = new(Luts.Setting)('autoDraw', false, 'Auto Draw Card', "Draw cards automatically (Change the order under cards)");
        this.autoGild = new(Luts.Setting)('autoGild', false, 'Auto Gild Card', "Gild cards automatically (Change the order under cards)");
        this.autoConvert = new Luts.Setting("autoConvert", false, 'Auto Convert', "Automatically convert when having 52 cards");
        this.autoUpgrade = new(Luts.Setting)("autoUpgrade", false, "Auto Upgrade", 'Automatically try to upgrade a dice or combo every few seconds');
        Luts.Store.setItem("version", Luts.version);

        this.fbMulti = 1;

        this.kongMulti = 1;

        this.lastAsyncUpdateTime = new Date;
        this.rollInterval = new(Luts.Value)("rollInterval", 5, 'Roll Interval');
        this.rollCounter = this.rollInterval.modValue().toNumber();
        this.rollAnim = new(Luts.Value)('rollAnim', 2, 'Roll Animation Duration');
        this.rouletteAnim = new Luts.Value("rouletteAnim", 3, 'Roulette Animation Duration');

        this.animPlaying = false;

        this.dices = [];

        this.lastScore = 0;
        this.totalScore = new Luts.Value("totalScore", 0, 'Total Score', 'prestige2');
        this.prestigeScore = new(Luts.Value)('prestigeScore', 0, 'Current Prestige Score', "prestige");
        this.totalPrestige = new Luts.Value("totalPrestige", 1, 'Total Prestige Multiplier');
        this.totalDecks = new Luts.Value('totalDecks', 0, 'Total Decks');
        this.unlockedCards = Luts.Store.getItem('unlockedCards', 0);
        this.goldenCards = Luts.Store.getItem('goldenCards', 0);
        this.casinos = new(Luts.Value)('casinos', 0);
        this.luckMulti = new Luts.Value('luckMulti', 1, 'Luck Multiplier');

        this.prestiging = false;
        this.prestigedNum = new(Luts.Value)('prestigeNum', 0, 'Times Prestiged');
        this.rouletteSpins = new(Luts.Value)('rouletteSpins', 0, "Roulette Spins");
        this.rouletteLevel = new(Luts.Value)("rouletteLevel", 0, null, "prestige");
        this.chipMulti = new Luts.Value('chipMulti', 1, 'Chip Multi');
        this.focusCharge = new(Luts.Value)('focusCharge', 0, null, 'prestige');
        this.prestigeMM = new(Luts.Value)('prestigeMM', 1);
        this.interest = new(Luts.Value)("interest", 0, 'Interest per second');
        this.luckKept = new(Luts.Value)("luckKept", 0, 'Luck kept after investment');
        this.skillPointMulti = new(Luts.Value)('skillPointMulti', 1, 'Skill Points Multi');
        this.autoUpgradeInterval = new(Luts.Value)('autoUpgradeInterval', 10, 'Auto Upgrade Interval');

        this.autoUpgradeCounter = -10;
        this.rolled1 = new(Luts.Value)('rolled1', 0, "Total Rolled 1");
        this.rolled2 = new Luts.Value('rolled2', 0, 'Total Rolled 2');
        this.rolled3 = new(Luts.Value)("rolled3", 0, 'Total Rolled 3');
        this.rolled4 = new(Luts.Value)("rolled4", 0, 'Total Rolled 4');
        this.rolled5 = new(Luts.Value)('rolled5', 0, 'Total Rolled 5');
        this.rolled6 = new(Luts.Value)("rolled6", 0, "Total Rolled 6");
        this.multiDicesUnlocked = new(Luts.Value)('multiDices', 1, null, "prestige");
        this.goldReset = Luts.Store.getItem('goldReset', true);

        this.interestCounter = 0;

        this.interestInterval = 10;

        this.bonusUpgrades = [Luts.Upgrades.add("bonusComboMulti", 'Combo Multi', 'Increases your combo multiplier by 100%', 20, 1, 1, 1, null, 0, null, 6), Luts.Upgrades.add('bonusCardMulti', 'Card Progression Multi', "Increases your card progression by 100%", 50, 1, 1, 1, null, 0, null, 6), Luts.Upgrades.add('bonusChipMulti', 'Chip Multi', 'Increases your chip multi by 100%', 40, 1, 1, 1, null, 0, null, 6), Luts.Upgrades.add('bonusSkillMulti', 'Skill Point Multi', "Increases your skill point multi by 100%",
            1E3, 1, 1, 1, null, 0, null, 6), Luts.Upgrades.add("bonusPrestige", 'Prestige without reset', 'Increases your prestige without reseting your upgrades', 10, 1, 1, 1, null, 0, null, 6), Luts.Upgrades.add("bonusConvert", 'Convert without reset', 'Increases your luck and golden cards without reseting your prestige. YOU WILL AUTOMATICALLY PRESTIGE BUT KEEP YOUR MULTIPLIER', 100, 1, 1, 1, null, 0, null, 6)];
        Luts.Upgrades.get('bonusPrestige').onUpgrade.add(function () {
            new Luts.Object.Popup(this, 'You got ' + Luts.Format.Percent(this.getPrestigeMulti()) + ' Prestige Multi!');
            this.totalPrestige.set(this.totalPrestige.v.add(this.getPrestigeMulti()));
            Luts.Value.get('main0_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
            Luts.Value.get('main1_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
            Luts.Value.get("main2_multi").setMultiplier('prestigeMulti', this.totalPrestige.v, null);
            Luts.Value.get("main3_multi").setMultiplier('prestigeMulti', this.totalPrestige.v, null);
            Luts.Value.get("main4_multi").setMultiplier('prestigeMulti', this.totalPrestige.v, null);
            Luts.Events.onPrestige.dispatch();
        }, this);
        Luts.Upgrades.get("bonusConvert").onUpgrade.add(function () {
            Luts.Events.onPrestige2.dispatch();
            this.totalDecks.add(1);
            this.totalDecks.v = Decimal.min(this.totalDecks.v, Decimal(52));
            Luts.Upgrades.changeCurrency("GoldenCardsPoints", Luts.Upgrades.currency[2].add(this.goldenCards).lessThan(52) ? Luts.Upgrades.value('gildingGain') : 0);
            Luts.Upgrades.setCurrency("GoldenCardsPoints", Decimal.min(52 - this.goldenCards, Luts.Upgrades.currency[2]));
            this.prestige();
            Luts.Upgrades.changeCurrency("LuckPoints", this.totalPrestige.v.times(this.luckMulti.modValue()));
            Luts.Events.onAfterPrestige2.dispatch();
        }, this);

        this.luckUpgrades = [Luts.Upgrades.add("rollCurve", "Roll Curve", 'Increases the probability to roll higher numbers', new Decimal('1e+11'), 1, 15, 0.1, null, 0, null, 3), Luts.Upgrades.add('rerollChance', 'Reroll Chance', 'Chance to reroll automatically after a roll', new Decimal("1e+9"), 0, 2.15, 0.01, 100, 0, null, 3), Luts.Upgrades.add('comboIncrease', 'Combo Increase', 'Increases the combo multiplier everytime you roll a combo', new Decimal('5e+9'), 0, 1.75, 0.01, null, 0, null, 3), Luts.Upgrades.add('prestigeMultiMulti',
            'Prestige Multi Multi', 'Multiplies the prestige multiplier', new Decimal("5e+8"), 1, 10, 1, null, 0, null, 3), Luts.Upgrades.add("slowButStrong", 'Slow but Strong', 'Roll interval is x times slower, all dice multiplier times x', new Decimal('5e+8'), 1, 4, 1, null, 0, null, 3), Luts.Upgrades.add("focusChance", 'Focus Chance', 'Chance to hit your roulette focus without spending chips', new Decimal('5e+10'), 0, 25, 0.01, 100, 0, null, 3)];

        this.skillUpgrades = [Luts.Upgrades.add('rouletteUpgradeMulti', 'Roulette Level Multi', "Increases the Roulette Level more when you hit the upgrade", 1, 1, 2, 1, 30, 0, null, 5), Luts.Upgrades.add('multiPerRoll', "Dice Multi per roll", 'Increases the Multiplier of a dice by the points it rolls', 1, 0, 0, 1, null, 0, null, 5), Luts.Upgrades.add('cardProgressPerSpin', "Card progress per spin", 'Increases the Card progression multi each time you spin the roulette', 1, 0, 0, 0.1, null, 0, null, 5), Luts.Upgrades.add('chipPerCard', 'Chip multi per card',
            'Increases the Chip multi for each card you have', 1, 0, 0, 1, null, 0, null, 5), Luts.Upgrades.add("luckPerGold", 'Luck multi per golden card', 'Increases the Luck multi for each golden card you have', 1, 0, 0, 0.1, null, 0, null, 5), Luts.Upgrades.add('gildingGain', 'Gildings per convert', 'Increases the cards you can gild per convert', 2, 1, 2, 1, 51, 0, null, 5)];
        this.skillUpgrades.forEach(function (dataAndEvents) {

            dataAndEvents.priceIncreaseMethod = 1;
        });
        Luts.Upgrades.get('slowButStrong').onUpgrade.add(function () {
            var r20 = Luts.Upgrades.value('slowButStrong');
            Luts.Value.get('rollInterval').setMultiplier('slowButStrong', r20, null, 'prestige3');
            Luts.Value.get('main0_multi').setMultiplier('slowButStrong', r20, null, 'prestige3');
            Luts.Value.get('main1_multi').setMultiplier('slowButStrong', r20, null, 'prestige3');
            Luts.Value.get('main2_multi').setMultiplier('slowButStrong', r20, null, 'prestige3');
            Luts.Value.get('main3_multi').setMultiplier('slowButStrong', r20, null, 'prestige3');
            Luts.Value.get("main4_multi").setMultiplier('slowButStrong', r20, null, 'prestige3');
        }, this);
        Luts.Object.AchievementsHandler.init(this);
        Luts.Object.HighscoreHandler.init(this);

        this.rollHistory = [];
        this.cardsLevel = new(Luts.Levelable)('cards', 1, this.CARDPROGESS_COST_INCREASE, Math.max(0, 52 - Luts.Upgrades.currency[2].add(this.goldenCards).toNumber()));
        this.cardsLevel.onIncreaseLevel.add(function () {
            Luts.Upgrades.changeCurrency("CardsPoints", 1);
            this.cardsBar.playCompletedEffect();
            this.cardButton.setActive(false, true);
            this.cardButton.setActive(true, true);
        }, this);
        this.cardProgressMulti = new(Luts.Value)("cardProgressMulti", 1, 'Card progress per Ascension');
        this.ascensionMulti = new(Luts.Value)('ascensionMulti', 100, 'Multiplier per Ascension');
        this.comboMulti = new(Luts.Value)('comboMulti', 1, "All Combo Multiplier");
        Luts.Events.onCurrencyChanged[1].add(function () {
            this.cardButton.subtitle.setText(Luts.Format.Decimal(Luts.Upgrades.currency[1]));
        }, this);

        this.game.stage.backgroundColor = 16777215;
        this.background = this.game.add.image(Luts.GAME_WIDTH / 2, Luts.GAME_HEIGHT / 2, "bg");
        this.background.anchor.set(0.5);
        this.setResponsive(this.background, {
            "isBackground": true
        });
        this.gameGroup = this.game.add.image(Luts.GAME_WIDTH / 2, Luts.GAME_HEIGHT / 2);
        this.gameGroup.anchor.set(0.5);
        this.setResponsive(this.gameGroup);
        this.groupUI = this.game.add.group();
        this.topUI = this.game.add.image(Luts.GAME_WIDTH / 2, 0, "ui", 'uiLabelTop');
        this.topUI.anchor.set(0.5, 0.1);
        this.setResponsive(this.topUI);
        this.groupUI.add(this.topUI);
        this.botUI = this.game.add.image(Luts.GAME_WIDTH / 2, Luts.GAME_HEIGHT, "ui", 'uiLabelBot');
        this.botUI.anchor.set(0.5, 0.75);
        this.setResponsive(this.botUI);
        this.groupUI.add(this.botUI);
        this.cardsText = new(Luts.Object.Text)(this, -470, -62, "text", 'Next Card:', 12, '#000000');

        this.cardsText.strokeThickness = 0;
        this.botUI.addChild(this.cardsText);
        this.cardsBar = new(Luts.Object.Bar)(this, -480, -55, "progressBackSmall", 'progressBarSmall');
        this.botUI.addChild(this.cardsBar);
        this.cardButton = new(Luts.Object.Button)(this, -230, -30, 'Draw Card', Luts.Format.Decimal(Luts.Upgrades.currency[1]), this.openCards.bind(this));
        this.cardButton.setLock('cards');
        this.botUI.addChild(this.cardButton);
        new(Luts.Object.Tooltip)(this, this.cardsBar, 'Everytime you ascend a dice, you get 1 progress to the next card');
        this.prestigeText = new(Luts.Object.Text)(this, 240, -60, 'regular', `Prestige Multi:\
` + Luts.Format.Percent(this.totalPrestige.v), 12, '#000000');

        this.prestigeText.strokeThickness = 0;
        this.botUI.addChild(this.prestigeText);
        this.totalPrestige.onChange.add(function () {
            this.prestigeText.setText(`Prestige Multi:\
` + Luts.Format.Percent(this.totalPrestige.v));
        }, this);

        this.prestigeText.visible = false;
        this.prestigeButton = new(Luts.Object.Button)(this, 420, -30, 'Prestige', Luts.Format.Percent(this.getPrestigeMulti(), 2), this.clickPrestige.bind(this));
        this.botUI.addChild(this.prestigeButton);

        this.prestigeButton.visible = false;
        this.game.input.keyboard.addKey(Phaser.KeyCode.P).onDown.add(function () {
            if (this.prestigeButton.visible) {
                this.prestige();
            }
        }, this);
        new(Luts.Object.Tooltip)(this, this.prestigeButton, "Reset your upgrades (P)");
        this.nextRollText = new(Luts.Object.Text)(this, -100, -62, 'text', "Next Auto Roll:", 12, "#000000");

        this.nextRollText.strokeThickness = 0;
        this.botUI.addChild(this.nextRollText);
        this.nextRollBar = new(Luts.Object.Bar)(this, -110, -55, "progressBackSmall", 'progressBarSmall');
        this.botUI.addChild(this.nextRollBar);
        this.rollButton = new(Luts.Object.Button)(this, 140, -30, 'Roll', "", function () {
            this.roll(true);
        } ['bind'](this));
        this.botUI.addChild(this.rollButton);
        new(Luts.Object.Tooltip)(this, this.rollButton, "Roll the Dice (Space)");
        this.rollButton.setActive(false);
        this.rollButton.setActive(true, true);

        this.background.inputEnabled = true;
        this.background.events.onInputDown.add(function () {
            this.roll(true);
        } ['bind'](this));
        this.game.input.keyboard.addKey(Phaser.KeyCode.SPACEBAR).onDown.add(this.roll, this);
        this.scoreCounter = new(Luts.Object.Text)(this, 20, 30, 'regular', "0", 24);
        this.scoreCounter.anchor.set(0.5);
        this.topUI.addChild(this.scoreCounter);
        this.buyAllButton = new(Luts.Object.Button)(this, 255, 40, "Buy all", "", this.buyAll.bind(this));

        this.buyAllButton.baseScale = 0.75;
        this.buyAllButton.scale.set(0.75);
        this.topUI.addChild(this.buyAllButton);
        this.buyAllButton.setLock("buyAll");
        this.buyAllButton.setKey(Phaser.KeyCode.B);
        new(Luts.Object.Tooltip)(this, this.buyAllButton, 'Buy all Upgrades (B)');
        this.buyAmountButtons = new(Luts.Object.BuyAmountButtons)(this, 320, 40, [1, 10, 100], true, 0);
        this.topUI.addChild(this.buyAmountButtons);
        this.settingsButton = new(Luts.Object.Button)(this, -450, 35, "", "", this.settingsClicked.bind(this));
        this.settingsButton.setFrames('settings', 'settings');
        this.topUI.addChild(this.settingsButton);
        this.infoButton = new(Luts.Object.Button)(this, -400, 35, "", "", this.infoClicked.bind(this));
        this.infoButton.setFrames("infoButton", 'infoButton');
        this.topUI.addChild(this.infoButton);
        this.historyButton = new(Luts.Object.Button)(this, -350, 35, "", "", this.historyClicked.bind(this));
        this.historyButton.setFrames('historyButton', 'historyButton');
        this.topUI.addChild(this.historyButton);
        this.achievementsButton = new(Luts.Object.Button)(this, -300, 35, "", "", this.achievementsClicked.bind(this));
        this.achievementsButton.setFrames('achievementsButton', "achievementsButton");
        this.topUI.addChild(this.achievementsButton);
        this.rouletteButton = new(Luts.Object.Button)(this, -250, 35, "", "", this.rouletteClicked.bind(this));
        this.rouletteButton.loadTexture('ingame');
        this.rouletteButton.setFrames("rouletteButton", 'rouletteButton');
        this.topUI.addChild(this.rouletteButton);
        this.rouletteButton.setLock('roulette');
        this.rouletteCounter = new(Luts.Object.Text)(this, 0, 0, "regular", "0", 20);
        this.rouletteCounter.anchor.set(0.5, 0);
        this.rouletteButton.addChild(this.rouletteCounter);

        this.rouletteCounter.alpha = Luts.Lock.get('roulette').unlocked ? 1 : 0;
        Luts.Lock.get('roulette').onUnlocked.add(function () {

            this.rouletteCounter.alpha = 1;
        }, this);
        Luts.Events.onCurrencyChanged[0].add(function () {

            var r20 = 0;
            var windowEventHandlers = Luts.Upgrades.get("rouletteSpin").price;

            r20 = Luts.Upgrades.currency[0].e - windowEventHandlers.e + 1;
            this.rouletteCounter.setText(Luts.Format.Decimal(r20));

            this.rouletteCounter.visible = r20 > 0;
        }, this);
        this.shopButton = new(Luts.Object.Button)(this, -150, 35, "", "", this.shopClicked.bind(this));
        this.shopButton.setFrames('shopButton', 'shopButton');
        this.shopButton.setActive(false);
        this.shopButton.setActive(true, true);
        this.topUI.addChild(this.shopButton);
        this.casinoButton = new(Luts.Object.Button)(this, -200, 35, "", "", this.casinoClicked.bind(this));
        this.casinoButton.loadTexture('ingame');
        this.casinoButton.setFrames("casinoButton", 'casinoButton');
        this.topUI.addChild(this.casinoButton);
        this.casinoButton.setLock('goldenDeck');
        this.autoRollText = new(Luts.Object.Text)(this, -250, 90, 'text', 'Auto Roll', 24);
        this.autoRollText.anchor.set(0.5);

        this.autoRollText.alpha = 0;
        this.topUI.addChild(this.autoRollText);
        this.cardAvailableText = new(Luts.Object.Text)(this, -230, -80, 'text', "Card available!", 24);
        this.cardAvailableText.anchor.set(0.5);
        this.botUI.addChild(this.cardAvailableText);
        this.game.add.tween(this.cardAvailableText).to({
            "alpha": 0
        }, 500, Phaser.Easing.Sinusoidal.InOut, true, 0, -1, true);
        this.rewardAvailableText = new(Luts.Object.Text)(this, -150, 80, 'text', 'Daily Reward available!', 24);
        this.rewardAvailableText.anchor.set(0.5);
        this.topUI.addChild(this.rewardAvailableText);
        this.game.add.tween(this.rewardAvailableText).to({
            "alpha": 0
        }, 500, Phaser.Easing.Sinusoidal.InOut, true, 0, -1, true);
        Luts.Events.onCurrencyChanged[0].add(function (deepDataAndEvents) {
            if (this.scoreCounter.tw) {
                this.scoreCounter.tw.stop();
            }
            this.scoreCounter.setText(Luts.Format.Decimal(deepDataAndEvents, true, 0));
            this.scoreCounter.scale.set(1);
            if (Luts.isActive) {
                this.scoreCounter.tw = this.game.add.tween(this.scoreCounter.scale).from({
                    "x": 1.1,
                    "y": 1.1
                }, 1E3, Phaser.Easing.Elastic.Out, true);
            }
        }, this);

        this.diceContainers = [];
        var dep = new(Luts.Object.DiceContainer)(this, 0, 0, "main");
        this.diceContainers.push(dep);
        this.gameGroup.addChild(dep);
        this.settingsWindow = new(Luts.Object.SettingsWindow)(this);
        this.creditsWindow = new(Luts.Object.CreditsWindow)(this);
        this.infoWindow = new(Luts.Object.InfoWindow)(this);
        this.cardsWindow = new(Luts.Object.CardsWindow)(this);
        this.historyWindow = new(Luts.Object.HistoryWindow)(this);
        this.achievementsWindow = new(Luts.Object.AchievementsWindow)(this);
        this.rouletteWindow = new(Luts.Object.RouletteWindow)(this);
        this.goldCardsWindow = new(Luts.Object.GoldCardsWindow)(this);
        this.shopWindow = new(Luts.Object.ShopWindow)(this);
        this.casinoWindow = new(Luts.Object.CasinoWindow)(this);
        this.changelogWindow = new(Luts.Object.ChangeLogWindow)(this);
        this.mtxWindow = new(Luts.Object.MtxWindow)(this);
        this.slotWindow = new(Luts.Object.SlotWindow)(this);
        Luts.quality.onChanged.add(function () {
            if (this.game.scale.onResize) {
                this.game.scale.onResize(this.game.scale, null, true);
            }
        }, this);
        Luts.Time.handleTimeAway(0, function (deepDataAndEvents) {
            Luts.Time.passivePlaytime += deepDataAndEvents.msec;
            Luts.Time.currentResetPassivePlaytime += deepDataAndEvents.msec;
            this.handleTimeAway(deepDataAndEvents);
        } ["bind"](this));

        Luts.dcfix = true;
        this.game.canvas.addEventListener('click', function (dataAndEvents) {

            Luts.dcfix = true;
        } ['bind'](this));
        this.v102fix();
        this.resize(1, 1);
        Luts.Events.onPrestige.dispatch();
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
            new(Luts.Object.Popup)(this, 'Firefox is not fully supported and will maybe run slow. Consider using Chrome to play.');
        }
        if (screen.orientation) {
            if (screen.orientation.lock) {
                screen.orientation.lock("landscape").catch(function (dataAndEvents) {});
            }
        }
        if ("undefined" != typeof cordova) {
            if (cordova) {
                if (cordova.InAppBrowser) {
                    if (cordova.InAppBrowser.open) {
                        window.open = cordova.InAppBrowser.open;
                    }
                }
            }
        }
    }, Luts.State.Game.prototype.settingsClicked = function () {
        this.settingsWindow.toggle();
    }, Luts.State.Game.prototype.rouletteClicked = function () {
        this.rouletteWindow.toggle();
    }, Luts.State.Game.prototype.creditsClicked = function () {
        this.creditsWindow.toggle();
    }, Luts.State.Game.prototype.infoClicked = function () {
        this.infoWindow.toggle();
    }, Luts.State.Game.prototype.historyClicked = function () {
        this.historyWindow.toggle();
    }, Luts.State.Game.prototype.achievementsClicked = function () {
        this.achievementsWindow.toggle();
    }, Luts.State.Game.prototype.shopClicked = function () {
        this.shopWindow.toggle();
    }, Luts.State.Game.prototype.changelogClicked = function () {
        this.changelogWindow.toggle();
    }, Luts.State.Game.prototype.mtxClicked = function () {
        this.mtxWindow.toggle();
    }, Luts.State.Game.prototype.casinoClicked = function () {
        this.casinoWindow.toggle();
    }, Luts.State.Game.prototype.slotClicked = function () {
        this.slotWindow.toggle();
    }, Luts.State.Game.prototype.showAutoRoll = function (deepDataAndEvents) {
        this.autoRollText.setText(deepDataAndEvents);

        this.autoRollText.alpha = 0;
        this.game.add.tween(this.autoRollText).from({
            "alpha": 1
        }, 2E3, Phaser.Easing.Linear.None, true);
    }, Luts.State.Game.prototype.buyAll = function () {
        this.diceContainers.forEach(function (dataAndEvents) {
            dataAndEvents.buyAll();
        } ['bind'](this));
    }, Luts.State.Game.prototype.getPrestigeMulti = function () {
        var exports = Decimal.max(0, Decimal(this.totalScore.v.dividedBy(this.PRESTIGE_DIV).pow(this.PRESTIGE_POW)).times(Luts.Upgrades.value("prestigeMultiMulti")).times(this.prestigeMM.modValue()).minus(this.totalPrestige.v));
        var _0x313628 = Decimal.max(0, Decimal(this.prestigeScore.v.dividedBy(this.PRESTIGE_DIV).pow(this.PRESTIGE_POW))).times(Luts.Upgrades.value("prestigeMultiMulti"));
        return exports.add(_0x313628.dividedBy(100));
    }, Luts.State.Game.prototype.openCards = function () {
        this.cardsWindow.toggle();
    }, Luts.State.Game.prototype.clickPrestige = function () {
        new(Luts.Object.Popup)(this, `You will lose all your upgrades and start all over.\
You will keep your achievements and get ` + Luts.Format.Color('red') + +Luts.Format.Percent(this.getPrestigeMulti(), 2) + `</c> multiplier on all dice.\
Are you sure you want to prestige?`, true, function (dataAndEvents) {
            if (dataAndEvents) {
                this.prestige();
            }
        } ["bind"](this));
    }, Luts.State.Game.prototype.prestige = function () {

        this.prestiging = true;
        this.totalPrestige.set(this.totalPrestige.v.add(this.getPrestigeMulti()));
        Luts.Value.get('main0_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.get('main1_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.get('main2_multi').setMultiplier("prestigeMulti", this.totalPrestige.v, null);
        Luts.Value.get('main3_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.get('main4_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.resetAllMultipliers('prestige');
        Luts.Value.getByMarker('prestige').forEach(function (dataAndEvents) {
            dataAndEvents.reset();
        });
        Luts.Upgrades.resetOfCurrency(0);
        Luts.Upgrades.resetOfCurrency(1);
        Luts.Upgrades.resetOfCurrency(4);

        this.unlockedCards = 0;
        this.prestigedNum.set(this.prestigedNum.v.add(1));
        Luts.Store.setItem("unlockedCards", this.unlockedCards);
        this.cardsWindow.unlockedCardsText.setText(this.unlockedCards + '/52');
        this.cardsLevel.reset();
        this.cardsWindow.randomizeCards();
        Luts.Events.onPrestige.dispatch();

        this.animPlaying = true;

        this.rollCounter = 5;
        var r20 = Luts.Upgrades.buyAmount[0];
        this.buyAmountButtons.setBuyAmount(-1);
        this.buyAmountButtons.setBuyAmount(r20);
    }, Luts.State.Game.prototype.prestige2 = function () {
        Luts.Events.onPrestige2.dispatch();
        this.totalDecks.add(1);
        this.totalDecks.v = Decimal.min(this.totalDecks.v, Decimal(52));
        Luts.Upgrades.changeCurrency("GoldenCardsPoints", Luts.Upgrades.currency[2].add(this.goldenCards).lessThan(52) ? Luts.Upgrades.value("gildingGain") : 0);
        Luts.Upgrades.setCurrency('GoldenCardsPoints', Decimal.min(52 - this.goldenCards, Luts.Upgrades.currency[2]));
        this.cardsLevel.cost.setMultiplier('prestige' + this.totalDecks.v.toString(), Math.pow(this.CARDPROGESS_COST_INCREASE * this.CARDPROGESS_COST_INCREASE, Luts.Upgrades.value('gildingGain')), null, "prestige3");
        this.cardsLevel.maxLevel = Math.max(0, 52 - Luts.Upgrades.currency[2].add(this.goldenCards).toNumber());
        this.prestige();
        Luts.Upgrades.changeCurrency('LuckPoints', this.totalPrestige.v.times(this.luckMulti.modValue()));
        this.totalPrestige.set(1);
        this.totalScore.set(0);
        Luts.Value.get('main0_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.get('main1_multi').setMultiplier("prestigeMulti", this.totalPrestige.v, null);
        Luts.Value.get('main2_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);
        Luts.Value.get("main3_multi").setMultiplier("prestigeMulti", this.totalPrestige.v, null);
        Luts.Value.get('main4_multi').setMultiplier('prestigeMulti', this.totalPrestige.v, null);

        this.goldReset = true;
        Luts.Store.setItem('goldReset', this.goldReset);
        this.goldCardsWindow.resetButton.setActive(this.goldReset);
        Luts.Events.onAfterPrestige2.dispatch();
    }, Luts.State.Game.prototype.prestige3 = function () {
        this.casinos.add(1);
        Luts.Upgrades.changeCurrency(6, Decimal.min(33, this.casinos.v));
        this.prestige2();
        Luts.Upgrades.resetOfCurrency(2);
        var _0x342d32 = Luts.Upgrades.currency[3];
        Luts.Upgrades.resetOfCurrency(3);
        Luts.Upgrades.changeCurrency(3, _0x342d32.times(this.luckKept.modValue()));

        this.goldenCards = 0;
        Luts.Upgrades.changeCurrency(5, this.skillPointMulti.modValue());
        Luts.Upgrades.setCurrency(5, Decimal.min(Luts.Upgrades.currency[5], this.skillPointMulti.modValue().times(this.casinos.v)));
        Luts.Store.setItem("goldenCards", this.goldenCards);
        this.totalDecks.set(0);

        this.cardsLevel.cost.multipliers = [];
        this.cardsLevel.cost.onChange.dispatch();
        Luts.Value.resetAllMultipliers("prestige3");
        this.cardProgressMulti.setMultiplier(this.casinos.v.toString(), 0.7, null, 'prestige4');
        this.luckMulti.setMultiplier(this.casinos.v.toString(), 1.2, null, 'prestige4');
        this.cardsLevel.maxLevel = Math.max(52 - this.totalDecks.v.toNumber());
        this.prestige();
        Luts.Events.onPrestige3.dispatch();
    }, Luts.State.Game.prototype.roll = function (deepDataAndEvents) {
        if (!this.animPlaying) {

            this.rollCounter = 0;
            this.rollAll();

            this.animPlaying = true;
            Luts.Events.onRoll.dispatch(deepDataAndEvents);
        }
    }, Luts.State.Game.prototype._asyncUpdate = function () {
        this.asyncUpdate();
    }, Luts.State.Game.prototype.asyncUpdate = function () {
        var _0x32e76b = Luts.isActive;

        Luts.isActive = new Date - this.lastUpdateTime < 1E3;

        this.lastAsyncUpdateTime = new Date;
        if (_0x32e76b) {
            if (!Luts.isActive) {
                Luts.Events.onInactive.dispatch();
            }
        }
        if (!_0x32e76b) {
            if (Luts.isActive) {
                Luts.Events.onActive.dispatch();
            }
        }
        if (!Luts.gamePaused) {
            this.rollButton.setActive(!this.animPlaying, true);
            this.rollCounter += 0.1;
            if (this.animPlaying) {
                if (this.rollAnim.modValue().lessThanOrEqualTo(this.rollCounter.toExponential(4))) {

                    this.rollCounter = 0;
                    if (this.game.rnd.frac() < Luts.Upgrades.value('rerollChance').toNumber()) {
                        this.rollCounter = this.rollInterval.modValue().toNumber();
                    }

                    this.animPlaying = false;
                    if (!this.prestiging) {
                        Luts.Upgrades.changeCurrency(0, this.lastScore);
                        this.totalScore.set(this.totalScore.v.add(this.lastScore));
                        this.prestigeScore.set(this.prestigeScore.v.add(this.lastScore));
                    }
                    this.setPrestigeButtonText();

                    this.prestiging = false;
                    this.rollHistory.push({
                        "score": this.lastScore,
                        "values": this.diceContainers[0].lastValues,
                        "match": this.diceContainers[0].lastDiceMatch
                    });
                    if (this.rollHistory.length > 100) {
                        this.rollHistory.shift();
                    }
                    Luts.rollHistory = this.rollHistory;
                }
            } else {
                if (this.rollInterval.modValue().lessThanOrEqualTo(this.rollCounter.toExponential(4))) {
                    if (Luts.Lock.get('autoRoll').unlocked) {
                        this.roll();
                        this.nextRollBar.playCompletedEffect();
                    }
                }
            }
            this.interestCounter += 1;
            if (this.interestCounter >= this.interestInterval) {

                this.interestCounter = 0;
                Luts.Upgrades.changeCurrency(0, Luts.Upgrades.currency[0].times(this.interest.modValue()));
            }
            if (this.autoUpgrade.value) {
                this.autoUpgradeCounter += 0.1;
                if (this.autoUpgradeInterval.modValue().lessThanOrEqualTo(this.autoUpgradeCounter)) {

                    this.autoUpgradeCounter = 0;
                    this.diceContainers.forEach(function (dataAndEvents) {
                        dataAndEvents.buyRandom();
                    } ['bind'](this));
                }
            }
            Luts.Events.onAsyncUpdate.dispatch();
            this.save();
        }
    }, Luts.State.Game.prototype.setPrestigeButtonText = function () {
        var r20 = 'red';
        if (this.getPrestigeMulti().greaterThanOrEqualTo(this.totalPrestige.v)) {
            r20 = 'green';
        }
        this.prestigeButton.subtitle.setText(Luts.Format.Color(r20) + Luts.Format.Percent(this.getPrestigeMulti(), 2));
        this.prestigeButton.visible = this.getPrestigeMulti().greaterThan(0.5) || this.prestigedNum.v.greaterThan(0);
        this.prestigeText.visible = this.prestigeButton.visible;
    }, Luts.State.Game.prototype.rollAll = function () {
        var _0x5e0168 = Decimal(0);
        this.diceContainers.forEach(function (dataAndEvents) {
            _0x5e0168 = _0x5e0168.add(dataAndEvents.rollAll());
        } ['bind'](this));
        this.lastScore = _0x5e0168;
    }, Luts.State.Game.prototype.update = function () {
        var lastUpdateTime = this.lastUpdateTime;

        this.lastUpdateTime = new Date;

        this.deltaTime = (this.lastUpdateTime - lastUpdateTime) / 1E3;
        if (new Date - this.lastAsyncUpdateTime > Luts.GAME_SPEED) {
            this.asyncUpdate();
        }
        this.cardAvailableText.visible = Luts.Upgrades.currency[1].greaterThan(0);
        Luts.Events.onUpdate.dispatch();
        var _0x4a7287 = Luts.Lock.get('autoRoll').unlocked;
        this.nextRollBar.visible = _0x4a7287;
        this.nextRollText.visible = _0x4a7287;
        this.cardsBar.visible = _0x4a7287;
        this.cardsText.visible = _0x4a7287;
        this.cardButton.visible = _0x4a7287;
        if (_0x4a7287) {

            this.rollButton.x = 140;

            this.rewardAvailableText.y = 80;
        } else {

            this.rollButton.x = 0;

            this.rewardAvailableText.y = -100;
        }
        this.nextRollBar.barText.setText(this.animPlaying ? 0 : Luts.Format.Time(1E3 * (this.rollInterval.modValue().toNumber() - this.rollCounter)));
        this.nextRollBar.stepTo(this.animPlaying ? 0 : this.rollCounter / this.rollInterval.modValue().toNumber(), 0.1);
        this.nextRollBar.update();
        this.cardsBar.barText.setText(this.cardsLevel.progressDivString());
        this.cardsBar.stepTo(this.cardsLevel.progressDiv(), 0.1);
        this.cardsBar.update();
        if (Luts.newContent) {

            Luts.newContent = false;
            new(Luts.Object.Popup)(this, 'New Update available, refresh now?', true, function (dataAndEvents) {
                if (dataAndEvents) {
                    window.location.reload(false);
                }
            });
        }
        if (Luts.reg) {
            if (!Luts.regIntervalSet) {
                setInterval(function () {
                    Luts.reg.update();
                }, 6E4);

                Luts.regIntervalSet = true;
            }
        }
        if (Luts.DEBUG) {
            this.game.debug.text(this.game.time.fps, this.game.width - 25, 20, 0);
            this.game.debug.text(Luts.Format.Time(Luts.Time.activePlaytime), this.game.width - 90, 40);
            this.game.debug.text(Luts.Format.Time(Luts.Time.passivePlaytime), this.game.width - 90, 60);
            this.game.debug.text(Luts.Format.Time(Luts.Time.currentResetActivePlaytime), this.game.width - 90, 80);
            this.game.debug.text(Luts.Format.Time(Luts.Time.currentResetPassivePlaytime), this.game.width - 90, 100);
        }
    }, Luts.State.Game.prototype.save = function () {}, Luts.State.Game.prototype.hardReset = function () {

        Luts.gamePaused = true;
        new(Luts.Object.Popup)(this, 'Are you sure? All of your progress will be lost forever.', true, function (dataAndEvents) {
            if (dataAndEvents) {

                Luts.Store.savingEnabled = false;
                Luts.Storage.clear();
                window.location.reload(false);
            } else {

                Luts.gamePaused = false;
            }
        } ["bind"](this));
    }, Luts.State.Game.prototype.handleTimeAway = function (dataAndEvents, deepDataAndEvents) {
        var r20 = Luts.Upgrades.currency[0];
        var key = this.rollInterval.modValue().toNumber() + this.rollAnim.modValue().toNumber();
        var camelKey = this.averagePerSecond().times(dataAndEvents.sec).dividedBy(key);
        if (Luts.Upgrades.changeCurrency(0, camelKey), this.totalScore.set(this.totalScore.v.add(camelKey)), this.prestigeScore.set(this.prestigeScore.v.add(camelKey)), this.setPrestigeButtonText(), dataAndEvents.sec >= 10 && !deepDataAndEvents) {
            var _0x3faec2 = 'You were gone for ' + Luts.Format.Time(1E3 * dataAndEvents.sec, true) + ".\nYou gained: " + Luts.Format.Decimal(Luts.Upgrades.currency[0].minus(r20), true);
            new(Luts.Object.Popup)(this, _0x3faec2);
        }
    }, Luts.State.Game.prototype.averagePerSecond = function () {
        var _0xeae348 = Decimal(0);
        return this.diceContainers.forEach(function (dataAndEvents) {
            _0xeae348 = _0xeae348.add(dataAndEvents.averagePerSecond());
        }), _0xeae348;
    }, Luts.State.Game.prototype.clickFacebook = function () {
        window.open('https://www.facebook.com/lutsgamedev/', Luts.cordova ? '_system' : null);
        new(Luts.Object.Popup)(this, 'Thank you!');
        Luts.Value.get('main0_multi').setMultiplier('promo', 1.1);
    }, Luts.State.Game.prototype.clickKong = function () {
        window.open('https://www.kongregate.com/accounts/Luts91', Luts.cordova ? '_system' : null);
        new(Luts.Object.Popup)(this, 'Thank you!');
        Luts.Value.get('main1_multi').setMultiplier('promo', 1.1);
    }, Luts.State.Game.prototype.clickReddit = function () {
        window.open('https://www.reddit.com/r/idledice/', Luts.cordova ? '_system' : null);
        new(Luts.Object.Popup)(this, 'Thank you!');
        Luts.Value.get('main2_multi').setMultiplier("promo", 1.1);
    }, Luts.State.Game.prototype.clickDiscord = function () {
        window.open('https://discord.gg/gCe2DbJ', Luts.cordova ? '_system' : null);
        new Luts.Object.Popup(this, "Thank you!");
        Luts.Value.get('main3_multi').setMultiplier('promo', 1.1);
    }, Luts.State.Game.prototype.clickPaypal = function () {
        window.open('https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=3KFWW7MRK39ME&lc=US', Luts.cordova ? '_system' : null);
        new(Luts.Object.Popup)(this, 'Thank you!');
    }, Luts.State.Game.prototype.clickDisclaimer = function () {
        window.open("https://luts91.github.io/gaDisclaimer", Luts.cordova ? '_system' : null);
    }, Luts.Util.httpGetAsync = function (deepDataAndEvents, request, callback) {
        if (callback || (callback = request, request = null), Luts.cordova) {
            cordova.plugin.http.get(deepDataAndEvents, request, {}, function (cache) {
                if (200 == cache.status) {
                    callback(cache.data);
                }
            }, function (dataAndEvents) {
                console.log(dataAndEvents.status);
                console.log(dataAndEvents.error);
            });
        } else {

            var response = new XMLHttpRequest;

            response.onreadystatechange = function () {
                if (4 == response.readyState) {
                    if (200 == response.status) {
                        callback(response.responseText);
                    }
                }
            };
            response.open('GET', deepDataAndEvents, true);
            response.send(request);
        }
    }, Luts.Util.httpPostAsync = function (options, msg, callback) {
        if (Luts.cordova) {
            cordova.plugin.http.post(options, body, {}, function (response) {
                if (200 == response.status) {
                    callback(response.data);
                }
            }, function (dataAndEvents) {
                console.log(dataAndEvents.status);
                console.log(dataAndEvents.error);
            });
        } else {

            var collection = new XMLHttpRequest;

            collection.onreadystatechange = function () {
                if (4 == collection.readyState) {
                    if (200 == collection.status) {
                        callback(collection.responseText);
                    }
                }
            };
            collection.open("POST", options, true);
            collection.setRequestHeader('Content-Type', 'application/json');
            collection.send(JSON.stringify(msg));
        }
    }, Luts.Util.RandomWeight = function (a4, labels) {

        var b1 = 0;

        var j = 0;
        for (; j < labels.length; j++) {
            b1 += parseFloat(labels[j]);
        }

        var sum = 0;

        var labelCount = 0;
        for (; labelCount < labels.length && (sum += parseFloat(labels[labelCount]), !(a4 * b1 < sum)); labelCount++) {}
        return labelCount;
    }, Luts.Util.setQuality = function (deepDataAndEvents) {
        Luts.quality = Phaser.Math.clamp(deepDataAndEvents, 0.1, 1);
        var state = Luts.currentState;

        var restoreScript = window.innerWidth / Luts.GAME_WIDTH;

        var r20 = window.innerHeight / Luts.GAME_HEIGHT;
        state.game.scale.setGameSize(Luts.GAME_WIDTH * restoreScript * window.devicePixelRatio * Luts.quality, Luts.GAME_HEIGHT * r20 * window.devicePixelRatio * Luts.quality);
        state.game.scale.setUserScale(1 / (window.devicePixelRatio * Luts.quality));
        state.game.state.resize(restoreScript, r20);
    }, Luts.Util.htmlLog = function (dataAndEvents) {
        document.getElementById("debug").innerText = document.getElementById('debug').innerText + dataAndEvents;
    }, Luts.Util.isCMG = function () {
        return ["https://www.coolmath-games.com", 'www.coolmath-games.com', 'edit.coolmath-games.com', "www.stage.coolmath-games.com", 'edit-stage.coolmath-games.com', 'dev.coolmath-games.com', 'm.coolmath-games.com', 'https://www.coolmathgames.com', 'www.coolmathgames.com', 'edit.coolmathgames.com', "www.stage.coolmathgames.com", 'edit-stage.coolmathgames.com', "dev.coolmathgames.com", 'm.coolmathgames.com'].some(function (deepDataAndEvents) {
            return Luts.Util.isURL(deepDataAndEvents);
        });
    }, Luts.Util.isURL = function (deepDataAndEvents) {
        return window.location.href.toString().includes(deepDataAndEvents);
    }, Luts.Store = {
        "savingEnabled": true,
        "syncData": [],
        "SYNCINTERVAL": 2E3
    }, Luts.Store.init = function (dataAndEvents, isIE) {
        Luts.Store.pre = dataAndEvents;
        Luts.Store.temp = isIE;
        Luts.Storage = isIE ? window.sessionStorage : window.localStorage;
        setInterval(Luts.Store.sync, Luts.Store.SYNCINTERVAL);
        window.addEventListener('beforeunload', function (dataAndEvents) {
            Luts.Store.sync();
        });
        window.addEventListener('unload', function (dataAndEvents) {
            Luts.Store.sync();
        });
    }, Luts.Store.sync = function () {
        Luts.Store.syncData.forEach(function (dataAndEvents) {
            Luts.Store._setItem(dataAndEvents.name, dataAndEvents.val);
        });

        Luts.Store.syncData = [];
    }, Luts.Store._setItem = function (oid, deepDataAndEvents) {
        if (Luts.Store.savingEnabled) {
            Luts.Storage.setItem(Luts.Store.pre + "_" + oid, deepDataAndEvents);
        }
    }, Luts.Store.setItem = function (env, n) {
        if (Luts.Store.savingEnabled) {
            var v = Luts.Store.getSyncData(env);
            if (!v) {
                v = Luts.Store.syncData.push({
                    "name": env,
                    "val": n
                });
            }

            v.val = n;
        }
    }, Luts.Store.getSyncData = function (refetch) {

        var unlock = 0;
        for (; unlock < Luts.Store.syncData.length; unlock++) {
            var cache = Luts.Store.syncData[unlock];
            if (cache.name == refetch) {
                return cache;
            }
        }
        return null;
    }, Luts.Store.removeItem = function (oid, dataAndEvents) {
        Luts.Storage.removeItem(Luts.Store.pre + "_" + oid);
    }, Luts.Store.getItem = function (oid, step, dataAndEvents) {
        var n = Luts.Storage.getItem(Luts.Store.pre + "_" + oid);
        return null != n && 'undefined' != n || (n = step), isNaN(parseFloat(n)) || (dataAndEvents || (n = parseFloat(n))), 'true' == n && (n = true), 'false' == n && (n = false), n;
    }, Luts.Store.setStorage = function (helper) {
        for (key in helper) {
            Luts.Storage.setItem(key, helper[key]);
        }
    }, Luts.Upgrades = {}, Luts.Upgrades.init = function () {

        Luts.Upgrades.buyAmount = [];

        Luts.Upgrades.currency = [];

        Luts.Upgrades.currencyNames = [];
        Luts.Events.onUpgrade = new(Phaser.Signal);

        Luts.Events.onBuyAmountChanged = [];

        Luts.Events.onCurrencyChanged = [];
    }, Luts.Upgrades.createCurrency = function (deepDataAndEvents, _index) {
        return _index || (_index = 0), null == Luts.Upgrades.getCurrency(deepDataAndEvents) && (Luts.Upgrades.currencyNames.push(deepDataAndEvents), Luts.Upgrades.currency.push(Decimal(Luts.Store.getItem("currency_" + Luts.Upgrades.currency.length, _index, true))), Luts.Events.onCurrencyChanged.push(new(Phaser.Signal)), Luts.Upgrades.buyAmount.push(Luts.Store.getItem('buyAmount_' +
            Luts.Upgrades.buyAmount.length, 1)), Luts.Events.onBuyAmountChanged.push(new(Phaser.Signal))), Luts.Upgrades.currency.length - 1;
    }, Luts.Upgrades.changeCurrency = function ($conditional, basis, dataAndEvents) {
        var handler;
        var val;
        if ('string' == typeof $conditional) {
            handler = Luts.Upgrades.getCurrency($conditional);
            val = Luts.Upgrades.getCurrencyId($conditional);
        } else {
            handler = Luts.Upgrades.currency[$conditional];

            val = $conditional;
        }
        if (null == basis.e) {
            basis = Phaser.Math.roundTo(basis, -4);
        }
        Luts.Upgrades.currency[val] = Decimal.max(0, handler.add(basis));
        if (!dataAndEvents) {
            if (!Decimal(0).equals(basis)) {
                Luts.Events.onCurrencyChanged[val].dispatch(Luts.Upgrades.currency[val]);
            }
        }
        this.saveCurrency(val);
    }, Luts.Upgrades.setCurrency = function (selector, r, dataAndEvents) {
        var sel;
        if ('string' == typeof selector) {
            Luts.Upgrades.getCurrency(selector);
            sel = Luts.Upgrades.getCurrencyId(selector);
        } else {
            Luts.Upgrades.currency[selector];

            sel = selector;
        }
        if (null == r.e) {
            r = Phaser.Math.roundTo(r, -4);
        }
        var r20 = Luts.Upgrades.currency[sel];

        Luts.Upgrades.currency[sel] = r;
        if (!dataAndEvents) {
            if (!Decimal(r20).equals(r)) {
                Luts.Events.onCurrencyChanged[sel].dispatch(Luts.Upgrades.currency[sel]);
            }
        }
        this.saveCurrency(sel);
    }, Luts.Upgrades.loadCurrency = function (timeoutKey) {
        Luts.Upgrades.currency[timeoutKey] = Decimal(Luts.Store.getItem('currency_' + timeoutKey, 0, true));
    }, Luts.Upgrades.saveCurrency = function (timeoutKey) {
        Luts.Store.setItem("currency_" + timeoutKey, Luts.Upgrades.currency[timeoutKey].toExponential(6));
    }, Luts.Upgrades.getCurrency = function (elt) {

        var i = 0;
        for (; i < Luts.Upgrades.currencyNames.length; i++) {
            if (Luts.Upgrades.currencyNames[i] == elt) {
                return Luts.Upgrades.currency[i];
            }
        }
        return null;
    }, Luts.Upgrades.getCurrencyId = function (dataAndEvents) {

        var unlock = 0;
        for (; unlock < Luts.Upgrades.currencyNames.length; unlock++) {
            if (Luts.Upgrades.currencyNames[unlock] == dataAndEvents) {
                return unlock;
            }
        }
        return null;
    }, Luts.Upgrades.upgrades = [], Luts.Upgrades.upgradesIndex = [], Luts.Upgrades.add = function (key, list, itemDescription, M, primaryKey, dataAndEvents, deepDataAndEvents, maxLevel, level, test, ignoreMethodDoesntExist) {
        if (Luts.Upgrades.getByName(key)) {
            return Luts.Upgrades.getByName(key);
        }
        if (null == level) {

            level = 1;
        }
        if (null == maxLevel) {

            maxLevel = -1;
        }
        var value = {
            "name": key,
            "displayName": list,
            "description": itemDescription,
            "level": level,
            "initialLevel": level,
            "maxLevel": maxLevel,
            "multiplier": Decimal(1),
            "initialValue": Decimal(primaryKey),
            "initialPrice": M,
            "value": Decimal(primaryKey),
            "priceIncreaseFactor": dataAndEvents,
            "valueIncrease": Decimal(deepDataAndEvents),
            "condition": test,
            "lastBuyAmount": [],
            "lastBuyAmountLevel": [],
            "lastBuyAmountPrice": [],
            "lastMaxPrice": M,
            "currencyType": ignoreMethodDoesntExist || 0,
            "priceIncreaseMethod": 0,
            "valueIncreaseMethod": 0,
            "onUpgrade": new Phaser.Signal
        };
        return Array.isArray(M) ? (value.price = [], value.initialPrice = [], M.forEach(function (deepDataAndEvents) {
            value.price.push(Decimal(deepDataAndEvents));
            value.initialPrice.push(Decimal(deepDataAndEvents));
            value.lastBuyAmountPrice.push(Decimal(0));
            value.lastBuyAmount.push(0);
            value.lastBuyAmountLevel.push(0);
        })) : (value.price = Decimal(M), value.initialPrice = Decimal(M), value.lastBuyAmountPrice.push(Decimal(0)), value.lastBuyAmount.push(0), value.lastBuyAmountLevel.push(0)), value.value = Luts.Upgrades.calcValue(value), Luts.Upgrades.loadUpgrade(value), Luts.Upgrades.upgrades.push(value), Luts.Upgrades.upgradesIndex[key] = value, value;
    }, Luts.Upgrades.reset = function (entry) {
        var logger = Luts.Upgrades.get(entry);
        if (logger.level = logger.initialLevel, Array.isArray(logger.initialPrice)) {

            var currentParam = 0;
            for (; currentParam < logger.initialPrice.length; currentParam++) {
                logger.price[currentParam] = logger.initialPrice[currentParam];
            }
        } else {
            logger.price = logger.initialPrice;
        }
        Luts.Upgrades.calcValue(logger);
        logger.lastBuyAmount.forEach(function (dataAndEvents) {
            0;
        });
        logger.lastBuyAmountPrice.forEach(function (dataAndEvents) {
            Decimal(0);
        });
        logger.lastBuyAmountLevel.forEach(function (dataAndEvents) {
            0;
        });
        logger.lastMaxPrice = logger.initialPrice;
        Luts.Upgrades.saveUpgrade(logger);
    }, Luts.Upgrades.resetOfCurrency = function (elt) {
        Luts.Upgrades.upgrades.forEach(function (collection) {
            if (Array.isArray(collection.currencyType)) {
                if (collection.currencyType.some(function (dataAndEvents) {
                        return dataAndEvents == elt;
                    })) {
                    Luts.Upgrades.reset(collection);
                }
            } else {
                if (collection.currencyType == elt) {
                    Luts.Upgrades.reset(collection);
                }
            }
        });
        Luts.Upgrades.currency[elt] = Decimal(0);
        Luts.Events.onCurrencyChanged[elt].dispatch(0);
        Luts.Upgrades.saveCurrency(elt);
    }, Luts.Upgrades.remove = function (owner) {
        var unlock = Luts.Upgrades.get(owner);

        var sel = Luts.Upgrades.upgrades.length - 1;
        for (; sel >= 0; sel--) {
            if (Luts.Upgrades.upgrades[sel].name == unlock.name) {
                Luts.Upgrades.upgrades.splice(sel, 1);
            }
        }
    }, Luts.Upgrades.upgrade = function (deepDataAndEvents, walkers, opt_obj2) {
        var itemElement = Luts.Upgrades.get(deepDataAndEvents);
        if (Luts.Upgrades.isUpgradeable(deepDataAndEvents, walkers, 1)) {
            if (walkers || (Array.isArray(itemElement.currencyType) ? itemElement.currencyType.forEach(function (deepDataAndEvents, timeoutKey) {
                    if (Array.isArray(itemElement.price)) {
                        Luts.Upgrades.changeCurrency(deepDataAndEvents, itemElement.price[timeoutKey].neg(), opt_obj2);
                    } else {
                        Luts.Upgrades.changeCurrency(deepDataAndEvents, itemElement.price.neg(), opt_obj2);
                    }
                }) : Luts.Upgrades.changeCurrency(itemElement.currencyType, itemElement.price.neg(), opt_obj2)), itemElement.level += 1, 0 == itemElement.priceIncreaseMethod) {
                if (Array.isArray(itemElement.price)) {

                    var unlock = 0;
                    for (; unlock < itemElement.price.length; unlock++) {
                        itemElement.price[unlock] = itemElement.price[unlock].times(itemElement.priceIncreaseFactor[unlock].toString());
                    }
                } else {
                    itemElement.price = itemElement.price.times(itemElement.priceIncreaseFactor.toString());
                }
            } else {
                if (1 == itemElement.priceIncreaseMethod) {
                    if (Array.isArray(itemElement.price)) {

                        unlock = 0;
                        for (; unlock < itemElement.price.length; unlock++) {
                            itemElement.price[unlock] = itemElement.price[unlock].add(itemElement.priceIncreaseFactor[unlock].toString());
                        }
                    } else {
                        itemElement.price = itemElement.price.add(itemElement.priceIncreaseFactor.toString());
                    }
                }
            }
            return itemElement.value = Luts.Upgrades.calcValue(itemElement), opt_obj2 || (Luts.Events.onUpgrade.dispatch(itemElement, 1), itemElement.onUpgrade.dispatch(itemElement, 1)), this.saveUpgrade(itemElement), true;
        }
        return false;
    }, Luts.Upgrades.calcValue = function (style) {
        var target = Luts.Upgrades.get(style);
        return 0 == target.valueIncreaseMethod && (target.value = target.initialValue.plus(target.valueIncrease.times(target.level)).times(target.multiplier)), 1 == target.valueIncreaseMethod && (target.value = target.initialValue.times(target.valueIncrease.pow(target.level)).times(target.multiplier)), target.value;
    }, Luts.Upgrades.upgradeMultiple = function (prefix, b, deepDataAndEvents) {
        var testSource = Luts.Upgrades.get(prefix);
        if (null == b && (b = Luts.Upgrades.buyAmount[testSource.currencyType]), -1 != b) {
            if (Array.isArray(testSource.currencyType)) {

                var a = 0;
                for (; a < testSource.currencyType.length; a++) {
                    if (Luts.Upgrades.currency[testSource.currencyType[a]].lessThan(Luts.Upgrades.priceMultiple(prefix, b, a).floor())) {
                        return 0;
                    }
                }
            } else {
                if (Luts.Upgrades.currency[testSource.currencyType].lessThan(Luts.Upgrades.priceMultiple(prefix, b).floor())) {
                    return 0;
                }
            }
        }

        a = 0;
        for (;
            (a < b || -1 == b) && Luts.Upgrades.upgrade(prefix, deepDataAndEvents, true); a++) {}
        if (Array.isArray(testSource.currencyType)) {

            a = 0;
            for (; a < testSource.currencyType.length; a++) {
                Luts.Events.onCurrencyChanged[testSource.currencyType[a]].dispatch(Luts.Upgrades.currency[testSource.currencyType[a]]);
            }
        } else {
            Luts.Events.onCurrencyChanged[testSource.currencyType].dispatch(Luts.Upgrades.currency[testSource.currencyType]);
        }
        return Luts.Events.onUpgrade.dispatch(testSource, a), testSource.onUpgrade.dispatch(a), Luts.Analytics.track('design', "Upgrade:" + testSource.name + ':Level', testSource.level), Luts.Analytics.track('design', 'Upgrade:' + testSource.name + ":Amount", a), a;
    }, Luts.Upgrades.setBuyAmount = function (offsetPosition, i) {
        Luts.Upgrades.buyAmount[i] = offsetPosition;
        Luts.Upgrades.upgrades.forEach(function (dataAndEvents) {
            dataAndEvents.lastBuyAmount.forEach(function (dataAndEvents) {
                0;
            });
            dataAndEvents.lastBuyAmountPrice.forEach(function (dataAndEvents) {
                Decimal(0);
            });
            dataAndEvents.lastBuyAmountLevel.forEach(function (dataAndEvents) {
                0;
            });
            dataAndEvents.lastMaxPrice = dataAndEvents.price;
        });
        Luts.Events.onBuyAmountChanged[i].dispatch();
        Luts.Store.setItem('buyAmount_' + i, Luts.Upgrades.buyAmount[i]);
    }, Luts.Upgrades.priceMultiple = function (properties, x, key) {
        var values = Luts.Upgrades.get(properties);
        values.currencyType;
        if (null != key) {
            values.currencyType[key];
        } else {

            key = 0;
        }
        var value = values.price;
        if (Array.isArray(value)) {
            value = value[key];
        }
        var target = Decimal(value);
        if (null == x && (x = Luts.Upgrades.buyAmount[values.currencyType]), -1 == x) {

            values.lastBuyAmount[key] = -1;
        } else {
            if (values.lastBuyAmount[key] == Luts.Upgrades.buyAmount[values.currencyType] && values.level == values.lastBuyAmountLevel[key]) {
                return values.lastBuyAmountPrice[key];
            }

            var i = 1;
            for (; i < (-1 != values.maxLevel ? Math.min(values.maxLevel - values.level, x) : x); i++) {
                value = Luts.Upgrades.nextPrice(values, value, key);
                target = target.add(value);
                values.lastMaxPrice = value;
            }
            values.lastBuyAmount[key] = Luts.Upgrades.buyAmount[values.currencyType];
        }
        return values.lastBuyAmountLevel[key] = values.level, values.lastBuyAmountPrice[key] = target, target;
    }, Luts.Upgrades.nextPrice = function (elem, data, dir) {
        var _0x451e9e;
        var queue = Luts.Upgrades.get(elem);
        if (null == data) {
            data = queue.price;
            if (Array.isArray(data)) {
                data = data[dir];
            }
        }
        var cur = queue.priceIncreaseFactor;
        return Array.isArray(cur) && (cur = cur[dir]), 0 == queue.priceIncreaseMethod && (_0x451e9e = data.times(cur.toString())), 1 == queue.priceIncreaseMethod && (_0x451e9e = data.add(cur.toString())), _0x451e9e;
    }, Luts.Upgrades.isBelowMaxLevel = function (env) {
        var a = Luts.Upgrades.get(env);
        return -1 == a.maxLevel || a.level < a.maxLevel;
    }, Luts.Upgrades.isUpgradeable = function (key, deepDataAndEvents, opt_obj2) {
        var camelKey = Luts.Upgrades.get(key);
        return !(camelKey.condition && !camelKey.condition(camelKey)) && (Luts.Upgrades.isAffordable(key, deepDataAndEvents, opt_obj2) && Luts.Upgrades.isBelowMaxLevel(key));
    }, Luts.Upgrades.isAffordable = function (key, dataAndEvents, deepDataAndEvents) {
        var camelKey = Luts.Upgrades.get(key);
        return Array.isArray(camelKey.currencyType) ? camelKey.currencyType.every(function (timeoutKey, opt_obj2) {
            return Luts.Upgrades.currency[timeoutKey].greaterThanOrEqualTo(Luts.Upgrades.priceMultiple(camelKey, deepDataAndEvents, opt_obj2).floor()) || dataAndEvents;
        }) : Luts.Upgrades.currency[camelKey.currencyType].greaterThanOrEqualTo(Luts.Upgrades.priceMultiple(camelKey, deepDataAndEvents).floor()) || dataAndEvents;
    }, Luts.Upgrades.get = function (deepDataAndEvents) {
        return 'string' == typeof deepDataAndEvents ? Luts.Upgrades.getByName(deepDataAndEvents) : deepDataAndEvents;
    }, Luts.Upgrades.value = function (deepDataAndEvents) {
        return Luts.Upgrades.get(deepDataAndEvents).value;
    }, Luts.Upgrades.getByName = function (bits) {
        var max = Luts.Upgrades.upgradesIndex[bits];
        return max;
    }, Luts.Upgrades.saveUpgrade = function (env) {
        var v = Luts.Upgrades.get(env);
        if (Luts.Store.setItem('u_level_' + v.name, v.level), Luts.Store.setItem('u_value_' + v.name, v.value.toExponential(6)), Luts.Store.setItem('u_multi_' + v.name, v.multiplier.toExponential(6)), Luts.Store.setItem('u_vi_' + v.name, v.valueIncrease.toExponential(6)), Array.isArray(v.price)) {

            var id = 0;
            for (; id < v.price.length; id++) {
                Luts.Store.setItem('u_price' + id + "_" + v.name, v.price[id].toExponential(6));
            }
        } else {
            Luts.Store.setItem('u_price_' + v.name, v.price.toExponential(6));
        }
    }, Luts.Upgrades.loadUpgrade = function (url) {
        var value = Luts.Upgrades.get(url);
        var rhs = Luts.Store.getItem('u_level_' + value.name);
        if (null != rhs) {
            if (value.level = rhs, value.value = Decimal(Luts.Store.getItem("u_value_" + value.name, value.value, true)), value.multiplier = Decimal(Luts.Store.getItem("u_multi_" + value.name, value.multiplier, true)), Array.isArray(value.price)) {

                var height = 0;
                for (; height < value.price.length; height++) {
                    value.price[height] = Decimal(Luts.Store.getItem('u_price' + height + "_" + value.name, value.price[height], true));
                }
            } else {
                value.price = Decimal(Luts.Store.getItem('u_price_' + value.name, value.price, true));
            }
        }
    }, Luts.Upgrades.saveAll = function () {
        Luts.Upgrades.upgrades.forEach(Luts.Upgrades.saveUpgrade);

        var r20 = 0;
        for (; r20 < Luts.Upgrades.currency.length; r20++) {
            Luts.Upgrades.saveCurrency(r20);
        }
    }, Luts.Upgrades.loadAll = function () {
        Luts.Upgrades.upgrades.forEach(Luts.Upgrades.loadUpgrade);

        var r20 = 0;
        for (; r20 < Luts.Upgrades.currency.length; r20++) {
            Luts.Upgrades.loadCurrency(r20);
        }
    }, Luts.Achievements = {}, Luts.Achievements.init = function () {

        Luts.Achievements.achievements = [];

        Luts.Achievements.achievementsIndex = [];
        Luts.Achievements.achievedNum = Luts.Store.getItem("achievedNum", 0);
        Luts.Events.onAchievementUnlocked = new(Phaser.Signal);
    }, Luts.Achievements.add = function (moduleId, errorName, itemDescription, deepDataAndEvents, dataAndEvents, callback, opt_obj2, ignoreMethodDoesntExist) {
        var data = {
            "id": moduleId,
            "name": errorName,
            "description": itemDescription,
            "value": Decimal(0),
            "level": 0,
            "baseGoal": Decimal(deepDataAndEvents),
            "goal": Decimal(deepDataAndEvents),
            "goalIncrease": dataAndEvents,

            "callback": callback,
            "signal": new Phaser.Signal,
            "goalIncreaseMethod": 0,
            "baseReward": Decimal(opt_obj2),
            "reward": Decimal(opt_obj2),
            "rewardIncrease": ignoreMethodDoesntExist,
            "maxLevel": -1
        };
        return Luts.Achievements.achievements.push(data), Luts.Achievements.achievementsIndex[moduleId] = data, Luts.Achievements.loadAchievement(moduleId), data;
    }, Luts.Achievements.reset = function (tasks) {
        var keys = Luts.Achievements.get(tasks);

        keys.level = 0;
        keys.value = Decimal(0);
        keys.goal = keys.baseGoal;
        keys.reward = keys.baseReward;
    }, Luts.Achievements.resetAll = function () {
        Luts.Achievements.achievements.forEach(function (deepDataAndEvents) {
            Luts.Achievements.reset(deepDataAndEvents);
        });

        Luts.Achievements.achievedNum = 0;
    }, Luts.Achievements.get = function (deepDataAndEvents) {
        return 'string' == typeof deepDataAndEvents ? Luts.Achievements.getByName(deepDataAndEvents) : deepDataAndEvents;
    }, Luts.Achievements.getByName = function (id) {
        var mod = Luts.Achievements.achievementsIndex[id];
        if (mod) {
            return mod;
        }

        var i = 0;
        for (; i < Luts.Achievements.achievements.length; i++) {
            var attr = Luts.Achievements.achievements[i];
            if (attr.id == id) {
                return attr;
            }
        }
        return null;
    }, Luts.Achievements.set = function (index, iterator, initial) {
        var self = Luts.Achievements.get(index);
        if (null != self) {
            self.value = initial ? Decimal(iterator) : self.value.add(iterator);
            for (; self.value.greaterThanOrEqualTo(self.goal) && (self.level < self.maxLevel || -1 == self.maxLevel);) {
                if (self.callback) {
                    self.callback(self);
                }
                if (0 == self.goalIncreaseMethod) {
                    self.goal = self.goal.times(self.goalIncrease);
                } else {
                    self.goal = self.goal.add(self.goalIncrease);
                }
                self.level += 1;
                Luts.Achievements.achievedNum += 1;
                self.reward = self.reward.times(self.rewardIncrease);
                Luts.Store.setItem('achievedNum', Luts.Achievements.achievedNum);
                Luts.Events.onAchievementUnlocked.dispatch(self);
                self.signal.dispatch(self);
            }
            Luts.Achievements.saveAchievement(index);
        }
    }, Luts.Achievements.saveAchievement = function (string) {
        var ast = Luts.Achievements.get(string);
        Luts.Store.setItem('a_level_' + ast.id, ast.level);
        Luts.Store.setItem("a_value_" + ast.id, ast.value.toExponential(6));
        Luts.Store.setItem('a_goal_' + ast.id, ast.goal.toExponential(6));
        Luts.Store.setItem("a_reward_" + ast.id, ast.reward.toExponential(6));
    }, Luts.Achievements.loadAchievement = function (eventName) {
        var subscribers = Luts.Achievements.get(eventName);
        var onFulfillment = Luts.Store.getItem('a_level_' + subscribers.id);
        if (null != onFulfillment) {
            subscribers.level = onFulfillment;
            subscribers.value = Decimal(Luts.Store.getItem('a_value_' + subscribers.id, subscribers.value, true));
            subscribers.goal = Decimal(Luts.Store.getItem('a_goal_' + subscribers.id, subscribers.goal, true));
            subscribers.reward = Decimal(Luts.Store.getItem('a_reward_' + subscribers.id, subscribers.reward, true));
        }
    }, Luts.Achievements.saveAll = function () {
        Luts.Achievements.achievements.forEach(Luts.Achievements.saveAchievement);
        Luts.Store.setItem('achievedNum', Luts.Achievements.achievedNum);
    }, Luts.Achievements.loadAll = function () {
        Luts.Achievements.achievements.forEach(Luts.Achievements.loadAchievement);
    }, Luts.Format = {}, Luts.Format.Time = function (y, dataAndEvents) {
        var i;
        var D;
        var _0x4b87fc;
        var id;
        var pre;

        var delta = y;
        var number = Math.floor(delta / 1E3);
        var deltaY = Math.floor(number / 60);
        var deltaX = Math.floor(deltaY / 60);
        var _ = Math.floor(deltaX / 24);

        var days = deltaX - 24 * _;

        var tobj = deltaY - 60 * deltaX;

        var x = number - 60 * deltaY;

        var d = delta - 1E3 * number;

        var str = "";
        return dataAndEvents ? (i = " Days, ", D = " Hours, ", _0x4b87fc = ' Minutes, ', id = ' Seconds', pre = "") : (i = "d", D = ":", _0x4b87fc = ":", id = "", pre = ""), _ > 0 && (str += _ + i), (days > 0 || _ > 0) && (str += days + D), tobj > 0 || (days > 0 || _ > 0) ? (str += days > 0 || _ > 0 ? tobj.toString().paddingLeft("00") + _0x4b87fc : tobj.toString() + _0x4b87fc, str += x.toString().paddingLeft("00") + id) : (str += x.toString() + id,
            x < 10 && (!dataAndEvents && (str += "." + Math.floor(d / 100) + pre))), str;
    }, Luts.Format.Color = function (i) {
        return "<c=" + Luts.Config.colors[i] + ">";
    }, Luts.Format.Percent = function (params, x) {
        return null == params.e ? params > 10 ? "x" + Luts.Format.Decimal(params, false, x) : Luts.Format.Decimal(100 * params, false, x) + "%" : params.e >= 1 ? "x" + Luts.Format.Decimal(params, false, x) : Luts.Format.Decimal(params.times(100), false, x) + "%";
    }, Luts.Format.Decimal = function (n, d, bot) {

        var s = "";

        var k = 0;
        if (null == bot && (bot = 2), null == n.e && (n = Decimal(parseFloat(n).toExponential(15))), n.e < 3) {
            var _0x23a051 = n.times(Math.pow(10, bot)).round().dividedBy(Math.pow(10, bot)).toString();
            return "0" != _0x23a051 || n.equals(0) ? _0x23a051 : Luts.Format.Decimal(n, d, bot + 1);
        }
        var c;
        if (!Luts.numberFormat.value) {
            c = Luts.Format.DecimalSuffix(n, d);
        }
        if (Luts.numberFormat.value) {
            c = Luts.Format.DecimalExp(n);
        }
        s = c.post;
        k = c.i;

        var msToS = 1;

        var _0x41327b = 0;
        for (; k > 0 && _0x41327b++ < 2;) {
            k--;
            msToS *= 10;
        }
        return n.dividedBy(Decimal(10).pow(k)).round() / msToS + s;
    }, Luts.Format.DecimalSuffix = function (mapper, isXML) {
        var part;

        var rows = 0;

        var post = "";
        return part = isXML ? Luts.Format.DecimalNames : Luts.Format.DecimalNamesSmall, mapper.e > 100 ? Luts.Format.DecimalExp(mapper) : (mapper.e >= 3 && (isXML && (post = " "), post += part[Math.floor((mapper.e - 3) / 3)], rows = 3 * Math.floor(mapper.e / 3)), {
            "post": post,
            "i": rows
        });
    }, Luts.Format.DecimalExp = function (exts) {

        var rows = 0;

        var post = "";
        return exts.e >= 3 && (post += "e" + 3 * Math.floor(exts.e / 3), rows = 3 * Math.floor(exts.e / 3)), {
            "post": post,
            "i": rows
        };
    }, Luts.Format.DecimalAB = function (exts) {

        var rows = 0;

        var current = "";
        var result = Luts.Format.Letters;
        var i = Math.floor((exts.e - 6) / 3);
        return i < result.length ? current += result[i] : i < Math.pow(result.length, 2) ? (current += result[Math.floor(i / result.length)], current += result[i % result.length]) : i < Math.pow(result.length, 3) && (current += result[Math.floor(i / Math.pow(result.length, 2))], current += result[i % Math.pow(result.length, 2)], current += result[i % result.length]), rows = 3 * Math.floor(exts.e /
            3), {
            "post": current,
            "i": rows
        };
    }, Luts.Format.DecimalNames = ["K", 'Million', 'Billion', 'Trillion', "Quadrillion", 'Quintillion', 'Sextillion', 'Septillion', 'Octillion', 'Nonillion', 'Decillion', "Undecillion", 'Duodecillion', 'Tredecillion', 'Quattuordecillion', "Quinquadecillion", 'Sedecillion', 'Septendecillion', 'Octodecillion', "Novendecillion", 'Vigintillion', 'Unvigintillion', "Duovigintillion", 'Tresvigintillion', 'Quattuorvigintillion',
        "Quinquavigintillion", 'Sesvigintillion', 'Septemvigintillion', 'Octovigintillion', 'Novemvigintillion', "Trigintillion", "Untrigintillion", 'Duotrigintillion'
    ], Luts.Format.DecimalNamesSmall = ["k", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "De", "UD", "DD", "TD", 'QaD', "QiD", 'SxD', 'SpD', "OcD", 'NoD', "Vi", "UV", "DuV", "TV", "QaV", 'QiV', 'SxV', 'SpV', 'OcV', 'NoV', "Tg", "UT",
        "DT"
    ], Luts.Format.Letters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], String.prototype.paddingLeft = function (idx) {
        return String(idx + this).slice(-idx.length);
    }, Luts.Value = function (field, deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist) {

        this.name = field;
        this.displayName = dataAndEvents;
        this.initialValue = deepDataAndEvents;
        this.v = Decimal(Luts.Store.getItem(field, deepDataAndEvents, true));

        this.multipliers = [];
        this.marker = ignoreMethodDoesntExist;
        this.onChange = new Phaser.Signal;
        Luts.Value.values.push(this);
        Luts.Value.valuesIndex[this.name] = this;
        var _0x4e9995 = JSON.parse(Luts.Store.getItem(field + "_m", null));
        if (_0x4e9995) {
            _0x4e9995.forEach(function (dataAndEvents) {
                var r20 = new(Luts.Multiplier)(dataAndEvents, this.name);
                this.multipliers.push(r20);
            } ['bind'](this));
        }
        this.save();
        this.onChange.add(function () {

            this.changed = true;
        }, this);

        this.changed = true;
        this._modValue = this.modValue();
    }, Luts.Value.values = [], Luts.Value.valuesIndex = {}, Luts.Value.prototype.constructor = Luts.Value, Luts.Value.saveAll = function () {
        Luts.Value.values.forEach(function (dataAndEvents) {
            dataAndEvents.save();
        });
    }, Luts.Value.getByName = function (bits) {
        var max = Luts.Value.valuesIndex[bits];
        if (max) {
            return max;
        }

        var unlock = 0;
        for (; unlock < Luts.Value.values.length; unlock++) {
            if (Luts.Value.values[unlock].name == bits) {
                return Luts.Value.values[unlock];
            }
        }
        return null;
    }, Luts.Value.getByMarker = function (dataAndEvents) {

        var match = [];

        var key = 0;
        for (; key < Luts.Value.values.length; key++) {
            if (Luts.Value.values[key].marker == dataAndEvents) {
                match.push(Luts.Value.values[key]);
            }
        }
        return match;
    }, Luts.Value.get = function (deepDataAndEvents) {
        return 'string' == typeof deepDataAndEvents ? Luts.Value.getByName(deepDataAndEvents) : deepDataAndEvents;
    }, Luts.Value.prototype.set = function (v) {
        var vendor = this.v;
        this.v = Decimal(v);
        if (!vendor.equals(Decimal(v))) {
            this.onChange.dispatch();
        }
        this.save();
    }, Luts.Value.prototype.reset = function () {
        this.set(this.initialValue);
    }, Luts.Value.prototype.add = function (deepDataAndEvents) {
        this.set(this.v.add(deepDataAndEvents));
    }, Luts.Value.prototype.save = function () {
        Luts.Store.setItem(this.name, this.v.toExponential(6));

        var r20 = [];

        var unlock = 0;
        for (; unlock < this.multipliers.length; unlock++) {
            r20.push(this.multipliers[unlock].name);
        }
        Luts.Store.setItem(this.name + "_m", JSON.stringify(r20));
        this.multipliers.forEach(function (strings) {
            strings.save();
        });
    }, Luts.Value.resetAllMultipliers = function (elt) {
        Luts.Value.values.forEach(function (strings) {

            var _0x6183cc = false;
            strings.multipliers.forEach(function (collection) {
                if (collection.marker == elt) {
                    collection.value = Decimal(1);

                    _0x6183cc = true;
                }
            });
            if (_0x6183cc) {
                strings.onChange.dispatch();
            }
            strings.save();
        });
    }, Luts.Value.prototype.setMultiplier = function (slide, p, deepDataAndEvents, dataAndEvents) {
        var e;

        var found = true;
        return e = this.getMultiplier(slide), e ? e.value.equals(p) && (found = false) : (e = new(Luts.Multiplier)(slide, this.name, p, deepDataAndEvents, dataAndEvents), this.multipliers.push(e)), e.value = Decimal(p), e.marker = dataAndEvents, found && this.onChange.dispatch(), this.save(), e;
    }, Luts.Value.prototype.changeMultiplier = function (arr, opt_obj2, deepDataAndEvents, capture, walkers) {
        var i = this.getMultiplier(arr);
        if (i) {
            this.setMultiplier(arr, i.value.add(deepDataAndEvents), capture, walkers);
        } else {
            i = this.setMultiplier(arr, opt_obj2, capture, walkers);
        }
    }, Luts.Value.prototype.getMultiplier = function (code) {

        var id = 0;
        for (; id < this.multipliers.length; id++) {
            if (this.multipliers[id].name == code) {
                return this.multipliers[id];
            }
        }
        return null;
    }, Luts.Value.prototype.modValue = function () {
        if (!this.changed) {
            return this._modValue;
        }
        var vendor = this.v;

        var i = 0;
        for (; i < this.multipliers.length; i++) {
            var part = this.multipliers[i];
            if (1 == part.type) {
                vendor = vendor.add(part.value);
            }
        }

        i = 0;
        for (; i < this.multipliers.length; i++) {
            part = this.multipliers[i];
            if (0 == part.type) {
                vendor = vendor.mul(part.value);
            }
        }
        return this._modValue = vendor, this.changed = false, vendor;
    }, Luts.Multiplier = function (region, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, opt_obj2) {
        if (null == ignoreMethodDoesntExist) {

            ignoreMethodDoesntExist = 0;
        }
        this.name = region;
        this.prefix = dataAndEvents;
        this.value = Decimal(Luts.Store.getItem(this.prefix + "_" + this.name, deepDataAndEvents, true));

        this.type = ignoreMethodDoesntExist;
        if (!opt_obj2) {
            this.marker = Luts.Store.getItem(this.prefix + "_" + this.name + '_marker', opt_obj2);
        }
    }, Luts.Multiplier.prototype.constructor = Luts.Multiplier, Luts.Multiplier.prototype.save = function () {
        Luts.Store.setItem(this.prefix + "_" + this.name, this.value.toExponential(6));
        if (this.marker) {
            Luts.Store.setItem(this.prefix + "_" + this.name + '_marker', this.marker);
        }
    }, Luts.Levelable = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {

        this.name = dataAndEvents;

        this.baseCost = deepDataAndEvents;
        this.progress = new(Luts.Value)('la_' + dataAndEvents + 'Progress', 0);
        this.cost = new Luts.Value("la_" + dataAndEvents + "Cost", deepDataAndEvents);
        this.costIncrease = ignoreMethodDoesntExist;
        this.level = new(Luts.Value)("la_" + dataAndEvents + "Level", 0);
        this.maxLevel = textAlt;
        this.onIncreaseLevel = new(Phaser.Signal);
        this.onChange = new(Phaser.Signal);
    }, Luts.Levelable.prototype.constructor = Luts.Levelable, Luts.Levelable.prototype.addProgress = function (deepDataAndEvents) {
        this.progress.set(this.progress.v.add(deepDataAndEvents));
        this.onChange.dispatch(this);
        for (; this.progress.v.greaterThanOrEqualTo(this.cost.modValue()) && (null == this.maxLevel || this.level.v.lessThan(this.maxLevel));) {
            this.progress.set(this.progress.v.minus(this.cost.modValue()));
            this.cost.set(this.cost.v.times(this.costIncrease));
            this.level.set(this.level.v.add(1));
            this.onIncreaseLevel.dispatch(this.level.v);
        }
    }, Luts.Levelable.prototype.progressDiv = function () {
        return null != this.maxLevel && this.level.v.greaterThanOrEqualTo(this.maxLevel) ? 1 : this.progress.v.dividedBy(this.cost.modValue());
    }, Luts.Levelable.prototype.progressDivString = function () {
        return null != this.maxLevel && this.level.v.greaterThanOrEqualTo(this.maxLevel) ? 'MAX' : Luts.Format.Decimal(this.progress.v) + ' / ' + Luts.Format.Decimal(this.cost.modValue());
    }, Luts.Levelable.prototype.reset = function () {
        this.level.set(Decimal(0));
        this.progress.set(Decimal(0));
        this.cost.set(Decimal(this.baseCost));
    }, Luts.Shop = {
        "buyableItems": [],
        "fakeList": [{
            "id": 'item1',
            "name": "item 1",
            "cost": 10,

            "callback": function () {}
        }]
    }, Luts.Shop.init = function (dataAndEvents) {};
Luts.Shop.getBuyableItems = function (on) {

    var failuresLink = [];
    if (Luts.Connect.kong) {
        Luts.Connect.kong.mtx.requestItemList([], function (args) {
            if (args.success) {
                if (Luts.DEBUG) {
                    console.log(args.data);
                }
                args.data.forEach(function (pair) {
                    failuresLink.push({
                        "id": pair.identifier,
                        "name": pair.name,
                        "cost": pair.price,
                        "callback": Luts.Shop.getCallback(pair.identifier)
                    });
                });
            }
            on(failuresLink);
        });
    } else {
        if (Luts.Connect.store) {
            inAppPurchase.getProducts(['1bp10', '2bp50', "3bp100", '4bp500', "5bp1000"]).then(function (dataAndEvents) {
                dataAndEvents.forEach(function (rowData) {
                    failuresLink.push({
                        "id": rowData.productId,
                        "name": rowData.title,
                        "cost": dataAndEvents.price,
                        "callback": Luts.Shop.getCallback(rowData.id)
                    });
                });
                on(failuresLink);
            }).catch(function (message) {
                Luts.Util.htmlLog(message);
                console.log(message);
            });
        } else {
            on(Luts.Shop.fakeList);
        }
    }
}, Luts.Shop.getCallback = function (refetch) {

    var unlock = 0;
    for (; unlock < Luts.Shop.fakeList.length; unlock++) {
        var cache = Luts.Shop.fakeList[unlock];
        if (cache.id == refetch) {
            return cache.callback;
        }
    }
    return function () {};
}, Luts.Shop.getCost = function (com, cb) {
    if (0 == Luts.Shop.buyableItems.length) {
        setTimeout(function () {
            Luts.Shop.getCost(com, cb);
        }, 1E3);
    } else {

        var unlock = 0;
        for (; unlock < Luts.Shop.buyableItems.length; unlock++) {
            var cache = Luts.Shop.buyableItems[unlock];
            if (cache.id == com) {
                return void cb(cache.cost);
            }
        }
        cb(10);
    }
}, Luts.Shop.buyItem = function (message, fn) {
    if (Luts.Connect.kong) {
        Luts.Connect.kong.mtx.purchaseItems([message], function (context) {
            if (fn) {
                fn(context.success);
            }
        });
    } else {
        if (Luts.Connect.store) {
            Luts.Util.htmlLog(message);
            inAppPurchases.buy(message).then(function (dataAndEvents) {
                fn(true);
                Luts.Util.htmlLog('data ' + dataAndEvents);
            }).catch(function (dataAndEvents) {
                Luts.Util.htmlLog("error " + dataAndEvents);
            });
        } else {
            if (Luts.DEBUG) {
                console.log('Bought item ' + message);
            }
            fn(true);
        }
    }
}, Luts.Shop.getItemList = function (callback) {
    if (Luts.Connect.kong) {
        Luts.Connect.kong.mtx.requestUserItemList(null, function (message) {
            if (message.success) {
                if (callback) {
                    callback(message.data);
                }
            }
        });
    } else {
        if (Luts.DEBUG) {
            console.log('Got item list');
        }
        callback(this.fakeList);
    }
}, Luts.Shop.hasItem = function (message, $sanitize) {
    if (Luts.Connect.kong) {
        Luts.Shop.getItemList(function (contexts) {
            if (Luts.DEBUG) {
                console.log('Item list: ', contexts);
            }

            var i = 0;
            for (; i < contexts.length; i++) {
                if (contexts[i].identifier == message) {
                    return void $sanitize(true);
                }
            }
            $sanitize(false);
        });
    } else {
        if (Luts.DEBUG) {
            console.log('Checked for ' + message);
        }
        $sanitize(false);
    }
}, Luts.Shop.getItemCount = function (dataAndEvents, on) {

    var failuresLink = 0;
    if (Luts.Connect.kong) {
        Luts.Shop.getItemList(function (stack) {

            var i = 0;
            for (; i < stack.length; i++) {
                if (stack[i].identifier == dataAndEvents) {
                    failuresLink++;
                }
            }
            on(failuresLink);
        });
    } else {
        on(failuresLink);
    }
}, Luts.Shop.getFirstItemId = function (dataAndEvents, fn) {
    if (Luts.Connect.kong) {
        Luts.Shop.getItemList(function (stack) {
            if (Luts.DEBUG) {
                console.log('Item list: ', stack);
            }

            var i = 0;
            for (; i < stack.length; i++) {
                if (stack[i].identifier == dataAndEvents) {
                    return void fn(stack[i].id);
                }
            }
            fn(null);
        });
    } else {
        if (Luts.DEBUG) {
            console.log('Checked for ' + dataAndEvents);
        }
        fn(1);
    }
}, Luts.Shop.useItem = function (message, fn) {
    if (Luts.Connect.kong) {
        Luts.Shop.getFirstItemId(message, function (deepDataAndEvents) {
            if (deepDataAndEvents) {
                Luts.Connect.kong.mtx.useItemInstance(deepDataAndEvents, function (context) {
                    fn(context.success);
                });
            } else {
                if (Luts.DEBUG) {
                    console.log('doesnt have item');
                }
            }
        });
    } else {
        if (Luts.DEBUG) {
            console.log('Used item ' + message);
        }
        fn(false);
    }
}, Luts.Connect = {
    "kong": false,
    "ga": false,
    "playfab": false,
    "crazygames": false,
    "cordova": false,
    "store": false
}, Luts.Connect.all = function (deepDataAndEvents) {
    Luts.Connect.Kongregate(function () {
        if (Luts.Connect.kong) {
            Luts.Connect.PlayFabKong(deepDataAndEvents);
        }
    });
}, Luts.Connect.Store = function ($sanitize) {
    if (window.inAppPurchase) {
        Luts.Connect.store = window.inAppPurchase;
        Luts.Shop.getBuyableItems(function (dataAndEvents) {
            Luts.Shop.buyableItems = dataAndEvents;
        });
        $sanitize();
    } else {
        $sanitize();
    }
}, Luts.Connect.CrazyGames = function ($sanitize) {
    if (!Luts.cordova && (!window.location.href.toString().includes("kongregate") && (!window.location.href.toString().includes('luts91.github') && window.CrazyGames))) {
        var _0x1ed4fd = window.CrazyGames.CrazySDK;
        Luts.Connect.crazygames = _0x1ed4fd.getInstance();
        Luts.Connect.crazygames.init();
        if ($sanitize) {
            $sanitize();
        }
    }
}, Luts.Connect.Kongregate = function ($sanitize) {
    if (window.location.href.toString().includes("kongregate")) {
        kongregateAPI.loadAPI(function () {
            Luts.Connect.kong = kongregateAPI.getAPI();
            Luts.Shop.getBuyableItems(function (dataAndEvents) {
                Luts.Shop.buyableItems = dataAndEvents;
            });
            if ($sanitize) {
                $sanitize();
            }
        });
    } else {
        if ($sanitize) {
            $sanitize();
        }
    }
}, Luts.Connect.GameAnalytics = function () {
    if (Luts.track) {
        GameAnalytics('setEnabledInfoLog', Luts.DEBUG && Luts.trackLog);
        GameAnalytics("setEnabledVerboseLog", Luts.DEBUG && Luts.trackLog);
        GameAnalytics('configureBuild', Luts.version);
        GameAnalytics("initialize", Luts.gameAnalytics.id, Luts.gameAnalytics.secret);
        Luts.Connect.ga = GameAnalytics;
    }
}, Luts.Connect.PlayFab = function ($sanitize) {
    PlayFab.settings.titleId = Luts.playfab.id;
    Luts.Connect.playfab = PlayFab;
    PlayFab.ClientApi.LoginWithCustomID({
        "TitleId": PlayFab.settings.titleId,
        "CustomId": 'anonymous',
        "CreateAccount": true
    }, function (dataAndEvents) {
        Luts.Connect.playfab = dataAndEvents;
        $sanitize();
    });
}, Luts.Connect.PlayFabKong = function ($sanitize) {
    PlayFab.settings.titleId = Luts.playfab.id;
    Luts.Connect.playfab = PlayFab;
    PlayFab.ClientApi.LoginWithKongregate({
        "TitleId": PlayFab.settings.titleId,
        "KongregateId": Luts.Connect.kong.services.getUserId(),
        "AuthTicket": Luts.Connect.kong.services.getGameAuthToken(),
        "CreateAccount": true
    }, function (dataAndEvents) {
        Luts.Connect.playfab = dataAndEvents;
        $sanitize();
    });
}, Luts.Highscore = {}, Luts.Highscore.submit = function (deepDataAndEvents, message) {
    Luts.Analytics.track('design', "Highscore:" + deepDataAndEvents, message);
    if (Luts.DEBUG) {
        console.log('HS_Submit: ' + deepDataAndEvents + ": " + message);
    }
    if (Luts.Connect.kong) {
        Luts.Connect.kong.stats.submit(deepDataAndEvents, message);
    }
}, Luts.Analytics = {}, Luts.Analytics.track = function (x, ext, style, deepDataAndEvents, opt_obj2, walkers) {
    if (Luts.track && (Luts.trackLog && console.log(x, ext, style), Luts.Connect.ga)) {
        var r20;
        switch (x) {
        case 'progress':
            r20 = 'addProgressionEvent';
            break;
        case 'design':

            r20 = "addDesignEvent";
            break;
        default:
            return;
        }
        GameAnalytics(r20, ext, style, deepDataAndEvents, opt_obj2, walkers);
    }
}, Luts.GameData = {}, Luts.GameData.getNews = function (fn) {
    if (Luts.Connect.playfab) {
        PlayFab.ClientApi.GetTitleNews({
            "Count": 1
        }, function (dataAndEvents) {
            var query = dataAndEvents.data.News[0];
            if (query) {
                if (query.Timestamp != Luts.Store.getItem('latestNews', 0, true)) {
                    Luts.Store.setItem('latestNews', query.Timestamp);
                    fn(query.Body);
                }
            }
        });
    }
}, Luts.Time = {}, Luts.Time.init = function (dataAndEvents) {
    Luts.Time.state = dataAndEvents;
    if (Luts.cordova) {
        Luts.Time.timeStampAdress = 'https://currentmillis.com/time/minutes-since-unix-epoch.php';
    } else {
        Luts.Time.timeStampAdress = '//currentmillis.com/time/minutes-since-unix-epoch.php';
    }
    setInterval(Luts.Time.asyncUpdate, Luts.GAME_SPEED);
    Luts.Time.activePlaytime = Luts.Store.getItem("activePlaytime", 0);
    Luts.Time.passivePlaytime = Luts.Store.getItem("passivePlaytime", 0);
    Luts.Time.currentResetActivePlaytime = Luts.Store.getItem('currentResetActivePlaytime', 0);
    Luts.Time.currentResetPassivePlaytime = Luts.Store.getItem("currentResetPassivePlaytime", 0);
    Luts.Time.lastDailyReward = Luts.Store.getItem('lastDailyReward', 0);
}, Luts.Time.asyncUpdate = function () {
    Luts.Time.activePlaytime += 100;
    Luts.Time.passivePlaytime += 100;
    Luts.Time.currentResetActivePlaytime += 100;
    Luts.Time.currentResetPassivePlaytime += 100;
    if (Luts.Time.state._asyncUpdate) {
        Luts.Time.state._asyncUpdate();
    }
}, Luts.Time.handleTimeAway = function (step, serialize) {
    Luts.Util.httpGetAsync(this.timeStampAdress, function (dataAndEvents) {

        var against = new Date(60 * dataAndEvents * 1E3);
        var fn = Luts.Store.getItem('time', (new Date).getTime());
        Luts.Store.setItem("time", (new Date).getTime());
        var start = Math.max((new Date).getTime() - fn, 0);
        if ((new Date).getTime() - against > 36E5) {

            start = 0;
        }
        if (step) {
            start += step;
        }
        var params = {};
        params.lastTime = fn;
        params.msec = start;
        params.sec = Math.floor(start / 1E3);
        params.min = Math.floor(params.sec / 60);
        params.hour = Math.floor(params.min / 60);
        params.day = Math.floor(params.hour / 24);
        params.month = Math.floor(params.day / 30);
        params.year = Math.floor(params.day / 365);
        console.log('Gone for:');
        console.log(params);
        if (serialize) {
            serialize(params);
        }
        setInterval(Luts.Time.saveTime, 1E3);
    });
}, Luts.Time.saveTime = function () {
    Luts.Store.setItem("time", (new Date).getTime());
    Luts.Store.setItem('activePlaytime', Luts.Time.activePlaytime);
    Luts.Store.setItem("passivePlaytime", Luts.Time.passivePlaytime);
    Luts.Store.setItem("currentResetActivePlaytime", Luts.Time.currentResetActivePlaytime);
    Luts.Store.setItem('currentResetPassivePlaytime', Luts.Time.currentResetPassivePlaytime);
}, Luts.Save = {}, Luts.Save.init = function () {
    document.getElementById("close").onclick = this.closeSavePrompt.bind(this);
    document.getElementById('copy').onclick = this.copySave.bind(this);
    document.getElementById('load').onclick = this.loadSave.bind(this);
}, Luts.Save.savePrompt = function () {
    Luts.Store.setItem('lastExport', Date.now());
    Luts.Store.sync();
    document.getElementById('savePrompt').style.display = 'block';

    document.getElementById('saveInstruction').style.display = "block";
    document.getElementById('loadInstruction').style.display = 'none';
    document.getElementById("load").style.display = 'none';

    document.getElementById('copy').style.display = "inline";
    var clt = document.getElementById('save');
    clt.value = btoa(JSON.stringify(Luts.Storage));
    clt.value = CryptoJS.AES.encrypt(clt.value, Luts.Name);
    clt.select();

    Luts.gamePaused = true;
}, Luts.Save.loadPrompt = function () {
    document.getElementById('savePrompt').style.display = 'block';
    document.getElementById("saveInstruction").style.display = 'none';
    document.getElementById('loadInstruction').style.display = 'block';
    document.getElementById('load').style.display = 'inline';
    document.getElementById("copy").style.display = 'none';

    document.getElementById('save').value = "";

    Luts.gamePaused = true;
}, Luts.Save.closeSavePrompt = function () {
    document.getElementById('savePrompt').style.display = 'none';

    Luts.gamePaused = false;
}, Luts.Save.copySave = function () {
    document.getElementById("save").select();
    document.execCommand("copy");
}, Luts.Save.loadSave = function () {
    var _0x248eb5 = document.getElementById('save');
    var secret = CryptoJS.AES.decrypt(_0x248eb5.value, Luts.Name).toString(CryptoJS.enc.Utf8);
    secret = atob(secret);
    var r20 = JSON.parse(secret.toString());
    if ("kong" != r20[Luts.Name + "_ver"] && Luts.Connect.kong) {
        new(Luts.Object.Popup)(Luts.currentState, 'Saves that started outside of Kongregate cannot be imported into the Kongregate Version');
    } else {
        Luts.Storage.clear();
        Luts.Store.setStorage(r20);
        window.location.reload(false);
    }
}, Luts.Save.saveToCloud = function ($sanitize) {
    if (Luts.Connect.kong || Luts.DEBUG) {
        Luts.Store.setItem('lastExport', Date.now());
        Luts.Store.setItem('trimmed', 1);
        Luts.Store.sync();
        var data = {};
        for (key in Luts.Storage) {
            if ("function" != typeof Luts.Storage[key]) {
                var cc = key.replace(Luts.Name + "_", "");
                data[cc] = Luts.Storage[key];
            }
        }
        var id = Luts.Connect.kong.services.getUserId();
        var tag = Luts.Connect.kong.services.getGameAuthToken();
        new(Luts.Object.Popup)(Luts.currentState, 'Uploading...');
        Luts.Util.httpPostAsync(Luts.dbServer, {
            "col": Luts.Id,
            "playerId": id,
            "data": data,
            "authToken": tag
        }, function (message) {
            if (message && JSON.parse(message).success) {
                Luts.Util.httpGetAsync(Luts.dbServer + "/" + Luts.Id + "/" + id + "/" + tag, function (message) {
                    if (message && (JSON.parse(message).success && (JSON.parse(message).data && JSON.parse(message).data.data))) {
                        new Luts.Object.Popup(Luts.currentState, 'Uploading to the cloud was successful!');
                    } else {
                        new(Luts.Object.Popup)(Luts.currentState, 'Something went wrong');
                        console.log(message);
                    }
                    $sanitize();
                });
            } else {
                new(Luts.Object.Popup)(Luts.currentState, "Something went wrong.");
                console.log(message);
            }
            $sanitize();
        });
    }
}, Luts.Save.loadFromCloud = function ($sanitize) {
    if (Luts.Connect.kong || Luts.DEBUG) {
        var tag = Luts.Connect.kong.services.getUserId();
        var srcDir = Luts.Connect.kong.services.getGameAuthToken();
        new(Luts.Object.Popup)(Luts.currentState, 'Waiting for data...');
        Luts.Util.httpGetAsync(Luts.dbServer + "/" + Luts.Id + "/" + tag + "/" + srcDir, function (message) {
            if (message && JSON.parse(message).success) {
                Luts.Storage.clear();
                var from = JSON.parse(message).data.data;
                var to = {};
                if ("1" === from.trimmed) {
                    for (key in from) {
                        if ('function' != typeof from[key]) {

                            var k = Luts.Name + "_" + key;
                            to[k] = from[key];
                        }
                    }
                } else {
                    to = from;
                }
                Luts.Store.setStorage(to);
                window.location.reload(false);
            } else {
                new(Luts.Object.Popup)(Luts.currentState, 'Something went wrong');
                console.log(message);
            }
            $sanitize();
        });
    }
}, Luts.Camera = function (dataAndEvents, deepDataAndEvents, opt_obj2, walkers, isXML) {
    this.state = dataAndEvents;
    this.game = dataAndEvents.game;
    this.setSize(deepDataAndEvents, opt_obj2, walkers, isXML);

    this.follow = null;
    this.raw = {
        "x": 0,
        "y": 0
    };
    this.smooth = {
        "x": 0,
        "y": 0
    };

    this.CAMERA_SMOOTH = 0.1;
    this.perlin = new SimplexNoise;

    this.minShake = 0.1;
    this.shakeEnabled = new(Luts.Util.Setting)('shakeEnabled', true, 'Enable screen shake');

    this.shake = 0;

    this.shakeMulti = 50;

    this.shakeReduce = 0.9;

    this.shakeSpeed = 0.2;

    this.t = 0;
}, Luts.Camera.prototype.constructor = Luts.Camera, Luts.Camera.prototype.setSize = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
    this.minX = dataAndEvents;
    this.maxX = deepDataAndEvents;
    this.minY = ignoreMethodDoesntExist;
    this.maxY = textAlt;
}, Luts.Camera.prototype.update = function () {
    if (this.follow) {
        this.centerOn(this.follow.x, this.follow.y);
    }
    var t = Phaser.Math.clamp(this.shake, this.minShake, 1);
    this.shake = Math.max(0, this.shake * this.shakeReduce);
    this.t += this.shakeSpeed * t;
    this.raw.x = Phaser.Math.clamp(this.raw.x, this.minX, this.maxX);
    this.raw.y = Phaser.Math.clamp(this.raw.y, this.minY, this.maxY);
    this.smooth.x += (this.raw.x - this.smooth.x) * this.CAMERA_SMOOTH;
    this.smooth.y += (this.raw.y - this.smooth.y) * this.CAMERA_SMOOTH;
    if (!this.shakeEnabled.value) {

        t = 0;
    }
    this.game.camera.x = this.smooth.x + Math.pow(t, 2) * this.shakeMulti * this.perlin.noise2D(this.t, 0);
    this.game.camera.y = this.smooth.y + Math.pow(t, 2) * this.shakeMulti * this.perlin.noise2D(this.t, 1);
}, Luts.Camera.prototype.setFollow = function (dataAndEvents) {
    this.follow = dataAndEvents;
    this.setTo(this.follow.x - this.game.width / 2, this.follow.y - this.game.height / 2);
}, Luts.Camera.prototype.centerOn = function (dataAndEvents, layer1) {

    this.raw.x = dataAndEvents - this.game.width / 2;

    this.raw.y = layer1 - this.game.height / 2;
}, Luts.Camera.prototype.setTo = function (v, sum) {
    this.raw.x = v;
    this.raw.y = sum;
    this.smooth.x = v;
    this.smooth.y = sum;
    this.game.camera.x = v;
    this.game.camera.y = sum;
}, Luts.Pathfinding = {

    "findPath": function (m2, pointB, pointA) {

        var grid = [];

        var z = 0;
        for (; z < m2.length; z++) {

            grid[z] = [];

            var y = 0;
            for (; y < m2[z].length; y++) {
                grid[z][y] = m2[z][y].tileObject.getWeight();
            }
        }
        var graph = new Graph(grid, {
            "diagonal": true
        });
        var camelKey = graph.grid[pointB.x][pointB.y];
        var newRecord = graph.grid[pointA.x][pointA.y];
        var data = astar.search(graph, camelKey, newRecord);
        return data.length > 0 ? data : [];
    }
};
var astar = {

    "search": function (cache, data, sort, elements) {
        cache.cleanDirty();
        elements = elements || {};
        var encodeURIComponent = elements.heuristic || astar.heuristics.manhattan;
        var r = elements.closest || false;
        var self = getHeap();

        var args = data;
        data.h = encodeURIComponent(data, sort);
        cache.markDirty(data);
        self.push(data);
        for (; self.size() > 0;) {
            var global = self.pop();
            if (global === sort) {
                return pathTo(global);
            }

            global.closed = true;
            var props = cache.neighbors(global);

            var j = 0;
            var jj = props.length;
            for (; j < jj; ++j) {
                var h = props[j];
                if (!h.closed && !h.isWall()) {
                    var s = global.g + h.getCost(global);
                    var num_aliases = h.visited;
                    if (!num_aliases || s < h.g) {

                        h.visited = true;
                        h.parent = global;
                        h.h = h.h || encodeURIComponent(h, sort);
                        h.g = s;
                        h.f = h.g + h.h;
                        cache.markDirty(h);
                        if (r) {
                            if (h.h < args.h || h.h === args.h && h.g < args.g) {
                                args = h;
                            }
                        }
                        if (num_aliases) {
                            self.rescoreElement(h);
                        } else {
                            self.push(h);
                        }
                    }
                }
            }
        }
        return r ? pathTo(args) : [];
    },
    "heuristics": {

        "manhattan": function (p1, p2) {
            return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
        },

        "diagonal": function (p1, p2) {
            var to = Math.sqrt(2);
            var t = Math.abs(p2.x - p1.x);
            var r = Math.abs(p2.y - p1.y);
            return 1 * (t + r) + (to - 2) * Math.min(t, r);
        }
    },

    "cleanNode": function (e) {

        e.f = 0;

        e.g = 0;

        e.h = 0;

        e.visited = false;

        e.closed = false;

        e.parent = null;
    }
};
Graph.prototype.init = function () {

    this.dirtyNodes = [];

    var i = 0;
    for (; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
    }
}, Graph.prototype.cleanDirty = function () {

    var unlock = 0;
    for (; unlock < this.dirtyNodes.length; unlock++) {
        astar.cleanNode(this.dirtyNodes[unlock]);
    }

    this.dirtyNodes = [];
}, Graph.prototype.markDirty = function (deepDataAndEvents) {
    this.dirtyNodes.push(deepDataAndEvents);
}, Graph.prototype.neighbors = function (coords) {

    var thisObj = [];
    var x = coords.x;
    var y = coords.y;
    var tmp = this.grid;
    return tmp[x - 1] && (tmp[x - 1][y] && thisObj.push(tmp[x - 1][y])), tmp[x + 1] && (tmp[x + 1][y] && thisObj.push(tmp[x + 1][y])), tmp[x] && (tmp[x][y - 1] && thisObj.push(tmp[x][y - 1])), tmp[x] && (tmp[x][y + 1] && thisObj.push(tmp[x][y + 1])), this.diagonal && (tmp[x - 1] && (tmp[x - 1][y - 1] && thisObj.push(tmp[x - 1][y - 1])), tmp[x + 1] && (tmp[x + 1][y - 1] && thisObj.push(tmp[x + 1][y - 1])), tmp[x - 1] && (tmp[x - 1][y +
        1
    ] && thisObj.push(tmp[x - 1][y + 1])), tmp[x + 1] && (tmp[x + 1][y + 1] && thisObj.push(tmp[x + 1][y + 1]))), thisObj;
}, Graph.prototype.toString = function () {

    var dashes = [];
    var segs = this.grid;

    var i = 0;
    for (; i < segs.length; i++) {

        var _0x31b9dd = [];
        var seg = segs[i];

        var axisIndex = 0;
        for (; axisIndex < seg.length; axisIndex++) {
            _0x31b9dd.push(seg[axisIndex].weight);
        }
        dashes.push(_0x31b9dd.join(" "));
    }
    return dashes.join("\n");
}, GridNode.prototype.toString = function () {
    return "[" + this.x + " " + this.y + "]";
}, GridNode.prototype.getCost = function (pointA) {
    return pointA && (pointA.x != this.x && pointA.y != this.y) ? 1.41421 * this.weight : this.weight;
}, GridNode.prototype.isWall = function () {
    return 0 === this.weight;
}, BinaryHeap.prototype = {

    "push": function (view) {
        this.content.push(view);
        this.sinkDown(this.content.length - 1);
    },

    "pop": function () {
        var _0x2d5241 = this.content[0];
        var _0x5180ad = this.content.pop();
        return this.content.length > 0 && (this.content[0] = _0x5180ad, this.bubbleUp(0)), _0x2d5241;
    },

    "remove": function (selector) {
        var sel = this.content.indexOf(selector);
        var r20 = this.content.pop();
        if (sel !== this.content.length - 1) {
            this.content[sel] = r20;
            if (this.scoreFunction(r20) < this.scoreFunction(selector)) {
                this.sinkDown(sel);
            } else {
                this.bubbleUp(sel);
            }
        }
    },

    "size": function () {
        return this.content.length;
    },

    "rescoreElement": function (deepDataAndEvents) {
        this.sinkDown(this.content.indexOf(deepDataAndEvents));
    },

    "sinkDown": function (id) {
        var data = this.content[id];
        for (; id > 0;) {

            var unlock = (id + 1 >> 1) - 1;
            var cache = this.content[unlock];
            if (!(this.scoreFunction(data) < this.scoreFunction(cache))) {
                break;
            }
            this.content[unlock] = data;
            this.content[id] = cache;

            id = unlock;
        }
    },

    "bubbleUp": function (n) {
        var length = this.content.length;
        var element = this.content[n];
        var right = this.scoreFunction(element);
        for (;;) {
            var left;

            var child1N = n + 1 << 1;

            var child2N = child1N - 1;

            var swap = null;
            if (child2N < length) {
                var child2 = this.content[child2N];
                left = this.scoreFunction(child2);
                if (left < right) {

                    swap = child2N;
                }
            }
            if (child1N < length) {
                var child1 = this.content[child1N];
                if (this.scoreFunction(child1) < (null === swap ? right : left)) {

                    swap = child1N;
                }
            }
            if (null === swap) {
                break;
            }
            this.content[n] = this.content[swap];
            this.content[swap] = element;

            n = swap;
        }
    }
}, Luts.Skills = {
    "skills": []
}, Luts.Skills.add = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData) {
    Luts.Skills.skills.push(new(Luts.Skill)(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData));
}, Luts.Skills.get = function (deepDataAndEvents) {
    return 'string' == typeof deepDataAndEvents ? Luts.Skills.getByName(deepDataAndEvents) : deepDataAndEvents;
}, Luts.Skills.getByName = function (com) {

    var scopeId = 0;
    for (; scopeId < Luts.Skills.skills.length; scopeId++) {
        if (Luts.Skills.skills[scopeId].id == com) {
            return Luts.Skills.skills[scopeId];
        }
    }
    return null;
}, Luts.Skill = function (proxyObj, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, dataAndEvents) {
    this.id = proxyObj;
    this.name = deepDataAndEvents;
    this.description = ignoreMethodDoesntExist;
    this.condition = textAlt;
    this.multiUseable = dataAndEvents;

    this.canUse = true;

    this.isActive = false;

    this.currentActiveTime = 0;

    this.activatable = false;
    this.onUse = new(Phaser.Signal);
    this.onCanUse = new Phaser.Signal;
    this.onCanUseChanged = new(Phaser.Signal);
    this.onActivate = new(Phaser.Signal);
    this.onDeactivate = new(Phaser.Signal);
    this.checkCondition();
}, Luts.Skill.prototype.use = function (deepDataAndEvents) {
    if (this.button.active) {
        this.onUse.dispatch(deepDataAndEvents);
    }
}, Luts.Skill.prototype.checkCondition = function () {
    var _0x50ea3b = this.canUse;
    return this.condition ? this.canUse = this.condition() && !this.isActive : this.canUse = true, !_0x50ea3b && (this.canUse && (this.onCanUse.dispatch(), this.onCanUseChanged.dispatch())), _0x50ea3b && (!this.canUse && this.onCanUseChanged.dispatch()), this.canUse;
}, Luts.Skill.prototype.update = function () {
    var isActive = this.isActive;
    if (this.isActive) {
        this.currentActiveTime -= 1;
    }
    if (this.currentActiveTime <= 0) {

        this.currentActiveTime = 0;

        this.isActive = false;
        if (isActive) {
            this.onDeactivate.dispatch();
        }
    }
}, Luts.Skill.prototype.setActive = function (dataAndEvents, deepDataAndEvents) {

    this.activatable = true;
    var isActive = this.isActive;
    this.isActive = dataAndEvents;
    if (dataAndEvents) {
        this.currentActiveTime = deepDataAndEvents;
        if (!isActive) {
            this.onActivate.dispatch();
        }
    } else {
        if (isActive) {
            this.onDeactivate.dispatch();
        }
    }
}, Luts.Skill.prototype.constructor = Luts.Skill, Luts.Lock = function (region, deepDataAndEvents) {
    this.name = region;
    this.unlocked = Luts.Store.getItem('lock_' + region, deepDataAndEvents);
    Luts.Lock.locks.push(this);
    this.onUnlocked = new(Phaser.Signal);
    this.onLocked = new(Phaser.Signal);
}, Luts.Lock.locks = [], Luts.Lock.prototype.constructor = Luts.Lock, Luts.Lock.saveAll = function () {
    Luts.Lock.locks.forEach(function (dataAndEvents) {
        dataAndEvents.save();
    });
}, Luts.Lock.getByName = function (dataAndEvents) {

    var unlock = 0;
    for (; unlock < Luts.Lock.locks.length; unlock++) {
        if (Luts.Lock.locks[unlock].name == dataAndEvents) {
            return Luts.Lock.locks[unlock];
        }
    }
    return null;
}, Luts.Lock.get = function (owner) {
    if ('string' == typeof owner) {
        var unlock = Luts.Lock.getByName(owner);
        return unlock || new Luts.Lock(owner, false);
    }
    return owner;
}, Luts.Lock.unlock = function (owner) {
    var unlock = Luts.Lock.get(owner);
    if (unlock) {
        unlock.unlock();
    }
}, Luts.Lock.lock = function (owner) {
    var unlock = Luts.Lock.get(owner);
    if (unlock) {
        unlock.lock();
    }
}, Luts.Lock.prototype.save = function () {
    Luts.Store.setItem('lock_' + this.name, this.unlocked);
}, Luts.Lock.prototype.lock = function () {
    var unlocked = this.unlocked;

    this.unlocked = false;
    if (unlocked != this.unlocked) {
        this.save();
        this.onLocked.dispatch();
    }
}, Luts.Lock.prototype.unlock = function () {
    var _0x39dfc4 = this.unlocked;

    this.unlocked = true;
    if (_0x39dfc4 != this.unlocked) {
        this.save();
        this.onUnlocked.dispatch(this);
    }
}, Luts.Sound = {
    "load": true,
    "enabledIfInactive": true,
    "currentAmbient": [],
    "currentAmbientName": "",
    "sounds": [],
    "soundsIndex": [],
    "musicsIndex": []
}, Luts.Sound.init = function (value) {
    Luts.Sound.volume = new(Luts.Setting)('soundVolume', 1, "Sound Volume");
    Luts.Sound.enabled = new(Luts.Setting)('soundEnabled', true, 'Enable Sound');
    Luts.Sound.musicEnabled = new Luts.Setting('musicEnabled', true, 'Enable Music');
    this.state = value;
    this.game = value.game;
    this.game.input.keyboard.addKey(Phaser.Keyboard.M).onDown.add(Luts.Sound.enabled.toggle, Luts.Sound.enabled);
    Luts.Events.onAsyncUpdate.add(function () {
        this.soundsIndex.forEach(function (dataAndEvents) {

            dataAndEvents.mute = !Luts.Sound.enabled.value;
        } ['bind'](this));
        this.musicsIndex.forEach(function (dataAndEvents) {

            dataAndEvents.mute = !Luts.Sound.musicEnabled.value;
        } ['bind'](this));
        this.game.sound.volume = Luts.Sound.volume.value;
        Luts.Sound.playAmbient();
    } ["bind"](this));
}, Luts.Sound.play = function (methodName, orig, deepDataAndEvents) {
    if (Luts.isActive || this.enabledIfInactive) {
        if (this.load) {
            if (this.sounds[methodName]) {
                this.sounds[methodName].play("", 0, orig, deepDataAndEvents);
            } else {
                this.sounds[methodName] = this.game.sound.play(methodName, orig, deepDataAndEvents);
            }
        }
    }
    this.sounds[methodName].mute = !this.enabled.value && !deepDataAndEvents || !this.musicEnabled.value && deepDataAndEvents;
    if (deepDataAndEvents) {
        this.musicsIndex.push(this.sounds[methodName]);
    } else {
        this.soundsIndex.push(this.sounds[methodName]);
    }
}, Luts.Sound.playRandom = function (deepDataAndEvents) {
    this.play(this.game.rnd.pick(deepDataAndEvents));
}, Luts.Sound.playAmbient = function () {
    this.currentAmbient.forEach(function (dataAndEvents) {
        dataAndEvents.update();
    });
}, Luts.Sound.setAmbient = function (owner) {
    if (this.currentAmbientName != owner) {
        this.currentAmbientName = owner;
        this.currentAmbient.forEach(function (old) {
            if (Luts.Sound.sounds[old.name]) {
                Luts.Sound.sounds[old.name].stop();
            }
        });

        this.currentAmbient = [];
        var unlock = this.getAmbient(owner);
        if (unlock) {
            unlock.sounds.forEach(function (old) {
                this.currentAmbient.push(new(Luts.Sound.IntervalSound)(old.name, old.interval_min, old.interval_max, old.start));
            } ['bind'](this));
        }
    }
}, Luts.Sound.getAmbient = function (dataAndEvents) {

    var i = 0;
    for (; i < Luts.Config.ambient.length; i++) {
        if (Luts.Config.ambient[i].name == dataAndEvents) {
            return Luts.Config.ambient[i];
        }
    }
    return null;
}, Luts.Sound.IntervalSound = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
    this.name = dataAndEvents;
    this.intervalMin = deepDataAndEvents;
    this.intervalMax = ignoreMethodDoesntExist;

    this.counter = 0;
    this.setInterval();
    if (textAlt) {
        Luts.Sound.play(this.name);
    }
}, Luts.Sound.IntervalSound.prototype.setInterval = function () {
    this.currentInterval = Luts.Sound.game.rnd.between(this.intervalMin, this.intervalMax);
}, Luts.Sound.IntervalSound.prototype.update = function () {
    if (++this.counter >= 10 * this.currentInterval) {
        if (!(Luts.Sound.sounds[this.name] && Luts.Sound.sounds[this.name].isPlaying)) {
            Luts.Sound.play(this.name);
        }

        this.counter = 0;
        this.setInterval();
    }
}, Luts.Sound.IntervalSound.prototype.constructor = Luts.Sound.IntervalSound, Luts.Settings = [], Luts.Setting = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt) {
    this.name = dataAndEvents;
    this.value = Luts.Store.getItem('setting_' + dataAndEvents, deepDataAndEvents);
    this.description = ignoreMethodDoesntExist;
    this.longDescription = textAlt;
    this.onChanged = new Phaser.Signal;
    Luts.Settings.push(this);
}, Luts.Setting.prototype.constructor = Luts.Setting, Luts.Setting.prototype.set = function (dataAndEvents) {
    this.value = dataAndEvents;
    this.save();
    this.onChanged.dispatch(this);
}, Luts.Setting.prototype.toggle = function () {
    this.set(!this.value);
}, Luts.getSetting = function (dataAndEvents) {

    var unlock = 0;
    for (; unlock < Luts.Settings.length; unlock++) {
        if (Luts.Settings[unlock].name == dataAndEvents) {
            return Luts.Settings[unlock];
        }
    }
    return null;
}, Luts.Setting.prototype.save = function () {
    Luts.Store.setItem('setting_' + this.name, this.value);
}, Luts.Ad = {}, Luts.Ad.init = function () {

    Luts.Ad.requested = false;

    Luts.Ad.enabled = false;
    Luts.Events.onAdEnded = new(Phaser.Signal);
    if (Luts.Connect.crazygames) {

        Luts.Ad.enabled = true;
        Luts.Connect.crazygames.addEventListener("adStarted", Luts.Ad.adStart);
        Luts.Connect.crazygames.addEventListener('adError', Luts.Ad.adError);
        Luts.Connect.crazygames.addEventListener('adFinished', Luts.Ad.adEnd);
    }
}, Luts.Ad.requestAd = function () {
    if (Luts.Ad.enabled) {

        Luts.Ad.requested = true;
        if (Luts.Connect.crazygames) {
            Luts.Connect.crazygames.requestAd();
        }
    }
}, Luts.Ad.adStart = function () {
    if (Luts.Sound.enabled) {
        Luts.Ad.soundEnabled = Luts.Sound.enabled.value;

        Luts.Sound.enabled.value = false;

        Luts.Ad.soundSaved = true;
    }

    Luts.gamePaused = true;
}, Luts.Ad.adEnd = function () {
    if (Luts.Ad.soundSaved) {
        Luts.Sound.enabled.value = Luts.Ad.soundEnabled;
    }

    Luts.Ad.requested = false;

    Luts.gamePaused = false;

    Luts.Ad.soundSaved = false;
    Luts.Events.onAdEnded.dispatch(true);
}, Luts.Ad.adError = function () {
    if (Luts.Ad.soundSaved) {
        Luts.Sound.enabled.value = Luts.Ad.soundEnabled;
    }

    Luts.Ad.requested = false;

    Luts.gamePaused = false;

    Luts.Ad.soundSaved = false;
    Luts.Events.onAdEnded.dispatch(false);
}, Luts.Object.Text = function (dataAndEvents, deepDataAndEvents, opt_obj2, ctag, basis, otag, fill) {
    if (null == fill) {
        fill = '#ffffff';
    }

    this.rawText = basis;

    this.baseColor = fill;

    this.size = otag;

    this.fnt = ctag;

    this.oldText = basis;

    this.hasChanged = true;
    if (basis.e) {
        basis = Luts.Format.Decimal(basis);
    }
    basis = this.handleTags();
    Phaser.Text.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2, basis, {
        "font": otag + "px " + ctag,
        "fill": fill
    });
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;
    this.fontWeight = 'bold';

    this.smoothed = true;

    this.wordWrapWidth = 1E3;

    this.wordWrap = true;

    this.strokeThickness = otag / 10;

    this.resolution = 1;
    this.applyColors();
    Luts.Events.onAfterResize.add(function (dataAndEvents) {
        var points = this.parent;

        var val = 1;
        for (; points && points.scale;) {
            val *= points.scale.x;
            points = points.parent;
        }

        this.resolution = val / this.state.world.scale.x * Luts.res;
    }, this);
}, Luts.Object.Text.prototype.constructor = Luts.Object.Text, Luts.Object.Text.prototype = Object.create(Phaser.Text.prototype), Luts.Object.Text.prototype.update = function () {}, Luts.Object.Text.prototype.setText = function (basis) {
    if (basis.e) {
        basis = Luts.Format.Decimal(basis);
    }

    this.rawText = basis;
    this.text = this.handleTags();
    this.applyColors();
    if (this.oldText != this.text) {

        this.hasChanged = true;
        this.oldText = this.text;
    }
}, Luts.Object.Text.prototype.applyColors = function () {
    this.clearColors();

    var unlock = 0;
    for (; unlock < this.colors2.length; unlock++) {
        var cache = this.colors2[unlock];
        this.addColor(cache.color, cache.start);
        this.addColor(this.baseColor, cache.end);
    }
}, Luts.Object.Text.prototype.handleTags = function () {

    this.colors2 = [];
    var remaining = this.rawText;
    var it = {
        "remaining": remaining,
        "changed": false
    };
    do {
        it = this.handleSingleTag(it.remaining);
    } while (it.changed);
    return it.remaining;
}, Luts.Object.Text.prototype.handleSingleTag = function (eventHandlers) {
    var viewportL = {
        "remaining": eventHandlers,
        "changed": false
    };
    if ('string' != typeof eventHandlers) {
        return viewportL;
    }
    var event = eventHandlers.indexOf("<");
    var camelKey = eventHandlers.indexOf(">");
    if (-1 != event && -1 != camelKey) {
        var data = eventHandlers.substring(event, camelKey);
        var pos = data.indexOf("c");
        var i = (data.substr(pos, 1), data.indexOf("="));
        if (-1 != i) {
            this.colors2.push({
                "color": data.substring(i + 1, camelKey),
                "start": event
            });
        } else {
            this.colors2[this.colors2.length - 1].end = event;
        }
        viewportL.remaining = eventHandlers.substring(0, event) + eventHandlers.substring(camelKey + 1);

        viewportL.changed = true;
    }
    return viewportL;
}, Luts.Object.Text.prototype.preUpdate = function () {
    if (this.worldVisible) {
        Phaser.Text.prototype.preUpdate.call(this);
    }
}, Luts.Object.Text.prototype.postUpdate = function () {
    if (this.worldVisible) {
        Phaser.Text.prototype.postUpdate.call(this);
    }
}, Luts.Object.Text.prototype._renderWebGL = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Text.prototype._renderWebGL.call(this, deepDataAndEvents);
    }
}, Luts.Object.Text.prototype._Canvas = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Text.prototype._Canvas.call(this, deepDataAndEvents);
    }
}, Luts.Object.Tab = function (dataAndEvents, deepDataAndEvents, opt_obj2, ignoreMethodDoesntExist) {
    Phaser.Image.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2);
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;
    this.name = ignoreMethodDoesntExist;
}, Luts.Object.Tab.prototype.constructor = Luts.Object.Tab, Luts.Object.Tab.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Tab.prototype.update = function () {
    this.children.forEach(function (dataAndEvents) {
        dataAndEvents.update();
    } ['bind'](this));
}, Luts.Object.Tab.prototype.showExclamation = function () {
    if (!this.visible) {

        this.exclamation.alpha = 1;
        this.exclamation.scale.set(1);
        this.game.add.tween(this.exclamation).from({
            "alpha": 0
        }, 500, Phaser.Easing.Linear.None, true);
        this.game.add.tween(this.exclamation.scale).from({
            "x": 5,
            "y": 5
        }, 3E3, Phaser.Easing.Elastic.Out, true);
    }
}, Luts.Object.TabManager = function (dataAndEvents, v, sum) {
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;
    this.x = v;
    this.y = sum;

    this.tabs = [];

    this.tabButtons = [];
}, Luts.Object.TabManager.prototype.constructor = Luts.Object.TabManager, Luts.Object.TabManager.prototype.add = function (dataAndEvents) {
    var dep = new(Luts.Object.Tab)(this.state, this.x, this.y, dataAndEvents);
    return this.tabs.push(dep), dep;
}, Luts.Object.TabManager.prototype.show = function (owner) {
    this.tabs.forEach(function (dataAndEvents) {

        dataAndEvents.visible = false;
    } ['bind'](this));
    this.tabButtons.forEach(function (dataAndEvents) {
        dataAndEvents.setActive(true);
    } ['bind'](this));
    var unlock = this.get(owner);

    unlock.visible = true;
    if (unlock.tabButton) {
        unlock.tabButton.setActive(false);
    }
    if (unlock.exclamation) {

        unlock.exclamation.alpha = 0;
    }
}, Luts.Object.TabManager.prototype.get = function (refetch) {
    if ('string' != typeof refetch) {
        return refetch;
    }

    var unlock = 0;
    for (; unlock < this.tabs.length; unlock++) {
        var cache = this.tabs[unlock];
        if (cache.name == refetch) {
            return cache;
        }
    }
    return null;
}, Luts.Object.TabManager.prototype.createTabButtons = function (offset, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {

    this.tabButtons = [];

    var sliceLength = deepDataAndEvents / this.tabs.length;

    var i = 0;
    for (; i < this.tabs.length; i++) {
        var old = this.tabs[i];
        var r20 = new Luts.Object.Button(this.state, offset + i * sliceLength, dataAndEvents + ignoreMethodDoesntExist / 2, old.name, "");
        r20.setFrames('buttonMiddleActive', "buttonMiddleInactive");
        r20.setFontSize(18);

        r20.fixedToCamera = true;
        this.setTabButton(old, r20);
    }
}, Luts.Object.TabManager.prototype.setTabButton = function (row, data) {
    data.callback = function (dataAndEvents) {
        this.show(dataAndEvents.tab);
    } ['bind'](this);
    row = this.get(row);
    this.tabButtons.push(data);

    data.tab = row;

    row.tabButton = data;
}, Luts.Object.Scrollable = function (dataAndEvents, deepDataAndEvents, opt_obj2, depth, v) {
    Phaser.Image.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2);
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;

    this.w = depth;
    this.h = v;
    this.scrollGroup = this.game.add.group();
    this.addChild(this.scrollGroup);
    this.scrollMask = this.game.add.graphics();
    this.addChild(this.scrollMask);
    this.scrollMask.beginFill(0);
    this.scrollMask.drawRect(0, 0, depth, v);
    this.scrollMask.endFill();
    this.scrollGroup.mask = this.scrollMask;
    this.createScrollbar(depth - 6, 6);
    Luts.Events.onMouseWheel.add(function () {
        this.scroll(this.game.input.mouse.wheelDelta * this.mouseWheelSpeed);
    }, this);

    this.mouseWheelSpeed = 42.5;

    this.inputEnabled = true;
    this.events.onInputDown.add(function (dataAndEvents, deepDataAndEvents) {
        this.lastY = this.game.input.y;
        this.lastGroupY = this.scrollGroup.y;

        this.dragging = true;
    }, this);
    this.game.input.onUp.add(function () {

        this.dragging = false;
    }, this);
}, Luts.Object.Scrollable.prototype.constructor = Luts.Object.Scrollable, Luts.Object.Scrollable.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Scrollable.prototype.update = function () {
    this.children.forEach(function (dataAndEvents) {
        dataAndEvents.update();
    } ["bind"](this));
    this.scrollGroup.children.forEach(function (params) {
        var param = params.visible;

        params.visible = params.bottom + this.scrollGroup.y > 0 && params.top + this.scrollGroup.y < this.h;
        if (params.visible && !param) {
            this.game.add.existing(params);
            this.scrollGroup.add(params);
        } else {
            if (param) {
                this.game.world.remove(params);
            }
        }
    } ['bind'](this));
    if (this.scrollGroup.worldVisible) {
        if (this.dragging) {
            this.previousY = this.scrollGroup.y;
            this.scrollGroup.y = this.lastGroupY + (this.game.input.y - this.lastY);

            this.speed = this.scrollGroup.y - this.previousY;
        } else {
            if (this.speed) {
                this.scrollGroup.y += this.speed;
                this.speed *= 0.9;
            }
        }
        if (!this.dragging) {
            this.scrollGroup.y = this.smoothClamp(this.scrollGroup.y, 0, this.h - this.getBottom());
        }

        this.scrollBar.scale.y = this.h / this.getTotalHeight();

        this.normalizedY = this.scrollGroup.y / (this.h - this.getTotalHeight());

        this.scrollBar.maxY = this.h - this.scrollBar.height;

        this.scrollBar.y = this.normalizedY * this.scrollBar.maxY;
        if (this.scrollBar.scale.y >= 1) {

            this.scrollGroup.y = 0;
        }
    }
}, Luts.Object.Scrollable.prototype.scroll = function (dataAndEvents) {
    if (this.scrollGroup.worldVisible) {
        this.scrollGroup.y += dataAndEvents;
    }
}, Luts.Object.Scrollable.prototype.addToScrollGroup = function (deepDataAndEvents) {
    this.scrollGroup.add(deepDataAndEvents);
}, Luts.Object.Scrollable.prototype.smoothClamp = function (x, chartWidth, canvasWidth, f) {
    return f = f || 0.3, x < canvasWidth && (x += (canvasWidth - x) * f), x > chartWidth && (x += (chartWidth - x) * f), x;
}, Luts.Object.Scrollable.prototype.getBottom = function () {

    var key = 0;
    return this.scrollGroup.children.forEach(function (keys) {
        if (keys.bottom > key) {
            key = keys.bottom;
        }
    } ['bind'](this)), key + 140;
}, Luts.Object.Scrollable.prototype.getTop = function () {

    var node = 0;
    return this.scrollGroup.children.forEach(function (opt_nodes) {
        if (opt_nodes.top < node) {
            node = opt_nodes.top;
        }
    } ['bind'](this)), node;
}, Luts.Object.Scrollable.prototype.getTotalHeight = function () {
    return this.getBottom() - this.getTop();
}, Luts.Object.Scrollable.prototype.createScrollbar = function (deepDataAndEvents, opt_obj2) {
    this.scrollBarBack = this.game.add.graphics(deepDataAndEvents, 0);
    this.addChild(this.scrollBarBack);
    this.scrollBarBack.beginFill(0, 0.1);
    this.scrollBarBack.drawRect(0, 0, opt_obj2, this.h);
    this.scrollBarBack.endFill();
    this.scrollBarMask = this.game.add.graphics(deepDataAndEvents, 0);
    this.addChild(this.scrollBarMask);
    this.scrollBarMask.beginFill(0);
    this.scrollBarMask.drawRect(0, 0, opt_obj2, this.h);
    this.scrollBarMask.endFill();
    this.scrollBar = this.game.add.graphics(deepDataAndEvents, 0);
    this.addChild(this.scrollBar);
    this.scrollBar.beginFill(0, 0.5);
    this.scrollBar.drawRect(0, 0, opt_obj2, this.h);
    this.scrollBar.endFill();
    this.scrollBar.mask = this.scrollBarMask;

    this.scrollBar.minY = 0;

    this.scrollBar.maxY = this.h - this.scrollBar.height;
}, Luts.Object.Button = function (dataAndEvents, deepDataAndEvents, opt_obj2, ignoreMethodDoesntExist, c, textAlt) {
    Phaser.Image.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2, "ui", "buttonMiddle_active");
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;
    this.callback = textAlt;
    this.activeFrame = 'buttonMiddle_active';

    this.inactiveFrame = "buttonMiddle_inactive";
    this.anchor.set(0.5);

    this.active = true;

    this.lock = null;
    this.onChanged = new(Phaser.Signal);

    this.baseScale = 1;
    this.icon = this.game.add.image(0, 0);
    this.icon.anchor.set(0.5);
    this.addChild(this.icon);
    this.text = new(Luts.Object.Text)(this.state, 0, -10, "text", ignoreMethodDoesntExist, Luts.Object.Button.FONT_SIZE_TITLE, '#000000');
    this.text.anchor.set(0.5);

    this.text.strokeThickness = 0;
    this.addChild(this.text);
    if ("" == c) {

        this.text.y = -5;
    }
    this.subtitle = new Luts.Object.Text(this.state, 0, Luts.Object.Button.FONT_SIZE_SUBTITLE - 8, 'regular', c, Luts.Object.Button.FONT_SIZE_SUBTITLE, "#000000");
    this.subtitle.anchor.set(0.5);

    this.subtitle.strokeThickness = 0;
    this.addChild(this.subtitle);
    this.lockIcon = this.game.add.image(0, 0, "ui", 'lock');
    this.lockIcon.anchor.set(0.5);

    this.lockIcon.visible = false;
    this.addChild(this.lockIcon);
    new(Luts.Object.Tooltip)(this.state, this.lockIcon, 'Locked');

    this.inputEnabled = true;

    this.mouseIsOver = false;

    this.downCounter = 0;

    this.downCounterMax = 15;

    this.downIntervalMax = 15;

    this.downInterval = 15;

    this.downIntervalCounter = 0;

    this.pulseTween = null;
    this.events.onInputDown.add(function () {
        if (Luts.dcfix) {
            this.down(true);
        }
    }, this);
    this.events.onInputUp.add(function (dataAndEvents) {

        this.isDown = false;
        if (Luts.dcfix) {
            this.click(true);
        }
    }, this);
    this.events.onInputOver.add(function () {

        this.mouseIsOver = true;
        if (this.active) {
            if (this.isUnlocked()) {
                if (this.pulseTween) {
                    this.pulseTween.stop();
                }
                this.scale.set(1 * this.baseScale);
                this.game.add.tween(this.scale).to({
                    "x": 1.05 * this.baseScale,
                    "y": 1.05 * this.baseScale
                }, 500, Phaser.Easing.Elastic.Out, true);
            }
        }
    }, this);
    this.events.onInputOut.add(function () {

        this.mouseIsOver = false;
        if (this.scale.x > 1 * this.baseScale) {
            if (this.pulseTween) {
                this.pulseTween.stop();
            }
            this.scale.set(1 * this.baseScale);
            this.game.add.tween(this.scale).from({
                "x": 1.05 * this.baseScale,
                "y": 1.05 * this.baseScale
            }, 500, Phaser.Easing.Elastic.Out, true);
        }
    }, this);
    Luts.Events.onUpdate.add(this.updateDown, this);
}, Luts.Object.Button.FONT_SIZE_TITLE = 18, Luts.Object.Button.FONT_SIZE_SUBTITLE = 16, Luts.Object.Button.prototype.constructor = Luts.Object.Button, Luts.Object.Button.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Button.prototype.updateDown = function () {
    this.isDown = this.isDown && (Luts.isActive && this.mouseIsOver);
    if (this.isDown) {
        if (this.active) {
            if (this.visible) {
                this.downCounter += 1;
                if (this.downCounter > this.downCounterMax) {
                    this.downIntervalCounter += 1;
                    if (this.downIntervalCounter > this.downInterval) {

                        this.downIntervalCounter = 0;
                        this.downInterval -= 0.2;
                        this.callback(this);
                    }
                }
            }
        }
    }
}, Luts.Object.Button.prototype.setKey = function (deepDataAndEvents) {
    this.game.input.keyboard.addKey(deepDataAndEvents).onDown.add(function () {
        this.click(false, true);
    }, this);
}, Luts.Object.Button.prototype.down = function (dataAndEvents, deepDataAndEvents) {
    if (this.visible) {
        if (this.active) {
            if (this.worldVisible || deepDataAndEvents) {
                if (this.isUnlocked()) {
                    if (dataAndEvents) {

                        this.isDown = true;

                        this.downCounter = 0;
                        this.downInterval = this.downIntervalMax;
                        Luts.Sound.play('button');
                    }
                    this.scale.set(0.9 * this.baseScale);
                    this.game.add.tween(this.scale).from({
                        "x": 1 * this.baseScale,
                        "y": 1 * this.baseScale
                    }, 125, Phaser.Easing.Back.Out, true);
                }
            }
        }
    }
}, Luts.Object.Button.prototype.click = function (dataAndEvents, deepDataAndEvents) {
    if (this.visible) {
        if (dataAndEvents) {
            if (!Luts.dcfix) {
                return;
            }
            if (!this.game.device.safari) {
                if (!this.game.device.iOS) {

                    Luts.dcfix = false;
                }
            }
        }
        if (this.active && ((this.worldVisible || deepDataAndEvents) && this.isUnlocked())) {
            if (this.pulseTween) {
                this.pulseTween.stop();
            }

            var _0x5837b6 = 1;
            if (this.mouseIsOver) {

                _0x5837b6 = 1.05;
            }
            this.scale.set(_0x5837b6 * this.baseScale);
            this.game.add.tween(this.scale).from({
                "x": 0.9 * this.baseScale,
                "y": 0.9 * this.baseScale
            }, 500, Phaser.Easing.Back.Out, true);
            if (!(!this.mouseIsOver && dataAndEvents)) {
                this.callback(this);
            }
        }
    }
}, Luts.Object.Button.prototype.setActive = function (actual, dataAndEvents) {
    if (!this.isUnlocked()) {
        return this.showLock(true), void(this.pulseTween && this.pulseTween.stop());
    }
    this.showLock(false);
    var expected = this.active;
    if (expected != actual) {
        this.onChanged.dispatch();
    }
    if (actual) {
        this.frameName = this.activeFrame;

        this.icon.alpha = 1;

        this.text.alpha = 1;

        this.subtitle.alpha = 1;

        this.active = true;
    } else {
        if (this.pulseTween) {
            this.pulseTween.stop();
        }
        this.scale.set(1 * this.baseScale);
        this.frameName = this.inactiveFrame;

        this.icon.alpha = 0.4;

        this.text.alpha = 0.6;

        this.subtitle.alpha = 0.6;

        this.active = false;
    }
    if (!expected) {
        if (actual) {
            if (dataAndEvents) {

                this.angle = 0;
                this.game.add.tween(this).to({
                    "angle": this.game.rnd.between(-10, 10)
                }, 125, Phaser.Easing.Sinusoidal.InOut, true, 0, 2, true);
                if (this.pulseTween) {
                    this.pulseTween.stop();
                }
                this.pulseTween = this.game.add.tween(this.scale).to({
                    "x": 0.9 * this.baseScale,
                    "y": 0.9 * this.baseScale
                }, 250, Phaser.Easing.Sinusoidal.InOut, true, 0, 1E3, true);
            }
        }
    }
}, Luts.Object.Button.prototype.setFrames = function (dataAndEvents, deepDataAndEvents) {
    this.activeFrame = dataAndEvents;
    this.inactiveFrame = deepDataAndEvents;
    this.setActive(this.active);
}, Luts.Object.Button.prototype.setFontSize = function (dataAndEvents, layer1) {
    this.text.fontSize = dataAndEvents;
    if (layer1) {

        this.subtitle.fontSize = layer1;

        this.subtitle.y = layer1 - 3;
    }
}, Luts.Object.Button.prototype.isUnlocked = function () {
    return null == this.lock || this.lock.unlocked;
}, Luts.Object.Button.prototype.showLock = function (dataAndEvents) {
    this.lockIcon.visible = dataAndEvents;
    if (this.lock) {
        if (dataAndEvents) {
            this.frameName = this.inactiveFrame;

            this.icon.alpha = 0.2;

            this.text.alpha = 0;

            this.subtitle.alpha = 0;
        }
    }
}, Luts.Object.Button.prototype.setLock = function (deepDataAndEvents) {
    this.lock = Luts.Lock.get(deepDataAndEvents);
    if (this.lock) {
        this.setActive(this.active);
        this.lock.onUnlocked.add(function () {

            this.active = false;
            this.setActive(true, true);
        }, this);
        this.lock.onLocked.add(function () {

            this.active = true;
            this.setActive(false, true);
        }, this);
    }
}, Luts.Object.Bar = function (item, opt_obj2, walkers, isXML, deepDataAndEvents) {
    Phaser.Image.call(this, item.game, opt_obj2, walkers, "ui", isXML);
    item.game.add.existing(this);
    this.game = item.game;

    this.state = item;
    this.bar = this.game.add.image(0, 0, "ui", deepDataAndEvents);
    this.bar.crop(new(Phaser.Rectangle)(0, 0, this.width, this.height));

    this.bar.w = 0;
    this.addChild(this.bar);
    this.effectBar = this.game.add.image(this.bar.width / 2, this.bar.height / 2, "ui", deepDataAndEvents);

    this.effectBar.alpha = 0;
    this.effectBar.anchor.set(0.5);
    this.addChild(this.effectBar);

    this.effectPlaying = false;
    this.barText = new(Luts.Object.Text)(this.state, this.width / 2, this.height / 2 - 5, 'regular', "100%", 16, '#000000');
    this.barText.anchor.set(0.5);

    this.barText.strokeThickness = 0;
    this.addChild(this.barText);

    this.dirty = true;
}, Luts.Object.Bar.prototype.constructor = Luts.Object.Bar, Luts.Object.Bar.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Bar.prototype.update = function () {
    if (this.dirty) {

        this.dirty = false;

        this.bar.cropRect.width = Math.max(0.01, this.bar.w) * this.width;
        this.bar.updateCrop();
    }
}, Luts.Object.Bar.prototype.stepTo = function (basis, dataAndEvents) {

    basis = parseFloat(basis.toString());
    basis = Phaser.Math.clamp(basis, 0, 1);
    this.bar.w += (basis - this.bar.w) * (dataAndEvents || 0.1);

    this.dirty = true;
}, Luts.Object.Bar.prototype.setTo = function (basis) {
    basis = Phaser.Math.clamp(basis, 0, 1);

    this.bar.w = basis;

    this.dirty = true;
}, Luts.Object.Bar.prototype.playCompletedEffect = function () {
    if (!this.effectPlaying && Luts.isActive) {

        this.effectPlaying = true;

        this.effectBar.alpha = 0;
        this.effectBar.scale.set(1.1);
        this.game.add.tween(this.effectBar).from({
            "alpha": 0.5
        }, 500, Phaser.Easing.Linear.None, true);
        this.game.add.tween(this.effectBar.scale).from({
            "x": 1,
            "y": 1
        }, 500, Phaser.Easing.Linear.None, true).onComplete.add(function () {

            this.effectPlaying = false;
        }, this);
    }
}, Luts.Object.Popup = function (dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, $sanitize) {
    Phaser.Image.call(this, dataAndEvents.game, Luts.GAME_WIDTH / 2, Luts.GAME_HEIGHT / 2, "ui", 'label');
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;

    this.state = dataAndEvents;
    this.anchor.set(0.5);
    this.state.setResponsive(this);

    this.dead = false;
    this.blackPlane = this.game.add.graphics();
    this.blackPlane.beginFill(0, 0.5);
    this.blackPlane.drawRect(0, 0, Luts.GAME_WIDTH, Luts.GAME_HEIGHT);
    this.blackPlane.endFill();

    this.blackPlane.inputEnabled = true;
    this.state.setResponsive(this.blackPlane, {
        "scaleWithGame": true
    });
    this.parent.swapChildren(this, this.blackPlane);
    this.text = new(Luts.Object.Text)(this.state, 0, -40, "text", deepDataAndEvents, 14, "#000000");
    this.text.anchor.set(0.5);

    this.text.strokeThickness = 0;

    this.text.wordWrapWidth = 0.8 * this.rWidth;
    this.addChild(this.text);
    this.yesButton = new(Luts.Object.Button)(dataAndEvents, 0, 70, "Ok", "", function () {
        if (!this.dead) {
            if ($sanitize) {
                $sanitize(true);
            }
            this.die();
        }
    } ["bind"](this));
    this.addChild(this.yesButton);
    if (ignoreMethodDoesntExist) {

        this.yesButton.x = -70;
        this.noButton = new(Luts.Object.Button)(dataAndEvents, 70, 70, "No", "", function () {
            if (!this.dead) {
                if ($sanitize) {
                    $sanitize(false);
                }
                this.die();
            }
        } ['bind'](this));
        this.addChild(this.noButton);
    }
    this.tw1 = this.game.add.tween(this.scale).from({
        "x": 0
    }, 1E3, Phaser.Easing.Elastic.Out, true);
    this.tw2 = this.game.add.tween(this.scale).from({
        "y": 0
    }, 1E3, Phaser.Easing.Elastic.Out, true);
    this.tw3 = this.game.add.tween(this.blackPlane).from({
        "alpha": 0
    }, 250, Phaser.Easing.Linear.None, true);
}, Luts.Object.Popup.prototype.constructor = Luts.Object.Popup, Luts.Object.Popup.prototype = Object.create(Phaser.Sprite.prototype), Luts.Object.Popup.prototype.update = function () {}, Luts.Object.Popup.prototype.die = function () {
    this.tw1.stop();
    this.tw2.stop();
    this.tw3.stop();

    this.dead = true;
    this.game.add.tween(this.scale).to({
        "x": 0,
        "y": 0
    }, 500, Phaser.Easing.Back.In, true);
    this.game.add.tween(this.blackPlane).to({
        "alpha": 0
    }, 500, Phaser.Easing.Linear.None, true).onComplete.add(function () {
        this.blackPlane.destroy();

        this.visible = false;
        this.destroy();
    }, this);
}, Luts.Object.FloatingText = function (item, deepDataAndEvents, opt_obj2, dataAndEvents, ignoreMethodDoesntExist) {
    Phaser.Image.call(this, item.game, deepDataAndEvents, opt_obj2);
    item.game.add.existing(this);
    this.game = item.game;

    this.state = item;
    this.anchor.set(0.5);
    this.text = new(Luts.Object.Text)(item, 0, 0, 'text', dataAndEvents, 60, ignoreMethodDoesntExist);
    this.text.anchor.set(0.5);
    this.addChild(this.text);
    this.game.add.tween(this).to({
        "alpha": 0
    }, 1E3, Phaser.Easing.Sinusoidal.Out, true).onComplete.add(function () {
        this.destroy();
    }, this);
    this.game.add.tween(this).to({
        "y": this.y - this.game.rnd.between(15, 30)
    }, 500, Phaser.Easing.Sinusoidal.InOut, true, 0, 2, true);
    this.game.add.tween(this).to({
        "x": this.x - this.game.rnd.between(-30, 30)
    }, 1E3, Phaser.Easing.Sinusoidal.InOut, true, 0);
}, Luts.Object.FloatingText.prototype.constructor = Luts.Object.FloatingText, Luts.Object.FloatingText.prototype = Object.create(Phaser.Image.prototype), Luts.Object.FloatingText.prototype.update = function () {}, Luts.Object.Tooltip = function (self, row, dataAndEvents) {
    Phaser.Graphics.call(this, self.game, row.x, row.y);
    self.game.add.existing(this);
    this.game = self.game;

    this.state = self;

    this.object = row;

    this.object.inputEnabled = true;

    this.fixedToCamera = true;

    this.textFunction = null;
    this.textString = dataAndEvents;
    if ('function' == typeof dataAndEvents) {
        this.textFunction = dataAndEvents;
        this.textString = this.getText();
    }
    this.g = this.game.add.graphics();
    this.addChild(this.g);
    this.text = new(Luts.Object.Text)(this.state, 0, 0, "text", this.textString, 20);

    this.text.wordWrapWidth = 200;
    this.addChild(this.text);
    this.g.beginFill(0);
    this.g.drawRect(-5, -5, this.text.width + 10, this.text.height + 10);
    this.g.endFill();

    this.alpha = 0;

    this.isOver = false;

    this.counter = 0;

    this.maxCounter = 600;
    row.events.onInputOver.add(function () {
        if (!(this.object.lock && !this.object.lock.unlocked)) {
            this.game.add.existing(this);

            this.isOver = true;
            this.setPosition();
        }
    }, this);
    row.events.onInputOut.add(function () {

        this.isOver = false;
    }, this);
}, Luts.Object.Tooltip.prototype.constructor = Luts.Object.Tooltip, Luts.Object.Tooltip.prototype = Object.create(Phaser.Graphics.prototype), Luts.Object.Tooltip.prototype.update = function () {
    if (this.isOver) {
        if (!this.object.getBounds().contains(this.game.input.x, this.game.input.y)) {

            this.isOver = false;
        }
        if (this.counter++ >= this.maxCounter) {

            this.isOver = false;

            this.counter = 0;
        }
        this.text.setText(this.getText());
        if (this.text.hasChanged) {

            this.text.hasChanged = false;
            this.resizeBackground();
        }
        this.alpha += 0.04 * (1 - this.alpha) * 60 / (this.game.time.fps || 60);
    } else {
        this.alpha += 0.2 * (0 - this.alpha) * 60 / (this.game.time.fps || 60);
        if (this.alpha < 0.01) {

            this.alpha = 0;
        }
    }
    if (this.alpha > 0) {
        this.setPosition();
    }

    this.renderable = this.alpha > 0;
    this.visible = this.renderable;
    if (!this.visible) {
        this.game.world.remove(this);
    }
}, Luts.Object.Tooltip.prototype.preUpdate = function () {
    if (this.worldVisible) {
        Phaser.Graphics.prototype.preUpdate.call(this);
    }
}, Luts.Object.Tooltip.prototype.postUpdate = function () {
    if (this.worldVisible) {
        Phaser.Graphics.prototype.postUpdate.call(this);
    }
}, Luts.Object.Tooltip.prototype._renderCanvas = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Graphics.prototype._renderCanvas.call(this, deepDataAndEvents);
    }
}, Luts.Object.Tooltip.prototype._renderWebGL = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Graphics.prototype._renderWebGL.call(this, deepDataAndEvents);
    }
}, Luts.Object.Tooltip.prototype.setPosition = function () {
    var r20 = this.game.input.x + 20;
    var topY = this.game.input.y;
    topY = Phaser.Math.clamp(topY, 0, this.game.height - this.text.height);
    if (r20 + this.text.width > this.game.width) {
        r20 -= this.text.width + 30;
    }
    this.cameraOffset.set(r20, topY);
}, Luts.Object.Tooltip.prototype.getText = function () {
    return null != this.textFunction ? this.textFunction() : this.textString;
}, Luts.Object.Tooltip.prototype.setText = function (dataAndEvents) {
    this.textString = dataAndEvents;
    if ('function' == typeof dataAndEvents) {
        this.textFunction = dataAndEvents;
        this.textString = this.getText();
    }
}, Luts.Object.Tooltip.prototype.resizeBackground = function () {
    this.g.clear();
    this.g.beginFill(0);
    this.g.drawRect(-5, -5, this.text.width + 10, this.text.height + 10);
    this.g.endFill();
}, Luts.Object.Window = function (self, dataAndEvents) {
    Phaser.Image.call(this, self.game, 150, 50, "ui", "labelBig");
    self.game.add.existing(this);
    this.game = self.game;

    this.state = self;
    this.state.groupUI.add(this);

    this.inputEnabled = true;
    this.state.setResponsive(this);

    this.toggleTween = null;

    this.shown = true;

    this.visible = false;
    this.title = new(Luts.Object.Text)(self, this.rWidth / 2, 40, 'text', dataAndEvents, 50);
    this.title.anchor.set(0.5);
    this.addChild(this.title);
    this.closeButton = new(Luts.Object.Button)(self, 580, 50, "", "", this.toggle.bind(this));
    this.closeButton.setFrames('closeButton', 'closeButton');
    this.addChild(this.closeButton);
    this.toggle();
    this.init();
}, Luts.Object.Window.prototype.constructor = Luts.Object.Window, Luts.Object.Window.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Window.prototype.init = function () {}, Luts.Object.Window.prototype.toggle = function () {

    this.shown = !this.shown;
    if (this.toggleTween) {
        this.toggleTween.stop();
    }
    if (this.shown) {
        this.game.add.existing(this);
        this.state.groupUI.add(this);
        this.bringToTop();
        this.scale.set(1 * this.state.lastScale);

        this.visible = true;

        this.renderable = true;
        this.toggleTween = this.game.add.tween(this.scale).from({
            "x": 0,
            "y": 0
        }, 250, Phaser.Easing.Back.Out, true);
    } else {
        this.scale.set(0);
        this.toggleTween = this.game.add.tween(this.scale).from({
            "x": this.state.lastScale,
            "y": this.state.lastScale
        }, 250, Phaser.Easing.Back.In, true);
        this.toggleTween.onComplete.add(function () {
            this.game.world.remove(this);

            this.visible = false;

            this.renderable = false;
        }, this);
    }
}, Luts.Object.Window.prototype.preUpdate = function () {
    if (this.worldVisible) {
        Phaser.Image.prototype.preUpdate.call(this);
    }
}, Luts.Object.Window.prototype.postUpdate = function () {
    if (this.worldVisible) {
        Phaser.Image.prototype.postUpdate.call(this);
    }
}, Luts.Object.Window.prototype._renderCanvas = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Image.prototype._renderCanvas.call(this, deepDataAndEvents);
    }
}, Luts.Object.Window.prototype._renderWebGL = function (deepDataAndEvents) {
    if (this.worldVisible) {
        Phaser.Image.prototype._renderWebGL.call(this, deepDataAndEvents);
    }
}, Luts.Object.BuyAmountButtons = function (dataAndEvents, opt_obj2, walkers, deepDataAndEvents, textAlt, ignoreMethodDoesntExist) {
    Phaser.Image.call(this, dataAndEvents.game, opt_obj2, walkers);
    this.state = dataAndEvents;
    dataAndEvents.game.add.existing(this);

    this.buyAmountButtons = [];
    this.buyId = ignoreMethodDoesntExist;

    var _0x395022 = 0;
    deepDataAndEvents.forEach(function (deepDataAndEvents) {
        this.addBuyAmountButton(45 * _0x395022++, deepDataAndEvents);
    } ['bind'](this));
    if (textAlt) {
        this.addBuyAmountButton(45 * _0x395022, -1);
    }
    this.setBuyAmount(Luts.Upgrades.buyAmount[this.buyId]);
    this.title = new(Luts.Object.Text)(this.state, -20, -35, 'text', "Buy: ", 12, '#000000');

    this.title.strokeThickness = 0;
    this.addChild(this.title);
}, Luts.Object.BuyAmountButtons.prototype.constructor = Luts.Object.BuyAmountButtons, Luts.Object.BuyAmountButtons.prototype = Object.create(Phaser.Image.prototype), Luts.Object.BuyAmountButtons.prototype.addBuyAmountButton = function (timeout, actualObject) {

    var object = actualObject;
    if (-1 == actualObject) {
        object = 'max';
    }
    var waitsFunc = new(Luts.Object.Button)(this.state, timeout, 0, object, "", function (dataAndEvents) {
        this.setBuyAmount(dataAndEvents.amount);
    } ['bind'](this));

    waitsFunc.amount = actualObject;

    waitsFunc.baseScale = 0.7;
    waitsFunc.scale.set(0.7);
    waitsFunc.setFrames('buttonSmall_active', 'buttonSmall_inactive');
    this.buyAmountButtons.push(waitsFunc);
    this.addChild(waitsFunc);
}, Luts.Object.BuyAmountButtons.prototype.setBuyAmount = function (deepDataAndEvents) {
    this.buyAmountButtons.forEach(function (model) {
        model.setActive(model.amount != deepDataAndEvents);
    });
    Luts.Upgrades.setBuyAmount(deepDataAndEvents, this.buyId);
}, Luts.Object.Slider = function (dataAndEvents, deepDataAndEvents, opt_obj2, ignoreMethodDoesntExist) {
    Phaser.Image.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2, "ui", 'sliderBack');
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;

    this.inputEnabled = true;
    this.anchor.set(0, 0.5);
    this.value = ignoreMethodDoesntExist;
    this.knob = this.game.add.image(this.value * this.width, 5, "ui", 'sliderKnob');
    this.knob.anchor.set(0.5);
    this.addChild(this.knob);
    this.onChange = new(Phaser.Signal);
    Luts.Events.onUpdate.add(this.update, this);
    this.events.onInputDown.add(function () {

        this.isDown = true;
    }, this);

    this.isDown = false;

    this.wasDown = false;
}, Luts.Object.Slider.prototype.constructor = Luts.Object.Slider, Luts.Object.Slider.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Slider.prototype.update = function () {
    if (this.worldVisible) {
        if (!this.state.input.activePointer.isDown) {

            this.isDown = false;
        }
        if (this.isDown) {
            this.knob.x = this.toLocal(new(Phaser.Point)(this.state.input.x, 0)).x;
            this.knob.x = Phaser.Math.clamp(this.knob.x, 0, this.width);

            this.value = this.knob.x / this.width;
        }
        if (this.wasDown) {
            if (!this.isDown) {
                this.onChange.dispatch(this.value);
            }
        }
        this.wasDown = this.isDown;
    }
}, Luts.Object.CreditsWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Credits');
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 70, this.rWidth - 30, this.rHeight - 90);
    this.addChild(this.scroll);

    this.scrollIndex = 0;

    this.texts = [];
    this.getCreditsType("general").forEach(function (dataAndEvents) {
        this.addCredit('Game made by', dataAndEvents.author);
    } ['bind'](this));
    this.scrollIndex++;
    var r20 = new(Luts.Object.Text)(this.state, 10, 40 * this.scrollIndex, 'text', 'Sounds used:', 20, '#000000');

    r20.strokeThickness = 0;
    this.scroll.addToScrollGroup(r20);
    this.scrollIndex++;
    this.getCreditsType('sound').forEach(function (loadedImages) {
        this.addCredit(loadedImages.name, loadedImages.author, loadedImages.url);
    } ['bind'](this));
}, Luts.Object.CreditsWindow.prototype.constructor = Luts.Object.CreditsWindow, Luts.Object.CreditsWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.CreditsWindow.prototype.update = function () {
    if (this.shown) {
        this.scroll.update();
    }
}, Luts.Object.CreditsWindow.prototype.getCreditsType = function (dataAndEvents) {

    var object = [];

    var i = 0;
    for (; i < Luts.Credits.length; i++) {
        if (Luts.Credits[i].type == dataAndEvents) {
            object.push(Luts.Credits[i]);
        }
    }
    return object;
}, Luts.Object.CreditsWindow.prototype.addCredit = function (ignoreMethodDoesntExist, dataAndEvents, deepDataAndEvents) {
    var rreturn = new(Luts.Object.Text)(this.state, 10, 40 * this.scrollIndex, "text", ignoreMethodDoesntExist, 20, "#000000");
    var restoreScript = new Luts.Object.Text(this.state, 550, 40 * this.scrollIndex, 'regular', dataAndEvents, 20, '#000000');
    if (restoreScript.anchor.set(1, 0), deepDataAndEvents) {
        var r20 = new(Luts.Object.Text)(this.state, 550, 40 * this.scrollIndex + 25, "regular", deepDataAndEvents, 10, '#000000');

        r20.strokeThickness = 0;
        r20.anchor.set(1, 0);

        r20.alpha = 0;
        this.scroll.addToScrollGroup(r20);
    }
    return rreturn.strokeThickness = 0, restoreScript.strokeThickness = 0, this.scroll.addToScrollGroup(rreturn), this.scroll.addToScrollGroup(restoreScript), this.texts.push(restoreScript), this.scrollIndex++, restoreScript;
}, Luts.Object.InfoWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, "Statistics");
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 70, this.rWidth - 30, this.rHeight - 90);
    this.addChild(this.scroll);
    this.swapChildren(this.scroll, this.closeButton);

    this.scrollIndex = 0;

    this.texts = [];

    this.updateCounter = 0;

    this.updateInterval = 30;
    this.gameVersion = this.addStatistic('Game Version', Luts.version);
    this.addStatistic("FPS", "", function () {
        return this.game.time.fps;
    } ['bind'](this));
    this.activePlaytime = this.addStatistic('Active Playtime', "", function () {
        return Luts.Format.Time(Luts.Time.activePlaytime);
    });
    this.passivePlaytime = this.addStatistic("Passive Playtime", "", function () {
        return Luts.Format.Time(Luts.Time.passivePlaytime);
    });
    this.offlineGain = this.addStatistic('Avg. Offline Gain per Second', "", function () {
        var r20 = this.state.rollInterval.modValue().toNumber() + this.state.rollAnim.modValue().toNumber();
        return Luts.Format.Decimal(this.state.averagePerSecond().dividedBy(r20));
    } ['bind'](this));
    this.copyButton = new(Luts.Object.Button)(this.state, 70, 50, "Copy", "", this.copyStats.bind(this));
    this.addChild(this.copyButton);
    Luts.Value.values.forEach(function (vert) {
        if (vert.displayName) {
            var pagerNum = this.addStatistic(vert.displayName, "", function () {
                return Luts.Format.Decimal(vert.modValue());
            } ['bind'](this));
            new(Luts.Object.Tooltip)(this.state, pagerNum, function () {
                var _0x5d85fa = Luts.Format.Decimal(vert.v);

                var i = 0;
                for (; i < vert.multipliers.length; i++) {
                    var seg = vert.multipliers[i];
                    _0x5d85fa += " x " + Luts.Format.Decimal(seg.value);
                }
                return _0x5d85fa;
            } ['bind'](this));
        }
    } ['bind'](this));
}, Luts.Object.InfoWindow.prototype.constructor = Luts.Object.InfoWindow, Luts.Object.InfoWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.InfoWindow.prototype.update = function () {
    if (this.shown) {
        if (this.updateCounter++ > this.updateInterval) {

            this.updateCounter = 0;
            this.texts.forEach(function (exports) {
                if (exports.assignFunction) {
                    var val = exports.assignFunction()
                }
                if (null != val) {
                    exports.text = val;
                }
            });
        }
        this.scroll.update();
    }
}, Luts.Object.InfoWindow.prototype.copyStats = function () {

    var x = "";
    this.texts.forEach(function (dataAndEvents) {
        x += dataAndEvents.title.text + ': 	' + dataAndEvents.text + "\n";
    });
    console.log(x);
    document.getElementById("savePrompt").style.display = 'block';
    var mat = document.getElementById('save');
    mat.value = x;
    mat.select();
    document.execCommand('copy');
    document.getElementById('savePrompt').style.display = 'none';
    new(Luts.Object.Popup)(this.state, 'Copied!');
}, Luts.Object.InfoWindow.prototype.addStatistic = function (dataAndEvents, deepDataAndEvents, characters) {
    var key = new(Luts.Object.Text)(this.state, 10, 20 * this.scrollIndex, "text", dataAndEvents, 20, '#000000');
    var groups = new(Luts.Object.Text)(this.state, 600, 20 * this.scrollIndex, "regular", deepDataAndEvents, 20, '#000000');
    return key.strokeThickness = 0, groups.strokeThickness = 0, groups.anchor.set(1, 0), groups.title = key, this.scroll.addToScrollGroup(key), this.scroll.addToScrollGroup(groups), groups.assignFunction = characters, this.texts.push(groups), this.scrollIndex++, groups;
}, Luts.Object.SettingsWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Settings');
    this.exportButton = new(Luts.Object.Button)(deepDataAndEvents, 80, 100, "Export", 'Save', Luts.Save.savePrompt);
    this.addChild(this.exportButton);
    this.importButton = new(Luts.Object.Button)(deepDataAndEvents, 200, 100, 'Import', 'Save', Luts.Save.loadPrompt);
    this.addChild(this.importButton);
    this.hardResetButton = new(Luts.Object.Button)(deepDataAndEvents, 320, 100, 'Hard Reset', "", function () {

        Luts.gamePaused = true;
        new(Luts.Object.Popup)(this.state, 'Are you sure? All of your progress will be lost forever.', true, function (dataAndEvents) {
            if (dataAndEvents) {

                Luts.Store.savingEnabled = false;
                setTimeout(function () {
                    Luts.Storage.clear();
                    window.location.reload(false);
                }, 1E3);
            } else {

                Luts.gamePaused = false;
            }
        } ['bind'](this));
    } ['bind'](this));
    this.addChild(this.hardResetButton);
    this.creditsButton = new(Luts.Object.Button)(deepDataAndEvents, 440, 100, 'Credits', "", function () {
        this.state.creditsClicked();
    } ['bind'](this));
    this.addChild(this.creditsButton);
    this.changeLogButton = new(Luts.Object.Button)(deepDataAndEvents, 560, 100, 'Changelog', "", function () {
        this.state.changelogClicked();
    } ['bind'](this));
    this.addChild(this.changeLogButton);
    this.disclaimerButton = new(Luts.Object.Button)(deepDataAndEvents, 80, 150, 'Disclaimer', "", function () {
        this.state.clickDisclaimer();
    } ["bind"](this));
    this.addChild(this.disclaimerButton);

    this.disclaimerButton.visible = false;
    if (Luts.Connect.kong || Luts.DEBUG) {
        this.cloudSaveButton = new(Luts.Object.Button)(deepDataAndEvents, 200, 150, 'Cloud Save', "", function () {
            Luts.Save.saveToCloud(function () {
                this.cloudSaveButton.setActive(true);
            } ['bind'](this));
            this.cloudSaveButton.setActive(false);
        } ["bind"](this));
        this.addChild(this.cloudSaveButton);
        this.cloudLoadButton = new(Luts.Object.Button)(deepDataAndEvents, 320, 150, 'Cloud Load', "", function () {
            new(Luts.Object.Popup)(deepDataAndEvents, 'Are you sure to load your save from the cloud? You should export your local save first.', true, function (dataAndEvents) {
                if (dataAndEvents) {
                    Luts.Save.loadFromCloud(function () {
                        this.cloudLoadButton.setActive(true);
                    } ['bind'](this));
                    this.cloudLoadButton.setActive(false);
                }
            } ['bind'](this));
        } ['bind'](this));
        this.addChild(this.cloudLoadButton);
    }
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 200, this.rWidth - 30, this.rHeight - 225);
    this.addChild(this.scroll);

    var unlock = 0;
    for (; unlock < Luts.Settings.length; unlock++) {
        var cache = Luts.Settings[unlock];
        this.createSettingEntry(cache, 10, 50 + 50 * unlock);
    }
}, Luts.Object.SettingsWindow.prototype.constructor = Luts.Object.SettingsWindow, Luts.Object.SettingsWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.SettingsWindow.prototype.update = function () {
    if (this.shown) {
        this.scroll.update();
    }
}, Luts.Object.SettingsWindow.prototype.createSettingEntry = function (frame, description, specDefinitions) {
    var suite = new Luts.Object.Text(this.state, description, specDefinitions, 'text', frame.description + ":", 16, "#000000");

    suite.strokeThickness = 0;
    this.scroll.addToScrollGroup(suite);
    if (frame.longDescription) {
        new(Luts.Object.Tooltip)(this.state, suite, frame.longDescription);
    }
    if (!(true !== frame.value && false !== frame.value)) {
        this.createToggleButton(frame, description, specDefinitions);
    }
    if ('number' == typeof frame.value) {
        this.createSlider(frame, description, specDefinitions);
    }
    frame.onChanged.dispatch(frame);
}, Luts.Object.SettingsWindow.prototype.createSlider = function (collection, dataAndEvents, deepDataAndEvents) {
    var arguments_wrapped = new Luts.Object.Slider(this.state, dataAndEvents + 285, deepDataAndEvents + 10, collection.value);
    arguments_wrapped.setting = collection;
    this.scroll.addToScrollGroup(arguments_wrapped);
    arguments_wrapped.onChange.add(function (resp) {
        collection.set(resp);
    });
}, Luts.Object.SettingsWindow.prototype.createToggleButton = function (val, dataAndEvents, deepDataAndEvents) {
    var qs = new(Luts.Object.Button)(this.state, dataAndEvents + 310, deepDataAndEvents + 10, "", "", this.settingClicked);

    qs.setting = val;
    this.scroll.addToScrollGroup(qs);
    val.onChanged.add(function (dataAndEvents) {
        if (dataAndEvents.value) {
            this.setFrames("settings_enabled", "settings_enabled");
        } else {
            this.setFrames('settings_disabled', "settings_disabled");
        }
    } ['bind'](qs));
    if ('autoAscend' == val.name) {
        qs.setLock("autoAscend");
    }
    if ('autoSpin' == val.name) {
        qs.setLock("autoSpin");
    }
    if ('autoRouletteUpgrade' == val.name) {
        qs.setLock('autoRouletteUpgrade');
    }
    if ("autoRouletteFocus" == val.name) {
        qs.setLock('autoRouletteFocus');
    }
    if ('autoDraw' == val.name) {
        qs.setLock('autoDraw');
    }
    if ('autoGild' == val.name) {
        qs.setLock('autoGild');
    }
    if ('focusOnCard' == val.name) {
        qs.setLock('roulette');
    }
    if ("autoConvert" == val.name) {
        qs.setLock("autoConvert");
    }
    if ('autoUpgrade' == val.name) {
        qs.setLock('autoUpgrade');
    }
}, Luts.Object.SettingsWindow.prototype.settingClicked = function () {
    this.setting.toggle();
}, Luts.Object.CardsWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Cards');

    this.types2 = ['caro', 'cross', 'heart', 'pik'];
    this.tabs = new(Luts.Object.TabManager)(deepDataAndEvents, 0, 0);
    this.allCards = this.tabs.add('allCards');
    this.drawCard = this.tabs.add('drawCard');
    this.deckTab = this.tabs.add('deckTab');
    this.autoDrawTab = this.tabs.add("autoDrawTab");
    this.addChild(this.allCards);
    this.addChild(this.drawCard);
    this.addChild(this.deckTab);
    this.addChild(this.autoDrawTab);
    this.allCardsButton = new(Luts.Object.Button)(deepDataAndEvents, 100, 100, "Cards", "");
    this.addChild(this.allCardsButton);
    this.drawCardButton = new(Luts.Object.Button)(deepDataAndEvents, 220, 100, "Draw", "");
    this.addChild(this.drawCardButton);
    this.deckTabButton = new(Luts.Object.Button)(deepDataAndEvents, 340, 100, 'Decks', "");
    this.deckTabButton.setLock("decks");
    this.addChild(this.deckTabButton);
    this.autoDrawTabButton = new(Luts.Object.Button)(deepDataAndEvents, 460, 100, 'Auto Draw', "");
    this.autoDrawTabButton.setLock("autoDraw");
    this.addChild(this.autoDrawTabButton);
    this.tabs.setTabButton(this.allCards, this.allCardsButton);
    this.tabs.setTabButton(this.drawCard, this.drawCardButton);
    this.tabs.setTabButton(this.deckTab, this.deckTabButton);
    this.tabs.setTabButton(this.autoDrawTab, this.autoDrawTabButton);
    this.tabs.show('drawCard');
    this.unlockedCardsText = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2 + 100, 20, "text", deepDataAndEvents.unlockedCards + '/52', 32);
    this.addChild(this.unlockedCardsText);

    var unlock = 0;
    for (; unlock < 4; unlock++) {

        var _0x1ac68a = 0;
        for (; _0x1ac68a < 13; _0x1ac68a++) {
            var commandObject = new(Luts.Object.Card)(deepDataAndEvents, 50 + 45 * _0x1ac68a, 200 + 65 * unlock, Luts.CardRules.typeToString(_0x1ac68a + 2), this.types2[unlock]);
            commandObject.scale.set(0.33);

            commandObject.baseScale = 0.33;
            this.allCards.addChild(commandObject);
        }
    }
    this.desc1 = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2 - 200, 360, 'text', "", 16, '#000000');

    this.desc1.strokeThickness = 0;
    this.desc1.anchor.set(0.5, 0);

    this.desc1.wordWrapWidth = 200;
    this.desc1.align = 'center';
    this.drawCard.addChild(this.desc1);
    this.desc2 = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2, 360, 'text', "", 16, "#000000");

    this.desc2.strokeThickness = 0;
    this.desc2.anchor.set(0.5, 0);

    this.desc2.wordWrapWidth = 200;
    this.desc2.align = 'center';
    this.drawCard.addChild(this.desc2);
    this.desc3 = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2 + 200, 360, "text", "", 16, '#000000');

    this.desc3.strokeThickness = 0;
    this.desc3.anchor.set(0.5, 0);

    this.desc3.wordWrapWidth = 200;
    this.desc3.align = 'center';
    this.drawCard.addChild(this.desc3);
    this.cardDrawable1 = new(Luts.Object.Card)(deepDataAndEvents, this.rWidth / 2 - 200, 270, Luts.Store.getItem('c0t1', "2"), Luts.Store.getItem("c0t2", 'caro'), true);
    this.cardDrawable1.desc = this.desc1;
    this.cardDrawable1.setType(null, null, true);
    this.drawCard.addChild(this.cardDrawable1);
    this.cardDrawable2 = new(Luts.Object.Card)(deepDataAndEvents, this.rWidth / 2, 270, Luts.Store.getItem("c1t1", "2"), Luts.Store.getItem('c1t2', "caro"), true);
    this.cardDrawable2.desc = this.desc2;
    this.cardDrawable2.setType(null, null, true);
    this.drawCard.addChild(this.cardDrawable2);
    this.cardDrawable3 = new(Luts.Object.Card)(deepDataAndEvents, this.rWidth / 2 + 200, 270, Luts.Store.getItem('c2t1', "2"), Luts.Store.getItem("c2t2", "caro"), true);
    this.cardDrawable3.desc = this.desc3;
    this.cardDrawable3.setType(null, null, true);
    this.drawCard.addChild(this.cardDrawable3);
    if (Luts.Store.getItem('firstCardDraw', true)) {
        this.randomizeCards();
        Luts.Store.setItem("firstCardDraw", false);
    }

    this.cardDrawable1.visible = this.state.unlockedCards < 52;

    this.cardDrawable2.visible = this.state.unlockedCards < 51;

    this.cardDrawable3.visible = this.state.unlockedCards < 50;
    if (Luts.Object.AchievementsHandler.unlockedCardTypeNum(this.cardDrawable3.ctype) >= 4) {

        this.cardDrawable3.visible = false;
    }
    if (Luts.Object.AchievementsHandler.unlockedCardTypeNum(this.cardDrawable2.ctype) >= 4) {

        this.cardDrawable2.visible = false;
    }
    this.desc1.visible = this.cardDrawable1.visible;
    this.desc2.visible = this.cardDrawable2.visible;
    this.desc3.visible = this.cardDrawable3.visible;

    this.cardDrawable1.baseScale = 0.9;

    this.cardDrawable2.baseScale = 0.9;

    this.cardDrawable3.baseScale = 0.9;
    this.cardDrawable1.scale.set(0.9);
    this.cardDrawable2.scale.set(0.9);
    this.cardDrawable3.scale.set(0.9);
    if (Luts.Ad.enabled) {
        this.reshuffleButton = new(Luts.Object.Button)(this.state, this.rWidth / 2, 155, 'Reshuffle', 'Watch Ad', this.watchAd.bind(this));
        this.reshuffleButton.setActive(false);
        this.reshuffleButton.setActive(true, true);
        this.drawCard.addChild(this.reshuffleButton);
    }
    this.convertText = new(Luts.Object.Text)(this.state, 50, 140, 'text', 'Convert your deck to a golden card and your prestige multiplier to luck', 14, '#000000');

    this.convertText.strokeThickness = 0;
    this.deckTab.addChild(this.convertText);
    this.luckBuyAmount = new(Luts.Object.BuyAmountButtons)(this.state, 450, 420, [1, 10, 100], true, 3);
    this.deckTab.addChild(this.luckBuyAmount);
    this.convertButton = new(Luts.Object.Button)(this.state, 550, 150, "Convert", "", this.convert.bind(this));
    this.deckTab.addChild(this.convertButton);
    this.gildButton = new(Luts.Object.Button)(this.state, 550, 200, 'Gild card', Luts.Upgrades.currency[2], this.gild.bind(this));
    this.deckTab.addChild(this.gildButton);
    this.casinoButton = new(Luts.Object.Button)(this.state, 550, 250, "Casinos", "", this.casinos.bind(this));
    this.deckTab.addChild(this.casinoButton);
    this.casinoButton.setLock('goldenDeck');
    Luts.Events.onDrawCard.add(function () {
        this.convertButton.setActive(this.state.unlockedCards >= 52, true);
    }, this);
    Luts.Events.onPrestige.add(function () {
        this.convertButton.setActive(this.state.unlockedCards >= 52, true);
    }, this);
    this.convertButton.setActive(this.state.unlockedCards >= 52, true);
    this.goldenCardsCounter = new(Luts.Object.Text)(this.state, 50, 160, 'text', "Gildings available: " + Luts.Format.Decimal(Luts.Upgrades.currency[2]), 14, "#000000");

    this.goldenCardsCounter.strokeThickness = 0;
    this.deckTab.addChild(this.goldenCardsCounter);
    this.luckCounter = new(Luts.Object.Text)(this.state, 260, 160, 'text', 'Luck points: ' + Luts.Format.Decimal(Luts.Upgrades.currency[3]), 14, "#000000");

    this.luckCounter.strokeThickness = 0;
    this.deckTab.addChild(this.luckCounter);
    Luts.Events.onCurrencyChanged[2].add(function (deepDataAndEvents) {
        this.goldenCardsCounter.setText('Gildings available: ' + Luts.Format.Decimal(deepDataAndEvents));
        this.gildButton.subtitle.setText(Luts.Upgrades.currency[2]);
    }, this);
    Luts.Events.onCurrencyChanged[3].add(function (deepDataAndEvents) {
        this.luckCounter.setText('Luck points: ' + Luts.Format.Decimal(deepDataAndEvents));
    }, this);
    this.state.luckUpgrades.forEach(function (dataAndEvents, deltaY) {
        var r20 = new(Luts.Object.LuckUpgradeButton)(deepDataAndEvents, 150 + 220 * Math.floor(deltaY / 3), 250 + deltaY % 3 * 50, dataAndEvents);
        this.deckTab.addChild(r20);
    } ['bind'](this));
    this.autoDrawOrder = Luts.Store.getItem('autoDrawOrder', "");
    if ("" == this.autoDrawOrder) {

        this.autoDrawOrder = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    } else {
        this.autoDrawOrder = JSON.parse(this.autoDrawOrder);
    }
    this.autoGildOrder = Luts.Store.getItem('autoGildOrder', "");
    if ("" == this.autoGildOrder) {

        this.autoGildOrder = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
    } else {
        this.autoGildOrder = JSON.parse(this.autoGildOrder);
    }
    this.mostPref = new(Luts.Object.Text)(deepDataAndEvents, 30, 140, 'text', 'Most Preferred', 20, '#000000');

    this.mostPref.strokeThickness = 0;
    this.autoDrawTab.addChild(this.mostPref);
    this.leastPref = new(Luts.Object.Text)(deepDataAndEvents, 480, 140, 'text', "Least Preferred", 20, '#000000');

    this.leastPref.strokeThickness = 0;
    this.autoDrawTab.addChild(this.leastPref);

    this.autoDrawCards = [];
    this.autoDrawOrder.forEach(function (dataAndEvents, ignoreMethodDoesntExist) {
        var commandObject = new(Luts.Object.AutoDrawCard)(deepDataAndEvents, 50 + 45 * ignoreMethodDoesntExist, 200, dataAndEvents, ignoreMethodDoesntExist);
        commandObject.scale.set(0.33);

        commandObject.baseScale = 0.33;
        this.autoDrawTab.addChild(commandObject);
        this.autoDrawCards.push(commandObject);
    } ['bind'](this));

    this.autoGildCards = [];
    this.autoGildOrder.forEach(function (dataAndEvents, ignoreMethodDoesntExist) {
        var commandObject = new(Luts.Object.AutoDrawCard)(deepDataAndEvents, 50 + 45 * ignoreMethodDoesntExist, 320, dataAndEvents, ignoreMethodDoesntExist, true);
        commandObject.scale.set(0.33);

        commandObject.baseScale = 0.33;
        this.autoDrawTab.addChild(commandObject);
        this.autoGildCards.push(commandObject);
    } ['bind'](this));
    Luts.Events.onCurrencyChanged[1].add(this.autoDraw, this);
    this.state.autoDraw.onChanged.add(this.autoDraw, this);
    this.autoDraw();
    this.state.autoGild.onChanged.add(this.autoGild, this);
    Luts.Events.onAfterPrestige2.add(this.autoGild, this);
    this.autoDrawText = new(Luts.Object.Text)(deepDataAndEvents, 20, 395, 'text', 'Auto Draw:', 20, '#000000');

    this.autoDrawText.strokeThickness = 0;
    this.autoDrawTab.addChild(this.autoDrawText);
    var r20 = Luts.getSetting('autoDraw');
    this.autoDrawSetting = new(Luts.Object.Button)(this.state, 150, 415, "", "", function () {
        r20.toggle();
    });
    this.autoDrawTab.addChild(this.autoDrawSetting);
    r20.onChanged.add(function (dataAndEvents) {
        if (dataAndEvents.value) {
            this.setFrames('settings_enabled', 'settings_enabled');
        } else {
            this.setFrames('settings_disabled', 'settings_disabled');
        }
    } ['bind'](this.autoDrawSetting));
    this.autoDrawSetting.setLock("autoDraw");
    r20.onChanged.dispatch(r20);
    this.autoGildText = new(Luts.Object.Text)(deepDataAndEvents, 220, 395, 'text', "Auto Gild:", 20, "#000000");

    this.autoGildText.strokeThickness = 0;
    this.autoDrawTab.addChild(this.autoGildText);
    var rreturn = Luts.getSetting('autoGild');
    this.autoGildSetting = new(Luts.Object.Button)(this.state, 350, 415, "", "", function () {
        rreturn.toggle();
    });
    this.autoDrawTab.addChild(this.autoGildSetting);
    rreturn.onChanged.add(function (tagMap) {
        if (tagMap.value) {
            this.setFrames("settings_enabled", 'settings_enabled');
        } else {
            this.setFrames('settings_disabled', "settings_disabled");
        }
    } ['bind'](this.autoGildSetting));
    this.autoGildSetting.setLock('autoGild');
    rreturn.onChanged.dispatch(rreturn);
    this.autoConvertText = new(Luts.Object.Text)(deepDataAndEvents, 20, 395, 'text', 'Auto Convert:', 20, '#000000');

    this.autoConvertText.strokeThickness = 0;
    this.deckTab.addChild(this.autoConvertText);
    var restoreScript = Luts.getSetting("autoConvert");
    this.autoConvertSetting = new(Luts.Object.Button)(this.state, 170, 415, "", "", function () {
        restoreScript.toggle();
    });
    this.deckTab.addChild(this.autoConvertSetting);
    restoreScript.onChanged.add(function (dataAndEvents) {
        if (dataAndEvents.value) {
            this.setFrames('settings_enabled', 'settings_enabled');
        } else {
            this.setFrames('settings_disabled', 'settings_disabled');
        }
    } ['bind'](this.autoConvertSetting));
    this.autoConvertSetting.setLock('autoConvert');
    restoreScript.onChanged.dispatch(restoreScript);
}, Luts.Object.CardsWindow.prototype.constructor = Luts.Object.CardsWindow, Luts.Object.CardsWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.CardsWindow.prototype.updateAutoDrawCards = function () {
    this.autoDrawCards.forEach(function (dataAndEvents, timeoutKey) {
        dataAndEvents.setType(this.autoDrawOrder[timeoutKey], dataAndEvents.type2);
        dataAndEvents.updateArrows();
    } ["bind"](this));
    this.autoGildCards.forEach(function (dataAndEvents, timeoutKey) {
        dataAndEvents.setType(this.autoGildOrder[timeoutKey], dataAndEvents.type2);
        dataAndEvents.updateArrows();
    } ['bind'](this));
    this.saveAutoDraw();
}, Luts.Object.CardsWindow.prototype.watchAd = function () {
    Luts.Ad.requestAd();
    this.reshuffleButton.setActive(false);
    Luts.Events.onAdEnded.addOnce(function (dataAndEvents) {
        this.reshuffleButton.setActive(true, true);
        if (dataAndEvents) {
            this.randomizeCards();
        } else {
            new(Luts.Object.Popup)(this.state, 'No Ad available, try again later');
        }
    }, this);
}, Luts.Object.CardsWindow.prototype.saveAutoDraw = function () {
    Luts.Store.setItem("autoDrawOrder", JSON.stringify(this.autoDrawOrder));
    Luts.Store.setItem('autoGildOrder', JSON.stringify(this.autoGildOrder));
}, Luts.Object.CardsWindow.prototype.update = function () {}, Luts.Object.CardsWindow.prototype.gild = function () {
    this.state.goldCardsWindow.toggle();
}, Luts.Object.CardsWindow.prototype.casinos = function () {
    this.state.casinoWindow.toggle();
}, Luts.Object.CardsWindow.prototype.convert = function () {
    var r20 = this.state.totalPrestige.v.add(this.state.getPrestigeMulti()).times(this.state.luckMulti.modValue());
    this.convertButton.setActive(false);
    new(Luts.Object.Popup)(this.state, Luts.Format.Color('red') + 'You will lose your upgrades and your prestige multiplier will reset to 0. You will be able to chose a golden card (which will stay after you prestige) and get ' + Luts.Format.Decimal(r20) + ' luck with that you can buy special upgrades. Are you sure to reset everything?', true, function (dataAndEvents) {
        this.convertButton.setActive(true);
        if (dataAndEvents) {
            this.state.prestige2();
        }
    } ['bind'](this));
}, Luts.Object.CardsWindow.prototype.randomizeCards = function () {
    if (this.reshuffleButton) {
        this.reshuffleButton.setActive(false);
        this.reshuffleButton.setActive(true, true);
    }
    if (this.state.unlockedCards < 52) {
        this.cardDrawable1.randomType(0);
    }
    if (this.state.unlockedCards < 51) {
        this.cardDrawable2.randomType(1, this.cardDrawable1.ctype);
    }
    if (this.state.unlockedCards < 50) {
        this.cardDrawable3.randomType(2, this.cardDrawable1.ctype, this.cardDrawable2.ctype);
    }

    this.cardDrawable1.visible = this.state.unlockedCards < 52;

    this.cardDrawable2.visible = this.state.unlockedCards < 51;

    this.cardDrawable3.visible = this.state.unlockedCards < 50;
    if (Luts.Object.AchievementsHandler.unlockedCardTypeNum(this.cardDrawable3.ctype) >= 4) {

        this.cardDrawable3.visible = false;
    }
    if (Luts.Object.AchievementsHandler.unlockedCardTypeNum(this.cardDrawable2.ctype) >= 4) {

        this.cardDrawable2.visible = false;
    }
    this.desc1.visible = this.cardDrawable1.visible;
    this.desc2.visible = this.cardDrawable2.visible;
    this.desc3.visible = this.cardDrawable3.visible;
}, Luts.Object.CardsWindow.prototype.autoDraw = function () {
    if (this.state.autoDraw.value) {
        this.autoDrawOrder.forEach(function (dataAndEvents) {
            return this.cardDrawable1.visible && this.cardDrawable1.ctype == dataAndEvents ? void this.cardDrawable1.clickCard() : this.cardDrawable2.visible && this.cardDrawable2.ctype == dataAndEvents ? void this.cardDrawable2.clickCard() : this.cardDrawable3.visible && this.cardDrawable3.ctype == dataAndEvents ? void this.cardDrawable3.clickCard() : void 0;
        } ['bind'](this));
    }
}, Luts.Object.CardsWindow.prototype.autoGild = function () {
    if (this.state.autoGild.value) {

        var _0x5487d7 = ['caro', 'cross', 'heart', 'pik'];
        this.autoGildOrder.forEach(function (near) {
            _0x5487d7.forEach(function (far) {
                var r20 = Luts.Upgrades.get(far + near + "_gold");
                if (0 == r20.level) {
                    Luts.Upgrades.upgrade(r20);
                    this.state.luckMulti.changeMultiplier('luckPerGold', 1, Luts.Upgrades.value('luckPerGold'), null, 'prestige3');
                }
            } ['bind'](this));
        } ["bind"](this));
    }
    Luts.Events.onDrawCard.dispatch();
}, Luts.Object.HistoryWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Roll History');
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 70, this.rWidth - 30, this.rHeight - 90);
    this.addChild(this.scroll);
    this.swapChildren(this.scroll, this.closeButton);

    this.scrollIndex = 0;

    this.texts = [];

    this.updateCounter = 0;

    this.updateInterval = 30;

    var _0x1156b5 = 0;
    for (; _0x1156b5 < 100; _0x1156b5++) {
        this.addStatistic(function (point) {
            var points = this.state.rollHistory[point];
            return points ? {
                "values": points.values,
                "combo": points.match,
                "points": points.score
            } : {
                "values": "",
                "combo": "",
                "points": ""
            };
        } ['bind'](this));
    }
    this.min = Decimal(0);
    this.max = Decimal(0);
}, Luts.Object.HistoryWindow.prototype.constructor = Luts.Object.HistoryWindow, Luts.Object.HistoryWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.HistoryWindow.prototype.update = function () {
    if (this.shown) {
        if (this.updateCounter++ > this.updateInterval) {
            if (this.updateCounter = 0, this.state.rollHistory.length <= 0) {
                return;
            }
            this.min = this.state.rollHistory[0].score;
            this.max = this.state.rollHistory[0].score;

            var i = 1;
            for (; i < this.state.rollHistory.length; i++) {
                if (this.min.greaterThan(this.state.rollHistory[i].score)) {
                    this.min = this.state.rollHistory[i].score;
                }
                if (this.max.lessThan(this.state.rollHistory[i].score)) {
                    this.max = this.state.rollHistory[i].score;
                }
            }
            this.texts.forEach(function (dataAndEvents, deepDataAndEvents) {
                if (dataAndEvents.assignFunction) {
                    var css = dataAndEvents.assignFunction(this.state.rollHistory.length - deepDataAndEvents)
                }
                if ("" != css.values) {
                    dataAndEvents.values.text = css.values;
                    dataAndEvents.combo.text = Luts.DiceRules.getData(css.combo).name;
                    dataAndEvents.score.text = Luts.Format.Decimal(css.points);
                    var r20 = css.points.minus(this.min).div(this.max.minus(this.min)).sqrt().times(1E4);
                    dataAndEvents.score.tint = Phaser.Color.interpolateColor(0, 16738002, 1E4, r20, 1);
                }
            } ["bind"](this));
        }
        this.scroll.update();
    }
}, Luts.Object.HistoryWindow.prototype.addStatistic = function (dataAndEvents) {
    var keyBindings = this.game.add.image(0, 20 * this.scrollIndex);
    return keyBindings.values = new Luts.Object.Text(this.state, 10, 0, "text", "", 20, '#000000'), keyBindings.score = new(Luts.Object.Text)(this.state, 600, 0, "regular", "", 20, "#ffffff"), keyBindings.combo = new(Luts.Object.Text)(this.state, 100, 0, 'regular', "", 20, "#000000"), keyBindings.values.strokeThickness = 0, keyBindings.score.strokeThickness =
        0, keyBindings.combo.strokeThickness = 0, keyBindings.addChild(keyBindings.values), keyBindings.addChild(keyBindings.score), keyBindings.addChild(keyBindings.combo), keyBindings.score.anchor.set(1, 0), this.scroll.addToScrollGroup(keyBindings), keyBindings.assignFunction = dataAndEvents, this.texts.push(keyBindings), this.scrollIndex++, keyBindings;
}, Luts.Object.AchievementsWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Achievements');
    this.tabs = new(Luts.Object.TabManager)(deepDataAndEvents, 0, 0);
    this.basicTab = this.addTab('basic', 'Basic');
    this.advTab = this.addTab('advanced', "Advanced");
    this.expertTab = this.addTab('expert', 'Expert');
    this.legendaryTab = this.addTab("legendary", 'Legendary');
    this.godlikeTab = this.addTab('godlike', 'Godlike');
    Luts.Lock.unlock('basicAchievements');
    this.tabs.show('basic');
    Luts.Achievements.achievements.forEach(function (current) {
        var _0x48d21a = this.tabs.get(current.category);
        var restoreScript = this.game.add.image(0, 40 * _0x48d21a.scrollIndex);
        var r20 = new Luts.Object.Text(deepDataAndEvents, 25, 0, "text", current.name, 18, '#000000');

        r20.strokeThickness = 0;
        var rreturn = new(Luts.Object.Text)(deepDataAndEvents, 25, 20, 'text', current.description, 14, "#000000");

        rreturn.strokeThickness = 0;
        var abbrevs = new(Luts.Object.Bar)(deepDataAndEvents, 410, 0, "progressBackSmall", "progressBarSmall");
        abbrevs.a = current;
        restoreScript.addChild(r20);
        restoreScript.addChild(rreturn);
        restoreScript.addChild(abbrevs);
        new(Luts.Object.Tooltip)(deepDataAndEvents, abbrevs, `Reward:\
` + current.unlockText);
        _0x48d21a.bars.push(abbrevs);
        _0x48d21a.scroll.addToScrollGroup(restoreScript);
        _0x48d21a.scrollIndex++;
    } ['bind'](this));

    this.texts = [];
}, Luts.Object.AchievementsWindow.prototype.constructor = Luts.Object.AchievementsWindow, Luts.Object.AchievementsWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.AchievementsWindow.prototype.addTab = function (key, dataAndEvents) {
    var camelKey = this.tabs.add(key);
    this.addChild(camelKey);
    var r20 = new(Luts.Object.Button)(this.state, 85 + 120 * (this.tabs.tabs.length - 1), 100, dataAndEvents, "");
    return r20.setLock(key + 'Achievements'), this.addChild(r20), this.tabs.setTabButton(key, r20), camelKey.scroll = new(Luts.Object.Scrollable)(this.state, 10, 120, this.rWidth - 30, this.rHeight - 150), camelKey.addChild(camelKey.scroll), camelKey.scrollIndex = 0, camelKey.bars = [], camelKey;
}, Luts.Object.AchievementsWindow.prototype.update = function () {
    if (this.shown) {
        this.tabs.tabs.forEach(function (dataAndEvents) {
            if (dataAndEvents.visible) {
                dataAndEvents.scroll.update();
                dataAndEvents.bars.forEach(function (params) {
                    if (0 == params.a.level) {
                        params.barText.text = Luts.Format.Decimal(params.a.value) + "/" + Luts.Format.Decimal(params.a.goal);
                        params.stepTo(params.a.value.dividedBy(params.a.goal), 0.1);
                    } else {
                        params.barText.text = 'DONE!';
                        params.setTo(1);
                    }
                    params.update();
                } ["bind"](this));
            }
        } ['bind'](this));
    }
}, Luts.Object.RouletteWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Roulette');
    this.rnd = new(Phaser.RandomDataGenerator)(Luts.Store.getItem('rouletteRng', Date.now()));

    this.rouletteUpgrades = [Luts.Upgrades.add('rouletteLevelUpgrade', "Level +", "Increase the level of the roulette", 5, 0, 5, 1, null, 0, null, 4), Luts.Upgrades.add("rouletteFocusUpgrade", "Focus", 'Hit your focus next spin', 1, 0, 4, 1, null, 0, null, 4)];
    Luts.Upgrades.get("rouletteLevelUpgrade").onUpgrade.add(function () {
        Luts.Value.get('rouletteLevel').add(1);
    }, this);
    Luts.Upgrades.get('rouletteFocusUpgrade').onUpgrade.add(function () {
        Luts.Value.get('focusCharge').add(1);
    }, this);

    this.rouletteSize = 300;
    this.roulette = this.state.add.graphics(this.rWidth / 2, this.rHeight / 2);
    this.addChild(this.roulette);
    this.rouletteMask = this.state.add.graphics(this.rWidth / 2, this.rHeight / 2);
    this.rouletteMask.beginFill(16777215);
    this.rouletteMask.drawCircle(0, 0, this.rouletteSize);
    this.rouletteMask.endFill();
    this.addChild(this.rouletteMask);
    this.roulette.mask = this.rouletteMask;
    this.rouletteArrow = this.state.add.graphics(this.rWidth / 2, this.rHeight / 2);
    this.rouletteArrow.beginFill(0);
    this.rouletteArrow.drawTriangle([{
        "x": 0,
        "y": 0.45 * -this.rouletteSize
    }, {
        "x": -10,
        "y": -this.rouletteSize / 2
    }, {
        "x": 10,
        "y": -this.rouletteSize / 2
    }]);
    this.rouletteArrow.endFill();
    this.addChild(this.rouletteArrow);
    this.spin = new(Luts.Upgrades.add)('rouletteSpin', 'Roulette Spin', "", 1E18, 0, 10, 1, null, 0, null, 0);
    this.rouletteLevel = Luts.Value.get('rouletteLevel');
    this.betOnBlack = Luts.Store.getItem("betOnBlack", true);
    this.focus = Luts.Store.getItem('rouletteFocus', "nothing");
    this.focusCharge = Luts.Value.get("focusCharge");

    this.rouletteIcons = [];

    this.rouletteTexts = [];

    this.spinning = false;
    this.spinButton = new(Luts.Object.Button)(deepDataAndEvents, this.rWidth / 2, 415, "Spin", Luts.Format.Decimal(this.spin.price), function () {
        this.clickSpin(false);
    } ['bind'](this));
    this.addChild(this.spinButton);
    this.spinButton.setKey(Phaser.KeyCode.S);
    this.spinButton.setLock("roulette");
    new(Luts.Object.Tooltip)(deepDataAndEvents, this.spinButton, 'Spin the roulette (S)');
    this.adSpinButton = new(Luts.Object.Button)(deepDataAndEvents, this.rWidth / 2 + 120, 415, 'Free Spin', 'Watch Ad', function () {
        Luts.Ad.requestAd();
        this.adSpinButton.setActive(false);
        Luts.Events.onAdEnded.addOnce(function (dataAndEvents) {
            this.adSpinButton.setActive(true, true);
            if (dataAndEvents) {
                this.clickSpin(true);
            } else {
                new(Luts.Object.Popup)(this.state, 'No Ad available, try again later');
            }
        }, this);
    } ['bind'](this));
    this.addChild(this.adSpinButton);
    this.adSpinButton.setActive(false);
    this.adSpinButton.setActive(true, true);
    this.adSpinButton.visible = Luts.Ad.enabled;
    this.slotButton = new(Luts.Object.Button)(deepDataAndEvents, this.rWidth / 2 + 240, 415, 'Slot Machine', Luts.Format.Color(Luts.Upgrades.currency[7].greaterThan(0) ? 'green' : 'red') + Luts.Format.Decimal(Luts.Upgrades.currency[7]), this.state.slotClicked.bind(deepDataAndEvents));
    this.addChild(this.slotButton);
    this.slotButton.setLock('slotMachine');
    Luts.Events.onCurrencyChanged[7].add(function (deepDataAndEvents) {
        this.slotButton.subtitle.setText(Luts.Format.Color(deepDataAndEvents.greaterThan(0) ? 'green' : 'red') + Luts.Format.Decimal(deepDataAndEvents));
    }, this);
    this.levelText = new(Luts.Object.Text)(deepDataAndEvents, 20, 100, 'text', 'Level: ' + Luts.Format.Decimal(this.rouletteLevel.modValue()), 32, '#000000');

    this.levelText.strokeThickness = 0;
    this.addChild(this.levelText);
    this.chipsText = new(Luts.Object.Text)(deepDataAndEvents, 20, 150, 'text', 'Chips: ' + Luts.Format.Decimal(Luts.Upgrades.currency[4]), 26, "#000000");

    this.chipsText.strokeThickness = 0;
    this.addChild(this.chipsText);
    this.focusChargeText = new(Luts.Object.Text)(deepDataAndEvents, 20, 190, 'text', 'Focus: ' + Luts.Format.Decimal(this.focusCharge.modValue()), 26, '#000000');

    this.focusChargeText.strokeThickness = 0;
    this.addChild(this.focusChargeText);
    this.betText = new(Luts.Object.Text)(deepDataAndEvents, 520, 100, 'text', 'Bet on: ', 24, '#000000');

    this.betText.strokeThickness = 0;
    this.addChild(this.betText);
    this.blackButton = new Luts.Object.Button(deepDataAndEvents, 520, 160, 'Black', "", this.clickBlack.bind(this));
    this.blackButton.setFrames('buttonSmall_active', 'buttonSmall_inactive');
    new(Luts.Object.Tooltip)(deepDataAndEvents, this.blackButton, "Get 1 Chip when the roulette lands on black");
    this.addChild(this.blackButton);
    this.redButton = new(Luts.Object.Button)(deepDataAndEvents, 590, 160, 'Red', "", this.clickRed.bind(this));
    this.redButton.setFrames("buttonSmall_active", 'buttonSmall_inactive');
    new(Luts.Object.Tooltip)(deepDataAndEvents, this.redButton, 'Get 1 Chip when the roulette lands on red');
    this.addChild(this.redButton);
    this.focusText = new(Luts.Object.Text)(deepDataAndEvents, 500, 200, 'text', "Focus on: ", 24, "#000000");

    this.focusText.strokeThickness = 0;
    this.addChild(this.focusText);
    this.focusNothingButton = new Luts.Object.Button(deepDataAndEvents, 520, 260, 'None', "", this.clickFocusNothing.bind(this));
    this.focusNothingButton.setFrames('buttonSmall_active', 'buttonSmall_inactive');
    this.addChild(this.focusNothingButton);
    this.focusMultiButton = new(Luts.Object.Button)(deepDataAndEvents, 590, 260, 'Multi', "", this.clickFocusMulti.bind(this));
    this.focusMultiButton.setFrames('buttonSmall_active', "buttonSmall_inactive");
    this.addChild(this.focusMultiButton);
    this.focusCardButton = new(Luts.Object.Button)(deepDataAndEvents, 520, 320, 'Card', "", this.clickFocusCard.bind(this));
    this.focusCardButton.setFrames("buttonSmall_active", 'buttonSmall_inactive');
    this.addChild(this.focusCardButton);
    this.focusFFButton = new(Luts.Object.Button)(deepDataAndEvents, 590, 320, "Time", "", this.clickFocusFF.bind(this));
    this.focusFFButton.setFrames('buttonSmall_active', 'buttonSmall_inactive');
    this.addChild(this.focusFFButton);
    this.updateButtons();
    this.rouletteUpgrades.forEach(function (dataAndEvents, ignoreMethodDoesntExist) {
        var r20 = new(Luts.Object.RouletteUpgradeButton)(deepDataAndEvents, 80, 290 + 50 * ignoreMethodDoesntExist, dataAndEvents);

        r20.text.fontSize = 20;
        this.addChild(r20);
    } ['bind'](this));
    this.rewardText = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2, this.rHeight / 2, "text", 'FAST FORWARD!', 64, '#ffffff');
    this.rewardText.anchor.set(0.5);
    this.rewardText.scale.set(0);
    this.addChild(this.rewardText);
    this.rouletteLevel.onChange.add(function () {
        this.levelText.setText('Level: ' + Luts.Format.Decimal(this.rouletteLevel.modValue()));
    }, this);
    this.focusCharge.onChange.add(function () {
        this.focusChargeText.setText('Focus: ' + Luts.Format.Decimal(this.focusCharge.modValue()));
    }, this);
    Luts.Events.onCurrencyChanged[4].add(function () {
        this.chipsText.setText('Chips: ' + Luts.Format.Decimal(Luts.Upgrades.currency[4]));
    }, this);
    this.autoSpinText = new(Luts.Object.Text)(deepDataAndEvents, 20, 395, 'text', 'Auto Spin:', 20, '#000000');

    this.autoSpinText.strokeThickness = 0;
    this.addChild(this.autoSpinText);
    var r20 = Luts.getSetting("autoSpin");
    this.autoSpinSetting = new(Luts.Object.Button)(this.state, this.rWidth / 2 - 160, 415, "", "", function () {
        r20.toggle();
    });
    this.addChild(this.autoSpinSetting);
    r20.onChanged.add(function (dataAndEvents) {
        if (dataAndEvents.value) {
            this.setFrames('settings_enabled', 'settings_enabled');
        } else {
            this.setFrames('settings_disabled', 'settings_disabled');
        }
    } ['bind'](this.autoSpinSetting));
    this.autoSpinSetting.setLock('autoSpin');
    r20.onChanged.dispatch(r20);
    this.setData();
    Luts.Events.onCurrencyChanged[0].add(this.updateText, this);
    this.rouletteLevel.onChange.add(this.setData, this);
    Luts.Events.onAsyncUpdate.add(function () {
        if (this.state.autoSpin.value) {
            this.spinButton.click(false, true);
        }
        if (this.state.autoRouletteUpgrade.value) {
            Luts.Upgrades.upgrade('rouletteLevelUpgrade');
        }
        if (this.state.autoRouletteFocus.value) {
            Luts.Upgrades.upgrade('rouletteFocusUpgrade');
        }
    }, this);
    Luts.Events.onPrestige.add(function () {
        if (this.state.goldenCards < 52) {
            if (this.state.focusOnCard.value) {
                this.clickFocusCard();
            }
        }
    }, this);
    Luts.Events.onDrawCard.add(function () {
        if (this.state.unlockedCards >= 52) {
            if ('card' == this.focus) {
                this.clickFocusNothing();
            }
        }
    }, this);
}, Luts.Object.RouletteWindow.prototype.constructor = Luts.Object.RouletteWindow, Luts.Object.RouletteWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.RouletteWindow.prototype.update = function () {}, Luts.Object.RouletteWindow.prototype.updateText = function () {
    var _0xb7572a = Luts.Upgrades.isUpgradeable(this.spin, false, 1);
    this.spinButton.subtitle.setText('<c=' + (_0xb7572a ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(this.spin.price));
    this.spinButton.setActive(_0xb7572a && !this.spinning, true);
}, Luts.Object.RouletteWindow.prototype.clickBlack = function () {

    this.betOnBlack = true;
    this.updateButtons();
}, Luts.Object.RouletteWindow.prototype.clickRed = function () {

    this.betOnBlack = false;
    this.updateButtons();
};
Luts.Object.RouletteWindow.prototype.clickFocusNothing = function () {

    this.focus = "nothing";
    this.updateButtons();
}, Luts.Object.RouletteWindow.prototype.clickFocusMulti = function () {
    this.focus = 'multi';
    this.updateButtons();
}, Luts.Object.RouletteWindow.prototype.clickFocusCard = function () {

    this.focus = "card";
    this.updateButtons();
}, Luts.Object.RouletteWindow.prototype.clickFocusFF = function () {

    this.focus = "ff";
    this.updateButtons();
}, Luts.Object.RouletteWindow.prototype.updateButtons = function () {
    Luts.Store.setItem('betOnBlack', this.betOnBlack);
    this.blackButton.setActive(!this.betOnBlack);
    this.redButton.setActive(this.betOnBlack);
    Luts.Store.setItem('rouletteFocus', this.focus);
    this.focusNothingButton.setActive("nothing" != this.focus);
    this.focusMultiButton.setActive("multi" != this.focus);
    this.focusCardButton.setActive('card' != this.focus);
    this.focusFFButton.setActive("ff" != this.focus);
}, Luts.Object.RouletteWindow.prototype.clickSpin = function (rootjQuery) {

    var context = false;
    if (rootjQuery || (context = Luts.Upgrades.upgrade(this.spin)), context || rootjQuery) {
        if (Luts.Sound.play('spin', 0.5), Luts.Value.get('rouletteSpins').add(1), this.state.cardProgressMulti.changeMultiplier('cardProgressPerSpin', 1, Luts.Upgrades.value('cardProgressPerSpin'), null, 'prestige'), this.spinning = true, this.updateText(), this.lastReward = this.rnd.between(0, this.data.size - 1), this.rnd.frac() <
            Luts.Upgrades.value('focusChance')) {

            var r20 = this.data.size - 1 - this.rnd.pick(this.getRewardIndexesOfFocus());
            if (!Number.isNaN(r20)) {

                this.lastReward = r20;
            }
        } else {
            if (this.focusCharge.v.greaterThan(0) && 'nothing' != this.focus) {

                r20 = this.data.size - 1 - this.rnd.pick(this.getRewardIndexesOfFocus());
                if (!Number.isNaN(r20)) {
                    this.focusCharge.add(-1);

                    this.lastReward = r20;
                }
            }
        }
        Luts.Store.setItem('rouletteRng', this.rnd.state());
        this.lastRewardData = Luts.Object.RouletteRules.data(this.data.rewards[this.data.size - 1 - this.lastReward]);

        var restoreScript = Math.sin(2 * Math.PI * (this.lastReward + 0.5) / this.data.size) * this.rouletteSize * 0.4;

        var rreturn = Math.cos(2 * Math.PI * (this.lastReward + 0.5) / this.data.size) * this.rouletteSize * 0.4;
        var rad = Phaser.Math.angleBetween(0, 0, restoreScript, rreturn) + Math.PI / 2;
        this.roulette.rotation = rad;
        var add = this.game.add.tween(this.roulette).from({
            "rotation": rad + 10
        }, this.state.rouletteAnim.modValue().times(1E3).toNumber(), Phaser.Easing.Sinusoidal.Out, true);

        var _0x4d1cd4 = false;
        var WAIT = function () {
            if (!_0x4d1cd4) {

                _0x4d1cd4 = true;
                var existingNode = this.lastRewardData.name;

                var _0x9b36e7 = false;
                if ('roulette_card' == this.lastRewardData.icon) {
                    if (this.state.unlockedCards >= 52) {
                        existingNode = 'Respin!';

                        _0x9b36e7 = true;
                        this.clickSpin(true);
                    }
                }
                this.lastRewardData.onUpgrade();

                this.spinning = _0x9b36e7;
                this.updateText();
                this.rewardText.setText(existingNode);
                if (this.lastReward % 2 == 0 === this.betOnBlack && Luts.Upgrades.changeCurrency(4, this.state.chipMulti.modValue()), Luts.isActive) {
                    if (!this.worldVisible) {
                        this.state.showAutoRoll(existingNode);
                    }
                    var node = this.game.add.tween(this.rewardText.scale).to({
                        "x": 1,
                        "y": 1
                    }, 1E3, Phaser.Easing.Elastic.Out, true);
                    var alpha = this.game.add.tween(this.rewardText.scale).to({
                        "x": 0,
                        "y": 0
                    }, 500, Phaser.Easing.Back.In, false);
                    node.chain(alpha);
                }
            }
        } ['bind'](this);
        setTimeout(WAIT, this.state.rouletteAnim.modValue().times(1E3).toNumber());
        add.onComplete.add(WAIT, this);
    }
}, Luts.Object.RouletteWindow.prototype.getRewardIndexesOfFocus = function () {

    var missing = [];
    switch (this.focus) {
    case 'nothing':
        missing = this.getRewardIndexesOfType();
        break;
    case 'multi':
        missing.push.apply(missing, this.getRewardIndexesOfType("m1x2"));
        missing.push.apply(missing, this.getRewardIndexesOfType('m2x2'));
        missing.push.apply(missing, this.getRewardIndexesOfType("m3x2"));
        missing.push.apply(missing, this.getRewardIndexesOfType('m4x2'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m5x2'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m1x5'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m2x5'));
        missing.push.apply(missing, this.getRewardIndexesOfType("m3x5"));
        missing.push.apply(missing, this.getRewardIndexesOfType('m4x5'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m5x5'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m1x10'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m2x10'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m3x10'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m4x10'));
        missing.push.apply(missing, this.getRewardIndexesOfType('m5x10'));
        break;
    case 'card':
        missing.push.apply(missing, this.getRewardIndexesOfType("c2"));
        missing.push.apply(missing, this.getRewardIndexesOfType("c3"));
        missing.push.apply(missing, this.getRewardIndexesOfType("c5"));
        break;
    case "ff":
        missing.push.apply(missing, this.getRewardIndexesOfType('ff1h'));
        missing.push.apply(missing, this.getRewardIndexesOfType('ff6h'));
        missing.push.apply(missing, this.getRewardIndexesOfType('ff24'));
    }
    return missing;
}, Luts.Object.RouletteWindow.prototype.getRewardIndexesOfType = function (stopEl) {

    var collection = [];
    return this.data.rewards.forEach(function (p, resp) {
        if (!(p != stopEl && null != stopEl)) {
            collection.push(resp);
        }
    }), collection;
}, Luts.Object.RouletteWindow.prototype.setData = function () {
    this.data = Luts.Object.RouletteRules.rouletteData(this.rouletteLevel.v.toNumber());
    this.createRoulette(this.data.size);
}, Luts.Object.RouletteWindow.prototype.createRoulette = function (snap) {
    this.roulette.clear();

    var type = 0;
    for (; type < snap; type++) {
        this.roulette.beginFill(type % 2 == 0 ? Phaser.Color.hexToRGB(Luts.Config.colors.red) : Phaser.Color.hexToRGB(Luts.Config.colors.gray));

        this.roulette.lineWidth = 1;

        this.roulette.lineColor = 16777215;
        this.roulette.drawTriangle([{
            "x": 0,
            "y": 0
        }, {
            "x": Math.sin(2 * Math.PI * type / snap) * this.rouletteSize,
            "y": Math.cos(2 * Math.PI * type / snap) * this.rouletteSize
        }, {
            "x": Math.sin(2 * Math.PI * (type + 1) / snap) * this.rouletteSize,
            "y": Math.cos(2 * Math.PI * (type + 1) / snap) * this.rouletteSize
        }]);
        this.roulette.endFill();
        var urls;
        var o;
        if (type >= this.rouletteIcons.length) {
            urls = this.game.add.image(0, 0, 'ingame', 'roulette_d1');
            urls.anchor.set(0.5);
            o = new Luts.Object.Text(this.state, 0, 0, 'text', "", 16, '#ffffff');
            o.anchor.set(0.5);
            urls.toti = new(Luts.Object.Tooltip)(this.state, urls, Luts.Object.RouletteRules.data(this.data.rewards[type]).name);
            this.rouletteIcons.push(urls);
            this.rouletteTexts.push(o);
            this.roulette.addChild(urls);
            this.roulette.addChild(o);
        } else {
            urls = this.rouletteIcons[type];
            o = this.rouletteTexts[type];
        }

        urls.x = Math.sin(2 * Math.PI * (type + 0.5) / snap) * this.rouletteSize * 0.4;

        urls.y = Math.cos(2 * Math.PI * (type + 0.5) / snap) * this.rouletteSize * 0.4;
        urls.rotation = Phaser.Math.angleBetween(0, 0, urls.x, urls.y) + Math.PI / 2;

        o.x = Math.sin(2 * Math.PI * (type + 0.5) / snap) * this.rouletteSize * 0.3;

        o.y = Math.cos(2 * Math.PI * (type + 0.5) / snap) * this.rouletteSize * 0.3;
        o.rotation = urls.rotation;
        urls.frameName = Luts.Object.RouletteRules.data(this.data.rewards[type]).icon;
        o.setText(Luts.Object.RouletteRules.data(this.data.rewards[type]).text);
        urls.toti.setText(Luts.Object.RouletteRules.data(this.data.rewards[type]).name);

        urls.visible = true;

        o.visible = true;
        if (snap >= 24) {
            urls.scale.set(0.75);
            o.scale.set(0.75);
        } else {
            urls.scale.set(1);
            o.scale.set(1);
        }
    }

    var realType = type;
    for (; realType < this.rouletteIcons.length; realType++) {

        this.rouletteIcons[realType].visible = false;

        this.rouletteTexts[realType].visible = false;
    }
}, Luts.Object.GoldCardsWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Golden Cards');

    this.types2 = ['caro', 'cross', "heart", "pik"];

    var unlock = 0;
    for (; unlock < 4; unlock++) {

        var _0x4ecdb0 = 0;
        for (; _0x4ecdb0 < 13; _0x4ecdb0++) {
            var commandObject = new(Luts.Object.Card)(deepDataAndEvents, 50 + 45 * _0x4ecdb0, 200 + 65 * unlock, Luts.CardRules.typeToString(_0x4ecdb0 + 2), this.types2[unlock], true, true);
            commandObject.scale.set(0.33);

            commandObject.baseScale = 0.33;
            this.addChild(commandObject);
        }
    }
    this.goldenCardsCounter = new(Luts.Object.Text)(this.state, this.rWidth / 2, 100, 'text', 'Gildings available: ' + Luts.Format.Decimal(Luts.Upgrades.currency[2]), 34, '#ffffff');
    this.goldenCardsCounter.anchor.set(0.5);
    this.addChild(this.goldenCardsCounter);
    Luts.Events.onCurrencyChanged[2].add(function (deepDataAndEvents) {
        this.goldenCardsCounter.setText('Gildings available: ' + Luts.Format.Decimal(deepDataAndEvents));
    }, this);
    this.explainantion = new Luts.Object.Text(this.state, 300, 120, 'text', `Golden cards persist\
after prestiging`, 16, '#000000');

    this.explainantion.strokeThickness = 0;
    this.addChild(this.explainantion);
    this.resetButton = new(Luts.Object.Button)(this.state, 550, 140, 'Reset', "", this.resetGoldenCards.bind(this));
    this.addChild(this.resetButton);
    this.resetButton.setActive(this.state.goldReset);
    new(Luts.Object.Tooltip)(this.state, this.resetButton, 'Reseting is only possible once per convert');
    this.confirmEnabled = new(Luts.Value)("confirmEnabled", 1);
    this.confirmText = new(Luts.Object.Text)(this.state, 30, 130, 'text', "Enable confirmation: ", 18, '#000000');

    this.confirmText.strokeThickness = 0;
    this.addChild(this.confirmText);
    this.createToggleButton(230, 130);
}, Luts.Object.GoldCardsWindow.prototype.constructor = Luts.Object.GoldCardsWindow, Luts.Object.GoldCardsWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.GoldCardsWindow.prototype.update = function () {}, Luts.Object.GoldCardsWindow.prototype.resetGoldenCards = function () {
    new(Luts.Object.Popup)(this.state, 'To reset all golden cards you need to prestige now. Ok?', true, function (dataAndEvents) {
        if (dataAndEvents) {
            this._resetGoldenCards();
        }
    } ['bind'](this));
}, Luts.Object.GoldCardsWindow.prototype._resetGoldenCards = function () {
    var r20 = Luts.Upgrades.currency[2].add(this.state.goldenCards);
    Luts.Upgrades.resetOfCurrency(2);
    Luts.Upgrades.changeCurrency(2, r20);

    this.state.goldenCards = 0;
    this.state.prestige();

    this.state.goldReset = false;
    Luts.Store.setItem('goldReset', this.state.goldReset);
    this.resetButton.setActive(this.state.goldReset);
}, Luts.Object.GoldCardsWindow.prototype.createToggleButton = function (dataAndEvents, deepDataAndEvents) {
    this.confirmButton = new(Luts.Object.Button)(this.state, dataAndEvents, deepDataAndEvents + 15, "", "", function () {
        this.confirmEnabled.set(this.confirmEnabled.v.equals(0) ? 1 : 0);
    } ['bind'](this));
    this.addChild(this.confirmButton);
    this.confirmEnabled.onChange.add(function () {
        if (this.confirmEnabled.v.equals(1)) {
            this.confirmButton.setFrames('settings_enabled', 'settings_enabled');
        } else {
            this.confirmButton.setFrames('settings_disabled', 'settings_disabled');
        }
    } ["bind"](this));
    this.confirmEnabled.onChange.dispatch();
}, Luts.Object.ShopWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Shop');
    this.tabs = new(Luts.Object.TabManager)(deepDataAndEvents, 0, 0);
    this.socialTab = this.addTab('social', 'Social');
    this.dailyTab = this.addTab('daily', "Daily Reward");
    this.shopTab = this.addTab("shop", 'Bonus Shop');
    this.tabs.show('shop');

    this.rewards = [{
        "dtxt": '1 Day',
        "rtxt": '1 BP',
        "reward": 1
    }, {
        "dtxt": '2 Days',
        "rtxt": '2 BP',
        "reward": 2
    }, {
        "dtxt": '3 Days',
        "rtxt": '4 BP',
        "reward": 4
    }, {
        "dtxt": "4 Days",
        "rtxt": '5 BP',
        "reward": 5
    }, {
        "dtxt": '5 Days',
        "rtxt": '7 BP',
        "reward": 7
    }, {
        "dtxt": '6 Days',
        "rtxt": '8 BP',
        "reward": 8
    }, {
        "dtxt": '7 Days+',
        "rtxt": "?",
        "reward": 10
    }];
    this.bpText = new(Luts.Object.Text)(deepDataAndEvents, 400, 40, "regular", "BP: " + Luts.Format.Decimal(Luts.Upgrades.currency[6]), 20);
    this.addChild(this.bpText);
    Luts.Events.onCurrencyChanged[6].add(function () {
        this.bpText.setText('BP: ' + Luts.Format.Decimal(Luts.Upgrades.currency[6]));
    }, this);
    this.fbText = new(Luts.Object.Text)(deepDataAndEvents, 50, 150, 'text', "Like me on Facebook for +10% 1st dice multiplier:", 16, '#000000');

    this.fbText.strokeThickness = 0;
    this.socialTab.addChild(this.fbText);
    this.kongText = new(Luts.Object.Text)(deepDataAndEvents, 50, 200, 'text', "Follow me on Kongregate for +10% 2nd multiplier:", 16, "#000000");

    this.kongText.strokeThickness = 0;
    this.socialTab.addChild(this.kongText);
    this.redditText = new(Luts.Object.Text)(deepDataAndEvents, 50, 250, 'text', 'Subscribe the subreddit for +10% 3rd multiplier:', 16, '#000000');

    this.redditText.strokeThickness = 0;
    this.socialTab.addChild(this.redditText);
    this.discordText = new(Luts.Object.Text)(deepDataAndEvents, 50, 300, 'text', 'Join the discord channel for +10% 4th multiplier:', 16, '#000000');

    this.discordText.strokeThickness = 0;
    this.socialTab.addChild(this.discordText);
    this.fbButton = new(Luts.Object.Button)(deepDataAndEvents, 530, 160, 'Facebook', "", this.state.clickFacebook.bind(this.state));
    this.socialTab.addChild(this.fbButton);
    this.kongButton = new(Luts.Object.Button)(deepDataAndEvents, 530, 210, 'Kongregate', "", this.state.clickKong.bind(this.state));
    this.socialTab.addChild(this.kongButton);
    this.redditButton = new(Luts.Object.Button)(deepDataAndEvents, 530, 260, 'Reddit', "", this.state.clickReddit.bind(this.state));
    this.socialTab.addChild(this.redditButton);
    this.discordButton = new(Luts.Object.Button)(deepDataAndEvents, 530, 310, 'Discord', "", this.state.clickDiscord.bind(this.state));
    this.socialTab.addChild(this.discordButton);
    this.paypalButton = new(Luts.Object.Button)(deepDataAndEvents, this.rWidth / 2, 410, "Donate", "", this.state.clickPaypal.bind(this.state));
    this.socialTab.addChild(this.paypalButton);

    this.paypalButton.visible = !Luts.Connect.kong;
    this.streak = Luts.Store.getItem('streak', 0);
    this.nextDailyText = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2, 150, 'text', 'Next Daily Reward: ', 22, '#000000');

    this.nextDailyText.strokeThickness = 0;
    this.nextDailyText.anchor.set(0.5);
    this.dailyTab.addChild(this.nextDailyText);
    this.streakText = new(Luts.Object.Text)(deepDataAndEvents, this.rWidth / 2, 180, 'text', 'Current Streak: ', 22, '#000000');

    this.streakText.strokeThickness = 0;
    this.streakText.anchor.set(0.5);
    this.dailyTab.addChild(this.streakText);
    this.boxes = this.state.add.graphics(25, 220);
    this.dailyTab.addChild(this.boxes);
    this.setStreakText();
    this.rewards.forEach(function (dataAndEvents, ignoreMethodDoesntExist) {
        var uriParts = new(Luts.Object.Text)(deepDataAndEvents, 65 + 85 * ignoreMethodDoesntExist, 340, 'text', dataAndEvents.dtxt, 22, "#000000");

        uriParts.strokeThickness = 0;
        uriParts.anchor.set(0.5);
        this.dailyTab.addChild(uriParts);
        var r20 = new(Luts.Object.Text)(deepDataAndEvents, 65 + 85 * ignoreMethodDoesntExist, 260, 'text', dataAndEvents.rtxt, 28, '#ffffff');
        r20.anchor.set(0.5);
        this.dailyTab.addChild(r20);
    } ['bind'](this));
    this.claimButton = new(Luts.Object.Button)(deepDataAndEvents, this.rWidth / 2, 410, 'Claim', "", this.claim.bind(this));
    this.dailyTab.addChild(this.claimButton);
    this.state.bonusUpgrades.forEach(function (dataAndEvents, deltaY) {
        var r20 = new(Luts.Object.BonusUpgradeButton)(deepDataAndEvents, 135 + 220 * Math.floor(deltaY / 3), 200 + deltaY % 3 * 50, dataAndEvents);
        this.shopTab.addChild(r20);
    } ['bind'](this));
    this.resetButton = new(Luts.Object.Button)(deepDataAndEvents, 550, 400, "Reset", "", function () {
        var r20 = Luts.Upgrades.currency[6];
        Luts.Upgrades.resetOfCurrency(6);
        Luts.Upgrades.changeCurrency(6, r20);
    } ["bind"](this));
    this.shopTab.addChild(this.resetButton);

    this.resetButton.visible = false;
    this.adButton = new(Luts.Object.Button)(deepDataAndEvents, 550, 400, 'Get 5 BP', 'Watch Ad', function () {
        this.requestAdForBp();
    } ["bind"](this));
    this.shopTab.addChild(this.adButton);
    this.adButton.visible = Luts.Ad.enabled;
    this.mtxButton = new(Luts.Object.Button)(deepDataAndEvents, 450, 400, 'Get More', "", function () {
        deepDataAndEvents.mtxClicked();
    } ['bind'](this));
    this.shopTab.addChild(this.mtxButton);
    this.mtxButton.visible = Luts.mtxEnabled && (Luts.Connect.kong || Luts.Connect.store);
    this.applyUpgrades();
}, Luts.Object.ShopWindow.prototype.constructor = Luts.Object.ShopWindow, Luts.Object.ShopWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.ShopWindow.prototype.applyUpgrades = function () {
    this.state.comboMulti.setMultiplier('bonus', Luts.Upgrades.value('bonusComboMulti'));
    this.state.chipMulti.setMultiplier('bonus', Luts.Upgrades.value("bonusChipMulti"));
    this.state.skillPointMulti.setMultiplier('bonus', Luts.Upgrades.value("bonusSkillMulti"));
    this.state.cardProgressMulti.setMultiplier('bonus', Luts.Upgrades.value('bonusCardMulti'));
}, Luts.Object.ShopWindow.prototype.requestAdForBp = function () {
    Luts.Ad.requestAd();
    Luts.Events.onAdEnded.addOnce(function (dataAndEvents) {
        if (dataAndEvents) {
            Luts.Upgrades.changeCurrency(6, 5);
            new(Luts.Object.Popup)(this.state, 'You got 5 Bonus Points!');
        } else {
            new(Luts.Object.Popup)(this.state, 'No Ad available, try again later');
        }
    }, this);
}, Luts.Object.ShopWindow.prototype.update = function () {

    var suggestedValue = Luts.Time.lastDailyReward - ((new Date).getTime() - 864E5);
    this.nextDailyText.setText('Next Daily Reward: ' + Luts.Format.Time(Math.max(0, suggestedValue)));
    this.claimButton.setActive(suggestedValue <= 0, true);

    this.state.rewardAvailableText.visible = false;
    if (suggestedValue <= 0) {
        this.nextDailyText.setText('Daily Reward available');
    }
    if (suggestedValue <= -864E5) {

        this.streak = 0;
        Luts.Store.setItem("streak", this.streak);
        this.setStreakText();
    }
}, Luts.Object.ShopWindow.prototype.setStreakText = function () {

    var spaces = "";
    if (1 != this.streak) {

        spaces = "s";
    }
    this.boxes.clear();

    this.boxes.lineWidth = 2;

    this.boxes.lineColor = 0;

    var _0x358c16 = 0;
    for (; _0x358c16 < 7; _0x358c16++) {
        this.boxes.drawRect(85 * _0x358c16, 0, 85, 140);
    }

    var streak = 0;
    for (; streak < 7; streak++) {
        this.boxes.beginFill(Luts.Config.colors.green2, this.streak >= streak ? 1 : 0);
        if (this.streak == streak) {
            this.boxes.beginFill(Luts.Config.colors.yellow2);
        }
        this.boxes.drawRect(85 * streak, 0, 85, 140);
        this.boxes.endFill();
    }
    this.streakText.setText('Current Streak: ' + this.streak + ' Day' + spaces);
}, Luts.Object.ShopWindow.prototype.claim = function () {

    Luts.Time.lastDailyReward = 864E5 * Math.floor((new Date).getTime() / 864E5);
    Luts.Store.setItem('lastDailyReward', Luts.Time.lastDailyReward);
    var r20 = this.rewards[Math.min(this.streak, 6)].reward;
    Luts.Upgrades.changeCurrency(6, r20);
    this.streak++;
    Luts.Store.setItem('streak', this.streak);
    this.setStreakText();
    new(Luts.Object.Popup)(this.state, 'You received ' + r20 + " Bonus Points!\nCome back tomorrow for more!");
}, Luts.Object.ShopWindow.prototype.addTab = function (key, dataAndEvents) {
    var camelKey = this.tabs.add(key);
    this.addChild(camelKey);
    var r20 = new(Luts.Object.Button)(this.state, 85 + 120 * (this.tabs.tabs.length - 1), 100, dataAndEvents, "");
    return this.addChild(r20), r20.visible = false, 'daily' == key && (r20.setActive(false), r20.setActive(true, Luts.Time.lastDailyReward - ((new Date).getTime() - 864E5))), this.tabs.setTabButton(key, r20), camelKey;
}, Luts.Object.CasinoWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Casinos');
    this.explainantion = new(Luts.Object.Text)(deepDataAndEvents, 30, 70, 'text', "Invest a golden deck into a casino to gain more luck and skills.", 20, "#000000");

    this.explainantion.strokeThickness = 0;
    this.addChild(this.explainantion);
    this.tabs = new(Luts.Object.TabManager)(deepDataAndEvents, 0, 0);
    this.casinosTab = this.tabs.add('casinos');
    this.skillsTab = this.tabs.add("skills");
    this.addChild(this.casinosTab);
    this.addChild(this.skillsTab);
    this.casinosButton = new(Luts.Object.Button)(deepDataAndEvents, 80, 140, 'Casinos', "");
    this.addChild(this.casinosButton);
    this.skillsButton = new(Luts.Object.Button)(deepDataAndEvents, 200, 140, 'Skills', "");
    this.addChild(this.skillsButton);
    this.tabs.setTabButton(this.casinosTab, this.casinosButton);
    this.tabs.setTabButton(this.skillsTab, this.skillsButton);
    this.tabs.show("casinos");
    this.skillPointsText = new(Luts.Object.Text)(deepDataAndEvents, 40, 180, "text", 'Skill Points: ' + Luts.Format.Decimal(Luts.Upgrades.currency[5]), 20, '#000000');

    this.skillPointsText.strokeThickness = 0;
    this.skillsTab.addChild(this.skillPointsText);
    this.resetButton = new(Luts.Object.Button)(deepDataAndEvents, 550, 200, "Reset", "", function () {
        Luts.Upgrades.resetOfCurrency(5);
        Luts.Upgrades.changeCurrency(5, this.state.casinos.v.times(this.state.skillPointMulti.modValue()));
        this.resetButton.setActive(false);
        Luts.Store.setItem('skillReset', false);
    } ['bind'](this));
    this.skillsTab.addChild(this.resetButton);
    new Luts.Object.Tooltip(deepDataAndEvents, this.resetButton, 'Only possible once per investment!');
    this.resetButton.setActive(Luts.Store.getItem('skillReset', true));
    this.state.skillPointMulti.onChange.add(this.resetButton.callback, this);
    Luts.Events.onCurrencyChanged[5].add(function () {
        this.skillPointsText.setText("Skill Points: " + Luts.Format.Decimal(Luts.Upgrades.currency[5]));
    }, this);
    this.state.skillUpgrades.forEach(function (dataAndEvents, deltaY) {
        var r20 = new(Luts.Object.SkillUpgradeButton)(deepDataAndEvents, 135 + 220 * Math.floor(deltaY / 3), 250 + deltaY % 3 * 50, dataAndEvents);
        this.skillsTab.addChild(r20);
    } ["bind"](this));
    this.skillBuyAmount = new(Luts.Object.BuyAmountButtons)(this.state, 450, 420, [1, 10, 100], true, 5);
    this.skillsTab.addChild(this.skillBuyAmount);
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 170, this.rWidth - 30, this.rHeight - 195);
    this.casinosTab.addChild(this.scroll);

    this.scrollIndex = 0;

    this.casinos = [];
    this.addCasino({
        "title": 'Table under a bridge'
    });
    this.addCasino({
        "title": "Dirty backyard hut"
    });
    this.addCasino({
        "title": "Backdoor of pizza place"
    });
    this.addCasino({
        "title": 'Groundfloor of harbour bar'
    });
    this.addCasino({
        "title": 'An actual registered small casino'
    });
    this.addCasino({
        "title": '2-Floor Casino'
    });
    this.addCasino({
        "title": "3-Floor Casino"
    });
    this.addCasino({
        "title": '1 Star Casino'
    });
    this.addCasino({
        "title": '2 Star Casino'
    });
    this.addCasino({
        "title": "3 Star Casino"
    });
    this.addCasino({
        "title": "4 Star Casino"
    });
    this.addCasino({
        "title": "5 Star Casino"
    });
    this.addCasino({
        "title": "Casino Village"
    });
    this.addCasino({
        "title": 'Casino Town'
    });
    this.addCasino({
        "title": 'Casino City'
    });
    this.addCasino({
        "title": 'Casino Country'
    });
    this.addCasino({
        "title": "Casino-filled Antarctica"
    });
    this.addCasino({
        "title": 'Casino-filled Australia'
    });
    this.addCasino({
        "title": 'Casino-filled Africa'
    });
    this.addCasino({
        "title": 'Casino-filled South America'
    });
    this.addCasino({
        "title": 'Casino-filled Asia'
    });
    this.addCasino({
        "title": 'Casino-filled Europe'
    });
    this.addCasino({
        "title": 'Casino-filled America'
    });
    this.addCasino({
        "title": 'Casino-filled Earth'
    });
    this.addCasino({
        "title": "Moon Casino"
    });
    this.addCasino({
        "title": "Mars Casino"
    });
    this.addCasino({
        "title": "Artificial Casino Planet"
    });
    this.addCasino({
        "title": 'Artificial Casino Star'
    });
    this.addCasino({
        "title": "Artificial Casino Galaxy"
    });
    this.addCasino({
        "title": 'The whole universe filled with casinos'
    });
    this.addCasino({
        "title": 'Casino in heaven'
    });
    this.addCasino({
        "title": "Casino in hell"
    });
    this.addCasino({
        "title": 'Satans personal casino'
    });
    this.initalCasinoLength = this.casinos.length;
    Luts.Events.onDrawCard.add(this.updateContainers, this);
    this.updateContainers();
}, Luts.Object.CasinoWindow.prototype.constructor = Luts.Object.CasinoWindow, Luts.Object.CasinoWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.CasinoWindow.prototype.update = function () {
    if (this.shown) {
        this.scroll.update();
    }
}, Luts.Object.CasinoWindow.prototype.invest = function (safe) {
    safe.i;
    safe.setActive(false);
    if (this.state.goldenCards >= 52) {
        new(Luts.Object.Popup)(this.state, "You will lose all you golden cards, it will be 30% harder to get cards but you get 20% more luck. You will lose all luck.\nInvest?", true, function (dataAndEvents) {
            safe.setActive(true);
            if (dataAndEvents) {
                this.state.prestige3();
                this.updateContainers();
                this.resetButton.setActive(true);
                Luts.Store.setItem("skillReset", true);
            }
        } ['bind'](this));
    }
}, Luts.Object.CasinoWindow.prototype.updateContainers = function () {
    for (; this.state.casinos.v.greaterThanOrEqualTo(this.casinos.length);) {
        this.addCasino({
            "title": 'Interdimensional Casino ' + (this.casinos.length - this.initalCasinoLength + 1)
        });
    }
    this.casinos.forEach(this.updateContainer.bind(this));
}, Luts.Object.CasinoWindow.prototype.updateContainer = function (btns) {
    if (this.state.casinos.v.greaterThanOrEqualTo(btns.i)) {

        btns.alpha = 1;
        if (this.state.casinos.v.equals(btns.i)) {

            btns.btn.visible = true;
            btns.btn.setActive(this.state.goldenCards >= 52);
        } else {

            btns.btn.visible = false;
        }
    } else {

        btns.alpha = 0;
    }
}, Luts.Object.CasinoWindow.prototype.addCasino = function (dataAndEvents) {
    var self = this.game.add.image(0, 50 * this.scrollIndex++);
    var tempFile = new(Luts.Object.Text)(this.state, 20, 0, 'text', dataAndEvents.title, 24);
    self.addChild(tempFile);
    var r20 = new(Luts.Object.Text)(this.state, 20, 30, 'text', 'Cardprogress /' + Luts.Format.Decimal(Math.pow(1.3, this.scrollIndex)), 14, '#000000');

    r20.strokeThickness = 0;
    self.addChild(r20);
    var className = new(Luts.Object.Text)(this.state, 170, 30, 'text', 'Luck Multi: ' + Luts.Format.Decimal(Math.pow(1.2, this.scrollIndex)), 14, '#000000');

    className.strokeThickness = 0;
    self.addChild(className);
    var restoreScript = new(Luts.Object.Text)(this.state, 320, 30, "text", 'BP: +' + Math.min(this.scrollIndex, 33), 14, '#000000');

    restoreScript.strokeThickness = 0;
    self.addChild(restoreScript);
    var e = new(Luts.Object.Button)(this.state, 540, 30, "Invest", "", this.invest.bind(this));

    e.i = this.scrollIndex - 1;
    self.addChild(e);
    self.btn = e;

    self.i = this.scrollIndex - 1;
    this.casinos.push(self);
    this.scroll.addToScrollGroup(self);
}, Luts.Object.ChangeLogWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, 'Changelog');
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 70, this.rWidth - 30, this.rHeight - 90);
    this.addChild(this.scroll);
    this.data = this.game.cache.getJSON('changelog');

    this.scrollIndex = 0;
    this.data.logs.forEach(this.addChangelog.bind(this));
}, Luts.Object.ChangeLogWindow.prototype.constructor = Luts.Object.ChangeLogWindow, Luts.Object.ChangeLogWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.ChangeLogWindow.prototype.update = function () {
    if (this.shown) {
        this.scroll.update();
    }
}, Luts.Object.ChangeLogWindow.prototype.addChangelog = function (dataAndEvents) {
    var r20 = new(Luts.Object.Text)(this.state, 10, 10 + 25 * this.scrollIndex, 'text', dataAndEvents.version, 24, '#000000');

    r20.strokeThickness = 0;
    this.scrollIndex++;
    this.scroll.addToScrollGroup(r20);
    dataAndEvents.log.forEach(function (dataAndEvents) {
        var r20 = new(Luts.Object.Text)(this.state, 10, 10 + 25 * this.scrollIndex, 'text', dataAndEvents, 18, '#000000');

        r20.strokeThickness = 0;

        r20.wordWrapWidth = 600;
        this.scrollIndex += r20.height / 20;
        this.scroll.addToScrollGroup(r20);
    } ['bind'](this));
    this.scrollIndex++;
    this.scrollIndex++;
}, Luts.Object.MtxWindow = function (deepDataAndEvents) {
    Luts.Object.Window.call(this, deepDataAndEvents, "Buy More");
    this.scroll = new(Luts.Object.Scrollable)(deepDataAndEvents, 10, 70, this.rWidth - 30, this.rHeight - 90);
    this.addChild(this.scroll);
    this.swapChildren(this.scroll, this.closeButton);

    this.scrollIndex = 0;
    this.claimedBPs = Luts.Store.getItem('claimedBPs', 0);
    this.claimBPs();

    Luts.Shop.fakeList = [{
        "id": "1bp10",
        "name": "10 Bonus Points",
        "cost": 10,
        "callback": this.claimBPs.bind(this),
        "androidCallback": function () {
            Luts.Upgrades.changeCurrency(6, 10);
        } ['bind'](this)
    }, {
        "id": '2bp50',
        "name": '55 Bonus Points',
        "cost": 50,
        "callback": this.claimBPs.bind(this),
        "androidCallback": function () {
            Luts.Upgrades.changeCurrency(6, 55);
        } ['bind'](this)
    }, {
        "id": '3bp100',
        "name": '115 Bonus Points',
        "cost": 100,
        "callback": this.claimBPs.bind(this),
        "androidCallback": function () {
            Luts.Upgrades.changeCurrency(6, 115);
        } ["bind"](this)
    }, {
        "id": "4bp500",
        "name": "600 Bonus Points",
        "cost": 500,
        "callback": this.claimBPs.bind(this),
        "androidCallback": function () {
            Luts.Upgrades.changeCurrency(6, 600);
        } ['bind'](this)
    }, {
        "id": '5bp1000',
        "name": '1300 Bonus Points (300 FREE!)',
        "cost": 1E3,
        "callback": this.claimBPs.bind(this),
        "androidCallback": function () {
            Luts.Upgrades.changeCurrency(6, 1300);
        } ["bind"](this)
    }];
    Luts.Shop.getBuyableItems(function (dataAndEvents) {
        dataAndEvents.forEach(this.addItem.bind(this));
    } ['bind'](this));
}, Luts.Object.MtxWindow.prototype.constructor = Luts.Object.MtxWindow, Luts.Object.MtxWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.MtxWindow.prototype.update = function () {
    if (this.shown) {
        this.scroll.update();
    }
}, Luts.Object.MtxWindow.prototype.getBoughtBPs = function (on) {
    Luts.Shop.getItemList(function (vis) {

        var failuresLink = 0;

        var i = 0;
        for (; i < vis.length; i++) {
            if ("1bp10" == vis[i].identifier) {
                failuresLink += 10;
            }
            if ("2bp50" == vis[i].identifier) {
                failuresLink += 55;
            }
            if ('3bp100' == vis[i].identifier) {
                failuresLink += 115;
            }
            if ('4bp500' == vis[i].identifier) {
                failuresLink += 600;
            }
            if ('5bp1000' == vis[i].identifier) {
                failuresLink += 1300;
            }
        }
        on(failuresLink);
    });
}, Luts.Object.MtxWindow.prototype.claimBPs = function () {
    this.getBoughtBPs(function (dataAndEvents) {
        Luts.Upgrades.changeCurrency(6, dataAndEvents - this.claimedBPs);
        this.claimedBPs = dataAndEvents;
        Luts.Store.setItem("claimedBPs", this.claimedBPs);
    } ['bind'](this));
}, Luts.Object.MtxWindow.prototype.addItem = function (done) {
    var r20 = new(Luts.Object.Text)(this.state, 10, 60 * this.scrollIndex + 30, "text", done.name, 20, '#000000');
    var restoreScript = new(Luts.Object.Button)(this.state, 550, 60 * this.scrollIndex + 50, 'Buy', done.cost + Luts.Connect.kong ? ' Kreds' : "", function () {
        Luts.Shop.buyItem(done.id, function (dataAndEvents) {
            if (dataAndEvents) {
                done.callback();
            }
        });
    });

    r20.strokeThickness = 0;
    this.scroll.addToScrollGroup(r20);
    this.scroll.addToScrollGroup(restoreScript);
    this.scrollIndex++;
}, Luts.Object.SlotWindow = function (name) {
    Luts.Object.Window.call(this, name, 'Slot Machine');
    Luts.Events.changedUsedItem = new(Phaser.Signal);
    this.tabs = new(Luts.Object.TabManager)(name, 0, 0);
    this.slotTab = this.addTab("slot", 'Slot');
    this.layoutTab = this.addTab("layout", 'Layout');
    this.diamondCardTab = this.addTab("diamondCards", "Dia Cards");
    this.tabs.show(this.slotTab);
    this.spins = Luts.Upgrades.add('slotSpins', "", "", 1, 1, 1, 0, null, 0, null, 7);
    this.columns = Luts.Upgrades.add('coloums', "Add column", 'If you hit the same item in multiple columns, the reward gets multiplied by (item hits) power 2', 10, 1, 50, 1, 4, 0, null, 8);
    this.diaCardDraw = Luts.Upgrades.add("diaCardDraw", "", "", 10, 0, 1, 1, null, 0, null, 9);

    this.itemUpgrades = [Luts.Upgrades.add('slotItem1', 'Apple', 'Gives 5 Diamonds', 1, 0, 1, 1, 50, 0, null, 8), Luts.Upgrades.add('slotItem2', 'Dice', "Gives +100% Combomulti", 5, 0, 5, 1, 50, 0, null, 8), Luts.Upgrades.add('slotItem3', "Luts", 'Gives 25 Diamonds', 25, 0, 25, 1, 50, 0, null, 8), Luts.Upgrades.add('slotItem4', "Chip", "Gives +100% Chip Multi",
        150, 0, 150, 1, 50, 0, null, 8), Luts.Upgrades.add('slotItem5', 'Apple', "Gives 125 Diamonds", 750, 0, 750, 1, 50, 0, null, 8), Luts.Upgrades.add('slotItem6', 'Diamond Card', 'Gives 1 Diamond Card Point', 3500, 0, 3500, 1, 50, 0, null, 8)];
    this.usedItem = JSON.parse(Luts.Store.getItem('usedSlots', '[40,0,0,0,0,0,0,0]'));
    this.slots = JSON.parse(Luts.Store.getItem('slots', '[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]]'));

    this.unlockedSlots = 1;

    this.slotImages = [];

    this.loImages = [];
    this.stopPos = Luts.Store.getItem('stopPos', 0);
    this.slotMask = this.game.add.graphics(200, 150);
    this.slotMask.beginFill(0);
    this.slotMask.drawRect(0, 0, 250, 138);
    this.slotMask.endFill();
    this.slotTab.addChild(this.slotMask);
    this.slotBack = this.game.add.image(197, 145, 'ingame', 'slotMachine');
    this.slotTab.addChild(this.slotBack);
    this.result = JSON.parse(Luts.Store.getItem('slotResult', "[]"));

    this.layoutRows = [];
    this.slotMachine = this.game.add.image(0, 0);
    this.slotTab.addChild(this.slotMachine);
    this.slotMachine.mask = this.slotMask;

    this.slotRows = [this.game.add.image(200, 0), this.game.add.image(250, 0), this.game.add.image(300, 0), this.game.add.image(350, 0), this.game.add.image(400, 0)];
    this.slotRows.forEach(function (res, opt_obj) {
        this.slotMachine.addChild(res);
        res.spinning = Luts.Store.getItem('spinning' + opt_obj, false);
        res.visible = this.columns.value.greaterThan(opt_obj);
        var r20 = this.game.add.image(20, 140 + 46 * opt_obj);
        this.layoutRows.push(r20);
        this.layoutTab.addChild(r20);
        r20.visible = this.columns.value.greaterThan(opt_obj);
    } ["bind"](this));
    this.fillImages();
    this.columns.onUpgrade.add(function () {
        this.slotRows.forEach(function (res, opt_obj) {
            res.visible = this.columns.value.greaterThan(opt_obj);
        } ["bind"](this));
        this.layoutRows.forEach(function (res, opt_obj) {
            res.visible = this.columns.value.greaterThan(opt_obj);
        } ['bind'](this));
    }, this);
    this.buyRowButton = new(Luts.Object.SlotUpgradeButton)(name, this.rWidth / 2 + 240, 225, this.columns);
    this.slotTab.addChild(this.buyRowButton);
    this.spinButton = new Luts.Object.Button(name, this.rWidth / 2, 415, this.slotRows[this.columns.value.toNumber() - 1].spinning ? 'Stop' : 'Spin', this.slotRows[this.columns.value.toNumber() - 1].spinning ? " " : Luts.Format.Decimal(Luts.Upgrades.currency[7]), function () {
        this.clickSpin(false);
    } ["bind"](this));
    this.slotTab.addChild(this.spinButton);
    Luts.Events.onCurrencyChanged[7].add(this.updateSpinButton, this);
    Luts.Events.onCurrencyChanged[6].add(this.updateSpinButton, this);
    this.spinButton.setActive(this.slotRows[this.columns.value.toNumber() - 1].spinning || Luts.Upgrades.currency[7].greaterThan(0));
    new(Luts.Object.Tooltip)(name, this.spinButton, 'To get Slot Spins, you need to prestige your roulette');
    this.bpSpinButton = new(Luts.Object.Button)(name, this.rWidth / 2 + 120, 415, 'BP Spin', '60 BP', this.bpSpin.bind(this));
    this.slotTab.addChild(this.bpSpinButton);
    this.prestigeRouletteButton = new(Luts.Object.Button)(name, this.rWidth / 2 + 240, 415, 'Prestige', "Roulette", this.prestigeRoulette.bind(this));
    this.slotTab.addChild(this.prestigeRouletteButton);
    this.prestigeRouletteButton.setActive(false);
    this.prestigeRouletteButton.setActive(Luts.Value.get("rouletteLevel").v.greaterThanOrEqualTo(34), true);
    Luts.Value.get('rouletteLevel').onChange.add(function () {
        this.prestigeRouletteButton.setActive(Luts.Value.get('rouletteLevel').v.greaterThanOrEqualTo(34), true);
    }, this);
    new(Luts.Object.Tooltip)(name, this.prestigeRouletteButton, 'If your roulette is at least level 34, you can reset it to level 1 and lose your chips + roulette upgrades. You will get Slot Machine Spins equal to your number of casinos / 10');
    this.diaText = new(Luts.Object.Text)(name, 400, 80, 'regular', "Diamonds: " + Luts.Format.Decimal(Luts.Upgrades.currency[8]), 20);
    this.addChild(this.diaText);
    Luts.Events.onCurrencyChanged[8].add(function () {
        this.diaText.setText('Diamonds: ' + Luts.Format.Decimal(Luts.Upgrades.currency[8]));
    }, this);
    this.rewardText = new(Luts.Object.Text)(name, this.rWidth / 2, this.rHeight / 2, 'text', 'Reward', 60);
    this.rewardText.anchor.set(0.5);
    this.rewardText.scale.set(0);
    this.addChild(this.rewardText);

    this.selectedItem = 0;
    this.inventoryText = new(Luts.Object.Text)(name, 20, 390, 'text', 'Inventory:', 20);
    this.layoutTab.addChild(this.inventoryText);
    this.buyText = new(Luts.Object.Text)(name, 570, 105, 'text', 'Buy:', 20);
    this.layoutTab.addChild(this.buyText);
    this.itemUpgrades.forEach(function (item, dataAndEvents) {

        item.priceIncreaseMethod = 1;
        var result = new(Luts.Object.Button)(name, 600, 165 + 46 * dataAndEvents, "", Luts.Format.Color(Luts.Upgrades.isAffordable(item) ? "green" : 'red') + Luts.Format.Decimal(item.price), function (dataObj) {
            Luts.Upgrades.upgrade(dataObj.u);
        });

        result.subtitle.strokeThickness = result.subtitle.size / 10;
        item.buyItem = result;

        result.u = item;

        result.visible = false;
        result.subtitle.y += 5;
        result.subtitle.scale.set(1.5);
        result.icon.loadTexture('ingame');

        result.icon.frameName = "slotItem" + (dataAndEvents + 1);
        result.loadTexture('ingame');
        result.setFrames('slotBack1', 'slotBack0');
        this.layoutTab.addChild(result);
        new(Luts.Object.Tooltip)(name, result, item.description);
        item.onUpgrade.add(function (deepDataAndEvents) {
            deepDataAndEvents.buyItem.subtitle.setText(Luts.Format.Color(Luts.Upgrades.isAffordable(deepDataAndEvents) ? "green" : 'red') + Luts.Format.Decimal(deepDataAndEvents.price));
        } ['bind'](this));
    } ['bind'](this));
    Luts.Events.onCurrencyChanged[8].add(function (dataAndEvents) {
        this.itemUpgrades.forEach(function (deepDataAndEvents) {
            deepDataAndEvents.buyItem.subtitle.setText(Luts.Format.Color(Luts.Upgrades.isAffordable(deepDataAndEvents) ? 'green' : "red") + Luts.Format.Decimal(deepDataAndEvents.price));
        } ['bind'](this));
    }, this);

    var element = 1;
    for (; element < 7; element++) {
        var data = Luts.Upgrades.get('slotItem' + element);
        var map = new(Luts.Object.Button)(name, 100 + 50 * element, 405, "", data.value.minus(this.usedItem[element]), this.assignItem.bind(this));
        data.invItem = map;

        data.i = element;

        map.subtitle.strokeThickness = map.subtitle.size / 10;
        map.subtitle.y += 5;

        map.i = element;

        map.visible = false;
        map.subtitle.scale.set(1.5);
        map.subtitle.addColor('#ffffff', 0);
        map.icon.loadTexture("ingame");
        map.icon.frameName = 'slotItem' + element;
        map.loadTexture('ingame');
        map.setFrames('slotBack1', 'slotBack0');
        new(Luts.Object.Tooltip)(this.state, map, 'Click on an item and then on a slot to assign it');
        this.layoutTab.addChild(map);
        data.onUpgrade.add(function (safe) {
            safe.invItem.subtitle.setText(safe.value.minus(this.usedItem[safe.i]));
            safe.invItem.subtitle.addColor('#ffffff', 0);
            safe.invItem.setActive(false);
            safe.invItem.setActive(true, true);
        } ['bind'](this));
    }
    this.itemUpgrades.forEach(function (i, dataAndEvents) {
        if (dataAndEvents > 0) {
            var state = Luts.Upgrades.get('slotItem' + dataAndEvents);
            if (state.value.greaterThan(0)) {

                i.invItem.visible = true;

                i.buyItem.visible = true;
            }

            state.u = i;
            state.onUpgrade.add(function (dataObj) {

                dataObj.u.invItem.visible = true;

                dataObj.u.buyItem.visible = true;
            }, this);
        } else {

            i.invItem.visible = true;

            i.buyItem.visible = true;
        }
    }, this);
    Luts.Events.changedUsedItem.add(function () {
        this.itemUpgrades.forEach(function (safe) {
            safe.invItem.subtitle.setText(safe.value.minus(this.usedItem[safe.i]));
            safe.invItem.subtitle.addColor("#ffffff", 0);
        } ['bind'](this));
    } ["bind"](this));
    Luts.Events.onAsyncUpdate.add(this.update, this);

    this.types2 = ['caro'];

    var unlock = 0;
    for (; unlock < this.types2.length; unlock++) {

        element = 0;
        for (; element < 13; element++) {
            var spy = new(Luts.Object.Card)(name, 50 + 45 * element, 200 + 65 * unlock, Luts.CardRules.typeToString(element + 2), this.types2[unlock], false, false, true);
            spy.scale.set(0.33);

            spy.baseScale = 0.33;
            this.diamondCardTab.addChild(spy);
        }
    }
    this.dcpText = new(Luts.Object.Text)(name, 30, 400, "text", "Dia Card Points: " + Luts.Format.Decimal(Luts.Upgrades.currency[9]), 20);
    this.diamondCardTab.addChild(this.dcpText);
    this.dcrewardText = new(Luts.Object.Text)(name, this.rWidth / 2, this.rHeight / 2, 'text', 'Reward', 60);
    this.dcrewardText.anchor.set(0.5);
    this.dcrewardText.scale.set(0);
    this.addChild(this.dcrewardText);
    this.drawDiaCardButton = new(Luts.Object.Button)(name, this.rWidth / 2, 415, "Draw", Luts.Format.Color(Luts.Upgrades.isUpgradeable("diaCardDraw") ? 'green' : 'red') + '10 DCP', this.drawDiaCard.bind(this));
    this.diamondCardTab.addChild(this.drawDiaCardButton);
    this.drawDiaCardButton.setActive(Luts.Upgrades.isUpgradeable("diaCardDraw"));
    Luts.Events.onCurrencyChanged[9].add(function (deepDataAndEvents) {
        this.drawDiaCardButton.subtitle.setText(Luts.Format.Color(Luts.Upgrades.isUpgradeable("diaCardDraw") ? 'green' : 'red') + '10 DCP');
        this.drawDiaCardButton.setActive(Luts.Upgrades.isUpgradeable('diaCardDraw'));
        this.dcpText.setText('Dia Card Points: ' + Luts.Format.Decimal(deepDataAndEvents));
    }, this);
}, Luts.Object.SlotWindow.prototype.constructor = Luts.Object.SlotWindow, Luts.Object.SlotWindow.prototype = Object.create(Luts.Object.Window.prototype), Luts.Object.SlotWindow.prototype.drawDiaCard = function () {
    if (Luts.Upgrades.upgrade(this.diaCardDraw)) {
        var arr = Luts.CardRules.typeToString(this.game.rnd.between(2, 14));
        var inner = 'caro';
        var r20 = Luts.Upgrades.get(inner + arr + "_dia");

        var later = "";
        if (0 === r20.level) {
            Luts.Upgrades.upgrade(r20, true);

            later = 'You draw caro ' + arr + "!";
        } else {
            Luts.Upgrades.changeCurrency(8, 1E4);
            later = 'You draw caro ' + arr + `\
Duplicate :(\
+10k Diamonds`;
        }
        this.rewardText.setText(later);
        var node = this.game.add.tween(this.rewardText.scale).to({
            "x": 1,
            "y": 1
        }, 1E3, Phaser.Easing.Elastic.Out, true);
        var alpha = this.game.add.tween(this.rewardText.scale).to({
            "x": 0,
            "y": 0
        }, 500, Phaser.Easing.Back.In, false);
        node.chain(alpha);
    }
}, Luts.Object.SlotWindow.prototype.assignItem = function (safe) {
    if (Luts.Upgrades.value('slotItem' + safe.i).greaterThan(this.usedItem[safe.i])) {
        this.selectedItem = safe.i;
        this.loImages.forEach(function (dataAndEvents) {
            dataAndEvents.forEach(function (commandObject) {
                commandObject.scale.set(1);
                this.game.add.tween(commandObject.scale).to({
                    "x": 0.9,
                    "y": 0.9
                }, 500, Phaser.Easing.Sinusoidal.InOut, true, 0, 2, true);
            } ['bind'](this));
        } ['bind'](this));
    }
}, Luts.Object.SlotWindow.prototype.updateSpinButton = function () {
    if (this.anySpinning()) {
        this.spinButton.setActive(true, true);
    } else {
        this.spinButton.subtitle.setText(Luts.Format.Decimal(Luts.Upgrades.currency[7]));
        this.spinButton.setActive(Luts.Upgrades.currency[7].greaterThan(0), true);
    }
}, Luts.Object.SlotWindow.prototype.update = function () {
    if (this.shown) {
        this.slotImages.forEach(function (dataAndEvents, timeoutKey) {
            if (this.slotRows[timeoutKey].spinning) {

                var j = this.game.rnd.realInRange(5, 10) * (0.5 * timeoutKey + 1);
                dataAndEvents.forEach(function (tz) {
                    tz.y += j;
                    if (tz.y >= 460) {
                        tz.y -= 460;
                    }
                } ["bind"](this));
            }
        } ['bind'](this));
    }
}, Luts.Object.SlotWindow.prototype.prestigeRoulette = function () {
    new(Luts.Object.Popup)(this.state, 'Reset your Chips, Roulette Upgrades and Roulette back to level 1 and get ' + Luts.Format.Decimal(this.state.casinos.v.dividedBy(10).ceil()) + " Slot spins (Equal to your number of casinos / 10). Are you sure to prestige your roulette?", true, function (dataAndEvents) {
        if (dataAndEvents) {
            if (Luts.Value.get('rouletteLevel').v.greaterThanOrEqualTo(34)) {
                Luts.Value.get('rouletteLevel').set(0);
                Luts.Upgrades.resetOfCurrency(4);
                Luts.Upgrades.changeCurrency(7, this.state.casinos.v.dividedBy(10).ceil());
            }
        }
    } ['bind'](this));
}, Luts.Object.SlotWindow.prototype.checkLastExport = function () {
    return Date.now() - Luts.Store.getItem('lastExport', 0) < 36E5;
}, Luts.Object.SlotWindow.prototype.nextSpin = function () {
    return Luts.Format.Color('red') + Luts.Format.Time(36E5 - (Date.now() - Luts.Store.getItem("lastExport", 0)), true) + '</c>';
}, Luts.Object.SlotWindow.prototype.bpSpin = function () {
    return this.checkLastExport() ? void new(Luts.Object.Popup)(this.state, 'You exported your save recently. To prevent cheating you have to wait ' + this.nextSpin() + ' to be able to spin again') : this.anySpinning() ? void this.clickSpin(true) : void(Luts.Upgrades.currency[6].greaterThanOrEqualTo(60) ? new(Luts.Object.Popup)(this.state, 'Do you really want to spend BP to spin?', true, function (dataAndEvents) {
        if (dataAndEvents) {
            this.clickSpin(true);
            Luts.Upgrades.changeCurrency(6, -60);
        }
    } ['bind'](this)) : Luts.Ad.enabled ? new(Luts.Object.Popup)(this.state, 'You dont have enough Bonus Points. Do you want to watch an Ad to get 5 BPs?', true, function (dataAndEvents) {
        if (dataAndEvents) {
            this.state.shopWindow.requestAdForBp();
        }
    } ["bind"](this)) : Luts.mtxEnabled && Luts.Connect.kong ? new(Luts.Object.Popup)(this.state, 'You dont have enough Bonus Points. Do you want to get more?', true, function (dataAndEvents) {
        if (dataAndEvents) {
            this.state.mtxClicked();
        }
    } ["bind"](this)) : new(Luts.Object.Popup)(this.state, 'You dont have enough Bonus Points. Check in daily and unlock achievements to get more BP'));
}, Luts.Object.SlotWindow.prototype.anySpinning = function () {

    var unlock = 0;
    for (; unlock < this.columns.value.toNumber(); unlock++) {
        if (this.slotRows[unlock].spinning) {
            return true;
        }
    }
    return false;
}, Luts.Object.SlotWindow.prototype.clickSpin = function (deepDataAndEvents) {
    if (this.checkLastExport()) {
        return void new(Luts.Object.Popup)(this.state, 'You exported your save recently. To prevent cheating you have to wait ' + this.nextSpin() + " to be able to spin again");
    }
    if (this.anySpinning()) {
        this.slotImages[this.stopPos].forEach(function (vals) {

            vals.y = 46 * Math.round(vals.y / 46) + 12;
            if (196 === vals.y) {
                this.result[this.stopPos] = this.slots[this.stopPos][vals.i];
                Luts.Store.setItem('slotResult', JSON.stringify(this.result));
            }
        } ['bind'](this));

        this.slotRows[this.stopPos].spinning = false;
        Luts.Store.setItem('spinning' + this.stopPos, false);
        this.stopPos++;
        Luts.Store.setItem("stopPos", this.stopPos);
        if (!(this.stopPos !== this.columns.value.toNumber() && this.anySpinning())) {
            this.finishSpin();
            this.spinButton.text.setText('Spin');
            Luts.Events.onCurrencyChanged[7].dispatch(Luts.Upgrades.currency[7]);
        }
    } else {
        if (Luts.Upgrades.upgrade(this.spins, deepDataAndEvents)) {
            this.slotRows.forEach(function (dataAndEvents, deepDataAndEvents) {
                if (this.columns.value.greaterThan(deepDataAndEvents)) {

                    dataAndEvents.spinning = true;
                    Luts.Store.setItem("spinning" + deepDataAndEvents, true);
                }
            } ['bind'](this));
            this.updateSpinButton();
            this.spinButton.text.setText('Stop');
            this.spinButton.subtitle.setText("");

            this.stopPos = 0;
            Luts.Store.setItem("stopPos", this.stopPos);

            this.result = [];
            Luts.Store.setItem("slotResult", JSON.stringify(this.result));
        }
    }
}, Luts.Object.SlotWindow.prototype.finishSpin = function () {

    var buf = [];

    var later = "";
    this.result.forEach(function (off, deepDataAndEvents) {
        if (this.columns.value.greaterThan(deepDataAndEvents)) {
            if (buf[off]) {
                buf[off]++;
            } else {

                buf[off] = 1;
            }
        }
    } ['bind'](this));
    buf.forEach(function (x, opt_el) {
        if (x > 0) {
            var k = Math.pow(x, 2);
            var el = this.getReward(opt_el);

            var offset0 = el.value * k;
            if ("" !== later) {
                later += "\n";
            }
            el.text = el.text.replace("%", offset0);
            el.text = el.text.replace("$", 1 === offset0 ? "" : "s");
            el.text = el.text.replace("Â§", 1 === offset0 ? "" : "S");
            later += el.text;
            el.cb(k);
        }
    } ['bind'](this));
    this.rewardText.setText(later);
    var collection = this.game.add.tween(this.rewardText.scale).to({
        "x": 1,
        "y": 1
    }, 1E3, Phaser.Easing.Elastic.Out, true);
    var resp = this.game.add.tween(this.rewardText.scale).to({
        "x": 0,
        "y": 0
    }, 500, Phaser.Easing.Back.In, false);
    collection.chain(resp);
}, Luts.Object.SlotWindow.prototype.addTab = function (key, dataAndEvents) {
    var camelKey = this.tabs.add(key);
    this.addChild(camelKey);
    var r20 = new(Luts.Object.Button)(this.state, 85 + 120 * (this.tabs.tabs.length - 1), 100, dataAndEvents, "");
    return this.addChild(r20), this.tabs.setTabButton(key, r20), 'diamondCards' === key && r20.setLock('diamondCards'), camelKey;
}, Luts.Object.SlotWindow.prototype.fillImages = function () {
    this.slots.forEach(function (dataAndEvents, m) {
        if (!this.slotImages[m]) {

            this.slotImages[m] = [];

            this.loImages[m] = [];
        }
        dataAndEvents.forEach(function (dataAndEvents, n) {
            if (!this.slotImages[m][n]) {
                this.slotImages[m][n] = this.game.add.image(0, 46 * n + 12, "ingame", 'slotBack' + n % 2);

                this.slotImages[m][n].i = n;
                this.slotImages[m][n].icon = this.game.add.image(23, 23, "ingame", 'slotItem0');
                this.slotImages[m][n].icon.anchor.set(0.5);
                this.slotImages[m][n].addChild(this.slotImages[m][n].icon);
                this.slotRows[m].addChild(this.slotImages[m][n]);
                this.loImages[m][n] = this.game.add.image(46 * n + 12 + 23, 23, 'ingame', 'slotBack' + n % 2);

                this.loImages[m][n].i = n;
                this.loImages[m][n].anchor.set(0.5);
                this.loImages[m][n].sx = m;

                this.loImages[m][n].sy = n;
                this.loImages[m][n].icon = this.game.add.image(0, 0, 'ingame', 'slotItem0');
                this.loImages[m][n].icon.anchor.set(0.5);
                this.loImages[m][n].addChild(this.loImages[m][n].icon);
                this.layoutRows[m].addChild(this.loImages[m][n]);

                this.loImages[m][n].inputEnabled = true;
                this.loImages[m][n].events.onInputDown.add(function (nextState) {
                    if (0 === this.selectedItem) {
                        this.usedItem[this.slots[nextState.sx][nextState.sy]] -= 1;
                    } else {
                        this.usedItem[this.slots[nextState.sx][nextState.sy]] -= 1;
                        this.usedItem[this.selectedItem] += 1;
                    }
                    this.slots[nextState.sx][nextState.sy] = this.selectedItem;
                    if (0 === this.selectedItem || Luts.Upgrades.value('slotItem' + this.selectedItem).lessThanOrEqualTo(this.usedItem[this.selectedItem])) {

                        this.selectedItem = 0;
                    }
                    Luts.Events.changedUsedItem.dispatch();
                    this.fillImages();
                    Luts.Store.setItem('slots', JSON.stringify(this.slots));
                    Luts.Store.setItem('usedSlots', JSON.stringify(this.usedItem));
                }, this);
            }
            this.slotImages[m][n].icon.frameName = 'slotItem' + dataAndEvents;
            this.loImages[m][n].icon.frameName = 'slotItem' + dataAndEvents;
        } ['bind'](this));
    } ["bind"](this));
}, Luts.Object.SlotWindow.prototype.getReward = function (dataAndEvents) {

    var randomNumber = function () {};

    var origValue = 0;

    var buf = "";
    switch (dataAndEvents) {
    case 0:

        randomNumber = function (range) {
            Luts.Upgrades.changeCurrency(8, 1 * range);
        };

        origValue = 1;
        buf = '+% Diamond$!';
        break;
    case 1:

        randomNumber = function (range) {
            Luts.Upgrades.changeCurrency(8, 5 * range);
        };

        origValue = 5;
        buf = '+% Diamonds!';
        break;
    case 2:

        randomNumber = function (range) {
            Luts.Value.get('comboMulti').changeMultiplier('slot', 1, 2 * range, 1);
        };

        origValue = 2;
        buf = 'Combomultiplier +x%!';
        break;
    case 3:

        randomNumber = function (range) {
            Luts.Upgrades.changeCurrency(8, 25 * range);
        };

        origValue = 25;
        buf = '+% Diamonds!';
        break;
    case 4:

        randomNumber = function (range) {
            Luts.Value.get("chipMulti").changeMultiplier('slot', 1, 2 * range, 1);
        };

        origValue = 2;
        buf = 'Chipmulti +x%!';
        break;
    case 5:

        randomNumber = function (range) {
            Luts.Upgrades.changeCurrency(8, 125 * range);
        };

        origValue = 125;
        buf = '+% Diamonds!';
        break;
    case 6:

        randomNumber = function (range) {
            Luts.Upgrades.changeCurrency(9, range);
            Luts.Lock.unlock("diamondCards");
        };

        origValue = 1;
        buf = '+% DIAMOND CARD POINTÂ§!!';
    }
    return {

        "cb": randomNumber,
        "value": origValue,
        "text": buf
    };
}, Luts.Object.SampleObject = function (dataAndEvents, deepDataAndEvents, opt_obj2) {
    Phaser.Image.call(this, dataAndEvents.game, deepDataAndEvents, opt_obj2, 'whiteSquare');
    dataAndEvents.game.add.existing(this);
    this.game = dataAndEvents.game;
    this.state = dataAndEvents;
}, Luts.Object.SampleObject.prototype.constructor = Luts.Object.SampleObject, Luts.Object.SampleObject.prototype = Object.create(Phaser.Image.prototype), Luts.Object.SampleObject.prototype.update = function () {}, Luts.Object.AchievementsHandler = {}, Luts.Object.AchievementsHandler.init = function (_locale) {
    Luts.Achievements.init();
    Luts.Object.AchievementsHandler.state = _locale;
    Luts.Object.AchievementsHandler.add('basic', 'firstSteps', 'First Steps', 'Upgrade your Dice', 'Unlocks Autoroll', 2, function () {
        Luts.Lock.unlock("autoRoll");
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', "points1m", 'Millionaire', 'Reach a total of 1M points', '1st Dice Multiplier +10%', 1E6, function () {
        Luts.Value.get('main0_multi').setMultiplier('points1m', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', "points1b", 'Billionaire', 'Reach a total of 1B points', '2nd Dice Multiplier +20%', 1E9, function () {
        Luts.Value.get('main1_multi').setMultiplier("points1b", 1.2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', "points1t", 'Trillionaire', 'Reach a total of 1T points', '3rd Dice Multiplier +30%', 1E12, function () {
        Luts.Value.get('main2_multi').setMultiplier("points1t", 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', 'points1qa', 'Quadrillionaire', "Reach a total of 1Qa points", '4th Dice Multiplier +40%', 1E15, function () {
        Luts.Value.get('main3_multi').setMultiplier('points1qa', 1.4);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("basic", 'points1qi', "Quintillionaire", "Reach a total of 1Qi points", '5th Dice Multiplier +50%', 1E18, function () {
        Luts.Value.get("main4_multi").setMultiplier("points1qi", 1.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('basic', 'roll20', "Roll 20", 'Roll manually 20 times', 'Autoroll interval -1%', 20, function () {
        Luts.Value.get("rollInterval").setMultiplier('roll20', 0.99);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', 'roll1k', 'Roll 1000', 'Roll manually 1000 times', "Autoroll interval -10%", 1E3, function () {
        Luts.Value.get('rollInterval').setMultiplier('roll1000', 0.9);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("basic", 'lazy', 'Lazy', 'Roll automaticually 1000 times', 'Animation Speed +10%', 1E3, function () {
        Luts.Value.get('rollAnim').setMultiplier('lazy', 0.9);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', 'playtime1', "Player", 'Play for 1 hour', 'Combomultiplier +10%', 1, function () {
        Luts.Value.get('comboMulti').setMultiplier('playtime1', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', "playtime24", 'Freak', "Play for 24 hours", 'Combomultiplier +20%', 24, function () {
        Luts.Value.get('comboMulti').setMultiplier("playtime24", 1.2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("basic", 'playtime168', 'No life', 'Play for 1 week', "Combomultiplier +30%", 168, function () {
        Luts.Value.get('comboMulti').setMultiplier("playtime168", 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("basic", "rollFive", '0.077%', "Roll five of a kind", "Combo Multiplier +50%", 1, function () {
        Luts.Value.get('comboMulti').setMultiplier('rollFive', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', 'prestige2', 'Double the fun', 'Reach a prestige multiplier of 200%', 'Unlocks advanced achievements', 2, function () {
        Luts.Lock.unlock('advancedAchievements');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', 'prestige10', 'Ten times the fun', 'Reach a prestige multiplier of x10', 'Cardprogression +10%', 10, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('prestige10', 1.1);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("basic", "prestige100", "Hundred times the fun", 'Reach a prestige multiplier of x100', "Cardprogression +10%", 100, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier("prestige100", 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('basic', "prestige1k", "Prestige Expert", 'Reach a prestige multiplier of x1k', 'Cardprogression +10%', 1E3, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('prestige1k', 1.1);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards5', 'Full Hand', 'Draw 5 cards in one run', 'Cardprogression +10%', 5, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('cards5', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards10', 'Double or nothing', 'Draw 10 cards in one run', 'Unlocks roulette', 10, function () {
        Luts.Lock.unlock('roulette');
        Luts.Lock.unlock("expertAchievements");
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards15', 'Three hands full', "Draw 15 cards in one run", "Cardprogression +10%", 15, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('cards15', 1.1);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards20', "Draw 20", 'Draw 20 cards in one run', 'Cardprogression +10%', 20, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('cards20', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards26', 'Half deck', 'Draw 26 cards in one run', 'Unlocks buy all', 26, function () {
        Luts.Lock.unlock('buyAll');
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards32', 'Wrong type of deck', 'Draw 32 cards in one run', 'Unlocks auto ascension', 32, function () {
        Luts.Lock.unlock('autoAscend');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards45', "Almost done", 'Draw 45 cards in one run', 'Cardprogression +10%', 45, function () {
        Luts.Value.get("cardProgressMulti").setMultiplier('cards45', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards52', 'Full deck', "Draw 52 cards in one run", 'Unlocks decks', 52, function () {
        Luts.Lock.unlock('decks');
        Luts.Lock.unlock('legendaryAchievements');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards4_2', 'Strategic Mastermind', 'Draw 4 2s in one run', "Cardprogression +20%", 4, function () {
        Luts.Value.get("cardProgressMulti").setMultiplier('cards4_2', 1.2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_3', 'Equality', 'Draw 4 3s in one run', "All dice multiplier +30%", 4, function () {
        Luts.Value.get('main0_multi').setMultiplier('cards4_3', 1.3);
        Luts.Value.get('main1_multi').setMultiplier("cards4_3", 1.3);
        Luts.Value.get('main2_multi').setMultiplier('cards4_3', 1.3);
        Luts.Value.get('main3_multi').setMultiplier('cards4_3', 1.3);
        Luts.Value.get('main4_multi').setMultiplier("cards4_3", 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_4', 'Into heaven', 'Draw 4 4s in one run', "Ascension multiplier +40%", 4, function () {
        Luts.Value.get('ascensionMulti').setMultiplier('cards4_4', 1.4);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards4_5', 'Combo master', 'Draw 4 5s in one run', 'Combo multiplier +50%', 4, function () {
        Luts.Value.get('comboMulti').setMultiplier('cards4_5', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', "cards4_6", '5th Dice', "Draw 4 6s in one run", '5th dice multiplier +50%', 4, function () {
        Luts.Value.get('main4_multi').setMultiplier('cards4_6', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards4_7', '4th Dice', 'Draw 4 7s in one run', '4th dice multiplier +40%', 4, function () {
        Luts.Value.get('main3_multi').setMultiplier('cards4_7', 1.4);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_8', '3rd Dice', "Draw 4 8s in one run", '3rd dice multiplier +30%', 4, function () {
        Luts.Value.get('main2_multi').setMultiplier('cards4_8', 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards4_9', '2nd Dice', 'Draw 4 9s in one run', '2nd dice multiplier +20%', 4, function () {
        Luts.Value.get("main1_multi").setMultiplier('cards4_9', 1.2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("advanced", 'cards4_10', '1st Dice', 'Draw 4 10s in one run', '1st dice multiplier +10%', 4, function () {
        Luts.Value.get('main0_multi').setMultiplier('cards4_10', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_J', 'Faster!!', 'Draw 4 Junkers in one run', 'Autoroll interval -10%', 4, function () {
        Luts.Value.get("rollInterval").setMultiplier("cards4_J", 0.9);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', "cards4_Q", 'Multiply the multipliers', "Draw 4 Queens in one run", 'Multiplier dice multiplier +50%', 4, function () {
        Luts.Value.get('main5_multi').setMultiplier('cards4_Q', 1.5);
        Luts.Value.get("main6_multi").setMultiplier("cards4_Q", 1.5);
        Luts.Value.get('main7_multi').setMultiplier('cards4_Q', 1.5);
        Luts.Value.get('main8_multi').setMultiplier("cards4_Q", 1.5);
        Luts.Value.get('main9_multi').setMultiplier('cards4_Q', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_K', "Patience", "Draw 4 Kings in one run", 'All dice multiplier x2', 4, function () {
        Luts.Value.get("main0_multi").setMultiplier("cards4_K", 2);
        Luts.Value.get("main1_multi").setMultiplier('cards4_K', 2);
        Luts.Value.get('main2_multi').setMultiplier('cards4_K', 2);
        Luts.Value.get('main3_multi').setMultiplier('cards4_K', 2);
        Luts.Value.get('main4_multi').setMultiplier("cards4_K", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('advanced', 'cards4_A', 'No Patience', 'Draw 4 Aces in one run', 'Roulette animation duration -50%', 4, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('cards4_A', 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', "spin5", 'Spin 5', 'Spin the roulette 5 times in total', "Roulette animation duration -5%", 5, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('spin5', 0.95);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'spin100', 'Spin 100', "Spin the roulette 100 times in total", 'Card progression +10%', 100, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier('spin100', 1.1);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("expert", 'spinRun5', 'Spinner', 'Spin the roulette 5 times in one run', "Roulette animation duration -5%", 5, function () {
        Luts.Value.get("rouletteAnim").setMultiplier("spinRun5", 0.95);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("expert", "spinRun15", "Expert Spinner", "Spin the roulette 15 times in one run", 'Card progression +20%', 15, function () {
        Luts.Value.get("cardProgressMulti").setMultiplier('spinRun15', 1.2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'spinRun100', 'Fidget Spinner', 'Spin the roulette 50 times in one run', 'Unlocks auto spin', 50, function () {
        Luts.Lock.unlock('autoSpin');
    } ['bind'](this));
    Luts.Achievements.get('spinRun100').goal = Decimal(50);
    Luts.Object.AchievementsHandler.add('expert', 'roulette3', "Red or Black?", "Reach roulette level 3", "Roulette animation duration -5%", 3, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('roulette3', 0.95);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'roulette5', 'Addicted', "Reach roulette level 5", 'Card progression +25%', 5, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier("roulette5", 1.25);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', "roulette7", 'Roulette 7', 'Reach roulette level 7', 'First Dice x2', 7, function () {
        Luts.Value.get('main0_multi').setMultiplier('roulette7', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'roulette8', 'Roulette 8', "Reach roulette level 8", 'Second Dice x2', 8, function () {
        Luts.Value.get('main1_multi').setMultiplier('roulette8', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'roulette9', 'Roulette 9', 'Reach roulette level 9', 'Third Dice x2', 9, function () {
        Luts.Value.get('main2_multi').setMultiplier('roulette9', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'roulette10', 'Roulette 10', 'Reach roulette level 10', "Fourth Dice x2", 10, function () {
        Luts.Value.get('main3_multi').setMultiplier('roulette10', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'roulette11', "Roulette 11", "Reach roulette level 11", "Fifth Dice x2", 11, function () {
        Luts.Value.get("main4_multi").setMultiplier('roulette11', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("expert", "roulette20", 'Roulette 20', 'Reach roulette level 20', 'Unlocks auto draw', 20, function () {
        Luts.Lock.unlock('autoDraw');
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("expert", 'roulette25', 'Roulette 25', 'Reach roulette level 25', 'Unlocks auto gild', 25, function () {
        Luts.Lock.unlock("autoGild");
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', "roulette34", 'Roulette Max', 'Reach roulette level 34', 'Prestige Multipier x5', 34, function () {
        Luts.Value.get('prestigeMM').setMultiplier("roulette34", 5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'pair1000', 'Pair Master', "Roll 1000 Pairs", "Combo Multiplier +10%", 1E3, function () {
        Luts.Value.get('comboMulti').setMultiplier('pair1000', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', "triplet1000", 'Triplet Master', 'Roll 1000 Triplets', 'Combo Multiplier +20%', 1E3, function () {
        Luts.Value.get("comboMulti").setMultiplier("triplet1000", 1.2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'twopair1000', "Two Pair Master", 'Roll 1000 Two Pairs', 'Combo Multiplier +10%', 1E3, function () {
        Luts.Value.get('comboMulti').setMultiplier('triplet1000', 1.1);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'four1000', "Four Master", 'Roll 1000 Fours', "Combo Multiplier +40%", 1E3, function () {
        Luts.Value.get('comboMulti').setMultiplier('four1000', 1.4);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('expert', "straight1000", "Straight Master", "Roll 1000 Straights", 'Combo Multiplier +30%', 1E3, function () {
        Luts.Value.get('comboMulti').setMultiplier('straight1000', 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('expert', 'fullhouse1000', 'Full House Master', 'Roll 1000 Full Houses', 'Combo Multiplier +30%', 1E3, function () {
        Luts.Value.get('comboMulti').setMultiplier('fullhouse1000', 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("expert", 'five1000', "Five Master", 'Roll 1000 Fives', 'Combo Multiplier x5', 1E3, function () {
        Luts.Value.get("comboMulti").setMultiplier('five1000', 5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'gold_2', 'God of strategy', 'Have 4 golden 2s', 'Card progression x2', 4, function () {
        Luts.Value.get('cardProgressMulti').setMultiplier("gold2", 2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('legendary', 'gold_3', "Equality", 'Have 4 golden 3s', 'Prestige Multi +30%', 4, function () {
        Luts.Value.get('prestigeMM').setMultiplier('gold3', 1.3);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("legendary", 'gold_4', 'Into the universe', "Have 4 golden 4s", "Ascension Multiplier +40%", 4, function () {
        Luts.Value.get('ascensionMulti').setMultiplier('gold_4', 1.4);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'gold_5', 'Combining galaxies', 'Have 4 golden 5s', "Combo Multiplier +50%", 4, function () {
        Luts.Value.get('comboMulti').setMultiplier('gold_5', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'gold_A', 'Spinning Ace', 'Have 4 golden As', 'Chip Multi x2', 4, function () {
        Luts.Value.get('chipMulti').setMultiplier("gold_5", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'noPrestige', "No prestige needed", 'Convert a deck without prestiging', 'Card progression +50%', 1, function () {
        Luts.Value.get("cardProgressMulti").setMultiplier("noPrestige", 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("legendary", 'golden52', 'Golden deck', 'Have 52 golden cards', "?", 52, function () {
        Luts.Lock.unlock('goldenDeck');
        Luts.Lock.unlock('godlikeAchievements');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'spin10noLevel', 'Unlucky', 'Spin the roulette 10 times on level 0 without leveling it up', "Chip Multi x2", 10, function () {
        Luts.Value.get('chipMulti').setMultiplier('spin10noLevel', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', "focus10", 'Meditation', 'Have a focus charge of 10', 'Unlocks auto roulette focus', 10, function () {
        Luts.Lock.unlock("autoRouletteFocus");
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('legendary', 'autoroll100', 'Perfect Speed', 'Have an reroll chance of 100%', 'Adds all dice x2 to J-Card', 100, function () {
        Luts.Lock.unlock('autoroll100');
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("legendary", 'noRoll', 'Too slow', 'Dont roll the dice for 1 minute', 'Roll Interval x0.5', 60, function () {
        Luts.Value.get('rollInterval').setMultiplier("noRoll", 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'roulette35', 'Roulette Prestige', 'Reach roulette level 35', 'Unlocks Roulette Prestige and the slot machine', 35, function () {
        Luts.Lock.unlock('slotMachine');
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino1', 'Investment Beginner', 'Have one casino', 'Get 0.1% interest per second', 1, function () {
        Luts.Value.get('interest').set(0.001);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino2', 'Roulette Investor', 'Have 2 casinos', 'Unlocks auto roulette upgrade', 2, function () {
        Luts.Lock.unlock("autoRouletteUpgrade");
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino3', 'Investor', 'Have 3 casinos', 'Interest x2', 3, function () {
        Luts.Value.get('interest').setMultiplier('casino3', 2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino4', 'Investing into speed', 'Have 4 casinos', 'Roulette Animation Duration -50%', 4, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('casino4', 0.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino5', "Chip Factory", 'Have 5 casinos', 'Chip Multi x2', 5, function () {
        Luts.Value.get('chipMulti').setMultiplier('casino5', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino6', 'Swiss Bank Account', 'Have 6 casinos', "Keep 0.001% of your luck after a investment", 6, function () {
        Luts.Value.get("luckKept").set(1E-5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino7", 'Lucky Number', 'Have 7 casinos', 'Interest +50%', 7, function () {
        Luts.Value.get('interest').setMultiplier("casino7", 1.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino8', 'Chip Mass Production', 'Have 8 casinos', 'Chip Multi x2', 8, function () {
        Luts.Value.get('chipMulti').setMultiplier('casino8', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino9", 'Corruption', "Have 9 casinos", 'Luck kept after investment x2', 9, function () {
        Luts.Value.get("luckKept").setMultiplier('casino9', 2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino10', 'Employees', 'Have 10 casinos', 'Skill Points per casino x2', 10, function () {
        Luts.Value.get('skillPointMulti').setMultiplier('casino10', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino11', 'Can buy anything', 'Have 11 casinos', 'Luck multiplier x5', 11, function () {
        Luts.Value.get('luckMulti').setMultiplier('casino11', 5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino12', 'Getting Lazy', 'Have 12 casinos', 'Unlocks auto convert', 12, function () {
        Luts.Lock.unlock('autoConvert');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino13', 'Unlucky Number', "Have 13 casinos", 'Interest +25%', 13, function () {
        Luts.Value.get('interest').setMultiplier('casino13', 1.25);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino14', "Particle Accelerator", "Have 14 casinos", 'Roulette Animation Duration -50%', 14, function () {
        Luts.Value.get("rouletteAnim").setMultiplier('casino14', 0.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino15", 'Greed', "Have 15 casinos", 'Luck kept after investment x2', 15, function () {
        Luts.Value.get('luckKept').setMultiplier('casino15', 2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino16', 'Hexadecagonal Chips', "Have 16 casinos", 'Chip Multi x2', 16, function () {
        Luts.Value.get('chipMulti').setMultiplier("casino16", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino17', 'Happiness', 'Have 17 casinos', "Luck Multiplier x4", 17, function () {
        Luts.Value.get("luckMulti").setMultiplier('casino17', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino18', 'No flavor for this one', 'Have 18 casinos', 'Interest +12.5%', 18, function () {
        Luts.Value.get('interest').setMultiplier('casino18', 1.125);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino19', 'Accelerator Farm', 'Have 19 casinos', "Roulette Animation Duration -50%", 19, function () {
        Luts.Value.get('rouletteAnim').setMultiplier("casino19", 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino20', "Slaves", "Have 20 casinos", 'Skill Points per casino x2', 20, function () {
        Luts.Value.get('skillPointMulti').setMultiplier('casino20', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino21', "Blackjack", 'Have 21 casinos', 'Unlocks Auto Upgrade', 21, function () {
        Luts.Lock.unlock('autoUpgrade');
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino22', 'Interesting', 'Have 22 casinos', 'Interest +25%', 22, function () {
        Luts.Value.get('interest').setMultiplier('casino22', 1.25);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino23', 'Sun Harvesting', "Have 23 casinos", "Roulette Animation Duration -25%", 23, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('casino23', 0.75);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino24', "Gluttony", 'Have 24 casinos', 'Luck kept after investment x1.5', 24, function () {
        Luts.Value.get('luckKept').setMultiplier('casino24', 1.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add("godlike", "casino25", 'Mega Chips', "Have 25 casinos", 'Chip Multi x2', 25, function () {
        Luts.Value.get('chipMulti').setMultiplier("casino25", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino26', "Fulfilment", "Have 26 casinos", "Luck Multiplier x3", 26, function () {
        Luts.Value.get("luckMulti").setMultiplier("casino26", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino27', 'Upgrade Machines', 'Have 27 casinos', 'Auto Upgrade Interval x0.5', 27, function () {
        Luts.Value.get('autoUpgradeInterval').setMultiplier('casino27', 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino28', 'Very Interesting', "Have 28 casinos", 'Interest +50%', 28, function () {
        Luts.Value.get('interest').setMultiplier("casino28", 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino29', 'Speed of light', "Have 29 casinos", 'Roulette Animation Duration -25%', 29, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('casino29', 0.75);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino30', 'Lust', "Have 30 casinos", 'Luck kept after investment x1.5', 30, function () {
        Luts.Value.get('luckKept').setMultiplier('casino30', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add("godlike", 'casino33', 'God of Luck', 'Have 33 casinos', 'Interest x10', 33, function () {
        Luts.Value.get('interest').setMultiplier("casino33", 10);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino35", 'Giga Chips', 'Have 35 casinos', "Chip Multi x2", 35, function () {
        Luts.Value.get("chipMulti").setMultiplier('casino35', 2);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino40', 'Gladstone Gander', 'Have 40 casinos', "Luck Multiplier x2", 40, function () {
        Luts.Value.get('luckMulti').setMultiplier('casino40', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino45', 'Upgrade Slaves', 'Have 45 casinos', 'Auto Upgrade Interval x0.5', 45, function () {
        Luts.Value.get("autoUpgradeInterval").setMultiplier('casino45', 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino50", 'Need more Names', 'Have 50 casinos', 'Interest +50%', 50, function () {
        Luts.Value.get('interest').setMultiplier('casino50', 1.5);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino55', 'Hypnotizing', 'Have 55 casinos', 'Roulette Animation Duration -25%', 55, function () {
        Luts.Value.get('rouletteAnim').setMultiplier('casino55', 0.75);
    } ["bind"](this));
    Luts.Object.AchievementsHandler.add('godlike', "casino60", 'Pride', 'Have 60 casinos', "Luck kept after investment x2", 60, function () {
        Luts.Value.get('luckKept').setMultiplier('casino60', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino65', "What will you do with all these Chips?", "Have 65 casinos", 'Chip Multi x10', 65, function () {
        Luts.Value.get('chipMulti').setMultiplier('casino65', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino70', 'Nothing bad will ever happen to you', 'Have 70 casinos', 'Luck Multiplier x3', 70, function () {
        Luts.Value.get('luckMulti').setMultiplier("casino70", 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino75', 'Upgrade Drones', "Have 75 casinos", 'Auto Upgrade Interval x0.5', 75, function () {
        Luts.Value.get('autoUpgradeInterval').setMultiplier('casino75', 0.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino80', 'Seriously...', 'Have 80 casinos', 'Interest +50%', 80, function () {
        Luts.Value.get('interest').setMultiplier('casino80', 1.5);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino85', 'Can your Computer even handle this speed', 'Have 85 casinos', "Roulette Animation Duration -25%", 85, function () {
        Luts.Value.get("rouletteAnim").setMultiplier("casino85", 0.75);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino90', 'Envy', 'Have 90 casinos', 'Luck kept after investment x2', 90, function () {
        Luts.Value.get("luckKept").setMultiplier('casino90', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino95', "Stop", "Have 95 casinos", 'Luck Multiplier x4', 95, function () {
        Luts.Value.get('luckMulti').setMultiplier('casino95', 2);
    } ['bind'](this));
    Luts.Object.AchievementsHandler.add('godlike', 'casino100', 'No need to play anymore', "Have 100 casinos", 'Auto Upgrade Interval x0.1', 100, function () {
        Luts.Value.get('autoUpgradeInterval').setMultiplier("casino100", 0.1);
    } ['bind'](this));
    Luts.Events.onAchievementUnlocked.add(function (dataAndEvents) {
        _locale.game.camera.flash(1, 250);
        if (_locale.achievementsButton) {
            _locale.achievementsButton.setActive(false);
            _locale.achievementsButton.setActive(true, true);
            Luts.Upgrades.changeCurrency(6, Luts.Object.AchievementsHandler.categoryToBP(dataAndEvents.category));
            new(Luts.Object.AchievementUnlockedLabel)(_locale, dataAndEvents);
            Luts.Sound.play("success");
        }
    }, this);
    Luts.Events.onCurrencyChanged[0].add(function () {
        Luts.Object.AchievementsHandler.set('points1m', Luts.Value.get("totalScore").v, true);
        Luts.Object.AchievementsHandler.set("points1b", Luts.Value.get("totalScore").v, true);
        Luts.Object.AchievementsHandler.set('points1t', Luts.Value.get('totalScore').v, true);
        Luts.Object.AchievementsHandler.set('points1qa', Luts.Value.get("totalScore").v, true);
        Luts.Object.AchievementsHandler.set('points1qi', Luts.Value.get('totalScore').v, true);
    }, this);
    Luts.Events.onRoll.add(function (dataAndEvents) {
        if (dataAndEvents) {
            Luts.Object.AchievementsHandler.set('roll20', 1);
            Luts.Object.AchievementsHandler.set("roll1k", 1);
        } else {
            Luts.Object.AchievementsHandler.set('lazy', 1);
        }
        if (this.lastRoll) {
            Luts.Object.AchievementsHandler.set('noRoll', ((new Date).getTime() - this.lastRoll) / 1E3, true);
        }
        this.lastRoll = (new Date).getTime();
    }, this);
    Luts.Events.onRolledCombo.add(function (dataAndEvents) {
        if (dataAndEvents == Luts.DiceRules.Match.FIVER) {
            Luts.Object.AchievementsHandler.set("rollFive", 1);
        }
        Luts.Object.AchievementsHandler.set('five1000', Luts.Value.get('totalCombofiver').v, true);
        Luts.Object.AchievementsHandler.set('fullhouse1000', Luts.Value.get('totalCombofullhouse').v, true);
        Luts.Object.AchievementsHandler.set('straight1000', Luts.Value.get('totalCombostraight').v, true);
        Luts.Object.AchievementsHandler.set("twopair1000", Luts.Value.get('totalCombotwopair').v, true);
        Luts.Object.AchievementsHandler.set('four1000', Luts.Value.get("totalCombofour").v, true);
        Luts.Object.AchievementsHandler.set('triplet1000', Luts.Value.get('totalCombotriplet').v, true);
        Luts.Object.AchievementsHandler.set('pair1000', Luts.Value.get('totalCombopair').v, true);
    }, this);
    Luts.Events.onAsyncUpdate.add(function () {
        Luts.Object.AchievementsHandler.set('playtime1', Luts.Time.activePlaytime / 36E5, true);
        Luts.Object.AchievementsHandler.set('playtime24', Luts.Time.activePlaytime / 36E5, true);
        Luts.Object.AchievementsHandler.set("playtime168", Luts.Time.activePlaytime / 36E5, true);
    }, this);
    Luts.Events.onPrestige.add(function () {
        Luts.Object.AchievementsHandler.set('prestige2', _locale.totalPrestige.v, true);
        Luts.Object.AchievementsHandler.set('prestige10', _locale.totalPrestige.v, true);
        Luts.Object.AchievementsHandler.set("prestige100", _locale.totalPrestige.v, true);
        Luts.Object.AchievementsHandler.set('prestige1k', _locale.totalPrestige.v, true);
        Luts.Object.AchievementsHandler.set('casino1', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino2', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino3", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino4', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino5', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino6', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino7", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino8', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino9', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino10', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino11", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino12', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino13', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino14", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino15', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino16', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino17', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino18', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino19', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino20', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino21", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino22", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino23", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino24', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino25', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino26", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino27', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino28", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino29', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino30', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino33', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino35', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino40", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino45", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino50', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino55', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino60", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino65", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino70', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino75', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino80', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set("casino85", _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino90', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino95', _locale.casinos.v, true);
        Luts.Object.AchievementsHandler.set('casino100', _locale.casinos.v, true);
    }, this);
    Luts.Events.onDrawCard.add(function () {
        Luts.Object.AchievementsHandler.set('cards5', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards10', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards15', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards20', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards26', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set("cards32", _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards45', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('cards52', _locale.unlockedCards, true);
        Luts.Object.AchievementsHandler.set('golden52', _locale.goldenCards, true);
        Luts.Object.AchievementsHandler.set('cards4_2', Luts.Object.AchievementsHandler.unlockedCardTypeNum("2"), true);
        Luts.Object.AchievementsHandler.set('cards4_3', Luts.Object.AchievementsHandler.unlockedCardTypeNum("3"), true);
        Luts.Object.AchievementsHandler.set("cards4_4", Luts.Object.AchievementsHandler.unlockedCardTypeNum("4"), true);
        Luts.Object.AchievementsHandler.set("cards4_5", Luts.Object.AchievementsHandler.unlockedCardTypeNum("5"), true);
        Luts.Object.AchievementsHandler.set("cards4_6", Luts.Object.AchievementsHandler.unlockedCardTypeNum("6"), true);
        Luts.Object.AchievementsHandler.set("cards4_7", Luts.Object.AchievementsHandler.unlockedCardTypeNum("7"), true);
        Luts.Object.AchievementsHandler.set('cards4_8', Luts.Object.AchievementsHandler.unlockedCardTypeNum("8"), true);
        Luts.Object.AchievementsHandler.set('cards4_9', Luts.Object.AchievementsHandler.unlockedCardTypeNum("9"), true);
        Luts.Object.AchievementsHandler.set('cards4_10', Luts.Object.AchievementsHandler.unlockedCardTypeNum("10"), true);
        Luts.Object.AchievementsHandler.set('cards4_J', Luts.Object.AchievementsHandler.unlockedCardTypeNum("J"), true);
        Luts.Object.AchievementsHandler.set('cards4_Q', Luts.Object.AchievementsHandler.unlockedCardTypeNum("Q"), true);
        Luts.Object.AchievementsHandler.set("cards4_K", Luts.Object.AchievementsHandler.unlockedCardTypeNum("K"), true);
        Luts.Object.AchievementsHandler.set('cards4_A', Luts.Object.AchievementsHandler.unlockedCardTypeNum("A"), true);
        Luts.Object.AchievementsHandler.set('gold_2', Luts.Object.AchievementsHandler.unlockedCardTypeNum("2", true), true);
        Luts.Object.AchievementsHandler.set("gold_3", Luts.Object.AchievementsHandler.unlockedCardTypeNum("3", true), true);
        Luts.Object.AchievementsHandler.set("gold_4", Luts.Object.AchievementsHandler.unlockedCardTypeNum("4", true), true);
        Luts.Object.AchievementsHandler.set('gold_5', Luts.Object.AchievementsHandler.unlockedCardTypeNum("5", true), true);
        Luts.Object.AchievementsHandler.set('gold_A', Luts.Object.AchievementsHandler.unlockedCardTypeNum("A", true), true);
    }, this);
    Luts.Value.get('rouletteLevel').onChange.add(function () {
        Luts.Object.AchievementsHandler.set("roulette3", Luts.Value.get("rouletteLevel").v, true);
        Luts.Object.AchievementsHandler.set("roulette5", Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette7', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette8', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set("roulette9", Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette10', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set("roulette11", Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette20', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette25', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette34', Luts.Value.get('rouletteLevel').v, true);
        Luts.Object.AchievementsHandler.set('roulette35', Luts.Value.get('rouletteLevel').v, true);
    }, this);
    Luts.Value.get('rouletteLevel').onChange.dispatch();
    Luts.Value.get("rouletteSpins").onChange.add(function () {
        Luts.Object.AchievementsHandler.set('spin5', Luts.Value.get('rouletteSpins').v, true);
        Luts.Object.AchievementsHandler.set("spin100", Luts.Value.get('rouletteSpins').v, true);
        if (Luts.Value.get("rouletteLevel").v.eq(0)) {
            Luts.Object.AchievementsHandler.set('spin10noLevel', 1);
        } else {
            Luts.Object.AchievementsHandler.set('spin10noLevel', 0, true);
        }
    }, this);
    Luts.Value.get('rouletteSpins').onChange.dispatch();
    Luts.Events.onUpgrade.add(function () {
        if (Luts.Upgrades.get('rouletteSpin')) {
            Luts.Object.AchievementsHandler.set("spinRun5", Luts.Upgrades.get('rouletteSpin').level, true);
            Luts.Object.AchievementsHandler.set('spinRun15', Luts.Upgrades.get("rouletteSpin").level, true);
            Luts.Object.AchievementsHandler.set('spinRun100', Luts.Upgrades.get('rouletteSpin').level, true);
            Luts.Object.AchievementsHandler.set('autoroll100', Luts.Upgrades.get('rerollChance').level, true);
        }
        if (Luts.Upgrades.get('main0value')) {
            Luts.Object.AchievementsHandler.set('firstSteps', Luts.Upgrades.get('main0value').level, true);
        }
    }, this);
    Luts.Events.onPrestige2.add(function () {
        if (this.state.totalPrestige.v.lessThanOrEqualTo(1)) {
            Luts.Object.AchievementsHandler.set('noPrestige', 1, true);
        }
    }, this);
    Luts.Value.get("focusCharge").onChange.add(function () {
        Luts.Object.AchievementsHandler.set('focus10', Luts.Value.get('focusCharge').modValue(), true);
    }, this);
}, Luts.Object.AchievementsHandler.add = function (data, libraryName, ns, deepDataAndEvents, dataAndEvents, opt_obj2, walkers, ignoreMethodDoesntExist) {
    var library = Luts.Achievements.add(libraryName, ns, deepDataAndEvents, opt_obj2, 9999999999999, walkers, 0, 0);
    return library.maxLevel = 1, library.unlockText = dataAndEvents, library.show = !ignoreMethodDoesntExist, library.category = data, library;
}, Luts.Object.AchievementsHandler.simpleUnlock = function (key) {
    var camelKey = Luts.Achievements.get(key);
    if (0 == camelKey.level) {
        Luts.Achievements.set(camelKey, 1, true);
    }
}, Luts.Object.AchievementsHandler.set = function (owner, deepDataAndEvents, opt_obj2) {
    var unlock = Luts.Achievements.get(owner);
    if (Luts.Lock.get(unlock.category + 'Achievements').unlocked) {
        Luts.Achievements.set(owner, deepDataAndEvents, opt_obj2);
    }
}, Luts.Object.AchievementsHandler.unlockedCardTypeNum = function (dataAndEvents, deepDataAndEvents) {

    var _0x84a66a = 0;

    var optsData = "";
    return deepDataAndEvents && (optsData = '_gold'), Luts.Upgrades.get("pik" + dataAndEvents + optsData).level >= 1 && _0x84a66a++, Luts.Upgrades.get('heart' + dataAndEvents + optsData).level >= 1 && _0x84a66a++, Luts.Upgrades.get('cross' + dataAndEvents + optsData).level >= 1 && _0x84a66a++, Luts.Upgrades.get('caro' + dataAndEvents + optsData).level >=
        1 && _0x84a66a++, _0x84a66a;
}, Luts.Object.AchievementsHandler.categoryToBP = function (dataAndEvents) {
    switch (dataAndEvents) {
    case "basic":
        ;
    default:
        ;
    case 'advanced':
        return 1;
    case 'expert':
        ;
    case 'legendary':
        return 2;
    case 'godlike':
        return 3;
    }
}, Luts.Object.HighscoreHandler = {}, Luts.Object.HighscoreHandler.init = function (_locale) {
    Luts.Events.onAchievementUnlocked.add(function () {
        Luts.Highscore.submit('achievements', Luts.Achievements.achievedNum);
    });
    Luts.Events.onPrestige3.add(function () {
        Luts.Highscore.submit('casinos', _locale.casinos.v.toNumber());
    });

    Luts.Object.HighscoreHandler.lastMoneyE = 0;
}, Luts.Object.SkillsHandler = {}, Luts.Object.SkillsHandler.init = function (value) {
    Luts.Object.SkillsHandler.state = value;
    this.game = value.game;
    Luts.Skills.skills.forEach(function (dataAndEvents) {
        dataAndEvents.onDeactivate.dispatch();
    });
    Luts.Skills.skills.forEach(function (dataAndEvents) {
        dataAndEvents.checkCondition();
    });
}, Luts.Object.SoundHandler = {}, Luts.Object.SoundHandler.init = function (item) {

    this.state = item;
    this.game = item.game;
}, Luts.Object.Dice = function ($cookies, next_scope, shallow, timeoutKey, deepDataAndEvents, opt_obj2, walkers, isXML, dataAndEvents, ignoreMethodDoesntExist, textAlt) {
    var value = $cookies.state;
    Phaser.Image.call(this, value.game, next_scope, shallow);
    value.game.add.existing(this);
    this.game = value.game;
    this.state = value;

    this.diceContainer = $cookies;
    this.ascentIncrease = ignoreMethodDoesntExist;
    this.diceType = Luts.Config.diceTypes[timeoutKey];
    this.isMulti = textAlt;
    this.id = this.diceContainer.dices.length;

    this.min = 1;
    this.max = this.diceType;

    this.lastPoints = 0;

    this.lastScore = 0;
    if (this.isMulti) {
        this.multi = new Luts.Value($cookies.diceName + this.id + "_multi", 1);
        this.upgrade = Luts.Upgrades.add(this.diceContainer.diceName + this.id + "value", 'Dice ' + this.id, "", deepDataAndEvents, -1, walkers, 1, 9, dataAndEvents || 0, null, 0);
        this.ascentNum = new Luts.Value(this.diceContainer.diceName + this.id + '_ascNum', 0, null, "prestige");
        this.diceType = Luts.Config.diceTypes[Phaser.Math.clamp(this.upgrade.value.toNumber(), 0, 7)];
        this.max = this.diceType;
    } else {
        this.multi = new(Luts.Value)($cookies.diceName + this.id + '_multi', 1, 'Dice ' + (this.id + 1) + ' Multi');
        this.upgrade = Luts.Upgrades.add(this.diceContainer.diceName + this.id + "value", 'Dice ' + this.id, "", deepDataAndEvents, opt_obj2, walkers, isXML, 100, dataAndEvents || 0, null, 0);
        this.ascentNum = new Luts.Value(this.diceContainer.diceName + this.id + '_ascNum', 0, null, "prestige");
    }
    this.shine = this.game.add.image(0, 0, 'ingame', 'shine');
    this.shine.anchor.set(0.5);

    this.shine.visible = false;
    this.addChild(this.shine);
    this.game.add.tween(this.shine).to({
        "angle": 360
    }, this.game.rnd.between(1500, 2500), Phaser.Easing.Linear.None, true, 0, -1);
    this.game.add.tween(this.shine.scale).to({
        "x": 1.2,
        "y": 1.2
    }, this.game.rnd.between(500, 1500), Phaser.Easing.Linear.None, true, 0, -1, true);
    this.diceImage = this.game.add.image(0, 0, "ingame");
    this.diceImage.anchor.set(0.5);
    this.addChild(this.diceImage);
    if (this.isMulti) {
        new(Luts.Object.Tooltip)(value, this.diceImage, 'The points of this dice will multiply the total score you made. Multiplicative with other mutliplier dice');
    }
    this.diceNumber = new(Luts.Object.Text)(this.state, 0, 0, 'regular', "1", 24);
    this.diceNumber.anchor.set(0.5);
    this.diceImage.addChild(this.diceNumber);
    this.levelText = new(Luts.Object.Text)(this.state, 0, 60, "text", "", 16, '#000000');
    this.levelText.anchor.set(0.5);

    this.levelText.strokeThickness = 0;
    this.addChild(this.levelText);
    this.valueText = new(Luts.Object.Text)(this.state, 0, 80, 'text', "", 16, "#000000");
    this.valueText.anchor.set(0.5);

    this.valueText.strokeThickness = 0;
    this.addChild(this.valueText);
    this.pointsText = new(Luts.Object.Text)(this.state, 0, -60, 'regular', "", 18, '#ffffff');
    this.pointsText.anchor.set(0.5);
    this.addChild(this.pointsText);

    this.pointsText.alpha = 0;

    var arg = ;
    if (textAlt) {

        arg = "x";
    }
    this.plusText = new(Luts.Object.Text)(this.state, -60, -60, "regular", this.id > 0 ? arg : "", 32, "#000000");

    this.plusText.strokeThickness = 0;
    this.plusText.anchor.set(0.5);
    this.addChild(this.plusText);

    this.plusText.alpha = 0;
    this.upgradeButton = new(Luts.Object.Button)(this.state, 0, 120, "Upgrade", "0", function (dataAndEvents) {
        Luts.Upgrades.upgradeMultiple(this.upgrade);
        if (this.isMulti) {
            this.diceType = Luts.Config.diceTypes[Phaser.Math.clamp(this.upgrade.value.toNumber(), 0, 7)];
            this.max = this.diceType;
        } else {
            this.multi.setMultiplier('upgrade', this.upgrade.value, null, 'prestige');
        }
        this.updateText();
    } ['bind'](this));
    this.addChild(this.upgradeButton);
    this.ascendButton = new(Luts.Object.Button)(this.state, 0, 180, Luts.Format.Color('red') + 'Ascend', "", this.ascent.bind(this));
    this.addChild(this.ascendButton);
    Luts.Events.onCurrencyChanged[0].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[0].add(this.updateText, this);
    Luts.Events.onUpgrade.add(function (dataAndEvents) {
        if (dataAndEvents == this.upgrade) {
            this.updateText();
        }
    }, this);
    this.setImage(1);
    this.updateText();
    this.diceContainer.dices.push(this);
}, Luts.Object.Dice.prototype.constructor = Luts.Object.Dice, Luts.Object.Dice.prototype = Object.create(Phaser.Image.prototype), Luts.Object.Dice.prototype.update = function () {}, Luts.Object.Dice.prototype.averagePerSecond = function () {
    return this.upgrade.level > 0 ? this.multi.modValue().times(this.max / 2) : this.isMulti ? 1 : 0;
}, Luts.Object.Dice.prototype.ascent = function () {
    if (this.upgrade.level >= 100 || this.isMulti && this.upgrade.level >= 9) {
        Luts.Lock.unlock('cards');
        this.ascentNum.set(this.ascentNum.v.add(1));
        Luts.Upgrades.reset(this.upgrade);
        this.upgrade.price = this.upgrade.price.times(Decimal(this.ascentIncrease).times(this.ascentNum.v).pow(this.ascentNum.v));
        if (0 === this.upgrade.initialLevel) {
            Luts.Upgrades.upgrade(this.upgrade, true);
        }
        Luts.Upgrades.saveUpgrade(this.upgrade);
        this.multi.setMultiplier('ascent', this.state.ascensionMulti.modValue().pow(this.ascentNum.v), null, 'prestige');
        if (this.isMulti) {
            this.diceType = Luts.Config.diceTypes[Phaser.Math.clamp(this.upgrade.value.toNumber(), 0, 7)];
            this.max = this.diceType;
        } else {
            this.multi.setMultiplier('upgrade', this.upgrade.value, null, 'prestige');
        }
        this.updateText();
        this.state.cardsLevel.addProgress(this.state.cardProgressMulti.modValue());
    }
}, Luts.Object.Dice.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false);
    this.upgradeButton.subtitle.setText("<c=" + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade), false, 0));
    this.levelText.setText("Level: " + Luts.Format.Decimal(this.upgrade.level) + (this.ascentNum.v.greaterThan(0) ? "a" + Luts.Format.Decimal(this.ascentNum.v) : ""));
    if (this.isMulti) {
        this.valueText.setText("D" + this.diceType);
    } else {
        this.valueText.setText('Multi: ' + Luts.Format.Decimal(this.multi.modValue()));
    }
    this.upgradeButton.setActive(r20, this.upgrade.level <= 1);

    var visible = this.upgrade.level > 0;

    this.diceImage.visible = visible;

    this.valueText.visible = visible;

    this.levelText.visible = visible;

    this.pointsText.visible = visible;

    this.plusText.visible = visible;
    this.ascendButton.visible = this.upgrade.level >= 100 || this.isMulti && this.upgrade.level >= 9;
    if (this.ascendButton.visible) {
        if (this.state.autoAscend.value) {
            this.ascendButton.click();
        }
    }
    if (this.id > 0) {
        this.upgradeButton.visible = this.diceContainer.dices[this.id - 1].upgrade.level >= 10 || this.diceContainer.dices[this.id - 1].ascentNum.v.greaterThan(0);
        if (this.id > 5) {

            this.upgradeButton.visible = this.diceContainer.dices[this.id - 1].upgrade.level > 0 && Luts.Value.get('multiDices').v.toNumber() > this.id - 5;
        }
        if (this.upgrade.level >= this.upgrade.maxLevel) {

            this.upgradeButton.visible = false;
        }
    } else {

        this.upgradeButton.visible = this.upgrade.level < this.upgrade.maxLevel;
    }
    if (visible) {
        this.upgradeButton.text.setText('Upgrade');
    } else {
        this.upgradeButton.text.setText('Buy');
    }
}, Luts.Object.Dice.prototype.roll = function () {
    if (this.lastScore = 0, this.upgrade.level > 0) {
        var _0x372a62 = Math.pow(this.game.rnd.frac(), 1 / Luts.Upgrades.value('rollCurve'));
        var r20 = Math.floor(this.min + _0x372a62 * (this.max - this.min + 1));
        this.setImage(r20);
        this.lastPoints = r20;
        if (!this.isMulti) {
            Luts.Value.get("rolled" + r20).add(1);
            this.multi.changeMultiplier("multiPerRoll", 1, Luts.Upgrades.value('multiPerRoll').times(r20 / 100), null, 'prestige');
        }
        this.lastScore = this.multi.modValue().times(r20);
    }
    return this.lastScore;
}, Luts.Object.Dice.prototype.setImage = function (b) {
    if (6 === this.diceType) {

        var c = "";
        if (this.isMulti) {

            c = "m";
        }

        this.diceImage.frameName = "d" + this.diceType + "_" + b + c;

        this.diceNumber.visible = false;
    } else {
        this.diceImage.frameName = "d" + this.diceType;
        this.diceNumber.setText(b);

        this.diceNumber.visible = true;
    }
}, Luts.Object.Dice.prototype.playRollAnim = function (dataAndEvents) {
    if (this.pointsText.alpha = 0, this.plusText.alpha = 0, Luts.isActive) {
        if (this.rollAnim) {
            this.rollAnim.stop();
        }

        this.diceImage.y = 0;

        this.diceImage.angle = 0;
        var r20 = this.game.rnd.between(0, dataAndEvents / 2);
        this.rollAnim = this.game.add.tween(this.diceImage).from({
            "y": -500
        }, 1E3 * dataAndEvents, Phaser.Easing.Bounce.Out, true, r20);
        this.game.add.tween(this.diceImage).from({
            "angle": this.game.rnd.between(-360, 360)
        }, 1E3 * dataAndEvents, Phaser.Easing.Back.Out, true, r20);
        this.rollAnim.onComplete.add(this.playScoreAnim, this);
    }
}, Luts.Object.Dice.prototype.playScoreAnim = function () {

    this.pointsText.alpha = 1;
    this.pointsText.setText(Luts.Format.Decimal(this.lastScore));
    this.pointsText.scale.set(1);
    this.game.add.tween(this.pointsText.scale).from({
        "x": 0,
        "y": 0
    }, 500, Phaser.Easing.Elastic.Out, true);

    this.plusText.alpha = 1;
    this.plusText.scale.set(1);
    this.game.add.tween(this.plusText.scale).from({
        "x": 0,
        "y": 0
    }, 500, Phaser.Easing.Elastic.Out, true);
}, Luts.DiceRules = function (key) {
    var camelKey = Luts.DiceRules.getAmounts(key);
    return camelKey.some(function (dataAndEvents) {
        return 5 === dataAndEvents.amount;
    }) ? Luts.DiceRules.Match.FIVER : camelKey.some(function (dataAndEvents) {
        return 3 === dataAndEvents.amount;
    }) && camelKey.some(function (dataAndEvents) {
        return 2 === dataAndEvents.amount;
    }) ? Luts.DiceRules.Match.FULLHOUSE : camelKey.some(function (dataAndEvents) {
        return 4 === dataAndEvents.amount;
    }) ? Luts.DiceRules.Match.FOUR : Luts.DiceRules.detectStraight(key) ? Luts.DiceRules.Match.STRAIGHT : camelKey.some(function (dataAndEvents) {
        return 3 === dataAndEvents.amount;
    }) ? Luts.DiceRules.Match.TRIPLET : Luts.DiceRules.detectTwoPair(camelKey) ? Luts.DiceRules.Match.TWOPAIR : camelKey.some(function (dataAndEvents) {
        return 2 === dataAndEvents.amount;
    }) ? Luts.DiceRules.Match.PAIR : Luts.DiceRules.Match.NOTHING;
}, Luts.DiceRules.Match = {
    "NOTHING": 'nothing',
    "FIVER": "fiver",
    "FULLHOUSE": 'fullhouse',
    "FOUR": 'four',
    "TRIPLET": 'triplet',
    "PAIR": 'pair',
    "STRAIGHT": 'straight',
    "TWOPAIR": 'twopair',
    "all": ['pair', 'triplet', 'twopair', "four", 'straight', 'fullhouse', 'fiver']
}, Luts.DiceRules.getData = function (dataAndEvents) {
    var params = {
        "displayName": "",
        "name": "",
        "chance": 1,
        "multi": 1,
        "effect": 0,
        "minDices": 0
    };
    switch (dataAndEvents) {
    case Luts.DiceRules.Match.NOTHING:
        break;
    case Luts.DiceRules.Match.FIVER:
        params.displayName = 'FIVE!!!!!!1';
        params.name = 'Five';

        params.minDices = 5;

        params.chance = 7.7E-4;

        params.multi = 1500;

        params.effect = 5;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.FULLHOUSE:
        params.displayName = 'FULLHOUSE!!';
        params.name = 'Full House';

        params.minDices = 5;

        params.chance = 0.038;

        params.multi = 30;

        params.effect = 3;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.FOUR:
        params.displayName = 'FOUR!!!';
        params.name = 'Four';

        params.minDices = 4;

        params.chance = 0.019;

        params.multi = 60;

        params.effect = 4;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.TRIPLET:
        params.displayName = 'Triplet!!';
        params.name = 'Triplet';

        params.minDices = 3;

        params.chance = 0.154;

        params.multi = 7;

        params.effect = 2;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.PAIR:

        params.displayName = "Pair";

        params.name = "Pair";

        params.minDices = 2;

        params.chance = 0.3;

        params.multi = 2;

        params.effect = 1;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.STRAIGHT:
        params.displayName = 'STRAIGHT!';
        params.name = 'Straight';

        params.minDices = 5;

        params.chance = 0.03;

        params.multi = 20;

        params.effect = 3;

        params.price = 50;
        break;
    case Luts.DiceRules.Match.TWOPAIR:
        params.displayName = 'Two Pair!';
        params.name = 'Two Pair';

        params.minDices = 4;

        params.chance = 0.2;

        params.multi = 5;

        params.effect = 1;

        params.price = 50;
    }
    return params;
}, Luts.DiceRules.getAmounts = function (dimensions) {

    var obj = [];

    var j = 0;
    for (; j < dimensions.length; j++) {
        if (null != dimensions[j]) {
            var root = Luts.DiceRules.hasAmount(obj, dimensions[j]);
            if (null != root) {
                obj[root].amount += 1;
            } else {
                obj.push({
                    "value": dimensions[j],
                    "amount": 1
                });
            }
        }
    }
    return obj;
}, Luts.DiceRules.hasAmount = function (stack, dataAndEvents) {

    var i = 0;
    for (; i < stack.length; i++) {
        if (stack[i].value == dataAndEvents) {
            return i;
        }
    }
    return null;
}, Luts.DiceRules.detectTwoPair = function (defaults) {

    var value = null;

    var key = 0;
    for (; key < defaults.length; key++) {
        if (2 == defaults[key].amount) {
            value = defaults[key];
        }
    }
    if (value) {

        key = 0;
        for (; key < defaults.length; key++) {
            if (defaults[key] != value && 2 == defaults[key].amount) {
                return true;
            }
        }
    }
    return false;
}, Luts.DiceRules.detectStraight = function (h) {
    h.sort();

    var k = 1;
    for (; k < h.length; k++) {
        if (h[k] != h[k - 1] + 1) {
            return false;
        }
    }
    return true;
}, Luts.Object.DiceContainer = function (value, deepDataAndEvents, opt_obj2, dataAndEvents) {
    Phaser.Image.call(this, value.game, deepDataAndEvents, opt_obj2);
    value.game.add.existing(this);
    this.game = value.game;

    this.state = value;
    this.diceName = dataAndEvents;

    this.dices = [];

    this.mainDices = [];

    this.multiDices = [];
    this.createDices();

    this.lastScore = 0;

    this.unlockedDices = -1;
    this.totalText = new(Luts.Object.Text)(value, 0, -100, 'regular', 100, 30);
    this.totalText.anchor.set(0.5);
    this.addChild(this.totalText);

    this.totalText.visible = false;
    this.bonusText = new(Luts.Object.Text)(value, -100, -120, 'regular', '100', 32, '#ffffff');

    this.bonusText.angle = -25;
    this.bonusText.anchor.set(0.5);
    this.addChild(this.bonusText);

    this.bonusText.visible = false;
    this.leftUI = this.game.add.image(0, Luts.GAME_HEIGHT / 2);
    this.state.setResponsive(this.leftUI);
    this.state.groupUI.add(this.leftUI);
    this.matchContainer = this.game.add.image(-270, 0, "ui", "labelMiddle");
    this.matchContainer.anchor.set(0, 0.5);
    this.matchContainer.arrowButton = new(Luts.Object.Button)(value, 280, 0, "", "", this.moveMatchContainer.bind(this));
    this.matchContainer.arrowButton.setFrames('arrowButton', 'arrowButton');

    this.matchContainer.out = false;

    this.matchContainer.buttons = [];
    this.matchContainer.addChild(this.matchContainer.arrowButton);
    this.leftUI.addChild(this.matchContainer);
    Luts.DiceRules.Match.all.forEach(function (prefix, dataAndEvents) {
        var testSource = Luts.DiceRules.getData(prefix);
        var optional_timeoutMessage_ = Luts.Upgrades.add(prefix + '_multi', testSource.name + ' Multiplier', 'Multiplies points of rolls of ' + testSource.name, testSource.price, testSource.multi, 2.35, testSource.multi / 10, null, 0);
        var waitsForFunc = new Luts.Object.MatchButton(value, 140, 56 * dataAndEvents - 170, optional_timeoutMessage_, testSource, this);
        new(Luts.Value)('totalCombo' + prefix, 0, 'Total ' + testSource.name + ' Combos');
        this.matchContainer.buttons.push(waitsForFunc);
        this.matchContainer.addChild(waitsForFunc);
    } ['bind'](this));
    Luts.Events.onUpdate.add(this.update, this);
    Luts.Events.onUnlockedDice.add(function () {

        this.totalText.alpha = this.unlockedDices > 0 ? 1 : 0;

        this.matchContainer.visible = this.unlockedDices > 0;
        this.matchContainer.arrowButton.setActive(this.unlockedDices > 0, true);
    }, this);
}, Luts.Object.DiceContainer.prototype.constructor = Luts.Object.DiceContainer, Luts.Object.DiceContainer.prototype = Object.create(Phaser.Image.prototype), Luts.Object.DiceContainer.prototype.moveMatchContainer = function () {
    if (this.matchContainer.tw) {
        this.matchContainer.tw.stop();
    }
    if (this.matchContainer.out) {

        this.matchContainer.x = -270;
        this.matchContainer.tw = this.game.add.tween(this.matchContainer).from({
            "x": -20
        }, 250, Phaser.Easing.Elastic.Out, true);
    } else {

        this.matchContainer.x = -20;
        this.matchContainer.tw = this.game.add.tween(this.matchContainer).from({
            "x": -270
        }, 250, Phaser.Easing.Bounce.Out, true);
    }

    this.matchContainer.out = !this.matchContainer.out;
}, Luts.Object.DiceContainer.prototype.update = function () {

    var error = -1;

    var a2 = -1;
    this.dices.forEach(function (_locale) {
        if (_locale.upgrade.level > 0 || _locale.ascentNum.v.greaterThan(0)) {
            error += 1;
        }
        if (_locale.upgradeButton.visible || _locale.upgrade.level >= _locale.upgrade.maxLevel) {
            a2 += 1;
        }
    } ['bind'](this));
    if (error > 5) {
        error = a2;
    }
    if (error !== this.unlockedDices) {
        this.unlockedDices = error;
        Luts.Events.onUnlockedDice.dispatch();
    }
    this.dices.forEach(function (a, dataAndEvents) {

        var x = -60 * this.unlockedDices + 120 * dataAndEvents;
        a.x += 0.05 * (x - a.x);
    } ['bind'](this));
    this.scale.set(7 / Math.max(7, a2));
}, Luts.Object.DiceContainer.prototype.buyAll = function () {
    this.mainDices.forEach(function (dataAndEvents) {
        if (dataAndEvents.upgradeButton.visible) {
            dataAndEvents.upgradeButton.click();
        }
    });
    this.multiDices.forEach(function (dataAndEvents) {
        if (dataAndEvents.upgradeButton.visible) {
            dataAndEvents.upgradeButton.click();
        }
    });
    this.matchContainer.buttons.forEach(function (dataAndEvents) {
        if (dataAndEvents.visible) {
            dataAndEvents.click();
        }
    });
}, Luts.Object.DiceContainer.prototype.buyRandom = function () {

    var missing = [];
    this.mainDices.forEach(function (dataAndEvents) {
        if (dataAndEvents.upgradeButton.visible) {
            missing.push(dataAndEvents.upgrade);
        }
    });
    this.multiDices.forEach(function (dataAndEvents) {
        if (dataAndEvents.upgradeButton.visible) {
            missing.push(dataAndEvents.upgrade);
        }
    });
    this.matchContainer.buttons.forEach(function (dataAndEvents) {
        if (dataAndEvents.visible) {
            missing.push(dataAndEvents.upgrade);
        }
    });
    Luts.Upgrades.upgrade(this.game.rnd.pick(missing));
}, Luts.Object.DiceContainer.prototype.createDices = function () {
    var dices = Luts.Config.dices;
    dices[this.diceName].forEach(function (card, dataAndEvents) {
        var dep = new(Luts.Object.Dice)(this, 120 * dataAndEvents - 240, 0, card.startD, card.cost, card.value, card.costIncrease, card.valueIncrease, card.initialLevel, card.ascentIncrease);
        dep.anchor.set(0.5);
        this.mainDices.push(dep);
        this.addChild(dep);
    } ["bind"](this));
    dices.multi.forEach(function (dataAndEvents, deepDataAndEvents) {
        var r20 = new(Luts.Object.Dice)(this, 120 * (deepDataAndEvents + 5) - 240, 0, 0, dataAndEvents.cost, 1, dataAndEvents.costIncrease, 1, 0, dataAndEvents.ascentIncrease, true);
        r20.anchor.set(0.5);
        this.multiDices.push(r20);
        this.addChild(r20);
    } ['bind'](this));
}, Luts.Object.DiceContainer.prototype.rollAll = function () {
    var pdataOld = Decimal(0);

    var key = [];
    this.mainDices.forEach(function (dataAndEvents) {
        var src = dataAndEvents.roll();
        pdataOld = pdataOld.add(src);
        key.push(dataAndEvents.upgrade.level > 0 ? dataAndEvents.lastPoints : null);
        dataAndEvents.playRollAnim(this.state.rollAnim.modValue().toNumber() / 2);
    } ["bind"](this));
    this.multiDices.forEach(function (dataAndEvents) {
        var r20 = dataAndEvents.roll();
        pdataOld = pdataOld.times(Decimal.max(1, r20));
        dataAndEvents.playRollAnim(this.state.rollAnim.modValue().toNumber() / 2);
    } ['bind'](this));
    Luts.Sound.play('dice', 0.5);
    var camelKey = Luts.DiceRules(key);
    return camelKey != Luts.DiceRules.Match.NOTHING && (this.playBonusAnim(camelKey), pdataOld = pdataOld.times(Luts.Upgrades.value(camelKey + '_multi').times(this.state.comboMulti.modValue())), Luts.Value.get('totalCombo' + camelKey).add(1), this.state.comboMulti.getMultiplier('comboIncrease') || this.state.comboMulti.setMultiplier('comboIncrease',
        1, null, 'prestige'), this.state.comboMulti.setMultiplier('comboIncrease', this.state.comboMulti.getMultiplier("comboIncrease").value.plus(Luts.Upgrades.value("comboIncrease")), null, 'prestige')), Luts.Events.onRolledCombo.dispatch(camelKey), this.lastValues = key, this.lastDiceMatch = camelKey, this.playTotalAnim(pdataOld), this.lastScore = pdataOld, pdataOld;
}, Luts.Object.DiceContainer.prototype.playBonusAnim = function (owner) {
    if (Luts.isActive) {
        if (this.bonusTween) {
            this.bonusTween.stop();
        }
        if (this.bonusTween2) {
            this.bonusTween2.stop();
        }
        if (this.bonusTween3) {
            this.bonusTween3.stop();
        }

        this.bonusText.visible = true;
        var unlock = Luts.DiceRules.getData(owner);
        var r20 = '#ffffff';

        var _0x4dffdc = 30;

        var restoreScript = 0;

        var _0x45e701 = this.state.rollAnim.modValue().toNumber() / 2;

        var later = "";
        switch (this.bonusText.angle = -25, unlock.effect) {
        case 1:
            later = 'success3';
            r20 = '#ffffff';

            _0x4dffdc = 30;
            break;
        case 2:

            later = "success2";
            r20 = Luts.Config.colors.yellow;

            _0x4dffdc = 35;
            this.bonusTween = this.game.add.tween(this.bonusText).from({
                "angle": -35
            }, 250, Phaser.Easing.Sinusoidal.InOut, true, 1500 * _0x45e701, -1, true);

            restoreScript = 0.005;
            break;
        case 3:

            later = "success4";
            r20 = Luts.Config.colors.pink;

            _0x4dffdc = 45;
            this.bonusTween = this.game.add.tween(this.bonusText).from({
                "angle": -35
            }, 125, Phaser.Easing.Sinusoidal.InOut, true, 1500 * _0x45e701, -1, true);

            restoreScript = 0.01;
            break;
        case 4:
            later = 'success5';
            r20 = Luts.Config.colors.red;

            _0x4dffdc = 50;
            this.bonusTween = this.game.add.tween(this.bonusText).from({
                "angle": -35
            }, 125, Phaser.Easing.Sinusoidal.InOut, true, 1500 * _0x45e701, -1, true);

            restoreScript = 0.05;
            break;
        case 5:
            later = 'success6';
            r20 = Luts.Config.colors.red;

            _0x4dffdc = 150;
            this.bonusTween = this.game.add.tween(this.bonusText).from({
                "angle": -35
            }, 125, Phaser.Easing.Sinusoidal.InOut, true, 1500 * _0x45e701, -1, true);

            restoreScript = 0.1;
        }
        this.bonusText.scale.set(1);
        this.bonusTween2 = this.game.add.tween(this.bonusText.scale).from({
            "x": 0,
            "y": 0
        }, 400 * _0x45e701, Phaser.Easing.Elastic.Out, true, 1500 * _0x45e701);
        this.bonusTween3 = this.game.add.tween(this.bonusText.scale).to({
            "x": 0,
            "y": 0
        }, 1E3, Phaser.Easing.Back.In);
        this.bonusTween2.chain(this.bonusTween3);
        this.game.time.events.add(1500 * _0x45e701, function () {
            Luts.Sound.play(later, 0.5);
        });
        if (this.state.enableScreenShake.value) {
            if (restoreScript > 0) {
                this.game.time.events.add(1600 * _0x45e701, function () {
                    this.game.camera.shake(restoreScript, 500 * _0x45e701);
                    this.game.camera.flash(Phaser.Color.hexToRGB(r20), 250 * _0x45e701);
                }, this);
            }
        }
        this.bonusText.setText("x" + Luts.Format.Decimal(Luts.Upgrades.value(owner + '_multi').times(this.state.comboMulti.modValue())) + "\n<c=" + r20 + ">" + unlock.displayName);

        this.bonusText.fontSize = _0x4dffdc;
    }
}, Luts.Object.DiceContainer.prototype.playTotalAnim = function (deepDataAndEvents) {
    if (Luts.isActive) {
        if (this.totalAnim) {
            this.totalAnim.stop();
        }

        this.totalText.visible = true;
        this.totalText.setText(Luts.Format.Decimal(deepDataAndEvents));
        this.totalText.scale.set(1);
        this.totalAnim = this.game.add.tween(this.totalText.scale).from({
            "x": 0,
            "y": 0
        }, 500 * this.state.rollAnim.modValue().toNumber() / 2, Phaser.Easing.Elastic.Out, true, 1500 * this.state.rollAnim.modValue().toNumber() / 2);
    }
}, Luts.Object.DiceContainer.prototype.averagePerSecond = function () {
    var _0x2c47e8 = Decimal(0);
    return this.mainDices.forEach(function (dataAndEvents) {
        _0x2c47e8 = _0x2c47e8.add(dataAndEvents.averagePerSecond());
    }), this.multiDices.forEach(function (dataAndEvents) {
        _0x2c47e8 = _0x2c47e8.times(dataAndEvents.averagePerSecond());
    }), Luts.DiceRules.Match.all.forEach(function (deepDataAndEvents) {
        if (this.unlockedDices + 1 >= Luts.DiceRules.getData(deepDataAndEvents).minDices) {
            _0x2c47e8 = _0x2c47e8.times(Luts.Upgrades.value(deepDataAndEvents + '_multi').times(Luts.DiceRules.getData(deepDataAndEvents).chance).dividedBy(7).add(1));
        }
    } ["bind"](this)), this.unlockedDices + 1 >= 2 && (_0x2c47e8 = _0x2c47e8.times(Decimal.max(1, this.state.comboMulti.modValue().times(0.5)))), _0x2c47e8;
}, Luts.Object.MatchButton = function (opt_obj2, walkers, isXML, dataAndEvents, ignoreMethodDoesntExist, deepDataAndEvents) {
    Luts.Object.Button.call(this, opt_obj2, walkers, isXML, dataAndEvents.displayName, dataAndEvents.price, this.clickUpgrade.bind(this));
    this.setFrames("button_active", 'button_inactive');
    this.upgrade = dataAndEvents;

    this.text.x = -90;
    this.text.anchor.set(0, 0.5);

    this.subtitle.x = 90;
    this.subtitle.anchor.set(1, 0.5);
    this.valueText = new(Luts.Object.Text)(opt_obj2, -90, this.subtitle.y, 'regular', dataAndEvents.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, '#000000');
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;
    this.addChild(this.valueText);
    this.match = ignoreMethodDoesntExist;
    this.diceContainer = deepDataAndEvents;
    new(Luts.Object.Tooltip)(opt_obj2, this, dataAndEvents.description);
    Luts.Events.onCurrencyChanged[0].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[0].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
}, Luts.Object.MatchButton.prototype.constructor = Luts.Object.MatchButton, Luts.Object.MatchButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.MatchButton.prototype.clickUpgrade = function () {
    Luts.Upgrades.upgradeMultiple(this.upgrade);
    this.updateText();
}, Luts.Object.MatchButton.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false);
    this.subtitle.setText('<c=' + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value.times(this.state.comboMulti.modValue())));

    this.visible = this.diceContainer.unlockedDices + 1 >= this.match.minDices;
    this.setActive(r20);
}, Luts.Object.MatchButton.prototype.update = function () {}, Luts.Object.Card = function (opt_obj2, walkers, isXML, millis, oldMillis, deepDataAndEvents, dataAndEvents, ignoreMethodDoesntExist) {
    Luts.Object.Button.call(this, opt_obj2, walkers, isXML, "", "", this.clickCard.bind(this));
    this.loadTexture('ingame');
    this.setFrames('cardBack', 'cardBack');
    opt_obj2.game.add.existing(this);
    this.game = opt_obj2.game;
    this.state = opt_obj2;
    this.anchor.set(0.5);
    this.data = Luts.CardRules.data(millis);
    this.golden = dataAndEvents;
    this.diamond = ignoreMethodDoesntExist;

    this.types2 = ['caro', "cross", 'heart', 'pik'];
    this.upgrade = ignoreMethodDoesntExist ? Luts.Upgrades.get(oldMillis + millis + "_dia") : dataAndEvents ? Luts.Upgrades.get(oldMillis + millis + '_gold') : Luts.Upgrades.get(oldMillis + millis);
    this.goldUpgrade = Luts.Upgrades.get(oldMillis + millis + '_gold');
    this.colorName = 'heart' == oldMillis || "caro" == oldMillis ? 'red' : 'gray';
    this.color = Luts.Config.colors[this.colorName];
    this.dia = this.game.add.image(0, 0, 'ingame', 'diaCard');
    this.dia.anchor.set(0.5);
    this.addChild(this.dia);
    this.typeText = this.game.add.image(0, 0, 'ingame', this.colorName + millis);

    this.typeText.strokeThickness = 0;
    this.typeText.anchor.set(0.5);
    this.addChild(this.typeText);
    this.typeTextSmall = this.game.add.image(-45, -75, 'ingame', this.colorName + millis);
    this.typeTextSmall.scale.set(0.3);
    this.typeTextSmall.anchor.set(0.5);
    this.addChild(this.typeTextSmall);
    this.type2Image = this.game.add.image(-45, -50, 'ingame', oldMillis);
    this.type2Image.anchor.set(0.5);
    this.addChild(this.type2Image);
    this.typeTextSmallMirror = this.game.add.image(45, 75, "ingame", this.colorName + millis);
    this.typeTextSmallMirror.scale.set(0.3);
    this.typeTextSmallMirror.anchor.set(0.5);

    this.typeTextSmallMirror.angle = 180;
    this.addChild(this.typeTextSmallMirror);
    this.type2ImageMirror = this.game.add.image(45, 50, 'ingame', oldMillis);
    this.type2ImageMirror.anchor.set(0.5);

    this.type2ImageMirror.angle = 180;
    this.addChild(this.type2ImageMirror);
    this.gold = this.game.add.image(0, 0, 'ingame', 'goldenCard');
    this.gold.anchor.set(0.5);
    this.addChild(this.gold);
    this.tooltip = new(Luts.Object.Tooltip)(opt_obj2, this, this.data.desc);
    this.drawable = deepDataAndEvents;
    this.setType(millis, oldMillis, true);
    Luts.Events.onUpgrade.add(function () {
        this.setType(this.ctype, this.ctype2);
    }, this);
    Luts.Events.onPrestige.add(function () {
        this.setType(this.ctype, this.ctype2);
    }, this);
}, Luts.Object.Card.prototype.constructor = Luts.Object.Card, Luts.Object.Card.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.Card.prototype.clickCard = function () {
    if (this.golden) {
        if (Luts.Value.get('confirmEnabled').v.equals(0)) {
            Luts.Upgrades.upgrade(this.upgrade);
            this.state.luckMulti.changeMultiplier('luckPerGold', 1, Luts.Upgrades.value("luckPerGold"), null, 'prestige3');
            Luts.Events.onDrawCard.dispatch();
        } else {
            new(Luts.Object.Popup)(this.state, 'Are you sure to gild this card?', true, function (dataAndEvents) {
                if (dataAndEvents) {
                    Luts.Upgrades.upgrade(this.upgrade);
                    Luts.Events.onDrawCard.dispatch();
                }
            } ['bind'](this));
        }
    } else {
        if (!this.diamond) {
            if (Luts.Upgrades.currency[2].greaterThan(0)) {
                if (!this.state.gildPopup) {

                    this.state.gildPopup = true;
                    new(Luts.Object.Popup)(this.state, 'Gild a card first! (Deck tab)', false, function () {

                        this.state.gildPopup = false;
                    } ['bind'](this));
                }
            } else {
                Luts.Upgrades.upgrade(this.upgrade);
                Luts.Events.onDrawCard.dispatch();
            }
        }
    }
}, Luts.Object.Card.prototype.setType = function (t, prefix, dataAndEvents) {
    if (null == t) {
        t = this.ctype;
    }
    if (null == prefix) {
        prefix = this.ctype2;
    }

    this.ctype = t;

    this.ctype2 = prefix;
    if (this.diamond) {
        this.upgrade = Luts.Upgrades.get(prefix + t + '_dia');
    } else {
        this.upgrade = Luts.Upgrades.get(prefix + t + (this.golden ? '_gold' : ""));
    }
    this.goldUpgrade = Luts.Upgrades.get(prefix + t + '_gold');
    this.diaUpgrade = Luts.Upgrades.get(prefix + t + '_dia');
    this.data = Luts.CardRules.data(t);

    this.colorName = 'heart' == prefix || 'caro' == prefix ? "red" : "gray";
    this.color = Luts.Config.colors[this.colorName];
    this.typeText.frameName = this.colorName + t;
    this.typeTextSmall.frameName = this.colorName + t;
    this.typeTextSmallMirror.frameName = this.colorName + t;

    this.type2Image.frameName = prefix;

    this.type2ImageMirror.frameName = prefix;
    this.tooltip.setText(this.data.desc);

    this.dia.visible = this.diaUpgrade.level >= 1;
    if (this.dia.visible) {
        if (0 == this.goldUpgrade.level) {
            if (!dataAndEvents) {
                Luts.Upgrades.upgrade(this.goldUpgrade, true);
            }
        }
    }

    this.gold.visible = this.goldUpgrade.level >= 1 && !this.diamond;
    if (this.gold.visible) {
        if (0 == this.upgrade.level) {
            if (!dataAndEvents) {
                Luts.Upgrades.upgrade(this.upgrade, true);
            }
        }
    }
    if (this.drawable) {
        if (this.desc) {
            this.desc.setText(this.data.desc + "\n(" + Luts.Object.AchievementsHandler.unlockedCardTypeNum(t) + ")", 20);
        }
    }
    if (!this.drawable) {

        this.callback = function () {};

        this.alpha = this.upgrade.level >= 1 ? 1 : 0.2;
        this.setActive(this.upgrade.level >= 1, true);
    }
}, Luts.Object.Card.prototype.randomType = function (_, element, dataAndEvents) {

    var _0x2184f7 = 0;
    do {
        var returns = this.game.rnd.between(2, 14);
        var SUBSCRIBE_KEY = this.game.rnd.pick(this.types2);

        var _0x38a056 = false;
        if (1 == _) {
            if (Luts.CardRules.typeToString(returns) == element) {

                _0x38a056 = true;
            }
        }
        if (!(2 != _)) {
            if (!(Luts.CardRules.typeToString(returns) != element && Luts.CardRules.typeToString(returns) != dataAndEvents)) {

                _0x38a056 = true;
            }
        }
        if (Luts.Upgrades.get(SUBSCRIBE_KEY + Luts.CardRules.typeToString(returns)).level >= 1) {

            _0x38a056 = true;
        }
    } while (_0x38a056 && _0x2184f7++ < 1E3);
    Luts.Store.setItem("c" + _ + "t1", Luts.CardRules.typeToString(returns));
    Luts.Store.setItem("c" + _ + "t2", SUBSCRIBE_KEY);
    this.setType(Luts.CardRules.typeToString(returns), SUBSCRIBE_KEY);

    this.visible = _0x38a056;

    this.desc.visible = _0x38a056;
}, Luts.Object.Card.prototype.update = function () {}, Luts.CardRules = function () {}, Luts.CardRules.init = function (dataAndEvents) {

    this.types2 = ['caro', 'cross', 'heart', 'pik'];

    dataAndEvents.unlockedCards = 0;

    dataAndEvents.goldenCards = 0;
    this.types2.forEach(function (a) {

        var strong = 2;
        for (; strong < 15; strong++) {
            var b = Luts.CardRules.typeToString(strong);
            var n = Luts.Upgrades.add(a + b, a + " " + b, Luts.CardRules.data(b).desc, 1, 0, 1, 1, 1, 0, null, 1);
            var e = Luts.Upgrades.add(a + b + '_gold', a + " " + b, Luts.CardRules.data(b).desc, 1, 0, 1, 1, 1, 0, null, 2);
            var self = Luts.Upgrades.add(a + b + "_dia", a + " " + b, Luts.CardRules.data(b).desc, 1, 0, 1, 1, 1, 0, null, 9);
            e.u = n;
            self.u = e;
            n.card = b;
            if (n.level > 0) {
                dataAndEvents.unlockedCards++;
            }
            if (e.level > 0) {
                dataAndEvents.goldenCards++;
            }
            n.onUpgrade.add(function (deepDataAndEvents) {
                Luts.CardRules.data(deepDataAndEvents.card).onUpgrade(deepDataAndEvents);
                dataAndEvents.unlockedCards += 1;
                if (dataAndEvents.cardsWindow.unlockedCardsText) {
                    dataAndEvents.cardsWindow.unlockedCardsText.setText(dataAndEvents.unlockedCards + '/52');
                }
                dataAndEvents.cardsWindow.randomizeCards();
                Luts.Store.setItem('unlockedCards', dataAndEvents.unlockedCards);
                dataAndEvents.chipMulti.changeMultiplier('chipPerCard', 1, Luts.Upgrades.value("chipPerCard"), null, "prestige");
                if (dataAndEvents.unlockedCards >= 52) {
                    if (dataAndEvents.goldenCards < 51) {
                        if (dataAndEvents.autoConvert.value) {
                            dataAndEvents.prestige2();
                        }
                    }
                }
            });
            e.onUpgrade.add(function (dataObj) {
                Luts.Upgrades.upgrade(dataObj.u, true);
                dataAndEvents.goldenCards += 1;
                Luts.Store.setItem("goldenCards", dataAndEvents.goldenCards);
            });
            self.onUpgrade.add(function (dataObj) {
                Luts.Upgrades.upgrade(dataObj.u, true);
            });
        }
    });
}, Luts.CardRules.typeToString = function (val2) {
    if (isNaN(val2)) {
        return val2;
    }
    if (val2 <= 10) {
        return val2.toString();
    }
    switch (val2) {
    case 11:
        return "J";
    case 12:
        return "Q";
    case 13:
        return "K";
    case 14:
        return "A";
    }
    return "";
}, Luts.CardRules.data = function (basis) {
    var obj = {
        "desc": "",

        "onUpgrade": function () {}
    };
    switch (basis = Luts.CardRules.typeToString(basis)) {
    case "2":
        obj.desc = 'Card progression per ascension x2';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('cardProgressMulti').setMultiplier(dataAndEvents.name, 2, null, 'prestige');
        };
        break;
    case "3":
        obj.desc = 'All dice x3 multiplier';

        obj.onUpgrade = function (old) {
            Luts.Value.get('main0_multi').setMultiplier(old.name, 3, null, 'prestige');
            Luts.Value.get('main1_multi').setMultiplier(old.name, 3, null, 'prestige');
            Luts.Value.get('main2_multi').setMultiplier(old.name, 3, null, 'prestige');
            Luts.Value.get('main3_multi').setMultiplier(old.name, 3, null, 'prestige');
            Luts.Value.get('main4_multi').setMultiplier(old.name, 3, null, 'prestige');
        };
        break;
    case "4":
        obj.desc = 'Dice multiplier per ascension +4%';

        obj.onUpgrade = function (old) {
            Luts.Value.get('ascensionMulti').setMultiplier(old.name, 1.04, null, 'prestige');
        };
        break;
    case "5":
        obj.desc = 'All Combo multipliers x5';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('comboMulti').setMultiplier(dataAndEvents.name, 5, null, 'prestige');
        };
        break;
    case "6":
        obj.desc = '5th dice multiplier x6';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('main4_multi').setMultiplier(dataAndEvents.name, 6, null, "prestige");
        };
        break;
    case "7":

        obj.desc = "4th dice multiplier x7";

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('main3_multi').setMultiplier(dataAndEvents.name, 7, null, "prestige");
        };
        break;
    case "8":
        obj.desc = '3rd dice multiplier x8';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('main2_multi').setMultiplier(dataAndEvents.name, 8, null, 'prestige');
        };
        break;
    case "9":
        obj.desc = '2nd dice multiplier x9';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('main1_multi').setMultiplier(dataAndEvents.name, 9, null, "prestige");
        };
        break;
    case "10":
        obj.desc = '1st dice multiplier x10';

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('main0_multi').setMultiplier(dataAndEvents.name, 10, null, 'prestige');
        };
        break;
    case "J":
        obj.desc = 'Autoroll interval x50%';
        if (Luts.Lock.get('autoroll100').unlocked) {
            obj.desc += '; All dice x2';
        }

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get('rollInterval').setMultiplier(dataAndEvents.name, 0.5, null, 'prestige');
            if (Luts.Lock.get('autoroll100').unlocked) {
                Luts.Value.get('main0_multi').setMultiplier('junker', 2, null, 'prestige');
                Luts.Value.get('main1_multi').setMultiplier("junker", 2, null, 'prestige');
                Luts.Value.get('main2_multi').setMultiplier('junker', 2, null, 'prestige');
                Luts.Value.get('main3_multi').setMultiplier('junker', 2, null, 'prestige');
                Luts.Value.get('main4_multi').setMultiplier("junker", 2, null, 'prestige');
            }
        };
        break;
    case "Q":

        obj.desc = "+1 max multiplier dice";

        obj.onUpgrade = function (dataAndEvents) {
            Luts.Value.get("multiDices").add(1);
        };
        break;
    case "K":
        obj.desc = 'Collect all kings for x10000 multiplier for all dice';

        obj.onUpgrade = function (dataAndEvents) {
            if (Luts.Upgrades.get("pikK").level >= 1) {
                if (Luts.Upgrades.get('heartK').level >= 1) {
                    if (Luts.Upgrades.get('crossK').level >= 1) {
                        if (Luts.Upgrades.get("caroK").level >= 1) {
                            Luts.Value.get('main0_multi').setMultiplier("king", 1E4, null, 'prestige');
                            Luts.Value.get('main1_multi').setMultiplier("king", 1E4, null, 'prestige');
                            Luts.Value.get("main2_multi").setMultiplier('king', 1E4, null, 'prestige');
                            Luts.Value.get('main3_multi').setMultiplier('king', 1E4, null, 'prestige');
                            Luts.Value.get("main4_multi").setMultiplier('king', 1E4, null, 'prestige');
                        }
                    }
                }
            }
        };
        break;
    case "A":
        obj.desc = 'Animation duration -20%; Chip Multi x2';

        obj.onUpgrade = function (old) {
            Luts.Value.get('rollAnim').setMultiplier(old.name, 0.8, null, 'prestige');
            Luts.Value.get('chipMulti').setMultiplier(old.name, 2, null, 'prestige');
        };
    }
    return obj;
}, Luts.Object.RouletteRules = function () {}, Luts.Object.RouletteRules.reward = {
    "FASTFORWARD_1h": 'ff1h',
    "FASTFORWARD_6h": 'ff6h',
    "FASTFORWARD_24h": 'ff24',
    "MULTI_1x2": 'm1x2',
    "MULTI_2x2": 'm2x2',
    "MULTI_3x2": 'm3x2',
    "MULTI_4x2": 'm4x2',
    "MULTI_5x2": 'm5x2',
    "MULTI_1x5": 'm1x5',
    "MULTI_2x5": 'm2x5',
    "MULTI_3x5": 'm3x5',
    "MULTI_4x5": 'm4x5',
    "MULTI_5x5": 'm5x5',
    "MULTI_1x10": 'm1x10',
    "MULTI_2x10": "m2x10",
    "MULTI_3x10": 'm3x10',
    "MULTI_4x10": "m4x10",
    "MULTI_5x10": 'm5x10',
    "CARD_2": "c2",
    "CARD_3": "c3",
    "CARD_5": "c5",
    "UPGRADE": 'upgrade'
}, Luts.Object.RouletteRules.data = function (dataAndEvents) {
    var result = {

        "onUpgrade": function () {},
        "icon": 'roulette_',
        "text": "",
        "name": ""
    };
    switch (dataAndEvents) {
    case Luts.Object.RouletteRules.reward.FASTFORWARD_1h:
        result.icon += "ff";
        result.text = '10m';
        result.name = 'Fast Forward 10 minutes';

        result.onUpgrade = function () {
            Luts.currentState.handleTimeAway({
                "sec": 600
            }, true);
        };
        break;
    case Luts.Object.RouletteRules.reward.FASTFORWARD_6h:
        result.icon += "ff";

        result.text = "20m";
        result.name = 'Fast Forward 20 minutes!';

        result.onUpgrade = function () {
            Luts.currentState.handleTimeAway({
                "sec": 1200
            }, true);
        };
        break;
    case Luts.Object.RouletteRules.reward.FASTFORWARD_24h:
        result.icon += "ff";

        result.text = "1h";
        result.name = 'Fast Forward 1 hour!!';

        result.onUpgrade = function () {
            Luts.currentState.handleTimeAway({
                "sec": 3600
            }, true);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_1x2:
        result.icon += "d1";

        result.text = "x2";
        result.name = '1st Dice x2';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(0, 2);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_2x2:
        result.icon += "d2";

        result.text = "x2";
        result.name = '2nd Dice x2';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(1, 2);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_3x2:
        result.icon += "d3";

        result.text = "x2";

        result.name = "3rd Dice x2";

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(2, 2);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_4x2:
        result.icon += "d4";

        result.text = "x2";
        result.name = '4th Dice x2';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(3, 2);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_5x2:
        result.icon += "d5";

        result.text = "x2";
        result.name = '5th Dice x2';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(4, 2);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_1x5:
        result.icon += "d1";

        result.text = "x5";
        result.name = '1st Dice x5!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(0, 5);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_2x5:
        result.icon += "d2";

        result.text = "x5";

        result.name = "2nd Dice x5!";

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(1, 5);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_3x5:
        result.icon += "d3";

        result.text = "x5";
        result.name = '3rd Dice x5!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(2, 5);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_4x5:
        result.icon += "d4";

        result.text = "x5";
        result.name = '4th Dice x5!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(3, 5);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_5x5:
        result.icon += "d5";

        result.text = "x5";

        result.name = "5th Dice x5!";

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(4, 5);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_1x10:
        result.icon += "d1";
        result.text = 'x10';

        result.name = "1st Dice x10!!";

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(0, 10);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_2x10:
        result.icon += "d2";
        result.text = 'x10';
        result.name = '2nd Dice x10!!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(1, 10);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_3x10:
        result.icon += "d3";
        result.text = 'x10';
        result.name = '3rd Dice x10!!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(2, 10);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_4x10:
        result.icon += "d4";
        result.text = 'x10';

        result.name = "4th Dice x10!!";

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(3, 10);
        };
        break;
    case Luts.Object.RouletteRules.reward.MULTI_5x10:
        result.icon += "d5";
        result.text = 'x10';
        result.name = '5th Dice x10!!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.diceMulti(4, 10);
        };
        break;
    case Luts.Object.RouletteRules.reward.CARD_2:
        result.icon += 'card';

        result.text = "x2";
        result.name = 'Card progression x2';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.cardMulti(2);
        };
        break;
    case Luts.Object.RouletteRules.reward.CARD_3:
        result.icon += 'card';

        result.text = "x3";
        result.name = 'Card progression x3!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.cardMulti(3);
        };
        break;
    case Luts.Object.RouletteRules.reward.CARD_5:
        result.icon += "card";

        result.text = "x5";
        result.name = 'Card progression x5!!';

        result.onUpgrade = function () {
            Luts.Object.RouletteRules.cardMulti(5);
        };
        break;
    case Luts.Object.RouletteRules.reward.UPGRADE:
        result.icon += 'upgrade';

        result.text = "";
        result.name = 'Roulette Upgrade!!';

        result.onUpgrade = function () {
            Luts.Value.get("rouletteLevel").add(Luts.Upgrades.value("rouletteUpgradeMulti"));
        };
    }
    return result;
}, Luts.Object.RouletteRules.diceMulti = function (name, array) {
    var setMultiplier = Luts.Value.get("main" + name + '_multi');
    var iterator = setMultiplier.getMultiplier("rd" + name + "x" + array);
    setMultiplier.setMultiplier("rd" + name + "x" + array, iterator ? iterator.value.times(array) : array, null, 'prestige');
}, Luts.Object.RouletteRules.cardMulti = function (array) {
    var cardProgressMulti = Luts.Value.get("cardProgressMulti");
    var iterator = cardProgressMulti.getMultiplier('rouletteCard');
    cardProgressMulti.setMultiplier('rouletteCard', iterator ? iterator.value.times(array) : array, null, 'prestige');
}, Luts.Object.RouletteRules.rouletteData = function (dataAndEvents) {
    var data = {
        "size": 4,
        "rewards": []
    };
    switch (dataAndEvents) {
    case 0:

        data.size = 4;

        data.rewards = ['upgrade', "ff1h", 'm1x2', 'm2x2'];
        break;
    case 1:

        data.size = 6;

        data.rewards = ['upgrade', 'ff1h', 'm1x2', "m2x2", 'm3x2', 'm4x2'];
        break;
    case 2:

        data.size = 8;

        data.rewards = ["upgrade", 'ff1h', "c2", 'm1x2', 'm2x2', 'm3x2', "m4x2", "m5x2"];
        break;
    case 3:

        data.size = 10;

        data.rewards = ['upgrade', 'ff1h', "c2", "m1x2", 'm2x2', 'm3x2', 'm4x2', "m5x2", 'm1x5', 'm2x5'];
        break;
    case 4:

        data.size = 14;

        data.rewards = ['upgrade', 'ff1h', "ff6h", "c2", 'm1x2', "m2x2", 'm3x2', "m4x2", 'm5x2', "m1x5", 'm2x5', "m3x5", "m4x5", "m5x5"];
        break;
    case 5:

        data.size = 18;

        data.rewards = ['upgrade', 'ff1h', 'ff6h', "ff24", "c2", 'm1x2', "m2x2", 'm3x2', "m4x2", "m5x2", "m1x5", 'm2x5', 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', 'm3x10'];
        break;
    case 6:

        data.size = 24;

        data.rewards = ['upgrade', 'ff1h', 'ff6h', 'ff24', "ff1h", 'ff6h', 'ff24', "c2", "c3", 'm1x2', 'm2x2', 'm3x2', "m4x2", 'm5x2', 'm1x5', 'm2x5', "m3x5", 'm4x5', 'm5x5', 'm1x10', 'm2x10', "m3x10", "m4x10", 'm5x10'];
        break;
    case 7:

        data.size = 28;

        data.rewards = ['upgrade', "ff1h", "ff6h", 'ff24', 'ff1h', 'ff6h', "ff24", "c2", "c3", 'm1x2', 'm2x2', 'm3x2', 'm4x2', 'm5x2', 'm1x5', 'm2x5', 'm3x5', "m4x5", 'm5x5', "m1x10", "m2x10", 'm3x10', "m4x10", 'm5x10', 'm1x10', "m2x10", 'm3x10', "m4x10"];
        break;
    case 8:

        data.size = 32;

        data.rewards = ['upgrade', 'ff1h', 'ff6h', 'ff24', 'ff1h', 'ff6h', 'ff24', 'ff24', "c2", "c2", "c3", "c5", 'm1x2', 'm2x2', 'm3x2', 'm4x2', 'm5x2', 'm1x5', 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10',
            'm2x10', 'm3x10', "m4x10", 'm5x10'
        ];
        break;
    case 9:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', "ff6h", "ff24", 'ff1h', 'ff6h', 'ff24', 'ff24', "c2", "c2", "c3", "c5", "m1x2", 'm2x2', 'm3x2', 'm4x2', "m5x2", "m1x5", 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', "m3x10", 'm4x10',
            "m5x10"
        ];
        break;
    case 10:

        data.size = 32;

        data.rewards = ['upgrade', "ff6h", "ff6h", "ff24", 'ff6h', 'ff6h', 'ff24', "ff24", "c2", "c2", "c3", "c5", "m1x2", 'm2x2', 'm3x2', 'm4x2', 'm5x2', 'm1x5', 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10',
            'm5x10'
        ];
        break;
    case 11:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', "ff6h", 'ff24', "ff6h", 'ff6h', "ff24", 'ff24', "c2", "c2", "c3", "c5", 'm1x5', "m2x2", 'm3x2', 'm4x2', 'm5x2', "m1x5", "m2x5", 'm3x5', "m4x5", "m5x5", 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10', "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 12:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', 'ff6h', 'ff24', 'ff6h', "ff6h", "ff24", 'ff24', "c2", "c2", "c3", "c5", 'm1x5', 'm2x5', "m3x2", "m4x2", 'm5x2', 'm1x5', 'm2x5', "m3x5", 'm4x5', 'm5x5', 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10',
            'm5x10'
        ];
        break;
    case 13:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', 'ff6h', 'ff24', 'ff6h', 'ff6h', 'ff24', 'ff24', "c2", "c2", "c3", "c5", 'm1x5', 'm2x5', 'm3x5', "m4x2", 'm5x2', 'm1x5', 'm2x5', 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', "m3x10", 'm4x10', "m5x10", 'm1x10', "m2x10", "m3x10", 'm4x10', 'm5x10'];
        break;
    case 14:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', "ff6h", 'ff24', 'ff6h', "ff6h", 'ff24', 'ff24', "c2", "c2", "c3", "c5", "m1x5", "m2x5", 'm3x5', 'm4x5', "m5x2", "m1x5", 'm2x5', 'm3x5', 'm4x5', 'm5x5', "m1x10", 'm2x10', "m3x10", 'm4x10', "m5x10", 'm1x10', 'm2x10', 'm3x10', 'm4x10', "m5x10"];
        break;
    case 15:

        data.size = 32;

        data.rewards = ['upgrade', "ff6h", 'ff6h', "ff24", 'ff6h', 'ff6h', "ff24", 'ff24', "c2", "c2", "c3", "c5", 'm1x5', 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x5', 'm2x5', 'm3x5', 'm4x5', 'm5x5', "m1x10", "m2x10", 'm3x10', 'm4x10', "m5x10", 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 16:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', 'ff6h', 'ff24', 'ff6h', 'ff6h', 'ff24', 'ff24', "c2", "c3", "c3", "c5", 'm1x5', 'm2x5', "m3x5", "m4x5", 'm5x5', 'm1x5', 'm2x5', 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', "m5x10", 'm1x10', "m2x10", 'm3x10', "m4x10", "m5x10"];
        break;
    case 17:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', 'ff24', 'ff24', 'ff6h', 'ff6h', 'ff24', 'ff24', "c2", "c3", "c3", "c5", 'm1x5', "m2x5", 'm3x5', 'm4x5', 'm5x5', 'm1x5', 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10',
            'm2x10', 'm3x10', "m4x10", 'm5x10'
        ];
        break;
    case 18:

        data.size = 32;

        data.rewards = ['upgrade', 'ff6h', 'ff24', 'ff24', 'ff6h', "ff24", 'ff24', 'ff24', "c2", "c3", "c3", "c5", 'm1x5', 'm2x5', 'm3x5', "m4x5", "m5x5", 'm1x5', 'm2x5', 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', "m2x10", 'm3x10', 'm4x10',
            'm5x10'
        ];
        break;
    case 19:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', "ff24", 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c2", "c3", "c3", "c5", "m1x5", 'm2x5', 'm3x5', "m4x5", 'm5x5', "m1x5", 'm2x5', 'm3x5', 'm4x5', "m5x5", 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10'];
        break;
    case 20:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", "ff24", 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c2", "c3", "c3", "c5", 'm1x10', 'm2x5', 'm3x5', 'm4x5', 'm5x5', "m1x5", 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', "m5x10", 'm1x10', 'm2x10', "m3x10", 'm4x10',
            'm5x10'
        ];
        break;
    case 21:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", "ff24", "ff24", 'ff6h', "ff24", 'ff24', "ff24", "c2", "c3", "c3", "c5", 'm1x10', 'm2x10', "m3x5", "m4x5", 'm5x5', 'm1x5', 'm2x5', 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10', 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10'];
        break;
    case 22:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', 'ff24', 'ff24', 'ff6h', "ff24", 'ff24', 'ff24', "c2", "c3", "c3", "c5", "m1x10", 'm2x10', 'm3x10', 'm4x5', "m5x5", 'm1x5', "m2x5", 'm3x5', "m4x5", 'm5x5', 'm1x10', 'm2x10', "m3x10", "m4x10", 'm5x10', 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 23:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', 'ff24', 'ff24', "ff6h", 'ff24', 'ff24', 'ff24', "c2", "c3", "c3", "c5", "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x5', "m1x5", 'm2x5', 'm3x5', 'm4x5', 'm5x5', 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10', "m1x10", 'm2x10', "m3x10", "m4x10", 'm5x10'];
        break;
    case 24:

        data.size = 32;

        data.rewards = ["upgrade", "ff24", 'ff24', 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c2", "c3", "c3", "c5", 'm1x10', "m2x10", 'm3x10', 'm4x10', "m5x10", 'm1x5', 'm2x5', "m3x5", 'm4x5', "m5x5", "m1x10", "m2x10", 'm3x10', 'm4x10', 'm5x10', 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 25:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', 'ff24', "ff24", 'ff6h', 'ff24', 'ff24', "ff24", "c2", "c3", "c3", "c5", 'm1x10', "m2x10", 'm3x10', "m4x10", 'm5x10', 'm1x10', "m2x5", "m3x5", 'm4x5', 'm5x5', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 26:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", 'ff24', "ff24", 'ff6h', 'ff24', "ff24", 'ff24', "c2", "c3", "c3", "c5", 'm1x10', 'm2x10', 'm3x10', 'm4x10', "m5x10", 'm1x10', "m2x10", 'm3x5', 'm4x5', 'm5x5', "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', "m3x10", "m4x10", "m5x10"];
        break;
    case 27:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", 'ff24', 'ff24', 'ff6h', 'ff24', "ff24", 'ff24', "c2", "c3", "c3", "c5", 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', "m4x5", "m5x5", 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10',
            'm5x10'
        ];
        break;
    case 28:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', "ff24", "ff24", 'ff6h', 'ff24', 'ff24', "ff24", "c2", "c3", "c3", "c5", 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10', 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x5', 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10', 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10'];
        break;
    case 29:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', 'ff24', 'ff24', 'ff6h', "ff24", "ff24", 'ff24', "c2", "c3", "c3", "c5", 'm1x10', 'm2x10', "m3x10", 'm4x10', "m5x10", "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', "m3x10", 'm4x10',
            'm5x10'
        ];
        break;
    case 30:

        data.size = 32;

        data.rewards = ["upgrade", "ff24", 'ff24', 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c2", "c3", "c5", "c5", "m1x10", 'm2x10', 'm3x10', "m4x10", 'm5x10', 'm1x10', 'm2x10', 'm3x10', "m4x10", 'm5x10', "m1x10", 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10',
            'm5x10'
        ];
        break;
    case 31:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", 'ff24', 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c3", "c3", "c5", "c5", 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', "m2x10", 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10',
            "m3x10", 'm4x10', 'm5x10'
        ];
        break;
    case 32:

        data.size = 32;

        data.rewards = ['upgrade', 'ff24', "ff24", 'ff24', "ff6h", "ff24", 'ff24', "ff24", "c3", "c5", "c5", "c5", 'm1x10', 'm2x10', 'm3x10', 'm4x10', "m5x10", 'm1x10', "m2x10", "m3x10", 'm4x10', "m5x10", 'm1x10', 'm2x10', "m3x10", "m4x10", 'm5x10', 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10'];
        break;
    case 33:

        data.size = 32;

        data.rewards = ['upgrade', "ff24", "ff24", 'ff24', 'ff6h', 'ff24', 'ff24', 'ff24', "c5", "c5", "c5", "c5", 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10',
            'm4x10', 'm5x10'
        ];
        break;
    case 34:
        ;
    default:

        data.size = 32;

        data.rewards = ['ff24', "ff24", 'ff24', "ff24", 'ff6h', "ff24", "ff24", 'ff24', "c5", "c5", "c5", "c5", 'm1x10', "m2x10", 'm3x10', 'm4x10', "m5x10", 'm1x10', 'm2x10', "m3x10", 'm4x10', 'm5x10', 'm1x10', 'm2x10', 'm3x10', 'm4x10', 'm5x10', "m1x10", "m2x10", 'm3x10', 'm4x10', 'm5x10'];
    }
    return data;
}, Luts.Object.AchievementUnlockedLabel = function (title, currentContact) {
    Phaser.Image.call(this, title.game, -445, 60, "ui", 'labelSmall');
    title.game.add.existing(this);
    this.game = title.game;

    this.state = title;
    this.state.topUI.addChild(this);
    var text = currentContact.name + "\n\n";
    text += currentContact.unlockText + "; +" + Luts.Object.AchievementsHandler.categoryToBP(currentContact.category) + "BP";
    this.title = new(Luts.Object.Text)(title, 20, 10, "text", 'Achievement Unlocked!', 28);
    this.addChild(this.title);
    this.text = new(Luts.Object.Text)(title, 20, 40, 'text', text, 18, '#000000');

    this.text.wordWrapWidth = this.rWidth - 80;

    this.text.strokeThickness = 0;
    this.addChild(this.text);

    this.inputEnabled = true;
    this.events.onInputDown.add(function () {
        this.die();
    }, this);
    this.game.add.tween(this).from({
        "y": -100
    }, 1E3, Phaser.Easing.Bounce.Out, true);
    if (!("" != currentContact.unlockText && null != currentContact.unlockText)) {
        this.destroy();
    }
}, Luts.Object.AchievementUnlockedLabel.prototype.constructor = Luts.Object.AchievementUnlockedLabel, Luts.Object.AchievementUnlockedLabel.prototype = Object.create(Phaser.Image.prototype), Luts.Object.AchievementUnlockedLabel.prototype.die = function () {
    if (!this.tw) {
        this.tw = this.game.add.tween(this).to({
            "y": -100
        }, 500, Phaser.Easing.Back.In, true);
        this.tw.onComplete.add(function () {
            this.destroy();
        }, this);
    }
}, Luts.Object.LuckUpgradeButton = function (deepDataAndEvents, opt_obj2, walkers, item) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, item.displayName, item.price, this.clickUpgrade.bind(this));
    this.setFrames('button_active', 'button_inactive');

    this.upgrade = item;

    this.text.x = -90;
    this.text.anchor.set(0, 0.5);

    this.subtitle.x = 90;
    this.subtitle.anchor.set(1, 0.5);
    this.valueText = new Luts.Object.Text(deepDataAndEvents, -90, this.subtitle.y, 'regular', item.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, "#000000");
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;
    this.addChild(this.valueText);
    new(Luts.Object.Tooltip)(deepDataAndEvents, this, item.description);
    Luts.Events.onCurrencyChanged[3].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[3].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
}, Luts.Object.LuckUpgradeButton.prototype.constructor = Luts.Object.LuckUpgradeButton, Luts.Object.LuckUpgradeButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.LuckUpgradeButton.prototype.clickUpgrade = function () {
    Luts.Upgrades.upgradeMultiple(this.upgrade);
    this.updateText();
}, Luts.Object.LuckUpgradeButton.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false);
    this.subtitle.setText("<c=" + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value));
    if (!Luts.Upgrades.isBelowMaxLevel(this.upgrade)) {
        this.subtitle.setText('MAX');
    }
    this.setActive(r20);
}, Luts.Object.LuckUpgradeButton.prototype.update = function () {}, Luts.Object.RouletteUpgradeButton = function (deepDataAndEvents, opt_obj2, walkers, tagMap) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, tagMap.displayName, tagMap.price, this.clickUpgrade.bind(this));

    this.upgrade = tagMap;

    this.text.x = -40;
    this.text.anchor.set(0, 0.5);

    this.subtitle.x = 40;
    this.subtitle.anchor.set(1, 0.5);
    this.valueText = new(Luts.Object.Text)(deepDataAndEvents, -40, this.subtitle.y, 'regular', tagMap.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, "#000000");
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;

    this.valueText.visible = false;
    this.addChild(this.valueText);
    new Luts.Object.Tooltip(deepDataAndEvents, this, tagMap.description);
    Luts.Events.onCurrencyChanged[4].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[4].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
    tagMap.onUpgrade.add(this.updateText, this);
}, Luts.Object.RouletteUpgradeButton.prototype.constructor = Luts.Object.RouletteUpgradeButton, Luts.Object.RouletteUpgradeButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.RouletteUpgradeButton.prototype.clickUpgrade = function () {
    Luts.Upgrades.upgradeMultiple(this.upgrade, 1);
    this.updateText();
}, Luts.Object.RouletteUpgradeButton.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false, 1);
    this.subtitle.setText("<c=" + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade, 1), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value));
    this.setActive(r20);
}, Luts.Object.RouletteUpgradeButton.prototype.update = function () {}, Luts.Object.BonusUpgradeButton = function (deepDataAndEvents, opt_obj2, walkers, old) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, old.displayName, old.price, this.clickUpgrade.bind(this));
    this.setFrames('button_active', 'button_inactive');

    this.upgrade = old;

    this.text.x = -90;
    this.text.anchor.set(0, 0.5);

    this.subtitle.x = 90;
    this.subtitle.anchor.set(1, 0.5);
    this.valueText = new(Luts.Object.Text)(deepDataAndEvents, -90, this.subtitle.y, 'regular', old.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, '#000000');
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;
    this.addChild(this.valueText);
    new(Luts.Object.Tooltip)(deepDataAndEvents, this, old.description);
    Luts.Events.onCurrencyChanged[6].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[6].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
    if ('bonusSkillMulti' == old.name) {
        this.setLock('goldenDeck');
    }
    if ('bonusConvert' == old.name) {
        this.setLock('decks');
    }
    if ("bonusChipMulti" == old.name) {
        this.setLock('roulette');
    }
}, Luts.Object.BonusUpgradeButton.prototype.constructor = Luts.Object.BonusUpgradeButton, Luts.Object.BonusUpgradeButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.BonusUpgradeButton.prototype.clickUpgrade = function () {
    new Luts.Object.Popup(this.state, 'Are you sure to purchase ' + this.upgrade.displayName + " for " + this.upgrade.price + `BP?\
` + this.upgrade.description, true, function (dataAndEvents) {
        if (dataAndEvents) {
            var _0xe46252 = Luts.Upgrades.upgradeMultiple(this.upgrade, 1);
            this.updateText();
            this.state.shopWindow.applyUpgrades();
            if (!_0xe46252) {
                if (Luts.Ad.enabled) {
                    new(Luts.Object.Popup)(this.state, 'You dont have enough Bonus Points. Do you want to watch an Ad to get 5 BPs?', true, function (dataAndEvents) {
                        if (dataAndEvents) {
                            this.state.shopWindow.requestAdForBp();
                        }
                    } ["bind"](this));
                } else {
                    if (Luts.mtxEnabled && Luts.Connect.kong) {
                        new(Luts.Object.Popup)(this.state, 'You dont have enough Bonus Points. Do you want to get more?', true, function (dataAndEvents) {
                            if (dataAndEvents) {
                                this.state.mtxClicked();
                            }
                        } ['bind'](this));
                    } else {
                        new Luts.Object.Popup(this.state, 'You dont have enough Bonus Points. Unlock achievements to get more BP');
                    }
                }
            }
        }
    } ["bind"](this));
}, Luts.Object.BonusUpgradeButton.prototype.updateText = function () {
    var green = Luts.Upgrades.isUpgradeable(this.upgrade, false, 1);
    this.subtitle.setText('<c=' + (green ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade, 1), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value));
    if (!Luts.Upgrades.isBelowMaxLevel(this.upgrade)) {
        this.subtitle.setText('MAX');
    }
}, Luts.Object.BonusUpgradeButton.prototype.update = function () {}, Luts.Object.SkillUpgradeButton = function (deepDataAndEvents, opt_obj2, walkers, item) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, item.displayName, item.price, this.clickUpgrade.bind(this));
    this.setFrames('button_active', 'button_inactive');

    this.upgrade = item;

    this.text.x = -90;
    this.text.anchor.set(0, 0.5);

    this.subtitle.x = 90;
    this.subtitle.anchor.set(1, 0.5);

    this.text.fontSize = 16;
    this.valueText = new(Luts.Object.Text)(deepDataAndEvents, -90, this.subtitle.y, 'regular', item.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, "#000000");
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;
    this.addChild(this.valueText);
    new(Luts.Object.Tooltip)(deepDataAndEvents, this, item.description);
    Luts.Events.onCurrencyChanged[5].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[5].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[5].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
}, Luts.Object.SkillUpgradeButton.prototype.constructor = Luts.Object.SkillUpgradeButton, Luts.Object.SkillUpgradeButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.SkillUpgradeButton.prototype.clickUpgrade = function () {
    Luts.Upgrades.upgradeMultiple(this.upgrade);
    this.updateText();
}, Luts.Object.SkillUpgradeButton.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false);
    this.subtitle.setText('<c=' + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value));
    if (!Luts.Upgrades.isBelowMaxLevel(this.upgrade)) {
        this.subtitle.setText("MAX");
    }
    this.setActive(r20);
}, Luts.Object.SkillUpgradeButton.prototype.update = function () {}, Luts.Object.AutoDrawCard = function (deepDataAndEvents, opt_obj2, walkers, isXML, newValue, dataAndEvents) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, "", "", function () {});
    this.loadTexture('ingame');
    this.setFrames('cardBack', "cardBack");
    this.setActive(false);
    this.pos = newValue;
    deepDataAndEvents.game.add.existing(this);
    this.game = deepDataAndEvents.game;

    this.state = deepDataAndEvents;
    this.anchor.set(0.5);
    this.data = Luts.CardRules.data(isXML);
    this.isGold = dataAndEvents;

    this.colorName = "red";
    this.color = Luts.Config.colors[this.colorName];
    this.typeText = this.game.add.image(0, 0, 'ingame', this.colorName + isXML);

    this.typeText.strokeThickness = 0;
    this.typeText.anchor.set(0.5);
    this.addChild(this.typeText);
    this.typeTextSmall = this.game.add.image(-45, -75, 'ingame', this.colorName + isXML);
    this.typeTextSmall.scale.set(0.3);
    this.typeTextSmall.anchor.set(0.5);
    this.addChild(this.typeTextSmall);
    this.type2Image = this.game.add.image(-45, -50, 'ingame', 'caro');
    this.type2Image.anchor.set(0.5);
    this.addChild(this.type2Image);
    this.typeTextSmallMirror = this.game.add.image(45, 75, 'ingame', this.colorName + isXML);
    this.typeTextSmallMirror.scale.set(0.3);
    this.typeTextSmallMirror.anchor.set(0.5);

    this.typeTextSmallMirror.angle = 180;
    this.addChild(this.typeTextSmallMirror);
    this.type2ImageMirror = this.game.add.image(45, 50, 'ingame', 'caro');
    this.type2ImageMirror.anchor.set(0.5);

    this.type2ImageMirror.angle = 180;
    this.addChild(this.type2ImageMirror);
    this.gold = this.game.add.image(0, 0, 'ingame', 'goldenCard');
    this.gold.anchor.set(0.5);
    this.addChild(this.gold);
    this.gold.visible = dataAndEvents;
    this.tooltip = new(Luts.Object.Tooltip)(deepDataAndEvents, this, this.data.desc);
    this.leftButton = new Luts.Object.Button(deepDataAndEvents, -65, 150, "â‡„", "", this.goLeft.bind(this));
    this.leftButton.setFrames('buttonSmall_active', 'buttonSmall_inactive');
    this.leftButton.scale.set(2);

    this.leftButton.baseScale = 2;
    this.addChild(this.leftButton);
    if (dataAndEvents) {
        this.leftButton.setLock('autoGild');
    }
    this.setType(isXML, 'caro');
    this.updateArrows();
}, Luts.Object.AutoDrawCard.prototype.constructor = Luts.Object.AutoDrawCard, Luts.Object.AutoDrawCard.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.AutoDrawCard.prototype.goLeft = function () {
    if (this.isGold) {
        var _0x17ca75 = this.state.cardsWindow.autoGildOrder[this.pos];
        this.state.cardsWindow.autoGildOrder[this.pos] = this.state.cardsWindow.autoGildOrder[this.pos - 1];
        this.state.cardsWindow.autoGildOrder[this.pos - 1] = _0x17ca75;
    } else {
        _0x17ca75 = this.state.cardsWindow.autoDrawOrder[this.pos];
        this.state.cardsWindow.autoDrawOrder[this.pos] = this.state.cardsWindow.autoDrawOrder[this.pos - 1];
        this.state.cardsWindow.autoDrawOrder[this.pos - 1] = _0x17ca75;
    }
    this.state.cardsWindow.updateAutoDrawCards();
}, Luts.Object.AutoDrawCard.prototype.goRight = function () {
    if (this.isGold) {
        var _0x2ccb30 = this.state.cardsWindow.autoGildOrder[this.pos];
        this.state.cardsWindow.autoGildOrder[this.pos] = this.state.cardsWindow.autoGildOrder[this.pos + 1];
        this.state.cardsWindow.autoGildOrder[this.pos + 1] = _0x2ccb30;
    } else {
        _0x2ccb30 = this.state.cardsWindow.autoDrawOrder[this.pos];
        this.state.cardsWindow.autoDrawOrder[this.pos] = this.state.cardsWindow.autoDrawOrder[this.pos + 1];
        this.state.cardsWindow.autoDrawOrder[this.pos + 1] = _0x2ccb30;
    }
    this.state.cardsWindow.updateAutoDrawCards();
}, Luts.Object.AutoDrawCard.prototype.updateArrows = function () {
    if (0 == this.pos) {

        this.leftButton.visible = false;
    }
}, Luts.Object.AutoDrawCard.prototype.setType = function (deepDataAndEvents, no) {
    if (null == deepDataAndEvents) {
        deepDataAndEvents = this.ctype;
    }
    if (null == no) {
        no = this.ctype2;
    }

    this.ctype = deepDataAndEvents;

    this.ctype2 = no;
    this.data = Luts.CardRules.data(deepDataAndEvents);
    this.colorName = "heart" == no || 'caro' == no ? 'red' : 'gray';
    this.color = Luts.Config.colors[this.colorName];
    this.typeText.frameName = this.colorName + deepDataAndEvents;
    this.typeTextSmall.frameName = this.colorName + deepDataAndEvents;
    this.typeTextSmallMirror.frameName = this.colorName + deepDataAndEvents;

    this.type2Image.frameName = no;

    this.type2ImageMirror.frameName = no;
    this.tooltip.setText(this.data.desc);
}, Luts.Object.AutoDrawCard.prototype.randomType = function (_, absolute, dataAndEvents) {

    var _0x48e1ab = 0;
    do {
        var offsetChild = this.game.rnd.between(2, 14);
        var r20 = this.game.rnd.pick(this.types2);

        var _0x54f85c = false;
        if (1 == _) {
            if (Luts.CardRules.typeToString(offsetChild) == absolute) {

                _0x54f85c = true;
            }
        }
        if (!(2 != _)) {
            if (!(Luts.CardRules.typeToString(offsetChild) != absolute && Luts.CardRules.typeToString(offsetChild) != dataAndEvents)) {

                _0x54f85c = true;
            }
        }
        if (Luts.Upgrades.get(r20 + Luts.CardRules.typeToString(offsetChild)).level >= 1) {

            _0x54f85c = true;
        }
    } while (_0x54f85c && _0x48e1ab++ < 1E3);
    Luts.Store.setItem("c" + _ + "t1", Luts.CardRules.typeToString(offsetChild));
    Luts.Store.setItem("c" + _ + "t2", r20);
    this.setType(Luts.CardRules.typeToString(offsetChild), r20);

    this.visible = _0x54f85c;

    this.desc.visible = _0x54f85c;
}, Luts.Object.AutoDrawCard.prototype.update = function () {}, Luts.Object.SlotUpgradeButton = function (deepDataAndEvents, opt_obj2, walkers, dataAndEvents) {
    Luts.Object.Button.call(this, deepDataAndEvents, opt_obj2, walkers, dataAndEvents.displayName, dataAndEvents.price, this.clickUpgrade.bind(this));
    this.upgrade = dataAndEvents;
    this.valueText = new Luts.Object.Text(deepDataAndEvents, -40, this.subtitle.y, 'regular', dataAndEvents.value, Luts.Object.Button.FONT_SIZE_SUBTITLE, '#000000');
    this.valueText.anchor.set(0, 0.5);

    this.valueText.strokeThickness = 0;

    this.valueText.visible = false;
    this.addChild(this.valueText);
    new Luts.Object.Tooltip(deepDataAndEvents, this, dataAndEvents.description);
    Luts.Events.onCurrencyChanged[8].add(this.updateText, this);
    Luts.Events.onBuyAmountChanged[8].add(this.updateText, this);
    Luts.Events.onUnlockedDice.add(this.updateText, this);
    dataAndEvents.onUpgrade.add(this.updateText, this);
}, Luts.Object.SlotUpgradeButton.prototype.constructor = Luts.Object.SlotUpgradeButton, Luts.Object.SlotUpgradeButton.prototype = Object.create(Luts.Object.Button.prototype), Luts.Object.SlotUpgradeButton.prototype.clickUpgrade = function () {
    Luts.Upgrades.upgradeMultiple(this.upgrade, 1);
    this.updateText();
}, Luts.Object.SlotUpgradeButton.prototype.updateText = function () {
    var r20 = Luts.Upgrades.isUpgradeable(this.upgrade, false, 1);
    this.subtitle.setText('<c=' + (r20 ? Luts.Config.colors.green : Luts.Config.colors.red) + ">" + Luts.Format.Decimal(Luts.Upgrades.priceMultiple(this.upgrade, 1), false, 0));
    this.valueText.setText(Luts.Format.Decimal(this.upgrade.value));
    if (!Luts.Upgrades.isBelowMaxLevel(this.upgrade)) {
        this.subtitle.setText("MAX");
    }
    this.setActive(r20);
}, Luts.Object.SlotUpgradeButton.prototype.update = function () {};
